(*` {CSY}Knihovna vývojového systému Mosaic{ENU}Mosaic IDE library *)
(*` {CSY}Jméno souboru{ENU}File name{} : D:\TecoLib\RegoLib_V20_20121031.mlb *)
(*` {CSY}Knihovna : RegoLib{ENU}Library : RegoLib{} 2.0 *)
(*` {CSY}Autor{ENU}Author{} : Teco a.s. Kolin *)
(*` {CSY}Autorská práva{ENU}Copyright{} : (c) 2012 Teco a.s. *)
(*` {CSY}Verze IEC pøekladaèe{ENU}IEC compiler version{} : 3.8.17.0 *)
(*` {CSY}Verze assembleru{ENU}Assembler version{} : 4.3.00 *)

//{Knihovna : RegoLib 2.0  }
(*` {CSY}Historie{ENU}History{}: *)
(*`
2.0 31.10.2012  - pro PID11 a PID21 pridan navrat do automatickeho rezimu pokud se 
dostal vstup MSR mimo meze (Byd)

1.9 20.04.2010	- pro PID1, PID11, PID2, PID21, PID3 uprava typu promennych MinU a 
MaxU z UINT na INT

1.8 13.01.2010	- pro PID1, PID11, PID2, PID21, PID3 doplneno nulovani LastOut pri 
ACT=0

1.7 8.06.2009	- oprava signalizace kodu posledni vznikle chyby ErrC u binarnich 
poruchovek SigErr11, SigErr12 a SigErr13
		- oprava soubezne zadosti poruchy u analogovych poruchovek SigErr21, 
SigErr22, SigErr23

1.6 3.10.2008	- doplneni definice __R0...  do vsech PID FB 

1.5 22.01.2008  - v blocich Ekviterm1 a Ekviterm2 zmena poradi vnitrnich promennych 
VAR 
		  (zarazeny za VAR_OUTPUT kvuli Relianci, aby struktury VAR_INPUT a 
VAR_OUTPUT lezely 
		   bezprostredne za sebou)
		- v blocich PID opraven pristup na absolutni operand %R0 prez #def 
__R0__
		  (pri pouziti PID bloku z knihovny vyskakovalo zbytecne hlaseni o 
prekryvu promennych)	

1.4 20.10.2006	- v blocich SigErr13 a SigErr23 opraveno blikani signalky SigO pri 
kaskadovani

1.3 14.09.2006	- v blocich PID1 a PID2 doplneny vstupni parametry MinY a MaxY 
(vcetne inicializace)

1.2 26.07.2006	- oprava nazvu duplicitniho typu TTecoDateTime (kolidoval s typem v 
knihovne SysLib.mlb)

1.1 09.06.2006	- uprava nazvu i/o promennych bloku
		- oddeleni IRC bloku do samostatne knihovny 

1.0 17.05.2006	- vychozi verze (neuvolnena)
		- prevzaty regulacni komponenty z programovaciho prostredi Merkur
*)

(*----------------------------------------------------------------------------*)
// {LIBRARY="LOCALLIB\STDLIB_V16_20051107.MLB"}

TYPE Rego_TTecoDateTime :
  STRUCT
    year             : usint;  (*` last two numbers*)
    month            : usint;  (*` 1 .. 12*)
    day              : usint;  (*` 1 .. 28/29/30/31*)
    hour             : usint;  (*` 0 .. 23*)
    min              : usint;  (*` 0 .. 59*)
    sec              : usint;  (*` 0 .. 59*)
    dayOfWeek        : usint;  (*` 1 = Monday .. 7 = Sunday*)
    milisec          : uint;  (*` 0 .. 999*)
  END_STRUCT;
END_TYPE

__DECL FUNCTION Rego_GetTime : time
(*`------------------------------------------------------------------------------
 Function returns actual system time

*)
END_FUNCTION

__DECL FUNCTION Rego_GetDateTime : dt
(*`------------------------------------------------------------------------------
 Function returns actual system date and time

*)
  VAR
    tmp              : Rego_TTecoDateTime;
  END_VAR
END_FUNCTION

TYPE _TCascade2_IN_ :
  STRUCT
    LIMIT1           : real;  (*`mez spinani/vypinani 1. stupne kaskady*)
    LIMIT2           : real;  (*`mez spinani/vypinani 2. stupne kaskady*)
    HYSTER           : real;  (*`hystereze spinani/vypinani*)
    ECHNG            : bool;  (*`povoleni stridani stupnu kaskady*)
    ECHNGT           : bool;  (*`povoleni stridani stupnu kaskady podle provoznich hodin*)
  END_STRUCT;
END_TYPE

TYPE _TCascade2_OUT_ :
  STRUCT
    WT1              : time;  (*`provozni hodiny 1. stupne kaskady*)
    WT2              : time;  (*`provozni hodiny 2. stupne kaskady*)
    SEQ              : usint;  (*`poradi stupnu kaskady*)
  END_STRUCT;
END_TYPE

__DECL FUNCTION_BLOCK Cascade2
(*`
  Cascade2 - kaskáda 2 stupòù se støídáním
  Pokud je promìnná ACT v log.1 jsou na základì vstupní promìnné IN ovládány
  jednotlivé stupnì kaskády STx. Stupnì jsou spínány a odepínány podle jednotlivých
  mezí LIMITx (vztažených ke vstupní promìnné IN) a nastavené hystereze HYSTER.
  V pøípadì poruchy nìkterého ze stupòù ERRx je tento vypnut a nahrazen jiným
  (dalším v kaskádì).
  Komponenta dale obsahuje funkci pro zmìnu poøadí spínání stupòù.
  Pokud je promìnná ECHNG v log.1, je na nábìžnou hranu binárního signálu CHNG
  zmìnìno poøadí stupòù. Jednotlivé stupnì jsou øazeny tak, aby jejich použití bylo
  rovnomìrné (viz. tabulka poøadí). V pøípadì, že je navic promìnná ECHNGT v log.1,
  jsou stupnì kaskády øazeny podle nabìhaných provozních hodin WORKTx tak,
  aby ten s nejmenším poètem hodin byl v kaskádì na prvním místì.Èítání provozních
  hodin stupòù kaskády je aktivováno nastavením pøíslušné promìnné WRKx do log.1
  v dobì, kdy je daný stupeò v chodu. Signálem RES se provozní hodiny všech
  stupòù kaskady nulují.
  Vstup IN se pøipojuje na spojitý výstup regulaèních PID komponent a mùže
  nabývat hodnot v rozsahu od 0 do 100[%].

  Tabulka poøadí:
  PORADI  KASKÁDA
  0	  12
  1	  21

*)
  VAR_INPUT
    IN               : real;  (*`vstupni pozadovany vykon*)
    ACT              : bool;  (*`aktivace*)
    ERR1             : bool;  (*`porucha 1.stupne kaskady*)
    ERR2             : bool;  (*`porucha 2.stupne kaskady*)
    WRK1             : bool;  (*`chod 1.stupne kaskady*)
    WRK2             : bool;  (*`chod 2.stupne kaskady*)
    CHNG             : bool R_EDGE;  (*`zmena poradi*)
    RES              : bool;  (*`reset provoznich hodin*)
    CFG              : _TCascade2_IN_;  (*`konfiguracni parametry kaskady*)
  END_VAR
  VAR
    timer1           : TON;  (*`casovac provoznich hodin 1. stupne*)
    timer2           : TON;  (*`casovac provoznich hodin 2. stupne*)
    pomSt1           : bool;
    pomSt2           : bool;
  END_VAR
  VAR_OUTPUT
    OUT              : real;  (*`vystupni pozadovany vykon*)
    ST1              : bool;  (*`1. kaskadni vystup*)
    ST2              : bool;  (*`2. kaskadni vystup*)
    STAT             : _TCascade2_OUT_;  (*`stavove promenne kaskady*)
  END_VAR
END_FUNCTION_BLOCK

TYPE _TCascade3_IN_ :
  STRUCT
    LIMIT1           : real;  (*`mez spinani/vypinani 1. stupne kaskady*)
    LIMIT2           : real;  (*`mez spinani/vypinani 2. stupne kaskady*)
    LIMIT3           : real;  (*`mez spinani/vypinani 3. stupne kaskady*)
    HYSTER           : real;  (*`hystereze spinani/vypinani*)
    ECHNG            : bool;  (*`povoleni stridani stupnu kaskady*)
    ECHNGT           : bool;  (*`povoleni stridani stupnu kaskady podle provoznich hodin*)
  END_STRUCT;
END_TYPE

TYPE _TCascade3_OUT_ :
  STRUCT
    WT1              : time;  (*`provozni hodiny 1. stupne kaskady*)
    WT2              : time;  (*`provozni hodiny 2. stupne kaskady*)
    WT3              : time;  (*`provozni hodiny 3. stupne kaskady*)
    SEQ              : usint;  (*`poradi stupnu kaskady*)
  END_STRUCT;
END_TYPE

__DECL FUNCTION_BLOCK Cascade3
(*`
  Cascade3 - kaskáda 3 stupòù se støídáním
  Pokud je promìnná ACT v log.1 jsou na základì vstupní promìnné IN ovládány
  jednotlivé stupnì kaskády STx. Stupnì jsou spínány a odepínány podle jednotlivých
  mezí LIMITx (vztažených ke vstupní promìnné IN) a nastavené hystereze HYSTER.
  V pøípadì poruchy nìkterého ze stupòù ERRx je tento vypnut a nahrazen jiným
  (dalším v kaskádì).
  Komponenta dale obsahuje funkci pro zmìnu poøadí spínání stupòù.
  Pokud je promìnná ECHNG v log.1, je na nábìžnou hranu binárního signálu CHNG
  zmìnìno poøadí stupòù. Jednotlivé stupnì jsou øazeny tak, aby jejich použití bylo
  rovnomìrné (viz. tabulka poøadí). V pøípadì, že je navic promìnná ECHNGT v log.1,
  jsou stupnì kaskády øazeny podle nabìhaných provozních hodin WORKTx tak,
  aby ten s nejmenším poètem hodin byl v kaskádì na prvním místì.Èítání provozních
  hodin stupòù kaskády je aktivováno nastavením pøíslušné promìnné WRKx do log.1
  v dobì, kdy je daný stupeò v chodu. Signálem RES se provozní hodiny všech
  stupòù kaskady nulují.
  Vstup IN se pøipojuje na spojitý výstup regulaèních PID komponent a mùže
  nabývat hodnot v rozsahu od 0 do 100[%].

  Tabulka poøadí:
  PORADI  KASKÁDA
  0	  123
  1	  231
  2	  312

*)
  VAR_INPUT
    IN               : real;  (*`vstupni pozadovany vykon*)
    ACT              : bool;  (*`aktivace*)
    ERR1             : bool;  (*`porucha 1.stupne kaskady*)
    ERR2             : bool;  (*`porucha 2.stupne kaskady*)
    ERR3             : bool;  (*`porucha 3.stupne kaskady*)
    WRK1             : bool;  (*`chod 1.stupne kaskady*)
    WRK2             : bool;  (*`chod 2.stupne kaskady*)
    WRK3             : bool;  (*`chod 3.stupne kaskady*)
    CHNG             : bool R_EDGE;  (*`zmena poradi*)
    RES              : bool;  (*`reset provoznich hodin*)
    CFG              : _TCascade3_IN_;  (*`konfiguracni parametry kaskady*)
  END_VAR
  VAR
    timer1           : TON;  (*`casovac provoznich hodin 1. stupne*)
    timer2           : TON;  (*`casovac provoznich hodin 2. stupne*)
    timer3           : TON;  (*`casovac provoznich hodin 3. stupne*)
    pomSt1           : bool;
    pomSt2           : bool;
    pomSt3           : bool;
  END_VAR
  VAR_OUTPUT
    OUT              : real;  (*`vystupni pozadovany vykon*)
    ST1              : bool;  (*`1. kaskadni vystup*)
    ST2              : bool;  (*`2. kaskadni vystup*)
    ST3              : bool;  (*`3. kaskadni vystup*)
    STAT             : _TCascade3_OUT_;  (*`stavove promenne kaskady*)
  END_VAR
END_FUNCTION_BLOCK

TYPE _TCascade4_IN_ :
  STRUCT
    LIMIT1           : real;  (*`mez spinani/vypinani 1. stupne kaskady*)
    LIMIT2           : real;  (*`mez spinani/vypinani 2. stupne kaskady*)
    LIMIT3           : real;  (*`mez spinani/vypinani 3. stupne kaskady*)
    LIMIT4           : real;  (*`mez spinani/vypinani 4. stupne kaskady*)
    HYSTER           : real;  (*`hystereze spinani/vypinani*)
    ECHNG            : bool;  (*`povoleni stridani stupnu kaskady*)
    ECHNGT           : bool;  (*`povoleni stridani stupnu kaskady podle provoznich hodin*)
  END_STRUCT;
END_TYPE

TYPE _TCascade4_OUT_ :
  STRUCT
    WT1              : time;  (*`provozni hodiny 1. stupne kaskady*)
    WT2              : time;  (*`provozni hodiny 2. stupne kaskady*)
    WT3              : time;  (*`provozni hodiny 3. stupne kaskady*)
    WT4              : time;  (*`provozni hodiny 4. stupne kaskady*)
    SEQ              : usint;  (*`poradi stupnu kaskady*)
  END_STRUCT;
END_TYPE

__DECL FUNCTION_BLOCK Cascade4
(*`
  Cascade4 - kaskáda 4 stupòù se støídáním
  Pokud je promìnná ACT v log.1 jsou na základì vstupní promìnné IN ovládány
  jednotlivé stupnì kaskády STx. Stupnì jsou spínány a odepínány podle jednotlivých
  mezí LIMITx (vztažených ke vstupní promìnné IN) a nastavené hystereze HYSTER.
  V pøípadì poruchy nìkterého ze stupòù ERRx je tento vypnut a nahrazen jiným
  (dalším v kaskádì).
  Komponenta dale obsahuje funkci pro zmìnu poøadí spínání stupòù.
  Pokud je promìnná ECHNG v log.1, je na nábìžnou hranu binárního signálu CHNG
  zmìnìno poøadí stupòù. Jednotlivé stupnì jsou øazeny tak, aby jejich použití bylo
  rovnomìrné (viz. tabulka poøadí). V pøípadì, že je navic promìnná ECHNGT v log.1,
  jsou stupnì kaskády øazeny podle nabìhaných provozních hodin WORKTx tak,
  aby ten s nejmenším poètem hodin byl v kaskádì na prvním místì.Èítání provozních
  hodin stupòù kaskády je aktivováno nastavením pøíslušné promìnné WRKx do log.1
  v dobì, kdy je daný stupeò v chodu. Signálem RES se provozní hodiny všech
  stupòù kaskady nulují.
  Vstup IN se pøipojuje na spojitý výstup regulaèních PID komponent a mùže
  nabývat hodnot v rozsahu od 0 do 100[%].

  Tabulka poøadí:
  PORADI  KASKÁDA
  0	  1234
  1	  2341
  2	  3412
  3	  4123

*)
  VAR_INPUT
    IN               : real;  (*`vstupni pozadovany vykon*)
    ACT              : bool;  (*`aktivace*)
    ERR1             : bool;  (*`porucha 1.stupne kaskady*)
    ERR2             : bool;  (*`porucha 2.stupne kaskady*)
    ERR3             : bool;  (*`porucha 3.stupne kaskady*)
    ERR4             : bool;  (*`porucha 4.stupne kaskady*)
    WRK1             : bool;  (*`chod 1.stupne kaskady*)
    WRK2             : bool;  (*`chod 2.stupne kaskady*)
    WRK3             : bool;  (*`chod 3.stupne kaskady*)
    WRK4             : bool;  (*`chod 4.stupne kaskady*)
    CHNG             : bool R_EDGE;  (*`zmena poradi*)
    RES              : bool;  (*`reset provoznich hodin*)
    CFG              : _TCascade4_IN_;  (*`konfiguracni parametry kaskady*)
  END_VAR
  VAR
    timer1           : TON;  (*`casovac provoznich hodin 1. stupne*)
    timer2           : TON;  (*`casovac provoznich hodin 2. stupne*)
    timer3           : TON;  (*`casovac provoznich hodin 3. stupne*)
    timer4           : TON;  (*`casovac provoznich hodin 4. stupne*)
    pomSt1           : bool;
    pomSt2           : bool;
    pomSt3           : bool;
    pomSt4           : bool;
  END_VAR
  VAR_OUTPUT
    OUT              : real;  (*`vystupni pozadovany vykon*)
    ST1              : bool;  (*`1. kaskadni vystup*)
    ST2              : bool;  (*`2. kaskadni vystup*)
    ST3              : bool;  (*`3. kaskadni vystup*)
    ST4              : bool;  (*`4. kaskadni vystup*)
    STAT             : _TCascade4_OUT_;  (*`stavove promenne kaskady*)
  END_VAR
END_FUNCTION_BLOCK

TYPE _TCascade5_IN_ :
  STRUCT
    LIMIT1           : real;  (*`mez spinani/vypinani 1. stupne kaskady*)
    LIMIT2           : real;  (*`mez spinani/vypinani 2. stupne kaskady*)
    LIMIT3           : real;  (*`mez spinani/vypinani 3. stupne kaskady*)
    LIMIT4           : real;  (*`mez spinani/vypinani 4. stupne kaskady*)
    LIMIT5           : real;  (*`mez spinani/vypinani 5. stupne kaskady*)
    HYSTER           : real;  (*`hystereze spinani/vypinani*)
    ECHNG            : bool;  (*`povoleni stridani stupnu kaskady*)
    ECHNGT           : bool;  (*`povoleni stridani stupnu kaskady podle provoznich hodin*)
  END_STRUCT;
END_TYPE

TYPE _TCascade5_OUT_ :
  STRUCT
    WT1              : time;  (*`provozni hodiny 1. stupne kaskady*)
    WT2              : time;  (*`provozni hodiny 2. stupne kaskady*)
    WT3              : time;  (*`provozni hodiny 3. stupne kaskady*)
    WT4              : time;  (*`provozni hodiny 4. stupne kaskady*)
    WT5              : time;  (*`provozni hodiny 5. stupne kaskady*)
    SEQ              : usint;  (*`poradi stupnu kaskady*)
  END_STRUCT;
END_TYPE

__DECL FUNCTION_BLOCK Cascade5
(*`
  Cascade5 - kaskáda 5-ti stupòù se støídáním
  Pokud je promìnná ACTIV v log.1 jsou na základì vstupní promìnné INPUT ovládány
  jednotlivé stupnì kaskády STEPx. Stupnì jsou spínány a odepínány podle jednotlivých
  mezí LIMITx (vztažených ke vstupní promìnné INPUT) a nastavené hystereze HYSTER.
  V pøípadì poruchy nìkterého ze stupòù ERRx je tento vypnut a nahrazen jiným
  (dalším v kaskádì).
  Komponenta dale obsahuje funkci pro zmìnu poøadí spínání stupòù.
  Pokud je promìnná ECHNG v log.1, je na nábìžnou hranu binárního signálu CHNG
  zmìnìno poøadí stupòù. Jednotlivé stupnì jsou øazeny tak, aby jejich použití bylo
  rovnomìrné (viz. tabulka poøadí). V pøípadì, že je navic promìnná ECHNGT v log.1,
  jsou stupnì kaskády øazeny podle nabìhaných provozních hodin WORKTx tak,
  aby ten s nejmenším poètem hodin byl v kaskádì na prvním místì.Èítání provozních
  hodin stupòù kaskády je aktivováno nastavením pøíslušné promìnné WORKx do log.1
  v dobì, kdy je daný stupeò v chodu. Signálem RESET se provozní hodiny všech
  stupòù kaskady nulují.
  Vstup INPUT se pøipojuje na spojitý výstup regulaèních PID komponent a mùže
  nabývat hodnot v rozsahu od 0 do 100[%].

  Tabulka poøadí:
  PORADI  KASKÁDA
  0	  12345
  1	  23451
  2	  34512
  3	  45123
  4	  51234

*)
  VAR_INPUT
    IN               : real;  (*`vstupni pozadovany vykon*)
    ACT              : bool;  (*`aktivace*)
    ERR1             : bool;  (*`porucha 1.stupne kaskady*)
    ERR2             : bool;  (*`porucha 2.stupne kaskady*)
    ERR3             : bool;  (*`porucha 3.stupne kaskady*)
    ERR4             : bool;  (*`porucha 4.stupne kaskady*)
    ERR5             : bool;  (*`porucha 5.stupne kaskady*)
    WRK1             : bool;  (*`chod 1.stupne kaskady*)
    WRK2             : bool;  (*`chod 2.stupne kaskady*)
    WRK3             : bool;  (*`chod 3.stupne kaskady*)
    WRK4             : bool;  (*`chod 4.stupne kaskady*)
    WRK5             : bool;  (*`chod 5.stupne kaskady*)
    CHNG             : bool R_EDGE;  (*`zmena poradi*)
    RES              : bool;  (*`reset provoznich hodin*)
    CFG              : _TCascade5_IN_;  (*`konfiguracni parametry kaskady*)
  END_VAR
  VAR
    timer1           : TON;  (*`casovac provoznich hodin 1. stupne*)
    timer2           : TON;  (*`casovac provoznich hodin 2. stupne*)
    timer3           : TON;  (*`casovac provoznich hodin 3. stupne*)
    timer4           : TON;  (*`casovac provoznich hodin 4. stupne*)
    timer5           : TON;  (*`casovac provoznich hodin 5. stupne*)
    pomSt1           : bool;
    pomSt2           : bool;
    pomSt3           : bool;
    pomSt4           : bool;
    pomSt5           : bool;
  END_VAR
  VAR_OUTPUT
    OUT              : real;  (*`vystupni pozadovany vykon*)
    ST1              : bool;  (*`1. kaskadni vystup*)
    ST2              : bool;  (*`2. kaskadni vystup*)
    ST3              : bool;  (*`3. kaskadni vystup*)
    ST4              : bool;  (*`4. kaskadni vystup*)
    ST5              : bool;  (*`5. kaskadni vystup*)
    STAT             : _TCascade5_OUT_;  (*`stavove promenne kaskady*)
  END_VAR
END_FUNCTION_BLOCK

TYPE _TEkviterm1_Cfg_ :
  STRUCT  (*`casovy program pro*)
    TempEkvA         : real;  (*`pozadovana ekvitermni teplota pri venkovni teplote -20°C [°C]	*)
    TempEkvB         : real;  (*`pozadovana ekvitermni teplota pri venkovni teplote  -8°C [°C]	*)
    TempEkvC         : real;  (*`pozadovana ekvitermni teplota pri venkovni teplote  +5°C [°C]*)
    TempEkvD         : real;  (*`pozadovana ekvitermni teplota pri venkovni teplote +15°C [°C]*)
    MinTempOut       : real;  (*`minimalni ekvitermni teplota na vystupu [°C]*)
    Drop             : real;  (*`utlum vystupni teploty [°C]*)
    Ramp             : int;  (*`casove zpozdeni zacatku a konce utlumoveho provozu [min]*)
  END_STRUCT;
END_TYPE

__DECL FUNCTION_BLOCK Ekviterm1
(*`
  Komponenta provádí výpoèet žádané teploty OUT na základì mìøené venkovní teploty IN,
  nastavených parametrù ètyøbodové ekvitermní køivky a požadavku útlumového programu.
  Parametry TEMPEKVA-TEMPEKVD umožòují pohybovat nastavenou ekvitermní køivkou ve vertikálním
  smìru. Teploty zlomu ekvitermní køivky jsou stanoveny pevne na TempA = -20°C, TempB = -8°C,
  TempC = +5°C, TempD = +15°C.
  Maximální vypoètená teplota dle ekvitermní køivky je rovna bodu TEMPEKVA,
  minimální je rovna bodu TEMPEKVD. Minimální vypoètená teplota mùže být snížena o nastavený útlum,
  ne však ménì než urèuje parametr MINTEMOUT.
  Pokud je vstupní promìnná ACT v log.0, je vypoètená ekvitermní teplota postupnì dle rampy
  snižována na hodnotu ekvitermní sníženou o nastavený útlum DROP. Pokud se promìnná ACT zmìní
  z log.0 do log.1, je opìt výstupní teplota dle rampy zvyšována na vypoètenou ekvitermní teplotu.
  Doba, za kterou je tato hodnota dosažena, je dána parametrem RAMP.

*)
  VAR_INPUT
    Act              : bool;  (*`provoz topeni (1/0 - TOPIT/UTLUM)		*)
    In               : real;  (*`venkovni teplota [°C]*)
    Cfg              : _TEkviterm1_Cfg_;  (*`konfiguracni parametry bloku*)
  END_VAR
  VAR_OUTPUT
    Out              : real;  (*`vystupni ekvitermni teplota [°C]*)
  END_VAR
  VAR
    CNTRamp          : CTUD;  (*`citac utlumove rampy*)
  END_VAR
END_FUNCTION_BLOCK

TYPE _TEkviterm2_Cfg_ :
  STRUCT  (*`casovy program pro*)
    TempEkvA         : real;  (*`pozadovana ekvitermni teplota pri venkovni teplote bod A [°C]	*)
    TempEkvB         : real;  (*`pozadovana ekvitermni teplota pri venkovni teplote bod B [°C]	*)
    TempEkvC         : real;  (*`pozadovana ekvitermni teplota pri venkovni teplote bod C [°C]	*)
    TempEkvD         : real;  (*`pozadovana ekvitermni teplota pri venkovni teplote bod D [°C]	*)
    TempA            : real;  (*`pozadovana venkovni teplota bod A [°C]	*)
    TempB            : real;  (*`pozadovana venkovni teplota bod B [°C]	*)
    TempC            : real;  (*`pozadovana venkovni teplota bod C [°C]	*)
    TempD            : real;  (*`pozadovana venkovni teplota bod D [°C]	*)
    MinTempOut       : real;  (*`minimalni ekvitermni teplota na vystupu [°C]*)
    Drop             : real;  (*`utlum vystupni teploty [°C]*)
    Ramp             : int;  (*`casove zpozdeni zacatku a konce utlumoveho provozu [min]*)
  END_STRUCT;
END_TYPE

__DECL FUNCTION_BLOCK Ekviterm2
(*`
  Komponenta provádí výpoèet žádané teploty OUT na základì mìøené venkovní teploty IN,
  nastavených parametrù ètyøbodové ekvitermní køivky a požadavku útlumového programu.
  Parametry TEMPEKVA-Cfg.TempEkvD umožòují pohybovat nastavenou ekvitermní køivkou ve vertikálním
  a parametry TEMPA-TEMPD v horizontálním smìru.
  Maximální vypoètená teplota dle ekvitermní køivky je rovna bodu TEMPEKVA,
  minimální je rovna bodu TEMPEKVD. Minimální vypoètená teplota mùže být snížena o nastavený útlum DROP
  ne však ménì než urèuje parametr MINTEMPOUT.
  Pokud je vstupní promìnná ACT v log.0, je vypoètená ekvitermní teplota postupnì dle rampy
  snižována na hodnotu ekvitermní sníženou o nastavený útlum DROP. Pokud se promìnná ACT zmìní
  z log.0 do log.1, je opìt výstupní ekvitermní teplota dle rampy zvyšována na vypoètenou teplotu OUT.
  Doba, za kterou je tato hodnota dosažena, je dána parametrem RAMP.

*)
  VAR_INPUT
    Act              : bool;  (*`provoz topeni (1/0 - TOPIT/UTLUM)		*)
    In               : real;  (*`venkovni teplota [°C]*)
    Cfg              : _TEkviterm2_Cfg_;  (*`konfiguracni parametry bloku*)
  END_VAR
  VAR_OUTPUT
    Out              : real;  (*`vystupni ekvitermni teplota [°C]*)
  END_VAR
  VAR
    CNTRamp          : CTUD;  (*`citac utlumove rampy*)
  END_VAR
END_FUNCTION_BLOCK

TYPE _History_Rec_ :
  STRUCT  (*`struktura zaznamu jedne poruchy*)
    ETime            : dt;  (*`datum a cas vzniku poruchy*)
    ECode            : usint;  (*`kod poruchy*)
  END_STRUCT;
END_TYPE

TYPE _History_Buf_ :
  STRUCT  (*`struktura zaznamu chyboveho bufferu*)
    Err              : ARRAY [0..9] OF _History_Rec_;
  END_STRUCT;
END_TYPE

__DECL FUNCTION_BLOCK History1
(*`
  Komponenta provádí ukládání výskytu poruch do zásobníku typu FIFO.
  Na vstup komponenty IN je pøiveden výstup ERRC z nìkterých poruchových komponent
  (SigErr11, SigErr12, SigErr13 nebo SigErr21, SigErr22, SigErr23).
  Do databáze 10-ti poruch BUF[]
  je uložena vždy nová pøíchozí porucha s datumem a èasem vzniku.
  Poslední - desátá porucha je s posunem zásobníku ztracena.
  Èasovì je tedy porucha s è.[0] nejnovìjší a porucha s è.[9] nejstarší.
  Signálem RES je možné databázi uložených poruch vymazat.

*)
  VAR_INPUT
    In1              : usint;  (*`cislo aktualni poruchy z komponenty poruchove signalizace*)
    Res              : bool;  (*`nulovani zasobniku ulozenych poruch		*)
  END_VAR
  VAR
    LastErrCode      : usint;  (*`predchozi stav cisla poruchy*)
  END_VAR
  VAR_OUTPUT
    Buf              : _History_Buf_;  (*`chybovy buffer*)
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION_BLOCK History5
(*`
  Komponenta provádí ukládání výskytu poruch do zásobníku typu FIFO.
  Na vstup komponenty INx je pøiveden výstup ERRC z nìkterých poruchových komponent
  (SigErr11, SigErr12, SigErr13 nebo SigErr21, SigErr22, SigErr23).
  Do vnitøní databáze 10-ti poruch BUF[]
  je uložena vždy nová pøíchozí porucha s datumem a èasem vzniku.
  Poslední - desátá porucha je s posunem zásobníku ztracena.
  Èasovì je tedy porucha s è[0] nejnovìjší a porucha s è.[9] nejstarší.
  Signálem RES je možné databázi uložených poruch vymazat.
  U poruch z komponent pøivedených na druhý vstup a výše je k èíslu poruchy
  pøièten offset 8 a dále násobky osmi.

*)
  VAR_INPUT
    In1              : usint;  (*`cislo aktualni poruchy 1 z komponenty poruchovych signalizaci*)
    In2              : usint;  (*`cislo aktualni poruchy 2 z komponenty poruchovych signalizaci*)
    In3              : usint;  (*`cislo aktualni poruchy 3 z komponenty poruchovych signalizaci*)
    In4              : usint;  (*`cislo aktualni poruchy 4 z komponenty poruchovych signalizaci*)
    In5              : usint;  (*`cislo aktualni poruchy 5 z komponenty poruchovych signalizaci*)
    Res              : bool;  (*`nulovani zasobniku ulozenych poruch		*)
  END_VAR
  VAR
    LastErrCode1     : usint;  (*`predchozi stav cisla poruchy 1*)
    LastErrCode2     : usint;  (*`predchozi stav cisla poruchy 2*)
    LastErrCode3     : usint;  (*`predchozi stav cisla poruchy 3*)
    LastErrCode4     : usint;  (*`predchozi stav cisla poruchy 4*)
    LastErrCode5     : usint;  (*`predchozi stav cisla poruchy 5*)
  END_VAR
  VAR_OUTPUT
    Buf              : _History_Buf_;  (*`chybovy buffer*)
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION_BLOCK History10
(*`
  Komponenta provádí ukládání výskytu poruch do zásobníku typu FIFO.
  Na vstup komponenty INx je pøiveden výstup ERRC z nìkterých poruchových komponent
  (SigErr11, SigErr12, SigErr13 nebo SigErr21, SigErr22, SigErr23).
  Do vnitøní databáze 10-ti poruch BUF[]
  je uložena vždy nová pøíchozí porucha s datumem a èasem vzniku.
  Poslední - desátá porucha je s posunem zásobníku ztracena.
  Èasovì je tedy porucha s è.[0] nejnovìjší a porucha s è.[9] nejstarší.
  Signálem RES je možné databázi uložených poruch vymazat.
  U poruch z komponent pøivedených na druhý vstup a výše je k èíslu poruchy
  pøièten offset 8 a dále násobky osmi.

*)
  VAR_INPUT
    In1              : usint;  (*`cislo aktualni poruchy 1 z komponenty poruchovych signalizaci*)
    In2              : usint;  (*`cislo aktualni poruchy 2 z komponenty poruchovych signalizaci*)
    In3              : usint;  (*`cislo aktualni poruchy 3 z komponenty poruchovych signalizaci*)
    In4              : usint;  (*`cislo aktualni poruchy 4 z komponenty poruchovych signalizaci*)
    In5              : usint;  (*`cislo aktualni poruchy 5 z komponenty poruchovych signalizaci*)
    In6              : usint;  (*`cislo aktualni poruchy 6 z komponenty poruchovych signalizaci*)
    In7              : usint;  (*`cislo aktualni poruchy 7 z komponenty poruchovych signalizaci*)
    In8              : usint;  (*`cislo aktualni poruchy 8 z komponenty poruchovych signalizaci*)
    In9              : usint;  (*`cislo aktualni poruchy 9 z komponenty poruchovych signalizaci*)
    In10             : usint;  (*`cislo aktualni poruchy 10 z komponenty poruchovych signalizaci*)
    Res              : bool;  (*`nulovani zasobniku ulozenych poruch		*)
  END_VAR
  VAR
    LastErrCode1     : usint;  (*`predchozi stav cisla poruchy 1*)
    LastErrCode2     : usint;  (*`predchozi stav cisla poruchy 2*)
    LastErrCode3     : usint;  (*`predchozi stav cisla poruchy 3*)
    LastErrCode4     : usint;  (*`predchozi stav cisla poruchy 4*)
    LastErrCode5     : usint;  (*`predchozi stav cisla poruchy 5*)
    LastErrCode6     : usint;  (*`predchozi stav cisla poruchy 6*)
    LastErrCode7     : usint;  (*`predchozi stav cisla poruchy 7*)
    LastErrCode8     : usint;  (*`predchozi stav cisla poruchy 8*)
    LastErrCode9     : usint;  (*`predchozi stav cisla poruchy 9*)
    LastErrCode10    : usint;  (*`predchozi stav cisla poruchy 10*)
  END_VAR
  VAR_OUTPUT
    Buf              : _History_Buf_;  (*`chybovy buffer*)
  END_VAR
END_FUNCTION_BLOCK

TYPE _TPID_Control_ :
  STRUCT
    RC               : bool;
    AO               : bool;
    A12              : bool;
    KC               : bool;
    BU               : bool;
    IP               : bool;
    AM               : bool;
    HR               : bool;
    RF               : bool;
    RIO              : bool;
    R41              : bool;
    CHN              : bool;
    DUM              : bool;
    FU0              : bool;
    FU1              : bool;
    FU3              : bool;
  END_STRUCT;
END_TYPE

TYPE _TPID_Status_ :
  STRUCT
    UH               : bool;
    UC               : bool;
    UM               : bool;
    DR               : bool;
    EY1              : bool;
    EY2              : bool;
    EY3              : bool;
    DUM              : bool;
  END_STRUCT;
END_TYPE

TYPE _TPID_ :
  STRUCT
    MinY             : int;  (*` Hodnota unifikovaného rozsahu odpovídající 0%*)
    MaxY             : int;  (*` Hodnota unifikovaného rozsahu odpovídající 100%*)
    Input1           : int;  (*` Merena hodnota*)
    gW               : int;  (*` Cílová žádaná hodnota*)
    ConW             : int;  (*` Aktuální žádaná hodnota*)
    tiW              : uint;  (*` Èasová konstanta filtru žádané hodnoty*)
    Dev              : int;  (*` Regulaèní odchylka*)
    Output           : int;  (*` Akèní velièina*)
    LastOut          : int;  (*` Minulý akèní zásah*)
    CurOut           : int;  (*` Akèní zásah*)
    ConOut           : int;  (*` Akèní zásah v absolutní hodnotì modifikovaný dle øídícího slova*)
    DefOut           : int;  (*` Pøeddefinovaný akèní zásah pøi poruše (uDef)*)
    MinU             : int;  (*` Minimální povolený akèní zásah*)
    MaxU             : int;  (*` Maximální povolený akèní zásah*)
    dMaxU            : uint;  (*` Maximální pøírustek akèní velièiny za jednu periodu*)
    OutCycle         : uint;  (*` Perioda vzorkovaní regulaèního algoritmu [10ms]*)
    PBnd             : uint;  (*` Pásmo proporcionality (PBnd)*)
    RelCool          : uint;  (*` Relativní pásmo proporcionality pro záporné hodnoty regulaèní odchylky (RelCool)*)
    Ti               : uint;  (*` Integraèní èasová konstanta [0.1s]*)
    Td               : uint;  (*` Derivaèní èasová konstanta [0.1s]*)
    EGap             : uint;  (*` Symetrické pásmo necitlivosti*)
    DGap             : uint;  (*` Symetrické pásmo pùsobení derivaèní složky*)
    IGap             : uint;  (*` Symetrické pásmo pùsobení integraèní složky*)
    Control          : _TPID_Control_;  (*` Øídicí slovo*)
    Status           : _TPID_Status_;  (*` Stavové slovo*)
    AuxD             : ARRAY [0..22] OF usint;  (*` Rezervováno pro algoritmus PID, nemodifikovat!*)
  END_STRUCT;
END_TYPE

TYPE _TPID1_IN_ :
  STRUCT
    MinY             : int;  (*` Hodnota unifikovaného rozsahu odpovídající 0%*)
    MaxY             : int;  (*` Hodnota unifikovaného rozsahu odpovídající 100%*)
    tiW              : uint;  (*` Èasová konstanta filtru žádané hodnoty*)
    MinU             : int;  (*` Minimální povolený akèní zásah*)
    MaxU             : int;  (*` Maximální povolený akèní zásah*)
    dMaxU            : uint;  (*` Maximální pøírustek akèní velièiny za jednu periodu*)
    OutCycle         : uint;  (*` Perioda vzorkovaní regulaèního algoritmu [10ms]*)
    PBnd             : uint;  (*` Pásmo proporcionality (PBnd)*)
    RelCool          : uint;  (*` Relativní pásmo proporcionality pro záporné hodnoty regulaèní odchylky (RelCool)*)
    Ti               : uint;  (*` Integraèní èasová konstanta [0.1s]*)
    Td               : uint;  (*` Derivaèní èasová konstanta [0.1s]*)
    EGap             : uint;  (*` Symetrické pásmo necitlivosti*)
    DGap             : uint;  (*` Symetrické pásmo pùsobení derivaèní složky*)
    IGap             : uint;  (*` Symetrické pásmo pùsobení integraèní složky*)
  END_STRUCT;
END_TYPE

TYPE _TPID1_IN_OUT_ :
  STRUCT
    Control          : _TPID_Control_;  (*` Øídicí slovo*)
  END_STRUCT;
END_TYPE

__DECL FUNCTION_BLOCK PID1
(*`
  PID regulátor s pøírùstkovým øízením.
  Pokud je promìnná ACT v log.1 jsou akceptovány ostatní vstupní promìnné
  a je aktivován algoritmus regulátoru - regulace hodnoty mìøené MSR
  na hodnotu žádanou RQR. V promìnných MORE a LESS jsou pøedávány povely
  pro akèní orgán (regulaèní ventil).
  
  Regulátor nastavuje tyto promìnné:
  MSR     := Input1
  RQR     := gW
  MORE    := Status.0
  LESS	  := Status.1
  CONTROL := $0071 (pouze pøi startu regulace)

*)
  VAR_INPUT
    ACT              : bool;  (*`aktivace*)
    MSR              : real;  (*`merena hodnota*)
    RQR              : real;  (*`zadana hodnota*)
    CFI              : _TPID1_IN_ :=                         // vstupni parametry PID struktury
                              (MinY    := 0,     // Hodnota unifikovaného rozsahu odpovídající 0%
                               MaxY    := 1000,  // Hodnota unifikovaného rozsahu odpovídající 100%
                               tiW     := 0,     // Èasová konstanta filtru žádané hodnoty
                               MinU    := 0,     // Minimální povolený akèní zásah
                               MaxU    := 10000, // Maximální povolený akèní zásah
                               dMaxU   := 1000,  // Maximální pøírustek akèní velièiny za jednu periodu
                               OutCycle:= 820,   // Perioda vzorkovaní regulaèního algoritmu [10ms]
                               PBnd    := 500,   // Pásmo proporcionality (PBnd)
                               RelCool := 1000,  // Relativní pásmo proporcionality pro záporné hodnoty regulaèní odchylky (RelCool)
                               Ti      := 740,   // Integraèní èasová konstanta [0.1s]
                               Td      := 26,    // Derivaèní èasová konstanta [0.1s]
                               EGap    := 10,    // Symetrické pásmo necitlivosti
                               DGap    := 10000, // Symetrické pásmo pùsobení derivaèní složky
                               IGap    := 10000);  (*` vstupni parametry PID struktury*)
  END_VAR
  VAR
    strPID           : _TPID_;  (*`lokalni datova struktura PID instrukce*)
  END_VAR
  VAR_OUTPUT
    MORE             : bool;  (*`kladny akcni zasah*)
    LESS             : bool;  (*`zaporny akcni zasah*)
  END_VAR
  VAR_IN_OUT
    CFIO             : _TPID1_IN_OUT_;  (*` vstup/vystupni parametry PID struktury*)
  END_VAR
  VAR CONSTANT
    cControl         : _TPID_Control_ :=  (RC:= 1,  //provest restart PID regulatoru
                                  BU:= 1,  //binarni vystup
                                  IP:= 1,  //prirustkove rizeni
                                  AM:= 1);  (*`provest restart PID regulatoru*)
  END_VAR
END_FUNCTION_BLOCK

TYPE _TPID11_IN_ :
  STRUCT
    MinY             : int;  (*` Hodnota unifikovaného rozsahu odpovídající 0%*)
    MaxY             : int;  (*` Hodnota unifikovaného rozsahu odpovídající 100%*)
    MinU             : int;  (*` Minimální povolený akèní zásah*)
    MaxU             : int;  (*` Maximální povolený akèní zásah*)
    dMaxU            : uint;  (*` Maximální pøírustek akèní velièiny za jednu periodu*)
    OutCycle         : uint;  (*` Perioda vzorkovaní regulaèního algoritmu [10ms]*)
    PBnd             : uint;  (*` Pásmo proporcionality (PBnd)*)
    Ti               : uint;  (*` Integraèní èasová konstanta [0.1s]*)
    Td               : uint;  (*` Derivaèní èasová konstanta [0.1s]*)
    EGap             : uint;  (*` Symetrické pásmo necitlivosti*)
  END_STRUCT;
END_TYPE

__DECL FUNCTION_BLOCK PID11
(*`
  PID regulátor s pøírùstkovým øízením a užším výbìrem promìnných.
  Pokud je promìnná ACT v log.1 jsou akceptovány ostatní vstupní promìnné
  a je aktivován algoritmus regulátoru - regulace hodnoty mìøené MSR
  na hodnotu žádanou RQR. V promìnných MORE a LESS jsou pøedávány povely
  pro akèní orgán (regulaèní ventil).
  
  Komponenta tedy pracuje stejnì jako PID1, rozdíl je pouze v užším výbìru
  nastavitelnych promìnných. Promìnné TiW, RelCool, DGap, IGap jsou nastaveny
  do implicitních hodnot.

  Regulátor nastavuje tyto promìnné:
  MSE := Input1
  RQR := gW
  MORE    := Status.0
  LESS	  := Status.1
  CONTROL := $0071 (pouze pøi startu regulace)
  tiW     := 0
  RelCool := 1000
  DGap    := 10000
  IGap    := 10000

*)
  VAR_INPUT
    ACT              : bool;  (*`aktivace*)
    MSR              : real;  (*`merena hodnota*)
    RQR              : real;  (*`zadana hodnota*)
    CFI              : _TPID11_IN_ :=                           // vstupni parametry PID struktury
                               (MinY    := 0,     // Hodnota unifikovaného rozsahu odpovídající 0%
                                MaxY    := 1000,  // Hodnota unifikovaného rozsahu odpovídající 100%
                                MinU    := 0,     // Minimální povolený akèní zásah
                                MaxU    := 10000, // Maximální povolený akèní zásah
                                dMaxU   := 1000,  // Maximální pøírustek akèní velièiny za jednu periodu
                                OutCycle:= 1000,  // Perioda vzorkovaní regulaèního algoritmu [10ms]
                                PBnd    := 1000,  // Pásmo proporcionality (PBnd)
                                Ti      := 1000,  // Integraèní èasová konstanta [0.1s]
                                Td      := 0,     // Derivaèní èasová konstanta [0.1s]
                                EGap    := 10);  (*` vstupni parametry PID struktury*)
  END_VAR
  VAR
    strPID           : _TPID_;  (*`lokalni datova struktura PID instrukce*)
  END_VAR
  VAR_OUTPUT
    MORE             : bool;  (*`kladny akcni zasah*)
    LESS             : bool;  (*`zaporny akcni zasah*)
  END_VAR
  VAR CONSTANT
    cControl         : _TPID_Control_ :=  (RC:= 1,  //provest restart PID regulatoru
                                  BU:= 1,  //binarni vystup
                                  IP:= 1,  //prirustkove rizeni
                                  AM:= 1);  (*`provest restart PID regulatoru*)
  END_VAR
END_FUNCTION_BLOCK

TYPE _TPID2_IN_ :
  STRUCT
    MinY             : int;  (*` Hodnota unifikovaného rozsahu odpovídající 0%*)
    MaxY             : int;  (*` Hodnota unifikovaného rozsahu odpovídající 100%*)
    tiW              : uint;  (*` Èasová konstanta filtru žádané hodnoty*)
    MinU             : int;  (*` Minimální povolený akèní zásah*)
    MaxU             : int;  (*` Maximální povolený akèní zásah*)
    dMaxU            : uint;  (*` Maximální pøírustek akèní velièiny za jednu periodu*)
    OutCycle         : uint;  (*` Perioda vzorkovaní regulaèního algoritmu [10ms]*)
    PBnd             : uint;  (*` Pásmo proporcionality (PBnd)*)
    RelCool          : uint;  (*` Relativní pásmo proporcionality pro záporné hodnoty regulaèní odchylky (RelCool)*)
    Ti               : uint;  (*` Integraèní èasová konstanta [0.1s]*)
    Td               : uint;  (*` Derivaèní èasová konstanta [0.1s]*)
    EGap             : uint;  (*` Symetrické pásmo necitlivosti*)
    DGap             : uint;  (*` Symetrické pásmo pùsobení derivaèní složky*)
    IGap             : uint;  (*` Symetrické pásmo pùsobení integraèní složky*)
  END_STRUCT;
END_TYPE

TYPE _TPID2_IN_OUT_ :
  STRUCT
    Control          : _TPID_Control_;  (*` Øídicí slovo*)
  END_STRUCT;
END_TYPE

__DECL FUNCTION_BLOCK PID2
(*`
  PID2 - regulátor s pøímým øízením
  Pokud je promìnná ACT v log.1 jsou akceptovány ostatní vstupní promìnné
  a je aktivován algoritmus regulátoru - regulace hodnoty mìøené MSR
  na hodnotu žádanou RQR. V promìnné OUT je pøedáván požadovaný výkon
  pro akèní orgán (regulaèní ventil) v rozsahu 0.00-100.00%,
  odpovídající PCT formátu analogové výstupní karty.

  Regulátor nastavuje tyto promìnné:
  MSR     := Input1
  RQR     := gW
  OUT     := Output
  CONTROL := $0041 (pouze pøi startu regulace)

*)
  VAR_INPUT
    ACT              : bool;  (*`aktivace*)
    MSR              : real;  (*`merena hodnota*)
    RQR              : real;  (*`zadana hodnota*)
    CFI              : _TPID2_IN_ :=                           // vstupni parametry PID struktury
                              (MinY    := 0,     // Hodnota unifikovaného rozsahu odpovídající 0%
                               MaxY    := 1000,  // Hodnota unifikovaného rozsahu odpovídající 100%
                               tiW     := 0,     // Èasová konstanta filtru žádané hodnoty
                               MinU    := 0,     // Minimální povolený akèní zásah
                               MaxU    := 10000, // Maximální povolený akèní zásah
                               dMaxU   := 1000,  // Maximální pøírustek akèní velièiny za jednu periodu
                               OutCycle:= 820,   // Perioda vzorkovaní regulaèního algoritmu [10ms]
                               PBnd    := 500,   // Pásmo proporcionality (PBnd)
                               RelCool := 1000,  // Relativní pásmo proporcionality pro záporné hodnoty regulaèní odchylky (RelCool)
                               Ti      := 740,   // Integraèní èasová konstanta [0.1s]
                               Td      := 26,    // Derivaèní èasová konstanta [0.1s]
                               EGap    := 10,    // Symetrické pásmo necitlivosti
                               DGap    := 10000, // Symetrické pásmo pùsobení derivaèní složky
                               IGap    := 10000);  (*` vstupni parametry PID struktury*)
  END_VAR
  VAR
    strPID           : _TPID_;  (*`lokalni datova struktura PID instrukce*)
  END_VAR
  VAR_OUTPUT
    OUT              : real;  (*`vypocteny akcni zasah*)
  END_VAR
  VAR_IN_OUT
    CFIO             : _TPID2_IN_OUT_;  (*` vstup/vystupni parametry PID struktury*)
  END_VAR
  VAR CONSTANT
    cControl         : _TPID_Control_ :=  (RC:= 1,  //provest restart PID regulatoru
                                  AM:= 1);  (*`provest restart PID regulatoru*)
  END_VAR
END_FUNCTION_BLOCK

TYPE _TPID21_IN_ :
  STRUCT
    MinY             : int;  (*` Hodnota unifikovaného rozsahu odpovídající 0%*)
    MaxY             : int;  (*` Hodnota unifikovaného rozsahu odpovídající 100%*)
    MinU             : int;  (*` Minimální povolený akèní zásah*)
    MaxU             : int;  (*` Maximální povolený akèní zásah*)
    dMaxU            : uint;  (*` Maximální pøírustek akèní velièiny za jednu periodu*)
    OutCycle         : uint;  (*` Perioda vzorkovaní regulaèního algoritmu [10ms]*)
    PBnd             : uint;  (*` Pásmo proporcionality (PBnd)*)
    Ti               : uint;  (*` Integraèní èasová konstanta [0.1s]*)
    Td               : uint;  (*` Derivaèní èasová konstanta [0.1s]*)
    EGap             : uint;  (*` Symetrické pásmo necitlivosti*)
  END_STRUCT;
END_TYPE

__DECL FUNCTION_BLOCK PID21
(*`
  PID2 - regulátor s pøímým øízením a užším výbìrem promìnných.
  Pokud je promìnná ACT v log.1 jsou akceptovány ostatní vstupní promìnné
  a je aktivován algoritmus regulátoru - regulace hodnoty mìøené MSR
  na hodnotu žádanou RQR. V promìnné OUT je pøedáván požadovaný výkon
  pro akèní orgán (regulaèní ventil) v rozsahu 0.00-100.00%,
  odpovídající PCT formátu analogové výstupní karty.

  Komponenta tedy pracuje stejnì jako PID2, rozdíl je pouze v užším výbìru
  nastavitelnych promìnných. Promìnné TiW, RelCool, DGap, IGap jsou nastaveny
  do implicitních hodnot.

  Regulátor nastavuje tyto promìnné:
  MSR     := Input1
  RQR     := gW
  OUT     := Output
  CONTROL := $0041 (pouze pøi startu regulace)
  tiW     := 0
  RelCool := 1000
  DGap    := 10000
  IGap    := 10000

*)
  VAR_INPUT
    ACT              : bool;  (*`aktivace*)
    MSR              : real;  (*`merena hodnota*)
    RQR              : real;  (*`zadana hodnota*)
    CFI              : _TPID21_IN_ :=                           // vstupni parametry PID struktury
                               (MinY    := 0,     // Hodnota unifikovaného rozsahu odpovídající 0%
                                MaxY    := 1000,  // Hodnota unifikovaného rozsahu odpovídající 100%
                                MinU    := 0,     // Minimální povolený akèní zásah
                                MaxU    := 10000, // Maximální povolený akèní zásah
                                dMaxU   := 1000,  // Maximální pøírustek akèní velièiny za jednu periodu
                                OutCycle:= 1000,  // Perioda vzorkovaní regulaèního algoritmu [10ms]
                                PBnd    := 1000,  // Pásmo proporcionality (PBnd)
                                Ti      := 1000,  // Integraèní èasová konstanta [0.1s]
                                Td      := 0,     // Derivaèní èasová konstanta [0.1s]
                                EGap    := 10);  (*` vstupni parametry PID struktury*)
  END_VAR
  VAR
    strPID           : _TPID_;  (*`lokalni datova struktura PID instrukce*)
  END_VAR
  VAR_OUTPUT
    OUT              : real;  (*`vypocteny akcni zasah*)
  END_VAR
  VAR CONSTANT
    cControl         : _TPID_Control_ :=  (RC:= 1,  //provest restart PID regulatoru
                                  AM:= 1);  (*`provest restart PID regulatoru*)
  END_VAR
END_FUNCTION_BLOCK

TYPE _TPID3_IN_ :
  STRUCT
    MinY             : int;  (*` Hodnota unifikovaného rozsahu odpovídající 0%*)
    MaxY             : int;  (*` Hodnota unifikovaného rozsahu odpovídající 100%*)
    tiW              : uint;  (*` Èasová konstanta filtru žádané hodnoty*)
    DefOut           : int;  (*` Pøeddefinovaný akèní zásah pøi poruše (uDef)*)
    MinU             : int;  (*` Minimální povolený akèní zásah*)
    MaxU             : int;  (*` Maximální povolený akèní zásah*)
    dMaxU            : uint;  (*` Maximální pøírustek akèní velièiny za jednu periodu*)
    OutCycle         : uint;  (*` Perioda vzorkovaní regulaèního algoritmu [10ms]*)
    PBnd             : uint;  (*` Pásmo proporcionality (PBnd)*)
    RelCool          : uint;  (*` Relativní pásmo proporcionality pro záporné hodnoty regulaèní odchylky (RelCool)*)
    Ti               : uint;  (*` Integraèní èasová konstanta [0.1s]*)
    Td               : uint;  (*` Derivaèní èasová konstanta [0.1s]*)
    EGap             : uint;  (*` Symetrické pásmo necitlivosti*)
    DGap             : uint;  (*` Symetrické pásmo pùsobení derivaèní složky*)
    IGap             : uint;  (*` Symetrické pásmo pùsobení integraèní složky*)
  END_STRUCT;
END_TYPE

TYPE _TPID3_IN_OUT_ :
  STRUCT
    ConW             : int;  (*` Aktuální žádaná hodnota*)
    Output           : int;  (*` Akèní velièina*)
    Control          : _TPID_Control_;  (*` Øídicí slovo*)
  END_STRUCT;
END_TYPE

TYPE _TPID3_OUT_ :
  STRUCT
    Dev              : int;  (*` Regulaèní odchylka*)
    LastOut          : int;  (*` Minulý akèní zásah*)
    CurOut           : int;  (*` Akèní zásah*)
    ConOut           : int;  (*` Akèní zásah v absolutní hodnotì modifikovaný dle øídícího slova*)
    Status           : _TPID_Status_;  (*` Stavove slovo*)
  END_STRUCT;
END_TYPE

__DECL FUNCTION_BLOCK PID3
(*`
  PID3 - volnì nastavitelný regulátor
  Volnì nastavitelný PID regulátor.

  Regulátor nastavuje tyto promìnné:
  MSR := Input1
  RQR := gW
  MORE    := Status.0
  LESS	  := Status.1
  OUTPUT  := Output

*)
  VAR_INPUT
    ACT              : bool;  (*`aktivace*)
    MSR              : real;  (*`merena hodnota*)
    RQR              : real;  (*`zadana hodnota*)
    IN2              : real;  (*`pomerova regulace*)
    IN3              : uint;  (*`poloha servoventilu*)
    CFI              : _TPID3_IN_ :=                           // vstupni parametry PID struktury
                              (MinY    := 0,     // Hodnota unifikovaného rozsahu odpovídající 0%
                               MaxY    := 0,     // Hodnota unifikovaného rozsahu odpovídající 100%
                               tiW     := 0,     // Èasová konstanta filtru žádané hodnoty
                               DefOut  := 0,     // Pøeddefinovaný akèní zásah pøi poruše (uDef)
                               MinU    := 0,     // Minimální povolený akèní zásah
                               MaxU    := 10000, // Maximální povolený akèní zásah
                               dMaxU   := 1000,  // Maximální pøírustek akèní velièiny za jednu periodu
                               OutCycle:= 820,   // Perioda vzorkovaní regulaèního algoritmu [10ms]
                               PBnd    := 500,   // Pásmo proporcionality (PBnd)
                               RelCool := 1000,  // Relativní pásmo proporcionality pro záporné hodnoty regulaèní odchylky (RelCool)
                               Ti      := 740,   // Integraèní èasová konstanta [0.1s]
                               Td      := 26,    // Derivaèní èasová konstanta [0.1s]
                               EGap    := 10,    // Symetrické pásmo necitlivosti
                               DGap    := 10000, // Symetrické pásmo pùsobení derivaèní složky
                               IGap    := 10000);  (*` vstupni parametry PID struktury*)
  END_VAR
  VAR
    strPID           : _TPID_;  (*`lokalni datova struktura PID instrukce*)
  END_VAR
  VAR_OUTPUT
    MORE             : bool;  (*`kladny akcni zasah*)
    LESS             : bool;  (*`zaporny akcni zasah*)
    OUT              : real;  (*`vypocteny akcni zasah*)
    CFO              : _TPID3_OUT_;  (*`vystupni parametry PID struktury*)
  END_VAR
  VAR_IN_OUT
    CFIO             : _TPID3_IN_OUT_;  (*` vstup/vystupni parametry PID struktury*)
  END_VAR
END_FUNCTION_BLOCK

TYPE _TSigErr1_IN_ :
  STRUCT
    PresetTime1      : time;  (*`casova predvolba zpozdeni vyhodnoceni poruchy 1*)
    PresetTime2      : time;  (*`casova predvolba zpozdeni vyhodnoceni poruchy 2*)
    PresetTime3      : time;  (*`casova predvolba zpozdeni vyhodnoceni poruchy 3*)
    PresetTime4      : time;  (*`casova predvolba zpozdeni vyhodnoceni poruchy 4*)
    PresetTime5      : time;  (*`casova predvolba zpozdeni vyhodnoceni poruchy 5*)
    PresetTime6      : time;  (*`casova predvolba zpozdeni vyhodnoceni poruchy 6*)
    PresetTime7      : time;  (*`casova predvolba zpozdeni vyhodnoceni poruchy 7*)
    PresetTime8      : time;  (*`casova predvolba zpozdeni vyhodnoceni poruchy 8*)
  END_STRUCT;
END_TYPE

__DECL FUNCTION_BLOCK SigErr1
(*`
  Komponenta provádí vyhodnocení výskytu poruchy s nastaveným èasovým spoždìním
  PRESETTIME pro 8 binárních vstupù. Pokud je vstupní signál INx aktivní déle
  než je nastavena pøedvoba, je výstupní signál ERRx nastaven do log. 1. Dále
  komponenta provádí logický souèet všech vyhodnocených poruch SUM a
  signalizaci novì vyhodnocené poruchy SIG. Výskyt poruch je možné
  potvrdit (kvitovat) signálem ACK a neaktivni poruchy zrušit signálem RES.
  Každá novì vyhodnocená porucha rozbliká výstup pro optickou signalizaci SIG
  v intervalu 1sec. Je-li po odkvitování (na vstupu ACK log.1) promìnná SUM
  v log.1 je optická signalizace SIG v log.1 v opaèném pøípadì je v log.0.

*)
  VAR_INPUT
    In1              : bool;  (*`.0 vstupni signal poruchy 1*)
    In2              : bool;  (*`.1 vstupni signal poruchy 2*)
    In3              : bool;  (*`.2 vstupni signal poruchy 3*)
    In4              : bool;  (*`.3 vstupni signal poruchy 4*)
    In5              : bool;  (*`.4 vstupni signal poruchy 5*)
    In6              : bool;  (*`.5 vstupni signal poruchy 6*)
    In7              : bool;  (*`.6 vstupni signal poruchy 7*)
    In8              : bool;  (*`.7 vstupni signal poruchy 8*)
    Ack              : bool;  (*`potvrzení (kvitace) poruch*)
    Res              : bool;  (*`nulování neaktivních poruch*)
    Cfg              : _TSigErr1_IN_;  (*`konfiguraèní struktura bloku*)
  END_VAR
  VAR
    blikat           : bool;  (*`blikani signalky*)
    Timer            : ARRAY [1..8] OF TON;  (*`casovac vyhodnoceni poruchy*)
    LET              : ARRAY [1..8] OF bool;  (*`pomocna nabezna hrana od poruchy*)
    OutTim           : ARRAY [1..8] OF bool;  (*`pomocny vystup casovace vyhodnoceni poruchy*)
  END_VAR
  VAR_OUTPUT
    Err1             : bool;  (*`.0 vystupni signal poruchy 1*)
    Err2             : bool;  (*`.1 vystupni signal poruchy 2*)
    Err3             : bool;  (*`.2 vystupni signal poruchy 3*)
    Err4             : bool;  (*`.3 vystupni signal poruchy 4*)
    Err5             : bool;  (*`.4 vystupni signal poruchy 5*)
    Err6             : bool;  (*`.5 vystupni signal poruchy 6*)
    Err7             : bool;  (*`.6 vystupni signal poruchy 7*)
    Err8             : bool;  (*`.7 vystupni signal poruchy 8*)
    Sig              : bool;  (*`signálka*)
    Sum              : bool;  (*`sdružená porucha*)
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION_BLOCK SigErr11
(*`
  Komponenta provádí vyhodnocení výskytu poruchy s nastaveným èasovým spoždìním
  PRESETTIME pro 8 binárních vstupù. Pokud je vstupní signál INx aktivní déle
  než je nastavena pøedvoba, je výstupní signál ERRx nastaven do log. 1. Dále
  komponenta provádí logický souèet všech vyhodnocených poruch SUM a
  signalizaci novì vyhodnocené poruchy SIG. Výskyt poruch je možné potvrdit
  signálem ACK a zrušit signálem RES.
  Každá novì vyhodnocená porucha rozbliká výstup pro optickou signalizaci SIG
  v intervalu 1sec. Je-li po odkvitování (na vstupu ACK log.1) promìnná SUM
  v log.1 je optická signalizace SIG v log.1 v opaèném pøípadì je v log.0.
  Komponenta dále obsahuje výstupní promìnnou s èíslem poslední aktivní poruchy
  ErrC k pøipojení na komponentu historie poruch (History1,History5,History10).

*)
  VAR_INPUT
    In1              : bool;  (*`.0 vstupni signal poruchy 1*)
    In2              : bool;  (*`.1 vstupni signal poruchy 2*)
    In3              : bool;  (*`.2 vstupni signal poruchy 3*)
    In4              : bool;  (*`.3 vstupni signal poruchy 4*)
    In5              : bool;  (*`.4 vstupni signal poruchy 5*)
    In6              : bool;  (*`.5 vstupni signal poruchy 6*)
    In7              : bool;  (*`.6 vstupni signal poruchy 7*)
    In8              : bool;  (*`.7 vstupni signal poruchy 8*)
    Ack              : bool;  (*`potvrzeni (kvitace) poruch*)
    Res              : bool;  (*`nulovani neaktivnich poruch*)
    Cfg              : _TSigErr1_IN_;  (*`konfiguraèní struktura bloku*)
  END_VAR
  VAR
    blikat           : bool;  (*`blikani signalky*)
    Timer1           : TON;  (*`casovac vyhodnoceni poruchy 1*)
    Timer2           : TON;  (*`casovac vyhodnoceni poruchy 2*)
    Timer3           : TON;  (*`casovac vyhodnoceni poruchy 3*)
    Timer4           : TON;  (*`casovac vyhodnoceni poruchy 4*)
    Timer5           : TON;  (*`casovac vyhodnoceni poruchy 5*)
    Timer6           : TON;  (*`casovac vyhodnoceni poruchy 6*)
    Timer7           : TON;  (*`casovac vyhodnoceni poruchy 7*)
    Timer8           : TON;  (*`casovac vyhodnoceni poruchy 8*)
    LET1             : bool;  (*`.0 pomocna nabezna hrana od poruchy 1*)
    LET2             : bool;  (*`.1 pomocna nabezna hrana od poruchy 2*)
    LET3             : bool;  (*`.2 pomocna nabezna hrana od poruchy 3*)
    LET4             : bool;  (*`.3 pomocna nabezna hrana od poruchy 4*)
    LET5             : bool;  (*`.4 pomocna nabezna hrana od poruchy 5*)
    LET6             : bool;  (*`.5 pomocna nabezna hrana od poruchy 6*)
    LET7             : bool;  (*`.6 pomocna nabezna hrana od poruchy 7*)
    LET8             : bool;  (*`.7 pomocna nabezna hrana od poruchy 8*)
  END_VAR
  VAR_OUTPUT
    Err1             : bool;  (*`.0 vystupni signal poruchy 1*)
    Err2             : bool;  (*`.1 vystupni signal poruchy 2*)
    Err3             : bool;  (*`.2 vystupni signal poruchy 3*)
    Err4             : bool;  (*`.3 vystupni signal poruchy 4*)
    Err5             : bool;  (*`.4 vystupni signal poruchy 5*)
    Err6             : bool;  (*`.5 vystupni signal poruchy 6*)
    Err7             : bool;  (*`.6 vystupni signal poruchy 7*)
    Err8             : bool;  (*`.7 vystupni signal poruchy 8*)
    Sig              : bool;  (*`signalka*)
    Sum              : bool;  (*`sdruzena porucha*)
    ErrC             : usint;  (*`cislo poruchy*)
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION_BLOCK SigErr12
(*`
  Komponenta provádí vyhodnocení výskytu poruchy s nastaveným èasovým zpoždìním
  PRESETTIME pro 8 binárních vstupù Pokud je vstupní signál INx aktivní déle
  než je nastavena pøedvoba, je výstupní signál ERRx nastaven do log. 1.
  Dále komponenta provádí logický souèet všech vyhodnocených poruch SUMO a
  signalizaci novì vyhodnocené poruchy SIGO. Výskyt poruch je možné potvrdit
  signálem ACKI a zrušit signálem RESI. Promìnné ACKO, RESO, SIGO,
  SUMO slouží ke kaskádování více komponent. Komponenta dále obsahuje
  výstupní promìnnou s èíslem poslední aktivní poruchy ERRC k pøipojení
  na komponentu historie poruch (History1,History5,History10).
  Každá novì vyhodnocená porucha rozbliká výstup pro optickou signalizaci SIGO
  v intervalu 1sec.. Je-li po odkvitování (na vstupu ACKI log.1) promìnná
  SUMO v log.1 je optická signalizace SIGO v log.1 v opaèném pøípadì je
  v log.0.

*)
  VAR_INPUT
    In1              : bool;  (*`.0 vstupni signal poruchy 1*)
    In2              : bool;  (*`.1 vstupni signal poruchy 2*)
    In3              : bool;  (*`.2 vstupni signal poruchy 3*)
    In4              : bool;  (*`.3 vstupni signal poruchy 4*)
    In5              : bool;  (*`.4 vstupni signal poruchy 5*)
    In6              : bool;  (*`.5 vstupni signal poruchy 6*)
    In7              : bool;  (*`.6 vstupni signal poruchy 7*)
    In8              : bool;  (*`.7 vstupni signal poruchy 8*)
    AckI             : bool;  (*`.0 potvrzeni poruch*)
    ResI             : bool;  (*`.1 nulovani neaktivnich poruch*)
    SigI             : bool;  (*`.2 signalka		*)
    SumI             : bool;  (*`.3 sdruzena porucha*)
    Cfg              : _TSigErr1_IN_;  (*`konfiguraèní struktura bloku*)
  END_VAR
  VAR
    blikat           : bool;  (*`blikani signalky*)
    Timer1           : TON;  (*`casovac vyhodnoceni poruchy 1*)
    Timer2           : TON;  (*`casovac vyhodnoceni poruchy 2*)
    Timer3           : TON;  (*`casovac vyhodnoceni poruchy 3*)
    Timer4           : TON;  (*`casovac vyhodnoceni poruchy 4*)
    Timer5           : TON;  (*`casovac vyhodnoceni poruchy 5*)
    Timer6           : TON;  (*`casovac vyhodnoceni poruchy 6*)
    Timer7           : TON;  (*`casovac vyhodnoceni poruchy 7*)
    Timer8           : TON;  (*`casovac vyhodnoceni poruchy 8*)
    LET1             : bool;  (*`.0 pomocna nabezna hrana od poruchy 1*)
    LET2             : bool;  (*`.1 pomocna nabezna hrana od poruchy 2*)
    LET3             : bool;  (*`.2 pomocna nabezna hrana od poruchy 3*)
    LET4             : bool;  (*`.3 pomocna nabezna hrana od poruchy 4*)
    LET5             : bool;  (*`.4 pomocna nabezna hrana od poruchy 5*)
    LET6             : bool;  (*`.5 pomocna nabezna hrana od poruchy 6*)
    LET7             : bool;  (*`.6 pomocna nabezna hrana od poruchy 7*)
    LET8             : bool;  (*`.7 pomocna nabezna hrana od poruchy 8*)
  END_VAR
  VAR_OUTPUT
    Err1             : bool;  (*`.0 vystupni signal poruchy 1*)
    Err2             : bool;  (*`.1 vystupni signal poruchy 2*)
    Err3             : bool;  (*`.2 vystupni signal poruchy 3*)
    Err4             : bool;  (*`.3 vystupni signal poruchy 4*)
    Err5             : bool;  (*`.4 vystupni signal poruchy 5*)
    Err6             : bool;  (*`.5 vystupni signal poruchy 6*)
    Err7             : bool;  (*`.6 vystupni signal poruchy 7*)
    Err8             : bool;  (*`.7 vystupni signal poruchy 8*)
    AckO             : bool;  (*`.0 potvrzeni poruch*)
    ResO             : bool;  (*`.1 nulovani neaktivnich poruch*)
    SigO             : bool;  (*`.2 signalka		*)
    SumO             : bool;  (*`.3 sdruzena porucha*)
    ErrC             : usint;  (*`cislo poruchy*)
  END_VAR
END_FUNCTION_BLOCK

TYPE _TSigErr13_IN_ :
  STRUCT
    PresetTime1      : time;  (*`casova predvolba zpozdeni vyhodnoceni poruchy 1*)
    PresetTime2      : time;  (*`casova predvolba zpozdeni vyhodnoceni poruchy 2*)
    PresetTime3      : time;  (*`casova predvolba zpozdeni vyhodnoceni poruchy 3*)
    PresetTime4      : time;  (*`casova predvolba zpozdeni vyhodnoceni poruchy 4*)
    PresetTime5      : time;  (*`casova predvolba zpozdeni vyhodnoceni poruchy 5*)
    PresetTime6      : time;  (*`casova predvolba zpozdeni vyhodnoceni poruchy 6*)
    PresetTime7      : time;  (*`casova predvolba zpozdeni vyhodnoceni poruchy 7*)
    PresetTime8      : time;  (*`casova predvolba zpozdeni vyhodnoceni poruchy 8*)
    control1         : usint;  (*`ridici slovo pro zpusob nulovani poruchy 1*)
    control2         : usint;  (*`ridici slovo pro zpusob nulovani poruchy 2*)
    control3         : usint;  (*`ridici slovo pro zpusob nulovani poruchy 3*)
    control4         : usint;  (*`ridici slovo pro zpusob nulovani poruchy 4*)
    control5         : usint;  (*`ridici slovo pro zpusob nulovani poruchy 5*)
    control6         : usint;  (*`ridici slovo pro zpusob nulovani poruchy 6*)
    control7         : usint;  (*`ridici slovo pro zpusob nulovani poruchy 7*)
    control8         : usint;  (*`ridici slovo pro zpusob nulovani poruchy 8*)
    controls         : usint;  (*`ridici slovo pro zpusob signalizace neodkvitovanych poruch*)
  END_STRUCT;
END_TYPE

__DECL FUNCTION_BLOCK SigErr13
(*`
  Komponenta provádí vyhodnocení výskytu poruchy s nastaveným èasovým spoždìním PRESETTIMEx pro 8 binárních vstupù.
  Pokud je vstupní signál  INx aktivní déle než je nastavena èasová pøedvolba PRESETIMEx, je výstupní signál
  ERRx nastaven do log. 1. Dále komponenta provádí logický souèet všech vyhodnocených poruch SUMO
  a signalizaci novì vyhodnocené poruchy optickou signalizací SIGO, a akustickou signalizací AKUO.
  Výskyt poruch je možné potvrdit signálem ACKI a zrušit signálem RESI. Promìnné CASI, CASO slouží
  ke kaskádování více komponent. Komponenta dále obsahuje výstupní promìnnou s èíslem poslední aktivní poruchy
  ERRC k pøipojení na komponentu historie poruch (History1,History5,History10).
  Kod ERRC je oproti ostatnim komponentam SigErr nastaven pouze na jeden cyklus pri vyskytu nove poruchy.

  U každé poruchy lze v promìnné CONTROLx nastavit zpùsob nulování pøíslušné poruchy
  a promìnná CONTROLS urèuje zpùsob optické a akustické signalizace.

  CONTROLx = 0 	- není-li vstupní signál INx aktivní je výstupní promìnná ERRx snulována (samovratná porucha)
  CONTROLx = 1 	- výstupní promìnná ERRx je snulována signálem RESI bez ohledu na hodnotu vstupního signálu
  CONTROLx = 2 	- není-li vstupní signál INx aktivní je výstupní promìnná ERRx snulována signálem RESI

  Každá novì vyhodnocená porucha rozbliká výstup pro optickou signalizaci SIGO v intervalu 1sec. a nastaví
  do log.1 výstup pro akustickou signalizaci AKUO. Odkvitováním (na vstup ACKI log.1) je akustická signalizace snulována.
  Pokud je promìnná SUMO v log.1 je i optická signalizace SIGO po odkvitování v log.1 v opaèném pøípadì je v log.0.

  Promìnná CONTROLS urèuje zpùsob signalizace, jsou-li vyhodnocené poruchy snulovány bez pøedchozího odkvitování
  (pro samovratne poruchy).

  CONTROLS = 0 	- optická i akustická signalizace je v log.0
  CONTROLS = 1 	- akustická signalizace je v log.0, optická signalizace bliká v intervalu 1sec.
  CONTROLS = 2 	- akustická signalizace je v log.1, optická signalizace bliká v intervalu 1sec.

*)
  VAR_INPUT
    In1              : bool;  (*`.0 vstupni signal poruchy 1*)
    In2              : bool;  (*`.1 vstupni signal poruchy 2*)
    In3              : bool;  (*`.2 vstupni signal poruchy 3*)
    In4              : bool;  (*`.3 vstupni signal poruchy 4*)
    In5              : bool;  (*`.4 vstupni signal poruchy 5*)
    In6              : bool;  (*`.5 vstupni signal poruchy 6*)
    In7              : bool;  (*`.6 vstupni signal poruchy 7*)
    In8              : bool;  (*`.7 vstupni signal poruchy 8*)
    AckI             : bool;  (*`potvrzeni poruch*)
    ResI             : bool;  (*`nulovani poruch*)
    CasI             : usint;  (*`propojeni komponenty do kaskady-vstup*)
    Cfg              : _TSigErr13_IN_;  (*`konfiguraèní struktura bloku*)
  END_VAR
  VAR
    kvitace          : bool;  (*`.0 kvitace poruch*)
    reset            : bool;  (*`.1 reset poruch*)
    sdruzpor         : bool;  (*`.2 sdruzena porucha*)
    signalka         : bool;  (*`.3 signalka		*)
    akustika         : bool;  (*`.4 houkacka*)
    blikat           : bool;  (*`.5 blikani signalky*)
    rez6             : bool;  (*`.6*)
    rez7             : bool;  (*`.7*)
    pombit           : bool;
    Timer1           : TON;  (*`casovac vyhodnoceni poruchy 1*)
    Timer2           : TON;  (*`casovac vyhodnoceni poruchy 2*)
    Timer3           : TON;  (*`casovac vyhodnoceni poruchy 3*)
    Timer4           : TON;  (*`casovac vyhodnoceni poruchy 4*)
    Timer5           : TON;  (*`casovac vyhodnoceni poruchy 5*)
    Timer6           : TON;  (*`casovac vyhodnoceni poruchy 6*)
    Timer7           : TON;  (*`casovac vyhodnoceni poruchy 7*)
    Timer8           : TON;  (*`casovac vyhodnoceni poruchy 8*)
    LET1             : bool;  (*`.0 pomocna nabezna hrana od poruchy 1*)
    LET2             : bool;  (*`.1 pomocna nabezna hrana od poruchy 2*)
    LET3             : bool;  (*`.2 pomocna nabezna hrana od poruchy 3*)
    LET4             : bool;  (*`.3 pomocna nabezna hrana od poruchy 4*)
    LET5             : bool;  (*`.4 pomocna nabezna hrana od poruchy 5*)
    LET6             : bool;  (*`.5 pomocna nabezna hrana od poruchy 6*)
    LET7             : bool;  (*`.6 pomocna nabezna hrana od poruchy 7*)
    LET8             : bool;  (*`.7 pomocna nabezna hrana od poruchy 8*)
  END_VAR
  VAR_OUTPUT
    Err1             : bool;  (*`.0 vystupni signal poruchy 1*)
    Err2             : bool;  (*`.1 vystupni signal poruchy 2*)
    Err3             : bool;  (*`.2 vystupni signal poruchy 3*)
    Err4             : bool;  (*`.3 vystupni signal poruchy 4*)
    Err5             : bool;  (*`.4 vystupni signal poruchy 5*)
    Err6             : bool;  (*`.5 vystupni signal poruchy 6*)
    Err7             : bool;  (*`.6 vystupni signal poruchy 7*)
    Err8             : bool;  (*`.7 vystupni signal poruchy 8*)
    SumO             : bool;  (*`sdružená porucha*)
    SigO             : bool;  (*`signalka		*)
    AkuO             : bool;  (*`houkacka*)
    CasO             : usint;  (*`propojení komponenty do kaskady-vstup		*)
    ErrC             : usint;  (*`cislo poruchy*)
  END_VAR
END_FUNCTION_BLOCK

TYPE _TSigErr2_IN_ :
  STRUCT
    PresetTime1      : time;  (*`casova predvolba zpozdeni vyhodnoceni poruchy 1*)
    PresetTime2      : time;  (*`casova predvolba zpozdeni vyhodnoceni poruchy 2*)
    PresetTime3      : time;  (*`casova predvolba zpozdeni vyhodnoceni poruchy 3*)
    PresetTime4      : time;  (*`casova predvolba zpozdeni vyhodnoceni poruchy 4*)
    PresetMax1       : real;  (*`mez pro vyhodnoceni poruchy ErrMax1		*)
    PresetMin1       : real;  (*`mez pro vyhodnoceni poruchy ErrMin1		*)
    PresetMax2       : real;  (*`mez pro vyhodnoceni poruchy ErrMax2		*)
    PresetMin2       : real;  (*`mez pro vyhodnoceni poruchy ErrMin2		*)
    PresetMax3       : real;  (*`mez pro vyhodnoceni poruchy ErrMax3		*)
    PresetMin3       : real;  (*`mez pro vyhodnoceni poruchy ErrMin3		*)
    PresetMax4       : real;  (*`mez pro vyhodnoceni poruchy ErrMax4		*)
    PresetMin4       : real;  (*`mez pro vyhodnoceni poruchy ErrMin4		*)
  END_STRUCT;
END_TYPE

__DECL FUNCTION_BLOCK SigErr2
(*`
  Komponenta provádí kontrolu ètyø vstupních analogových hodnot. Pokud je
  mìøená hodnota INx vyšší než nastavené maximum PRESETMAXx po dobu delší než je
  pøedvolba PRESETTIMEx, je výstupní signál EMAXx  nastaven do log.1.
  V pøípadì, že je mìøená hodnota nižší než nastavené minimum PRESETMINx, po dobu
  delší než pøedvolba PRESETTIMEx, je do log. 1 nastaven signál EMINx. Dále
  komponenta provádí logický souèet všech vyhodnocených poruch SUM a
  signalizaci novì vyhodnocené poruchy optickou signalizací SIG. Výskyt
  poruch je možné potvrdit (kvitovat) signálem ACK a zrušit signálem RES.
  Každá novì vyhodnocená porucha rozbliká výstup pro optickou signalizaci SIG
  v intervalu 1sec. Je-li po odkvitování (na vstupu ACK log.1) promìnná
  SUM v log.1 je optická signalizace SIG v log.1, v opaèném pøípadì je v
  log.0.

*)
  VAR_INPUT
    In1              : real;  (*`vstupni analogova hodnota 1 (v ENG formatu)*)
    In2              : real;  (*`vstupni analogova hodnota 2 (v ENG formatu)*)
    In3              : real;  (*`vstupni analogova hodnota 3 (v ENG formatu)*)
    In4              : real;  (*`vstupni analogova hodnota 4 (v ENG formatu)*)
    Ack              : bool;  (*`potvrzeni (kvitace) poruch*)
    Res              : bool;  (*`nulovani neaktivnich poruch*)
    Cfg              : _TSigErr2_IN_;  (*`konfiguraèní struktura bloku*)
  END_VAR
  VAR
    blikat           : bool;  (*`blikani signalky*)
    Timer            : ARRAY [1..8] OF TON;  (*`casovac vyhodnoceni poruchy*)
    LET              : ARRAY [1..8] OF bool;  (*`pomocna nabezna hrana od poruchy*)
    OutTim           : ARRAY [1..8] OF bool;  (*`pomocny vystup casovace vyhodnoceni poruchy*)
  END_VAR
  VAR_OUTPUT
    EMax1            : bool;  (*`prekroceni maxima vstup1		*)
    EMin1            : bool;  (*`podteceni  minima vstup1		*)
    EMax2            : bool;  (*`prekroceni maxima vstup2		*)
    EMin2            : bool;  (*`podteceni  minima vstup2		*)
    EMax3            : bool;  (*`prekroceni maxima vstup3		*)
    EMin3            : bool;  (*`podteceni  minima vstup3		*)
    EMax4            : bool;  (*`prekroceni maxima vstup4		*)
    EMin4            : bool;  (*`podteceni  minima vstup4		*)
    Sig              : bool;  (*`signalka*)
    Sum              : bool;  (*`sdruzena porucha*)
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION_BLOCK SigErr21
(*`
  Komponenta provádí kontrolu ètyø vstupních analogových hodnot. Pokud je
  mìøená hodnota INx vyšší než nastavené maximum PRESETMAXx po dobu delší než je
  pøedvolba PRESETTIMEx, je výstupní signál EMAXx  nastaven do log.1.
  V pøípadì, že je mìøená hodnota nižší než nastavené minimum PRESETMINx, po dobu
  delší než pøedvolba PRESETTIMEx, je do log. 1 nastaven signál EMINx. Dále
  komponenta provádí logický souèet všech vyhodnocených poruch SUM a
  signalizaci novì vyhodnocené poruchy optickou signalizací SIG. Výskyt
  poruch je možné potvrdit (kvitovat) signálem ACK a zrušit signálem RES.
  Každá novì vyhodnocená porucha rozbliká výstup pro optickou signalizaci SIG
  v intervalu 1sec. Je-li po odkvitování (na vstupu ACK log.1) promìnná
  SUM v log.1 je optická signalizace SIG v log.1, v opaèném pøípadì je v
  log.0.
  Komponenta dále obsahuje výstupní promìnnou s èíslem poslední aktivní poruchy
  ERRC k pøipojení na komponentu historie poruch (History1,History5,History10).

*)
  VAR_INPUT
    In1              : real;  (*`vstupni analogova hodnota 1 (v ENG formatu)*)
    In2              : real;  (*`vstupni analogova hodnota 2 (v ENG formatu)*)
    In3              : real;  (*`vstupni analogova hodnota 3 (v ENG formatu)*)
    In4              : real;  (*`vstupni analogova hodnota 4 (v ENG formatu)*)
    Ack              : bool;  (*`potvrzeni (kvitace) poruch*)
    Res              : bool;  (*`nulovani neaktivnich poruch*)
    Cfg              : _TSigErr2_IN_;  (*`konfiguraèní struktura bloku*)
  END_VAR
  VAR
    blikat           : bool;  (*`blikani signalky*)
    Timer1           : TON;  (*`casovac vyhodnoceni poruchy 1*)
    Timer2           : TON;  (*`casovac vyhodnoceni poruchy 1*)
    Timer3           : TON;  (*`casovac vyhodnoceni poruchy 2*)
    Timer4           : TON;  (*`casovac vyhodnoceni poruchy 2*)
    Timer5           : TON;  (*`casovac vyhodnoceni poruchy 3*)
    Timer6           : TON;  (*`casovac vyhodnoceni poruchy 3*)
    Timer7           : TON;  (*`casovac vyhodnoceni poruchy 4*)
    Timer8           : TON;  (*`casovac vyhodnoceni poruchy 4*)
    LET1             : bool;  (*`.0 pomocna nabezna hrana od poruchy 1*)
    LET2             : bool;  (*`.1 pomocna nabezna hrana od poruchy 1*)
    LET3             : bool;  (*`.2 pomocna nabezna hrana od poruchy 2*)
    LET4             : bool;  (*`.3 pomocna nabezna hrana od poruchy 2*)
    LET5             : bool;  (*`.4 pomocna nabezna hrana od poruchy 3*)
    LET6             : bool;  (*`.5 pomocna nabezna hrana od poruchy 3*)
    LET7             : bool;  (*`.6 pomocna nabezna hrana od poruchy 4*)
    LET8             : bool;  (*`.7 pomocna nabezna hrana od poruchy 4*)
  END_VAR
  VAR_OUTPUT
    EMax1            : bool;  (*`.0 prekroceni maxima vstup1		*)
    EMin1            : bool;  (*`.1 podteceni  minima vstup1		*)
    EMax2            : bool;  (*`.2 prekroceni maxima vstup2		*)
    EMin2            : bool;  (*`.3 podteceni  minima vstup2		*)
    EMax3            : bool;  (*`.4 prekroceni maxima vstup3		*)
    EMin3            : bool;  (*`.5 podteceni  minima vstup3		*)
    EMax4            : bool;  (*`.6 prekroceni maxima vstup4		*)
    EMin4            : bool;  (*`.7 podteceni  minima vstup4		*)
    Sig              : bool;  (*`signalka*)
    Sum              : bool;  (*`sdruzena porucha*)
    ErrC             : usint;  (*`cislo poruchy*)
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION_BLOCK SigErr22
(*`
  Komponenta provádí kontrolu ètyø vstupních analogových hodnot. Pokud je
  mìøená hodnota INx vyšší než nastavené maximum PRESETMAXx po dobu delší než je
  pøedvolba PRESETTIMEx, je výstupní signál EMAXx  nastaven do log.1.
  V pøípadì, že je mìøená hodnota nižší než nastavené minimum PRESETMINx, po dobu
  delší než pøedvolba PRESETTIMEx, je do log. 1 nastaven signál EMINx. Dále
  komponenta provádí logický souèet všech vyhodnocených poruch SUMO a
  signalizaci novì vyhodnocené poruchy optickou signalizací SIGO. Výskyt
  poruch je možné potvrdit (kvitovat) signálem ACKI a zrušit signálem RESI.
  Promìnné ACKO, RESO, SIGO, SUMO slouží ke kaskádování více komponent.
  Každá novì vyhodnocená porucha rozbliká výstup pro optickou signalizaci SIGO
  v intervalu 1sec. Je-li po odkvitování (na vstupu ACKI log.1) promìnná
  SUMO v log.1 je optická signalizace SIGO v log.1, v opaèném pøípadì je v
  log.0.
  Komponenta dále obsahuje výstupní promìnnou s èíslem poslední aktivní poruchy
  ERRC k pøipojení na komponentu historie poruch (History1,History5,History10).

*)
  VAR_INPUT
    In1              : real;  (*`vstupni analogova hodnota 1 (v ENG formatu)*)
    In2              : real;  (*`vstupni analogova hodnota 2 (v ENG formatu)*)
    In3              : real;  (*`vstupni analogova hodnota 3 (v ENG formatu)*)
    In4              : real;  (*`vstupni analogova hodnota 4 (v ENG formatu)*)
    AckI             : bool;  (*`.0 potvrzeni poruch*)
    ResI             : bool;  (*`.1 nulovani neaktivnich poruch*)
    SigI             : bool;  (*`.2 signalka		*)
    SumI             : bool;  (*`.3 sdruzena porucha*)
    Cfg              : _TSigErr2_IN_;  (*`konfiguraèní struktura bloku*)
  END_VAR
  VAR
    blikat           : bool;  (*`blikani signalky*)
    Timer1           : TON;  (*`casovac vyhodnoceni poruchy 1*)
    Timer2           : TON;  (*`casovac vyhodnoceni poruchy 1*)
    Timer3           : TON;  (*`casovac vyhodnoceni poruchy 2*)
    Timer4           : TON;  (*`casovac vyhodnoceni poruchy 2*)
    Timer5           : TON;  (*`casovac vyhodnoceni poruchy 3*)
    Timer6           : TON;  (*`casovac vyhodnoceni poruchy 3*)
    Timer7           : TON;  (*`casovac vyhodnoceni poruchy 4*)
    Timer8           : TON;  (*`casovac vyhodnoceni poruchy 4*)
    LET1             : bool;  (*`.0 pomocna nabezna hrana od poruchy 1*)
    LET2             : bool;  (*`.1 pomocna nabezna hrana od poruchy 1*)
    LET3             : bool;  (*`.2 pomocna nabezna hrana od poruchy 2*)
    LET4             : bool;  (*`.3 pomocna nabezna hrana od poruchy 2*)
    LET5             : bool;  (*`.4 pomocna nabezna hrana od poruchy 3*)
    LET6             : bool;  (*`.5 pomocna nabezna hrana od poruchy 3*)
    LET7             : bool;  (*`.6 pomocna nabezna hrana od poruchy 4*)
    LET8             : bool;  (*`.7 pomocna nabezna hrana od poruchy 4*)
  END_VAR
  VAR_OUTPUT
    EMax1            : bool;  (*`.0 prekroceni maxima vstup1		*)
    EMin1            : bool;  (*`.1 podteceni  minima vstup1		*)
    EMax2            : bool;  (*`.2 prekroceni maxima vstup2		*)
    EMin2            : bool;  (*`.3 podteceni  minima vstup2		*)
    EMax3            : bool;  (*`.4 prekroceni maxima vstup3		*)
    EMin3            : bool;  (*`.5 podteceni  minima vstup3		*)
    EMax4            : bool;  (*`.6 prekroceni maxima vstup4		*)
    EMin4            : bool;  (*`.7 podteceni  minima vstup4		*)
    AckO             : bool;  (*`.0 potvrzeni poruch*)
    ResO             : bool;  (*`.1 nulovani neaktivnich poruch*)
    SigO             : bool;  (*`.2 signalka		*)
    SumO             : bool;  (*`.3 sdruzena porucha*)
    ErrC             : usint;  (*`cislo poruchy*)
  END_VAR
END_FUNCTION_BLOCK

TYPE _TSigErr23_IN_ :
  STRUCT
    PresetTime1      : time;  (*`casova predvolba zpozdeni vyhodnoceni poruchy 1*)
    PresetTime2      : time;  (*`casova predvolba zpozdeni vyhodnoceni poruchy 2*)
    PresetTime3      : time;  (*`casova predvolba zpozdeni vyhodnoceni poruchy 3*)
    PresetTime4      : time;  (*`casova predvolba zpozdeni vyhodnoceni poruchy 4*)
    PresetMax1       : real;  (*`mez pro vyhodnoceni poruchy ErrMax1		*)
    PresetMin1       : real;  (*`mez pro vyhodnoceni poruchy ErrMin1		*)
    PresetMax2       : real;  (*`mez pro vyhodnoceni poruchy ErrMax2		*)
    PresetMin2       : real;  (*`mez pro vyhodnoceni poruchy ErrMin2		*)
    PresetMax3       : real;  (*`mez pro vyhodnoceni poruchy ErrMax3		*)
    PresetMin3       : real;  (*`mez pro vyhodnoceni poruchy ErrMin3		*)
    PresetMax4       : real;  (*`mez pro vyhodnoceni poruchy ErrMax4		*)
    PresetMin4       : real;  (*`mez pro vyhodnoceni poruchy ErrMin4		*)
    control1         : usint;  (*`ridici slovo pro zpusob nulovani poruchy 1*)
    control2         : usint;  (*`ridici slovo pro zpusob nulovani poruchy 2*)
    control3         : usint;  (*`ridici slovo pro zpusob nulovani poruchy 3*)
    control4         : usint;  (*`ridici slovo pro zpusob nulovani poruchy 4*)
    controls         : usint;  (*`ridici slovo pro zpusob signalizace neodkvitovanych poruch*)
  END_STRUCT;
END_TYPE

__DECL FUNCTION_BLOCK SigErr23
(*`
  Komponenta provádí kontrolu ètyø vstupních analogových hodnot. Pokud je
  mìøená hodnota INx vyšší než nastavené maximum PRESETMAXx po dobu delší než je
  pøedvolba PRESETTIMEx, je výstupní signál EMAXx  nastaven do log.1.
  V pøípadì, že je mìøená hodnota nižší než nastavené minimum PRESETMINx, po dobu
  delší než pøedvolba PRESETTIMEx, je do log. 1 nastaven signál EMINx. Dále
  komponenta provádí logický souèet všech vyhodnocených poruch SUMO,
  signalizaci novì vyhodnocené poruchy optickou signalizací SIGO a
  akustickou signalizací AKUO. Výskyt poruch je možné potvrdit (kvitovat) signálem ACKI
  a zrušit signálem RESI.
  Promìnné CASI a CASO slouží ke kaskádování více komponent.
  Komponenta dále obsahuje výstupní promìnnou s èíslem poslední aktivní poruchy
  ERRC k pøipojení na komponentu historie poruch (History1,History5,History10).
  Kod ERRC je oproti ostatnim komponentam SigErr nastaven pouze na jeden cyklus pri vyskytu nove poruchy.
  
  U každého vstupu lze v promìnné CONTROLx nastavit zpùsob nulování pøíslušné poruchy
  a promìnná CONTROLS urèuje zpùsob optické a akustické signalizace.

  CONTROLx = 0 	- není-li vstupní signál INPUTx aktivní je výstupní promìnná ERRORx snulována (samovratná porucha)
  CONTROLx = 1 	- výstupní promìnná ERRORx je snulována signálem RESIN bez ohledu na hodnotu vstupního signálu
  CONTROLx = 2 	- není-li vstupní signál INPUTx aktivní je výstupní promìnná ERRORx snulována signálem RESIN

  Každá novì vyhodnocená porucha rozbliká výstup pro optickou signalizaci SIGO v intervalu 1sec. a nastaví
  do log.1 výstup pro akustickou signalizaci AKUO. Odkvitováním (na vstup ACKI log.1) je akustická signalizace snulována.
  Pokud je promìnná SUMO v log.1 je i optická signalizace SIGO po odkvitování v log.1 v opaèném pøípadì je v log.0.

  Promìnná CONTROLS urèuje zpùsob signalizace, jsou-li vyhodnocené poruchy snulovány bez pøedchozího odkvitování
  (pro samovratne poruchy).

  CONTROLS = 0 	- optická i akustická signalizace je v log.0
  CONTROLS = 1 	- akustická signalizace je v log.0, optická signalizace bliká v intervalu 1sec.
  CONTROLS = 2 	- akustická signalizace je v log.1, optická signalizace bliká v intervalu 1sec.

*)
  VAR_INPUT
    In1              : real;  (*`vstupni analogova hodnota 1 (v ENG formatu)*)
    In2              : real;  (*`vstupni analogova hodnota 2 (v ENG formatu)*)
    In3              : real;  (*`vstupni analogova hodnota 3 (v ENG formatu)*)
    In4              : real;  (*`vstupni analogova hodnota 4 (v ENG formatu)*)
    AckI             : bool;  (*`.0 potvrzeni poruch*)
    ResI             : bool;  (*`.1 nulovani neaktivnich poruch*)
    CasI             : usint;  (*`propojeni komponenty do kaskady-vstup*)
    Cfg              : _TSigErr23_IN_;  (*`konfiguraèní struktura bloku*)
  END_VAR
  VAR
    kvitace          : bool;  (*`.0 kvitace poruch*)
    reset            : bool;  (*`.1 reset poruch*)
    sdruzpor         : bool;  (*`.2 sdruzena porucha*)
    signalka         : bool;  (*`.3 signalka		*)
    akustika         : bool;  (*`.4 houkacka*)
    blikat           : bool;  (*`.5 blikani signalky*)
    rez6             : bool;  (*`.6*)
    rez7             : bool;  (*`.7*)
    pombit           : bool;
    Timer1           : TON;  (*`casovac vyhodnoceni poruchy 1*)
    Timer2           : TON;  (*`casovac vyhodnoceni poruchy 1*)
    Timer3           : TON;  (*`casovac vyhodnoceni poruchy 2*)
    Timer4           : TON;  (*`casovac vyhodnoceni poruchy 2*)
    Timer5           : TON;  (*`casovac vyhodnoceni poruchy 3*)
    Timer6           : TON;  (*`casovac vyhodnoceni poruchy 3*)
    Timer7           : TON;  (*`casovac vyhodnoceni poruchy 4*)
    Timer8           : TON;  (*`casovac vyhodnoceni poruchy 4*)
    LET1             : bool;  (*`.0 pomocna nabezna hrana od poruchy 1*)
    LET2             : bool;  (*`.1 pomocna nabezna hrana od poruchy 1*)
    LET3             : bool;  (*`.2 pomocna nabezna hrana od poruchy 2*)
    LET4             : bool;  (*`.3 pomocna nabezna hrana od poruchy 2*)
    LET5             : bool;  (*`.4 pomocna nabezna hrana od poruchy 3*)
    LET6             : bool;  (*`.5 pomocna nabezna hrana od poruchy 3*)
    LET7             : bool;  (*`.6 pomocna nabezna hrana od poruchy 4*)
    LET8             : bool;  (*`.7 pomocna nabezna hrana od poruchy 4*)
  END_VAR
  VAR_OUTPUT
    EMax1            : bool;  (*`.0 prekroceni maxima vstup1		*)
    EMin1            : bool;  (*`.1 podteceni  minima vstup1		*)
    EMax2            : bool;  (*`.2 prekroceni maxima vstup2		*)
    EMin2            : bool;  (*`.3 podteceni  minima vstup2		*)
    EMax3            : bool;  (*`.4 prekroceni maxima vstup3		*)
    EMin3            : bool;  (*`.5 podteceni  minima vstup3		*)
    EMax4            : bool;  (*`.6 prekroceni maxima vstup4		*)
    EMin4            : bool;  (*`.7 podteceni  minima vstup4		*)
    SumO             : bool;  (*`sdružená porucha*)
    SigO             : bool;  (*`signalka		*)
    AkuO             : bool;  (*`houkacka*)
    CasO             : usint;  (*`propojení komponenty do kaskady-vstup		*)
    ErrC             : usint;  (*`cislo poruchy*)
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION_BLOCK Hyst1
(*`
  Hystereze.
  Komponenta provede porovnání mìøené hodnoty IN s nastavenou požadovanou hodnotou PV a uvazovanim hytereze HV.
  Pokud je mìøená hodnota IN vyšší než žádaná hodnota PV+HV/2, je výstupní signál OUT nastaven do log. “1”.
  Pokud je mìøená hodnota IN nižší než žádaná hodnota PV-HV/2, je výstupní signál OUT nastaven do log. “0”.

*)
  VAR_INPUT
    PV               : real;  (*`preset value*)
    IN               : real;  (*`input value*)
    HV               : real;  (*`hysteresis*)
  END_VAR
  VAR_OUTPUT
    OUT              : bool;  (*`output value*)
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION_BLOCK Hyst2
(*`
  Hystereze MIN,MAX.
  Pokud mìøená hodnota IN pøekroèí
  požadovanou maximální hodnotu MX, je výstupní binární signál OUT nastaven do log. “1”,
  v pøípadì, že mìøená hodnota podkroèí požadovanou minimální hodnotu MN,
  je výstupní signál OUT nastaven do log. ”0”.

*)
  VAR_INPUT
    IN               : real;  (*`input value*)
    MX               : real;  (*`maximum*)
    MN               : real;  (*`minimum*)
  END_VAR
  VAR_OUTPUT
    OUT              : bool;  (*`output value*)
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION_BLOCK Hyst3
(*`
  Dvojitá hystereze MIN,MAX.
  Pokud mìøená hodnota IN pøekroèí požadovanou maximální hodnotu MX2,
  je výstupní binární signál LESS nastaven do log. “1”, v pøípadì,
  že mìøená hodnota IN podkroèí požadovanou minimální hodnotu MN2,
  je výstupní signál LESS nastaven do log. ”0”.
  Pokud mìøená hodnota IN podkroèí požadovanou minimální hodnotu MN1,
  je výstupní binární signál MORE nastaven do log. “1”, v pøípadì,
  že mìøená hodnota IN pøekroèí požadovanou maximální hodnotu MX1,
  je výstupní signál MORE nastaven do log. ”0”.

*)
  VAR_INPUT
    IN               : real;  (*`input value*)
    MX2              : real;  (*`maximum 2*)
    MN2              : real;  (*`minimum 2*)
    MX1              : real;  (*`maximum 1*)
    MN1              : real;  (*`minimum 1*)
  END_VAR
  VAR_OUTPUT
    LESS             : bool;  (*`output less*)
    MORE             : bool;  (*`output more*)
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION_BLOCK Hyst31
(*`
  Dvojitá hystereze MIN,MAX s øídící promìnnou.
  Pokud je vstupní promìnná ACT v log.1, funguje tato komponenta stejnì jako Hyst3, tzn :
  
  Pokud mìøená hodnota IN pøekroèí požadovanou maximální hodnotu MX2,
  je výstupní binární signál LESS nastaven do log. “1”, v pøípadì,
  že mìøená hodnota IN podkroèí požadovanou minimální hodnotu MN2,
  je výstupní signál LESS nastaven do log. ”0”.
  Pokud mìøená hodnota IN podkroèí požadovanou minimální hodnotu MN1,
  je výstupní binární signál MORE nastaven do log. “1”, v pøípadì,
  že mìøená hodnota IN pøekroèí požadovanou maximální hodnotu MX1,
  je výstupní signál MORE nastaven do log. ”0”.

  Pokud je vstupní promìnná ACT v log.0, pak jsou i vystupy LESS i MORE nastaveny do log.0.

*)
  VAR_INPUT
    ACT              : bool;  (*`activity*)
    IN               : real;  (*`input value*)
    MX2              : real;  (*`maximum 2*)
    MN2              : real;  (*`minimum 2*)
    MX1              : real;  (*`maximum 1*)
    MN1              : real;  (*`minimum 1*)
  END_VAR
  VAR_OUTPUT
    LESS             : bool;  (*`output less*)
    MORE             : bool;  (*`output more*)
  END_VAR
END_FUNCTION_BLOCK

TYPE _TimeProg1_Day_ :
  STRUCT  (*`casovy program pro jeden den*)
    T_ON             : time;  (*`cas sepnuti*)
    T_OFF            : time;  (*`cas vypnuti*)
  END_STRUCT;
END_TYPE

TYPE _TimeProg1_Week_ :
  STRUCT  (*`casovy program pro jeden tyden*)
    Mon              : _TimeProg1_Day_;  (*`casovy program pondeli*)
    Tue              : _TimeProg1_Day_;  (*`casovy program utery*)
    Wed              : _TimeProg1_Day_;  (*`casovy program streda*)
    Thu              : _TimeProg1_Day_;  (*`casovy program ctvrtek*)
    Fri              : _TimeProg1_Day_;  (*`casovy program patek*)
    Sat              : _TimeProg1_Day_;  (*`casovy program sobota*)
    Sun              : _TimeProg1_Day_;  (*`casovy program nedele*)
  END_STRUCT;
END_TYPE

__DECL FUNCTION_BLOCK TProg1
(*`
  Komponenta na základì nastaveného týdenního programu a systémového èasu nastavuje výstupní signál OUT.
  Promìnná OUT je v log.1 pokud je aktuální systémový èas mezi parametry T_ON a T_OFF pro daný den v týdnu,
  jinak je v log.0.
  Promìnné lze nastavit v rozsahu od 00:00:00 do 24:00:00, pøièemž hodnota 0 je uvažována jako poèátek a hodnota 24
  jako konec daného dne.
  Pro každý den v týdnu lze nastavit jeden èasový úsek provozu.

*)
  VAR_INPUT
    TPg              : _TimeProg1_Week_;  (*`tydenni casovy program*)
  END_VAR
  VAR_OUTPUT
    Out              : bool;  (*`vystupni promenna*)
  END_VAR
END_FUNCTION_BLOCK

TYPE _TimeProg2_Day_ :
  STRUCT  (*`casovy program pro jeden den*)
    T_ON1            : time;  (*`cas sepnuti 1*)
    T_OFF1           : time;  (*`cas vypnuti 1*)
    T_ON2            : time;  (*`cas sepnuti 2*)
    T_OFF2           : time;  (*`cas vypnuti 2*)
  END_STRUCT;
END_TYPE

TYPE _TimeProg2_Week_ :
  STRUCT  (*`casovy program pro jeden tyden*)
    Mon              : _TimeProg2_Day_;  (*`casovy program pondeli*)
    Tue              : _TimeProg2_Day_;  (*`casovy program utery*)
    Wed              : _TimeProg2_Day_;  (*`casovy program streda*)
    Thu              : _TimeProg2_Day_;  (*`casovy program ctvrtek*)
    Fri              : _TimeProg2_Day_;  (*`casovy program patek*)
    Sat              : _TimeProg2_Day_;  (*`casovy program sobota*)
    Sun              : _TimeProg2_Day_;  (*`casovy program nedele*)
  END_STRUCT;
END_TYPE

__DECL FUNCTION_BLOCK TProg2
(*`
  Komponenta na základì nastaveného týdenního programu a systémového èasu nastavuje výstupní signál OUTPUT.
  Promìnná OUTPUT je v log.1 pokud je aktuální systémový èas mezi parametry T_ON1 a T_OFF1, nebo T_ON2 a T_OFF2
  pro daný den v týdnu, jinak je v log.0.
  Promìnné lze nastavit v rozsahu od 00:00:00 do 24:00:00, pøièemž hodnota 0 je uvažována jako poèátek a hodnota 24
  jako konec daného dne.
  Pro každý den v týdnu lze nastavit dva èasové úseky provozu.

*)
  VAR_INPUT
    TPg              : _TimeProg2_Week_;  (*`tydenni casovy program*)
  END_VAR
  VAR_OUTPUT
    Out              : bool;  (*`vystupni promenna*)
  END_VAR
END_FUNCTION_BLOCK

TYPE _TimeProg31_Day_ :
  STRUCT  (*`casovy program pro jeden den*)
    T_ON             : time;  (*`cas sepnuti*)
    T_DUR            : time;  (*`prodleva sepnuti*)
  END_STRUCT;
END_TYPE

TYPE _TimeProg31_Week_ :
  STRUCT  (*`casovy program pro jeden tyden*)
    Mon              : _TimeProg31_Day_;  (*`casovy program pondeli*)
    Tue              : _TimeProg31_Day_;  (*`casovy program utery*)
    Wed              : _TimeProg31_Day_;  (*`casovy program streda*)
    Thu              : _TimeProg31_Day_;  (*`casovy program ctvrtek*)
    Fri              : _TimeProg31_Day_;  (*`casovy program patek*)
    Sat              : _TimeProg31_Day_;  (*`casovy program sobota*)
    Sun              : _TimeProg31_Day_;  (*`casovy program nedele*)
  END_STRUCT;
END_TYPE

__DECL FUNCTION_BLOCK TProg31
(*`
  Komponenta na základì nastaveného týdenního programu a systémového èasu nastavuje výstupní signál OUTPUT.
  Promìnná OUTPUT je v log.1 pokud je aktuální systémový èas vìtší nebo roven parametru T_ON
  a menší než parametr T_ON + parametr T_DUR, pro daný den v týdnu. Jinak je v log.0.
  Promìnné T_ON a T_DUR lze nastavit v rozsahu od 00:00:00 do 24:00:00, pøièemž hodnota 0 je uvažována jako poèátek
  a hodnota 24 jako konec daného dne. Pro daný den je možno v souètu hodnot T_ON a T_DUR dosáhnout maximálnì
  hodnoty 24:00:00.
  Pro každý den v týdnu lze nastavit jeden èasový úsek provozu.

*)
  VAR_INPUT
    TPg              : _TimeProg31_Week_;  (*`tydenni casovy program*)
  END_VAR
  VAR_OUTPUT
    Out              : bool;  (*`vystupni promenna*)
  END_VAR
END_FUNCTION_BLOCK

TYPE _TimeProg41_Day_ :
  STRUCT
    T_ON1            : time;  (*`cas sepnuti 1*)
    T_DUR1           : time;  (*`prodleva sepnuti 1*)
    T_ON2            : time;  (*`cas sepnuti 2*)
    T_DUR2           : time;  (*`prodleva sepnuti 2*)
  END_STRUCT;
END_TYPE

TYPE _TimeProg41_Week_ :
  STRUCT  (*`casovy program pro jeden tyden*)
    Mon              : _TimeProg41_Day_;  (*`casovy program pondeli*)
    Tue              : _TimeProg41_Day_;  (*`casovy program utery*)
    Wed              : _TimeProg41_Day_;  (*`casovy program streda*)
    Thu              : _TimeProg41_Day_;  (*`casovy program ctvrtek*)
    Fri              : _TimeProg41_Day_;  (*`casovy program patek*)
    Sat              : _TimeProg41_Day_;  (*`casovy program sobota*)
    Sun              : _TimeProg41_Day_;  (*`casovy program nedele*)
  END_STRUCT;
END_TYPE

__DECL FUNCTION_BLOCK TProg41
(*`
  Komponenta na základì nastaveného týdenního programu a systémového èasu nastavuje výstupní signál OUTPUT.
  Promìnná OUTPUT je v log.1 pokud je aktuální systémový èas vìtší nebo roven parametru T_ON
  a menší než parametr T_ON + parametr T_DUR, pro daný den v týdnu. Jinak je v log.0.
  Promìnné T_ON a T_DUR lze nastavit v rozsahu od 00:00:00 do 24:00:00, pøièemž hodnota 0 je uvažována jako poèátek
  a hodnota 24 jako konec daného dne. Pro daný den je možno v souètu hodnot T_ON a T_DUR dosáhnout maximálnì
  hodnoty 24:00:00.
  Pro každý den v týdnu lze nastavit dva èasové úseky provozu.

*)
  VAR_INPUT
    TPg              : _TimeProg41_Week_;  (*`tydenni casovy program*)
  END_VAR
  VAR_OUTPUT
    Out              : bool;  (*`vystupni promenna*)
  END_VAR
END_FUNCTION_BLOCK



{USES=History1:Rego_GetDateTime}
{USES=History5:Rego_GetDateTime}
{USES=History10:Rego_GetDateTime}
{USES=TProg1:Rego_GetTime}
{USES=TProg2:Rego_GetTime}
{USES=TProg31:Rego_GetTime}
{USES=TProg41:Rego_GetTime}
#srcfile 'D:\TECOAPP\KNIHOVNY\REGOLIB\GET_DATE_TIME.ST'
#pou Rego_GetTime
#srcline 15 ;FUNCTION Rego_GetTime : TIME
P     61
Rego_GetTime_L0:
 LINK 0
 NXT
; Initialize - variables
; End initialize - variables
#srcline 27 ;  Rego_GetTime :=  USINT_TO_TIME( %S5 ) * 10        +
 LD   %S5
 LD   time 10
 MULS
#srcline 28 ;                   USINT_TO_TIME( %S6 ) * 1000      +
 LD   %S6
 LD   time 1000
 MULS
 ADD
#srcline 29 ;                   USINT_TO_TIME( %S7 ) * 1000 * 60 +
 LD   %S7
 LD   time 1000
 MULS
 LD   time 60
 MULS
 ADD
#srcline 30 ;                   USINT_TO_TIME( %S8 ) * 1000 * 3600;
 LD   %S8
 LD   time 1000
 MULS
 LD   time 3600
 MULS
 ADD
 WRX  __fc__Rego_GetTime
#debug_left time Rego_GetTime
#srcline 31 ;END_FUNCTION
 PRV  
 LDX  __fc__Rego_GetTime
 ULNK
RET
E     61
#endpou 

#pou Rego_GetDateTime
#srcline 34 ;FUNCTION Rego_GetDateTime : DATE_AND_TIME
P     61
Rego_GetDateTime_L0:
 LINK 0
 NXT
; Initialize - variables
 LEAX tmp
 LD   9
 LD   0
 FIL 
; End initialize - variables
#srcline 52 ;  Rego_GetDateTime := DT#1970-01-01-00:00:00;
 LDQ  dt 0
 WRX  __fc__Rego_GetDateTime
#debug_left dt Rego_GetDateTime
#srcline 54 ;  tmp.year      := %S12;
 LD   %S12
 WRX  tmp~year
#debug_left usint tmp.year
#srcline 55 ;  tmp.month     := %S11;
 LD   %S11
 WRX  tmp~month
#debug_left usint tmp.month
#srcline 56 ;  tmp.day       := %S10;
 LD   %S10
 WRX  tmp~day
#debug_left usint tmp.day
#srcline 57 ;  tmp.hour      := %S8;
 LD   %S8
 WRX  tmp~hour
#debug_left usint tmp.hour
#srcline 58 ;  tmp.min       := %S7;
 LD   %S7
 WRX  tmp~min
#debug_left usint tmp.min
#srcline 59 ;  tmp.sec       := %S6;
 LD   %S6
 WRX  tmp~sec
#debug_left usint tmp.sec
#srcline 60 ;  tmp.dayOfWeek := %S9;
 LD   %S9
 WRX  tmp~dayOfWeek
#debug_left usint tmp.dayOfWeek
#srcline 61 ;  tmp.milisec   := USINT_TO_UINT(%S5) * 10;
 LD   %S5
 AND  $FFFF
 LD   uint 10
 MUL
 AND  $FFFF
 WRX  tmp~milisec
#debug_left uint tmp.milisec
#srcline 62 ;  {asm}
#srcline 63
        LEAX  tmp
#srcline 64
        SYS   18                ; konverze Rego_TTecoDateTime -> DATE_AND_TIME;
#srcline 65
        WRX   __fc__Rego_GetDateTime
#srcline 66 ;  {end_asm}
#srcline 67 ;END_FUNCTION
 PRV  
 LDX  __fc__Rego_GetDateTime
 ULNK
RET
E     61
#endpou 



 

#srcfile ''
#srcfile 'D:\TECOAPP\KNIHOVNY\REGOLIB\CASCADE2.ST'
#pou Cascade2
#srcline 19 ;FUNCTION_BLOCK Cascade2

#struct Cascade2__temp__
  real HystPul,
  bool nahrazeno,
  udint P0__st__
P     61
Cascade2_L0:
 LINK __SizeOf(Cascade2__temp__)
; Initialize - dynamic variables
; End initialize - dynamic variables
; R_EDGE, F_EDGE 
 LDX  CHNG
 LETX __EDGE_R__CHNG
 WRX  CHNG
#srcline 73 ;  IF ACT THEN
 LDX  ACT
#debug bool ACT
 JMC  Cascade2_L1
#srcline 74 ;    HystPul := CFG.HYSTER / 2.0;
 LDX  CFG~HYSTER
#debug real CFG.HYSTER
 LD   real 2.0
 DIF
 WRY  HystPul
#debug_left real HystPul
#srcline 75 ;    IF (IN > (CFG.LIMIT1+HystPul)) THEN  pomSt1 := true; END_IF;
 LDX  IN
#debug real IN
 LDX  CFG~LIMIT1
#debug real CFG.LIMIT1
 LDY  HystPul
#debug real HystPul
 ADF
 GTF
 JMC  Cascade2_L3
 LD   bool -1       ; true
 WRX  pomSt1
#debug_left bool pomSt1
Cascade2_L3:
#srcline 76 ;    IF (IN > (CFG.LIMIT2+HystPul)) THEN  pomSt2 := true; END_IF;
 LDX  IN
#debug real IN
 LDX  CFG~LIMIT2
#debug real CFG.LIMIT2
 LDY  HystPul
#debug real HystPul
 ADF
 GTF
 JMC  Cascade2_L5
 LD   bool -1       ; true
 WRX  pomSt2
#debug_left bool pomSt2
Cascade2_L5:
#srcline 78 ;    IF (IN < (CFG.LIMIT1-HystPul)) THEN  pomSt1 := false; END_IF;
 LDX  IN
#debug real IN
 LDX  CFG~LIMIT1
#debug real CFG.LIMIT1
 LDY  HystPul
#debug real HystPul
 SUF
 LTF
 JMC  Cascade2_L7
 LD   bool 0       ; false
 WRX  pomSt1
#debug_left bool pomSt1
Cascade2_L7:
#srcline 79 ;    IF (IN < (CFG.LIMIT2-HystPul)) THEN  pomSt2 := false; END_IF;
 LDX  IN
#debug real IN
 LDX  CFG~LIMIT2
#debug real CFG.LIMIT2
 LDY  HystPul
#debug real HystPul
 SUF
 LTF
 JMC  Cascade2_L9
 LD   bool 0       ; false
 WRX  pomSt2
#debug_left bool pomSt2
Cascade2_L9:
#srcline 80 ;  ELSE
 JMP  Cascade2_L2
Cascade2_L1:
#srcline 81 ;    pomSt1 := false;   //pokud neni provoz, vsechny stupne kaskady vypnout
 LD   bool 0       ; false
 WRX  pomSt1
#debug_left bool pomSt1
#srcline 82 ;    pomSt2 := false;
 LD   bool 0       ; false
 WRX  pomSt2
#debug_left bool pomSt2
#srcline 83 ;  END_IF;
Cascade2_L2:
#srcline 85 ;  IF IN <= 0.0 THEN
 LDX  IN
#debug real IN
 LD   real 0.0
 GTF
 NEG
 JMC  Cascade2_L11
#srcline 86 ;    pomSt1 := false;   //pokud neni signal INPUT, vsechny stupne kaskady vypnout
 LD   bool 0       ; false
 WRX  pomSt1
#debug_left bool pomSt1
#srcline 87 ;    pomSt2 := false;
 LD   bool 0       ; false
 WRX  pomSt2
#debug_left bool pomSt2
#srcline 88 ;  END_IF;
Cascade2_L11:
#srcline 90 ;  // stridani poradi stupnu kaskady
#srcline 91 ;  IF CHNG AND CFG.ECHNG THEN       //zadost o zmenu poradi a zmena povolena?
 LDX  CHNG
#debug bool CHNG
 LDX  CFG~ECHNG
#debug bool CFG.ECHNG
 AND
 JMC  Cascade2_L13
#srcline 92 ;    STAT.SEQ := STAT.SEQ + 1;
 LDX  STAT~SEQ
#debug usint STAT.SEQ
 LD   usint 1
 ADD
 AND  $FF
 WRX  STAT~SEQ
#debug_left usint STAT.SEQ
#srcline 94 ;    IF CFG.ECHNGT THEN             //povoleno vyhodnoceni provoznich hodin pri zmene?
 LDX  CFG~ECHNGT
#debug bool CFG.ECHNGT
 JMC  Cascade2_L15
#srcline 95 ;      IF STAT.WT1 < STAT.WT2 then   //porovnat provozni hodiny jednotlivych stupnu
 LDX  STAT~WT1
#debug time STAT.WT1
 LDX  STAT~WT2
#debug time STAT.WT2
 LTS
 JMC  Cascade2_L17
#srcline 96 ;        STAT.SEQ := 0;
 LD   usint 0
 WRX  STAT~SEQ
#debug_left usint STAT.SEQ
#srcline 97 ;      ELSE
 JMP  Cascade2_L18
Cascade2_L17:
#srcline 98 ;        STAT.SEQ := 1;
 LD   usint 1
 WRX  STAT~SEQ
#debug_left usint STAT.SEQ
#srcline 99 ;      END_IF;
Cascade2_L18:
#srcline 100 ;    END_IF;
Cascade2_L15:
#srcline 102 ;    IF STAT.SEQ > 1 THEN         //posledni mozne poradi
 LDX  STAT~SEQ
#debug usint STAT.SEQ
 LD   usint 1
 GT
 JMC  Cascade2_L19
#srcline 103 ;      STAT.SEQ := 0;             //zacit od zacatku
 LD   usint 0
 WRX  STAT~SEQ
#debug_left usint STAT.SEQ
#srcline 104 ;    END_IF;
Cascade2_L19:
#srcline 105 ;  END_IF;
Cascade2_L13:
#srcline 107 ;  // prirazeni povelu stupnum kaskady podle poradi
#srcline 108 ;  CASE STAT.SEQ OF
 LDX  STAT~SEQ
#debug usint STAT.SEQ
 WRY  P0__st__
 LD   0
 LDY  P0__st__
 EQ  
 JMC  Cascade2_L22
#srcline 109 ;    0 : ST1 := pomSt1;       //poradi 12
 LDX  pomSt1
#debug bool pomSt1
 WRX  ST1
#debug_left bool ST1
#srcline 110 ;        ST2 := pomSt2;
 LDX  pomSt2
#debug bool pomSt2
 WRX  ST2
#debug_left bool ST2
 JMP  Cascade2_L21
Cascade2_L22:
#srcline 111 ;  ELSE
#srcline 112 ;        ST1 := pomSt2;       //poradi 21
 LDX  pomSt2
#debug bool pomSt2
 WRX  ST1
#debug_left bool ST1
#srcline 113 ;        ST2 := pomSt1;
 LDX  pomSt1
#debug bool pomSt1
 WRX  ST2
#debug_left bool ST2
#srcline 114 ;  END_CASE;
Cascade2_L21:
#srcline 116 ;  // stridani stupnu kaskady pri poruse
#srcline 117 ;  IF ST1 AND ERR1 THEN                 //stupen 1 ma byt v provozu a je na nem porucha?
 LDX  ST1
#debug bool ST1
 LDX  ERR1
#debug bool ERR1
 AND
 JMC  Cascade2_L23
#srcline 118 ;    ST1:= false;   nahrazeno := false; //porouchany stupen odepnout
 LD   bool 0       ; false
 WRX  ST1
#debug_left bool ST1
 LD   bool 0       ; false
 WRY  nahrazeno
#debug_left bool nahrazeno
#srcline 119 ;    IF not ST2 AND not ERR2 AND not nahrazeno THEN
 LDX  ST2
#debug bool ST2
 NEG
 LDX  ERR2
#debug bool ERR2
 NEG
 AND
 LDY  nahrazeno
#debug bool nahrazeno
 NEG
 AND
 JMC  Cascade2_L25
#srcline 120 ;      ST2 := true; nahrazeno := true;
 LD   bool -1       ; true
 WRX  ST2
#debug_left bool ST2
 LD   bool -1       ; true
 WRY  nahrazeno
#debug_left bool nahrazeno
#srcline 121 ;    END_IF;
Cascade2_L25:
#srcline 122 ;  END_IF;
Cascade2_L23:
#srcline 124 ;  IF ST2 AND ERR2 THEN                 //stupen 2 ma byt v provozu a je na nem porucha?
 LDX  ST2
#debug bool ST2
 LDX  ERR2
#debug bool ERR2
 AND
 JMC  Cascade2_L27
#srcline 125 ;    ST2:= false;   nahrazeno := false; //porouchany stupen odepnout
 LD   bool 0       ; false
 WRX  ST2
#debug_left bool ST2
 LD   bool 0       ; false
 WRY  nahrazeno
#debug_left bool nahrazeno
#srcline 126 ;    IF not ST1 AND not ERR1 AND not nahrazeno THEN
 LDX  ST1
#debug bool ST1
 NEG
 LDX  ERR1
#debug bool ERR1
 NEG
 AND
 LDY  nahrazeno
#debug bool nahrazeno
 NEG
 AND
 JMC  Cascade2_L29
#srcline 127 ;      ST1 := true; nahrazeno := true;
 LD   bool -1       ; true
 WRX  ST1
#debug_left bool ST1
 LD   bool -1       ; true
 WRY  nahrazeno
#debug_left bool nahrazeno
#srcline 128 ;    END_IF;
Cascade2_L29:
#srcline 129 ;  END_IF;
Cascade2_L27:
#srcline 131 ;  //casovani provoznich hodin jednotlivych stupnu
#srcline 132 ;  timer1(IN :=  WRK1, PT := T#1s);
 LDX  WRK1
#debug bool WRK1
 WRX  timer1~IN
#debug_left bool timer1~IN
 LD   time 1000
 WRX  timer1~PT
#debug_left time timer1~PT
 LEAX timer1
 CAL  TON_L0
#srcline 133 ;  timer2(IN :=  WRK2, PT := T#1s);
 LDX  WRK2
#debug bool WRK2
 WRX  timer2~IN
#debug_left bool timer2~IN
 LD   time 1000
 WRX  timer2~PT
#debug_left time timer2~PT
 LEAX timer2
 CAL  TON_L0
#srcline 135 ;  IF timer1.Q THEN
 LDX  timer1~Q
#debug bool timer1.Q
 JMC  Cascade2_L31
#srcline 136 ;    timer1(IN := false);             //vynulovat casovac
 LD   bool 0       ; false
 WRX  timer1~IN
#debug_left bool timer1~IN
 LEAX timer1
 CAL  TON_L0
#srcline 137 ;    STAT.WT1 := STAT.WT1 + T#1s;     //provozni citac + 1s
 LDX  STAT~WT1
#debug time STAT.WT1
 LD   time 1000
 ADD
 WRX  STAT~WT1
#debug_left time STAT.WT1
#srcline 138 ;  END_IF;
Cascade2_L31:
#srcline 139 ;  IF timer2.Q THEN
 LDX  timer2~Q
#debug bool timer2.Q
 JMC  Cascade2_L33
#srcline 140 ;    timer2(IN := false);             //vynulovat casovac
 LD   bool 0       ; false
 WRX  timer2~IN
#debug_left bool timer2~IN
 LEAX timer2
 CAL  TON_L0
#srcline 141 ;    STAT.WT2 := STAT.WT2 + T#1s;     //provozni citac + 1s
 LDX  STAT~WT2
#debug time STAT.WT2
 LD   time 1000
 ADD
 WRX  STAT~WT2
#debug_left time STAT.WT2
#srcline 142 ;  END_IF;
Cascade2_L33:
#srcline 144 ;  // nulovani provoznich hodin jednotlivych stupnu
#srcline 145 ;  IF RES THEN
 LDX  RES
#debug bool RES
 JMC  Cascade2_L35
#srcline 146 ;    STAT.WT1 := T#0s;
 LD   time 0
 WRX  STAT~WT1
#debug_left time STAT.WT1
#srcline 147 ;    STAT.WT2 := T#0s;
 LD   time 0
 WRX  STAT~WT2
#debug_left time STAT.WT2
#srcline 148 ;    STAT.SEQ := 0;
 LD   usint 0
 WRX  STAT~SEQ
#debug_left usint STAT.SEQ
#srcline 149 ;  END_IF;
Cascade2_L35:
#srcline 151 ;  // kopie vstupu na vystup
#srcline 152 ;  OUT := IN;
 LDX  IN
#debug real IN
 WRX  OUT
#debug_left real OUT
#srcline 154 ;END_FUNCTION_BLOCK
 ULNK
RET
E     61
#endpou 



 

#srcfile ''
#srcfile 'D:\TECOAPP\KNIHOVNY\REGOLIB\CASCADE3.ST'
#pou Cascade3
#srcline 21 ;FUNCTION_BLOCK Cascade3

#struct Cascade3__temp__
  real HystPul,
  time minWT,
  bool nahrazeno,
  udint P0__st__
P     61
Cascade3_L0:
 LINK __SizeOf(Cascade3__temp__)
; Initialize - dynamic variables
; End initialize - dynamic variables
; R_EDGE, F_EDGE 
 LDX  CHNG
 LETX __EDGE_R__CHNG
 WRX  CHNG
#srcline 82 ;  IF ACT THEN
 LDX  ACT
#debug bool ACT
 JMC  Cascade3_L1
#srcline 83 ;    HystPul := CFG.HYSTER / 2.0;
 LDX  CFG~HYSTER
#debug real CFG.HYSTER
 LD   real 2.0
 DIF
 WRY  HystPul
#debug_left real HystPul
#srcline 84 ;    IF (In > (CFG.LIMIT1+HystPul)) THEN  pomSt1 := true; END_IF;
 LDX  In
#debug real In
 LDX  CFG~LIMIT1
#debug real CFG.LIMIT1
 LDY  HystPul
#debug real HystPul
 ADF
 GTF
 JMC  Cascade3_L3
 LD   bool -1       ; true
 WRX  pomSt1
#debug_left bool pomSt1
Cascade3_L3:
#srcline 85 ;    IF (In > (CFG.LIMIT2+HystPul)) THEN  pomSt2 := true; END_IF;
 LDX  In
#debug real In
 LDX  CFG~LIMIT2
#debug real CFG.LIMIT2
 LDY  HystPul
#debug real HystPul
 ADF
 GTF
 JMC  Cascade3_L5
 LD   bool -1       ; true
 WRX  pomSt2
#debug_left bool pomSt2
Cascade3_L5:
#srcline 86 ;    IF (In > (CFG.LIMIT3+HystPul)) THEN  pomSt3 := true; END_IF;
 LDX  In
#debug real In
 LDX  CFG~LIMIT3
#debug real CFG.LIMIT3
 LDY  HystPul
#debug real HystPul
 ADF
 GTF
 JMC  Cascade3_L7
 LD   bool -1       ; true
 WRX  pomSt3
#debug_left bool pomSt3
Cascade3_L7:
#srcline 88 ;    IF (In < (CFG.LIMIT1-HystPul)) THEN  pomSt1 := false; END_IF;
 LDX  In
#debug real In
 LDX  CFG~LIMIT1
#debug real CFG.LIMIT1
 LDY  HystPul
#debug real HystPul
 SUF
 LTF
 JMC  Cascade3_L9
 LD   bool 0       ; false
 WRX  pomSt1
#debug_left bool pomSt1
Cascade3_L9:
#srcline 89 ;    IF (In < (CFG.LIMIT2-HystPul)) THEN  pomSt2 := false; END_IF;
 LDX  In
#debug real In
 LDX  CFG~LIMIT2
#debug real CFG.LIMIT2
 LDY  HystPul
#debug real HystPul
 SUF
 LTF
 JMC  Cascade3_L11
 LD   bool 0       ; false
 WRX  pomSt2
#debug_left bool pomSt2
Cascade3_L11:
#srcline 90 ;    IF (In < (CFG.LIMIT3-HystPul)) THEN  pomSt3 := false; END_IF;
 LDX  In
#debug real In
 LDX  CFG~LIMIT3
#debug real CFG.LIMIT3
 LDY  HystPul
#debug real HystPul
 SUF
 LTF
 JMC  Cascade3_L13
 LD   bool 0       ; false
 WRX  pomSt3
#debug_left bool pomSt3
Cascade3_L13:
#srcline 91 ;  ELSE
 JMP  Cascade3_L2
Cascade3_L1:
#srcline 92 ;    pomSt1 := false;   //pokud neni provoz, vsechny stupne kaskady vypnout
 LD   bool 0       ; false
 WRX  pomSt1
#debug_left bool pomSt1
#srcline 93 ;    pomSt2 := false;
 LD   bool 0       ; false
 WRX  pomSt2
#debug_left bool pomSt2
#srcline 94 ;    pomSt3 := false;
 LD   bool 0       ; false
 WRX  pomSt3
#debug_left bool pomSt3
#srcline 95 ;  END_IF;
Cascade3_L2:
#srcline 97 ;  IF In <= 0.0 THEN
 LDX  In
#debug real In
 LD   real 0.0
 GTF
 NEG
 JMC  Cascade3_L15
#srcline 98 ;    pomSt1 := false;   //pokud neni signal In, vsechny stupne kaskady vypnout
 LD   bool 0       ; false
 WRX  pomSt1
#debug_left bool pomSt1
#srcline 99 ;    pomSt2 := false;
 LD   bool 0       ; false
 WRX  pomSt2
#debug_left bool pomSt2
#srcline 100 ;    pomSt3 := false;
 LD   bool 0       ; false
 WRX  pomSt3
#debug_left bool pomSt3
#srcline 101 ;  END_IF;
Cascade3_L15:
#srcline 103 ;  // stridani poradi stupnu kaskady
#srcline 104 ;  IF CHNG AND CFG.ECHNG THEN       //zadost o zmenu poradi a zmena povolena?
 LDX  CHNG
#debug bool CHNG
 LDX  CFG~ECHNG
#debug bool CFG.ECHNG
 AND
 JMC  Cascade3_L17
#srcline 105 ;    STAT.SEQ := STAT.SEQ + 1;
 LDX  STAT~SEQ
#debug usint STAT.SEQ
 LD   usint 1
 ADD
 AND  $FF
 WRX  STAT~SEQ
#debug_left usint STAT.SEQ
#srcline 107 ;    IF CFG.ECHNGT THEN             //povoleno vyhodnoceni provoznich hodin pri zmene?
 LDX  CFG~ECHNGT
#debug bool CFG.ECHNGT
 JMC  Cascade3_L19
#srcline 108 ;      IF STAT.WT1 < STAT.WT2 then   //porovnat provozni hodiny jednotlivych stupnu
 LDX  STAT~WT1
#debug time STAT.WT1
 LDX  STAT~WT2
#debug time STAT.WT2
 LTS
 JMC  Cascade3_L21
#srcline 109 ;        minWT  := STAT.WT1;
 LDX  STAT~WT1
#debug time STAT.WT1
 WRY  minWT
#debug_left time minWT
#srcline 110 ;        STAT.SEQ := 0;
 LD   usint 0
 WRX  STAT~SEQ
#debug_left usint STAT.SEQ
#srcline 111 ;      ELSE
 JMP  Cascade3_L22
Cascade3_L21:
#srcline 112 ;        minWT  := STAT.WT2;
 LDX  STAT~WT2
#debug time STAT.WT2
 WRY  minWT
#debug_left time minWT
#srcline 113 ;        STAT.SEQ := 1;
 LD   usint 1
 WRX  STAT~SEQ
#debug_left usint STAT.SEQ
#srcline 114 ;      END_IF;
Cascade3_L22:
#srcline 116 ;      IF STAT.WT3 < minWT THEN
 LDX  STAT~WT3
#debug time STAT.WT3
 LDY  minWT
#debug time minWT
 LTS
 JMC  Cascade3_L23
#srcline 117 ;        STAT.SEQ := 2;
 LD   usint 2
 WRX  STAT~SEQ
#debug_left usint STAT.SEQ
#srcline 118 ;      END_IF;
Cascade3_L23:
#srcline 120 ;    END_IF;
Cascade3_L19:
#srcline 122 ;    IF STAT.SEQ > 2 THEN         //posledni mozne poradi
 LDX  STAT~SEQ
#debug usint STAT.SEQ
 LD   usint 2
 GT
 JMC  Cascade3_L25
#srcline 123 ;      STAT.SEQ := 0;             //zacit od zacatku
 LD   usint 0
 WRX  STAT~SEQ
#debug_left usint STAT.SEQ
#srcline 124 ;    END_IF;
Cascade3_L25:
#srcline 125 ;  END_IF;
Cascade3_L17:
#srcline 127 ;  // prirazeni povelu stupnum kaskady podle poradi
#srcline 128 ;  CASE STAT.SEQ OF
 LDX  STAT~SEQ
#debug usint STAT.SEQ
 WRY  P0__st__
 LD   0
 LDY  P0__st__
 EQ  
 JMC  Cascade3_L28
#srcline 129 ;    0 : ST1 := pomSt1;       //poradi 123
 LDX  pomSt1
#debug bool pomSt1
 WRX  ST1
#debug_left bool ST1
#srcline 130 ;        ST2 := pomSt2;
 LDX  pomSt2
#debug bool pomSt2
 WRX  ST2
#debug_left bool ST2
#srcline 131 ;        ST3 := pomSt3;
 LDX  pomSt3
#debug bool pomSt3
 WRX  ST3
#debug_left bool ST3
 JMP  Cascade3_L27
Cascade3_L28:
 LD   1
 LDY  P0__st__
 EQ  
 JMC  Cascade3_L29
#srcline 133 ;    1 : ST1 := pomSt3;       //poradi 231
 LDX  pomSt3
#debug bool pomSt3
 WRX  ST1
#debug_left bool ST1
#srcline 134 ;        ST2 := pomSt1;
 LDX  pomSt1
#debug bool pomSt1
 WRX  ST2
#debug_left bool ST2
#srcline 135 ;        ST3 := pomSt2;
 LDX  pomSt2
#debug bool pomSt2
 WRX  ST3
#debug_left bool ST3
 JMP  Cascade3_L27
Cascade3_L29:
#srcline 136 ;  ELSE
#srcline 137 ;        ST1 := pomSt2;       //poradi 312
 LDX  pomSt2
#debug bool pomSt2
 WRX  ST1
#debug_left bool ST1
#srcline 138 ;        ST2 := pomSt3;
 LDX  pomSt3
#debug bool pomSt3
 WRX  ST2
#debug_left bool ST2
#srcline 139 ;        ST3 := pomSt1;
 LDX  pomSt1
#debug bool pomSt1
 WRX  ST3
#debug_left bool ST3
#srcline 140 ;  END_CASE;
Cascade3_L27:
#srcline 142 ;  // stridani stupnu kaskady pri poruse
#srcline 143 ;  IF ST1 AND ERR1 THEN                 //stupen 1 ma byt v provozu a je na nem porucha?
 LDX  ST1
#debug bool ST1
 LDX  ERR1
#debug bool ERR1
 AND
 JMC  Cascade3_L30
#srcline 144 ;    ST1:= false;   nahrazeno := false; //porouchany stupen odepnout
 LD   bool 0       ; false
 WRX  ST1
#debug_left bool ST1
 LD   bool 0       ; false
 WRY  nahrazeno
#debug_left bool nahrazeno
#srcline 145 ;    IF not ST2 AND not ERR2 AND not nahrazeno THEN
 LDX  ST2
#debug bool ST2
 NEG
 LDX  ERR2
#debug bool ERR2
 NEG
 AND
 LDY  nahrazeno
#debug bool nahrazeno
 NEG
 AND
 JMC  Cascade3_L32
#srcline 146 ;      ST2 := true; nahrazeno := true;
 LD   bool -1       ; true
 WRX  ST2
#debug_left bool ST2
 LD   bool -1       ; true
 WRY  nahrazeno
#debug_left bool nahrazeno
#srcline 147 ;    END_IF;
Cascade3_L32:
#srcline 148 ;    IF not ST3 AND not ERR3 AND not nahrazeno THEN
 LDX  ST3
#debug bool ST3
 NEG
 LDX  ERR3
#debug bool ERR3
 NEG
 AND
 LDY  nahrazeno
#debug bool nahrazeno
 NEG
 AND
 JMC  Cascade3_L34
#srcline 149 ;      ST3 := true; nahrazeno := true;
 LD   bool -1       ; true
 WRX  ST3
#debug_left bool ST3
 LD   bool -1       ; true
 WRY  nahrazeno
#debug_left bool nahrazeno
#srcline 150 ;    END_IF;
Cascade3_L34:
#srcline 151 ;  END_IF;
Cascade3_L30:
#srcline 153 ;  IF ST2 AND ERR2 THEN                 //stupen 2 ma byt v provozu a je na nem porucha?
 LDX  ST2
#debug bool ST2
 LDX  ERR2
#debug bool ERR2
 AND
 JMC  Cascade3_L36
#srcline 154 ;    ST2:= false;   nahrazeno := false; //porouchany stupen odepnout
 LD   bool 0       ; false
 WRX  ST2
#debug_left bool ST2
 LD   bool 0       ; false
 WRY  nahrazeno
#debug_left bool nahrazeno
#srcline 155 ;    IF not ST3 AND not ERR3 AND not nahrazeno THEN
 LDX  ST3
#debug bool ST3
 NEG
 LDX  ERR3
#debug bool ERR3
 NEG
 AND
 LDY  nahrazeno
#debug bool nahrazeno
 NEG
 AND
 JMC  Cascade3_L38
#srcline 156 ;      ST3 := true; nahrazeno := true;
 LD   bool -1       ; true
 WRX  ST3
#debug_left bool ST3
 LD   bool -1       ; true
 WRY  nahrazeno
#debug_left bool nahrazeno
#srcline 157 ;    END_IF;
Cascade3_L38:
#srcline 158 ;    IF not ST1 AND not ERR1 AND not nahrazeno THEN
 LDX  ST1
#debug bool ST1
 NEG
 LDX  ERR1
#debug bool ERR1
 NEG
 AND
 LDY  nahrazeno
#debug bool nahrazeno
 NEG
 AND
 JMC  Cascade3_L40
#srcline 159 ;      ST1 := true; nahrazeno := true;
 LD   bool -1       ; true
 WRX  ST1
#debug_left bool ST1
 LD   bool -1       ; true
 WRY  nahrazeno
#debug_left bool nahrazeno
#srcline 160 ;    END_IF;
Cascade3_L40:
#srcline 161 ;  END_IF;
Cascade3_L36:
#srcline 163 ;  IF ST3 AND ERR3 THEN                 //stupen 3 ma byt v provozu a je na nem porucha?
 LDX  ST3
#debug bool ST3
 LDX  ERR3
#debug bool ERR3
 AND
 JMC  Cascade3_L42
#srcline 164 ;    ST3:= false;   nahrazeno := false; //porouchany stupen odepnout
 LD   bool 0       ; false
 WRX  ST3
#debug_left bool ST3
 LD   bool 0       ; false
 WRY  nahrazeno
#debug_left bool nahrazeno
#srcline 165 ;    IF not ST1 AND not ERR1 AND not nahrazeno THEN
 LDX  ST1
#debug bool ST1
 NEG
 LDX  ERR1
#debug bool ERR1
 NEG
 AND
 LDY  nahrazeno
#debug bool nahrazeno
 NEG
 AND
 JMC  Cascade3_L44
#srcline 166 ;      ST1 := true; nahrazeno := true;
 LD   bool -1       ; true
 WRX  ST1
#debug_left bool ST1
 LD   bool -1       ; true
 WRY  nahrazeno
#debug_left bool nahrazeno
#srcline 167 ;    END_IF;
Cascade3_L44:
#srcline 168 ;    IF not ST2 AND not ERR2 and not nahrazeno THEN
 LDX  ST2
#debug bool ST2
 NEG
 LDX  ERR2
#debug bool ERR2
 NEG
 AND
 LDY  nahrazeno
#debug bool nahrazeno
 NEG
 AND
 JMC  Cascade3_L46
#srcline 169 ;      ST2 := true; nahrazeno := true;
 LD   bool -1       ; true
 WRX  ST2
#debug_left bool ST2
 LD   bool -1       ; true
 WRY  nahrazeno
#debug_left bool nahrazeno
#srcline 170 ;    END_IF;
Cascade3_L46:
#srcline 171 ;  END_IF;
Cascade3_L42:
#srcline 173 ;  //casovani provoznich hodin jednotlivych stupnu
#srcline 174 ;  timer1(IN :=  WRK1, PT := T#1s);
 LDX  WRK1
#debug bool WRK1
 WRX  timer1~IN
#debug_left bool timer1~IN
 LD   time 1000
 WRX  timer1~PT
#debug_left time timer1~PT
 LEAX timer1
 CAL  TON_L0
#srcline 175 ;  timer2(IN :=  WRK2, PT := T#1s);
 LDX  WRK2
#debug bool WRK2
 WRX  timer2~IN
#debug_left bool timer2~IN
 LD   time 1000
 WRX  timer2~PT
#debug_left time timer2~PT
 LEAX timer2
 CAL  TON_L0
#srcline 176 ;  timer3(IN :=  WRK3, PT := T#1s);
 LDX  WRK3
#debug bool WRK3
 WRX  timer3~IN
#debug_left bool timer3~IN
 LD   time 1000
 WRX  timer3~PT
#debug_left time timer3~PT
 LEAX timer3
 CAL  TON_L0
#srcline 178 ;  IF timer1.Q THEN
 LDX  timer1~Q
#debug bool timer1.Q
 JMC  Cascade3_L48
#srcline 179 ;    timer1(IN := false);             //vynulovat casovac
 LD   bool 0       ; false
 WRX  timer1~IN
#debug_left bool timer1~IN
 LEAX timer1
 CAL  TON_L0
#srcline 180 ;    STAT.WT1 := STAT.WT1 + T#1s;     //provozni citac + 1s
 LDX  STAT~WT1
#debug time STAT.WT1
 LD   time 1000
 ADD
 WRX  STAT~WT1
#debug_left time STAT.WT1
#srcline 181 ;  END_IF;
Cascade3_L48:
#srcline 182 ;  IF timer2.Q THEN
 LDX  timer2~Q
#debug bool timer2.Q
 JMC  Cascade3_L50
#srcline 183 ;    timer2(IN := false);             //vynulovat casovac
 LD   bool 0       ; false
 WRX  timer2~IN
#debug_left bool timer2~IN
 LEAX timer2
 CAL  TON_L0
#srcline 184 ;    STAT.WT2 := STAT.WT2 + T#1s;     //provozni citac + 1s
 LDX  STAT~WT2
#debug time STAT.WT2
 LD   time 1000
 ADD
 WRX  STAT~WT2
#debug_left time STAT.WT2
#srcline 185 ;  END_IF;
Cascade3_L50:
#srcline 186 ;  IF timer3.Q THEN
 LDX  timer3~Q
#debug bool timer3.Q
 JMC  Cascade3_L52
#srcline 187 ;    timer3(IN := false);             //vynulovat casovac
 LD   bool 0       ; false
 WRX  timer3~IN
#debug_left bool timer3~IN
 LEAX timer3
 CAL  TON_L0
#srcline 188 ;    STAT.WT3 := STAT.WT3 + T#1s;     //provozni citac + 1s
 LDX  STAT~WT3
#debug time STAT.WT3
 LD   time 1000
 ADD
 WRX  STAT~WT3
#debug_left time STAT.WT3
#srcline 189 ;  END_IF;
Cascade3_L52:
#srcline 191 ;  // nulovani provoznich hodin jednotlivych stupnu
#srcline 192 ;  IF RES THEN
 LDX  RES
#debug bool RES
 JMC  Cascade3_L54
#srcline 193 ;    STAT.WT1 := T#0s;
 LD   time 0
 WRX  STAT~WT1
#debug_left time STAT.WT1
#srcline 194 ;    STAT.WT2 := T#0s;
 LD   time 0
 WRX  STAT~WT2
#debug_left time STAT.WT2
#srcline 195 ;    STAT.WT3 := T#0s;
 LD   time 0
 WRX  STAT~WT3
#debug_left time STAT.WT3
#srcline 196 ;    STAT.SEQ := 0;
 LD   usint 0
 WRX  STAT~SEQ
#debug_left usint STAT.SEQ
#srcline 197 ;  END_IF;
Cascade3_L54:
#srcline 199 ;  // kopie vstupu na vystup
#srcline 200 ;  OUT := In;
 LDX  In
#debug real In
 WRX  OUT
#debug_left real OUT
#srcline 202 ;END_FUNCTION_BLOCK
 ULNK
RET
E     61
#endpou 



 

#srcfile ''
#srcfile 'D:\TECOAPP\KNIHOVNY\REGOLIB\CASCADE4.ST'
#pou Cascade4
#srcline 23 ;FUNCTION_BLOCK Cascade4

#struct Cascade4__temp__
  real HystPul,
  time minWT,
  bool nahrazeno,
  udint P0__st__
P     61
Cascade4_L0:
 LINK __SizeOf(Cascade4__temp__)
; Initialize - dynamic variables
; End initialize - dynamic variables
; R_EDGE, F_EDGE 
 LDX  CHNG
 LETX __EDGE_R__CHNG
 WRX  CHNG
#srcline 90 ;  IF ACT THEN
 LDX  ACT
#debug bool ACT
 JMC  Cascade4_L1
#srcline 91 ;    HystPul := CFG.HYSTER / 2.0;
 LDX  CFG~HYSTER
#debug real CFG.HYSTER
 LD   real 2.0
 DIF
 WRY  HystPul
#debug_left real HystPul
#srcline 92 ;    IF (IN > (CFG.LIMIT1+HystPul)) THEN  pomSt1 := true; END_IF;
 LDX  IN
#debug real IN
 LDX  CFG~LIMIT1
#debug real CFG.LIMIT1
 LDY  HystPul
#debug real HystPul
 ADF
 GTF
 JMC  Cascade4_L3
 LD   bool -1       ; true
 WRX  pomSt1
#debug_left bool pomSt1
Cascade4_L3:
#srcline 93 ;    IF (IN > (CFG.LIMIT2+HystPul)) THEN  pomSt2 := true; END_IF;
 LDX  IN
#debug real IN
 LDX  CFG~LIMIT2
#debug real CFG.LIMIT2
 LDY  HystPul
#debug real HystPul
 ADF
 GTF
 JMC  Cascade4_L5
 LD   bool -1       ; true
 WRX  pomSt2
#debug_left bool pomSt2
Cascade4_L5:
#srcline 94 ;    IF (IN > (CFG.LIMIT3+HystPul)) THEN  pomSt3 := true; END_IF;
 LDX  IN
#debug real IN
 LDX  CFG~LIMIT3
#debug real CFG.LIMIT3
 LDY  HystPul
#debug real HystPul
 ADF
 GTF
 JMC  Cascade4_L7
 LD   bool -1       ; true
 WRX  pomSt3
#debug_left bool pomSt3
Cascade4_L7:
#srcline 95 ;    IF (IN > (CFG.LIMIT4+HystPul)) THEN  pomSt4 := true; END_IF;
 LDX  IN
#debug real IN
 LDX  CFG~LIMIT4
#debug real CFG.LIMIT4
 LDY  HystPul
#debug real HystPul
 ADF
 GTF
 JMC  Cascade4_L9
 LD   bool -1       ; true
 WRX  pomSt4
#debug_left bool pomSt4
Cascade4_L9:
#srcline 97 ;    IF (IN < (CFG.LIMIT1-HystPul)) THEN  pomSt1 := false; END_IF;
 LDX  IN
#debug real IN
 LDX  CFG~LIMIT1
#debug real CFG.LIMIT1
 LDY  HystPul
#debug real HystPul
 SUF
 LTF
 JMC  Cascade4_L11
 LD   bool 0       ; false
 WRX  pomSt1
#debug_left bool pomSt1
Cascade4_L11:
#srcline 98 ;    IF (IN < (CFG.LIMIT2-HystPul)) THEN  pomSt2 := false; END_IF;
 LDX  IN
#debug real IN
 LDX  CFG~LIMIT2
#debug real CFG.LIMIT2
 LDY  HystPul
#debug real HystPul
 SUF
 LTF
 JMC  Cascade4_L13
 LD   bool 0       ; false
 WRX  pomSt2
#debug_left bool pomSt2
Cascade4_L13:
#srcline 99 ;    IF (IN < (CFG.LIMIT3-HystPul)) THEN  pomSt3 := false; END_IF;
 LDX  IN
#debug real IN
 LDX  CFG~LIMIT3
#debug real CFG.LIMIT3
 LDY  HystPul
#debug real HystPul
 SUF
 LTF
 JMC  Cascade4_L15
 LD   bool 0       ; false
 WRX  pomSt3
#debug_left bool pomSt3
Cascade4_L15:
#srcline 100 ;    IF (IN < (CFG.LIMIT4-HystPul)) THEN  pomSt4 := false; END_IF;
 LDX  IN
#debug real IN
 LDX  CFG~LIMIT4
#debug real CFG.LIMIT4
 LDY  HystPul
#debug real HystPul
 SUF
 LTF
 JMC  Cascade4_L17
 LD   bool 0       ; false
 WRX  pomSt4
#debug_left bool pomSt4
Cascade4_L17:
#srcline 101 ;  ELSE
 JMP  Cascade4_L2
Cascade4_L1:
#srcline 102 ;    pomSt1 := false;   //pokud neni provoz, vsechny stupne kaskady vypnout
 LD   bool 0       ; false
 WRX  pomSt1
#debug_left bool pomSt1
#srcline 103 ;    pomSt2 := false;
 LD   bool 0       ; false
 WRX  pomSt2
#debug_left bool pomSt2
#srcline 104 ;    pomSt3 := false;
 LD   bool 0       ; false
 WRX  pomSt3
#debug_left bool pomSt3
#srcline 105 ;    pomSt4 := false;
 LD   bool 0       ; false
 WRX  pomSt4
#debug_left bool pomSt4
#srcline 106 ;  END_IF;
Cascade4_L2:
#srcline 108 ;  IF IN <= 0.0 THEN
 LDX  IN
#debug real IN
 LD   real 0.0
 GTF
 NEG
 JMC  Cascade4_L19
#srcline 109 ;    pomSt1 := false;   //pokud neni signal IN, vsechny stupne kaskady vypnout
 LD   bool 0       ; false
 WRX  pomSt1
#debug_left bool pomSt1
#srcline 110 ;    pomSt2 := false;
 LD   bool 0       ; false
 WRX  pomSt2
#debug_left bool pomSt2
#srcline 111 ;    pomSt3 := false;
 LD   bool 0       ; false
 WRX  pomSt3
#debug_left bool pomSt3
#srcline 112 ;    pomSt4 := false;
 LD   bool 0       ; false
 WRX  pomSt4
#debug_left bool pomSt4
#srcline 113 ;  END_IF;
Cascade4_L19:
#srcline 115 ;  // stridani poradi stupnu kaskady
#srcline 116 ;  IF CHNG AND CFG.ECHNG THEN       //zadost o zmenu poradi a zmena povolena?
 LDX  CHNG
#debug bool CHNG
 LDX  CFG~ECHNG
#debug bool CFG.ECHNG
 AND
 JMC  Cascade4_L21
#srcline 117 ;    STAT.SEQ := STAT.SEQ + 1;
 LDX  STAT~SEQ
#debug usint STAT.SEQ
 LD   usint 1
 ADD
 AND  $FF
 WRX  STAT~SEQ
#debug_left usint STAT.SEQ
#srcline 119 ;    IF CFG.ECHNGT THEN             //povoleno vyhodnoceni provoznich hodin pri zmene?
 LDX  CFG~ECHNGT
#debug bool CFG.ECHNGT
 JMC  Cascade4_L23
#srcline 120 ;      IF STAT.WT1 < STAT.WT2 then   //porovnat provozni hodiny jednotlivych stupnu
 LDX  STAT~WT1
#debug time STAT.WT1
 LDX  STAT~WT2
#debug time STAT.WT2
 LTS
 JMC  Cascade4_L25
#srcline 121 ;        minWT  := STAT.WT1;
 LDX  STAT~WT1
#debug time STAT.WT1
 WRY  minWT
#debug_left time minWT
#srcline 122 ;        STAT.SEQ := 0;
 LD   usint 0
 WRX  STAT~SEQ
#debug_left usint STAT.SEQ
#srcline 123 ;      ELSE
 JMP  Cascade4_L26
Cascade4_L25:
#srcline 124 ;        minWT  := STAT.WT2;
 LDX  STAT~WT2
#debug time STAT.WT2
 WRY  minWT
#debug_left time minWT
#srcline 125 ;        STAT.SEQ := 1;
 LD   usint 1
 WRX  STAT~SEQ
#debug_left usint STAT.SEQ
#srcline 126 ;      END_IF;
Cascade4_L26:
#srcline 128 ;      IF STAT.WT3 < minWT THEN
 LDX  STAT~WT3
#debug time STAT.WT3
 LDY  minWT
#debug time minWT
 LTS
 JMC  Cascade4_L27
#srcline 129 ;        minWT  := STAT.WT3;
 LDX  STAT~WT3
#debug time STAT.WT3
 WRY  minWT
#debug_left time minWT
#srcline 130 ;        STAT.SEQ := 2;
 LD   usint 2
 WRX  STAT~SEQ
#debug_left usint STAT.SEQ
#srcline 131 ;      END_IF;
Cascade4_L27:
#srcline 133 ;      IF STAT.WT4 < minWT THEN
 LDX  STAT~WT4
#debug time STAT.WT4
 LDY  minWT
#debug time minWT
 LTS
 JMC  Cascade4_L29
#srcline 134 ;        STAT.SEQ := 3;
 LD   usint 3
 WRX  STAT~SEQ
#debug_left usint STAT.SEQ
#srcline 135 ;      END_IF;
Cascade4_L29:
#srcline 136 ;    END_IF;
Cascade4_L23:
#srcline 138 ;    IF STAT.SEQ > 3 THEN         //posledni mozne poradi
 LDX  STAT~SEQ
#debug usint STAT.SEQ
 LD   usint 3
 GT
 JMC  Cascade4_L31
#srcline 139 ;      STAT.SEQ := 0;             //zacit od zacatku
 LD   usint 0
 WRX  STAT~SEQ
#debug_left usint STAT.SEQ
#srcline 140 ;    END_IF;
Cascade4_L31:
#srcline 141 ;  END_IF;
Cascade4_L21:
#srcline 143 ;  // prirazeni povelu stupnum kaskady podle poradi
#srcline 144 ;  CASE STAT.SEQ OF
 LDX  STAT~SEQ
#debug usint STAT.SEQ
 WRY  P0__st__
 LD   0
 LDY  P0__st__
 EQ  
 JMC  Cascade4_L34
#srcline 145 ;    0 : ST1 := pomSt1;       //poradi 1234
 LDX  pomSt1
#debug bool pomSt1
 WRX  ST1
#debug_left bool ST1
#srcline 146 ;        ST2 := pomSt2;
 LDX  pomSt2
#debug bool pomSt2
 WRX  ST2
#debug_left bool ST2
#srcline 147 ;        ST3 := pomSt3;
 LDX  pomSt3
#debug bool pomSt3
 WRX  ST3
#debug_left bool ST3
#srcline 148 ;        ST4 := pomSt4;
 LDX  pomSt4
#debug bool pomSt4
 WRX  ST4
#debug_left bool ST4
 JMP  Cascade4_L33
Cascade4_L34:
 LD   1
 LDY  P0__st__
 EQ  
 JMC  Cascade4_L35
#srcline 150 ;    1 : ST1 := pomSt4;       //poradi 2341
 LDX  pomSt4
#debug bool pomSt4
 WRX  ST1
#debug_left bool ST1
#srcline 151 ;        ST2 := pomSt1;
 LDX  pomSt1
#debug bool pomSt1
 WRX  ST2
#debug_left bool ST2
#srcline 152 ;        ST3 := pomSt2;
 LDX  pomSt2
#debug bool pomSt2
 WRX  ST3
#debug_left bool ST3
#srcline 153 ;        ST4 := pomSt3;
 LDX  pomSt3
#debug bool pomSt3
 WRX  ST4
#debug_left bool ST4
 JMP  Cascade4_L33
Cascade4_L35:
 LD   2
 LDY  P0__st__
 EQ  
 JMC  Cascade4_L36
#srcline 155 ;    2 : ST1 := pomSt3;       //poradi 3412
 LDX  pomSt3
#debug bool pomSt3
 WRX  ST1
#debug_left bool ST1
#srcline 156 ;        ST2 := pomSt4;
 LDX  pomSt4
#debug bool pomSt4
 WRX  ST2
#debug_left bool ST2
#srcline 157 ;        ST3 := pomSt1;
 LDX  pomSt1
#debug bool pomSt1
 WRX  ST3
#debug_left bool ST3
#srcline 158 ;        ST4 := pomSt2;
 LDX  pomSt2
#debug bool pomSt2
 WRX  ST4
#debug_left bool ST4
 JMP  Cascade4_L33
Cascade4_L36:
#srcline 159 ;  ELSE
#srcline 160 ;        ST1 := pomSt2;       //poradi 4123
 LDX  pomSt2
#debug bool pomSt2
 WRX  ST1
#debug_left bool ST1
#srcline 161 ;        ST2 := pomSt3;
 LDX  pomSt3
#debug bool pomSt3
 WRX  ST2
#debug_left bool ST2
#srcline 162 ;        ST3 := pomSt4;
 LDX  pomSt4
#debug bool pomSt4
 WRX  ST3
#debug_left bool ST3
#srcline 163 ;        ST4 := pomSt1;
 LDX  pomSt1
#debug bool pomSt1
 WRX  ST4
#debug_left bool ST4
#srcline 164 ;  END_CASE;
Cascade4_L33:
#srcline 166 ;  // stridani stupnu kaskady pri poruse
#srcline 167 ;  IF ST1 AND ERR1 THEN                 //stupen 1 ma byt v provozu a je na nem porucha?
 LDX  ST1
#debug bool ST1
 LDX  ERR1
#debug bool ERR1
 AND
 JMC  Cascade4_L37
#srcline 168 ;    ST1:= false;   nahrazeno := false; //porouchany stupen odepnout
 LD   bool 0       ; false
 WRX  ST1
#debug_left bool ST1
 LD   bool 0       ; false
 WRY  nahrazeno
#debug_left bool nahrazeno
#srcline 169 ;    IF not ST2 AND not ERR2 AND not nahrazeno THEN
 LDX  ST2
#debug bool ST2
 NEG
 LDX  ERR2
#debug bool ERR2
 NEG
 AND
 LDY  nahrazeno
#debug bool nahrazeno
 NEG
 AND
 JMC  Cascade4_L39
#srcline 170 ;      ST2 := true; nahrazeno := true;
 LD   bool -1       ; true
 WRX  ST2
#debug_left bool ST2
 LD   bool -1       ; true
 WRY  nahrazeno
#debug_left bool nahrazeno
#srcline 171 ;    END_IF;
Cascade4_L39:
#srcline 172 ;    IF not ST3 AND not ERR3 AND not nahrazeno THEN
 LDX  ST3
#debug bool ST3
 NEG
 LDX  ERR3
#debug bool ERR3
 NEG
 AND
 LDY  nahrazeno
#debug bool nahrazeno
 NEG
 AND
 JMC  Cascade4_L41
#srcline 173 ;      ST3 := true; nahrazeno := true;
 LD   bool -1       ; true
 WRX  ST3
#debug_left bool ST3
 LD   bool -1       ; true
 WRY  nahrazeno
#debug_left bool nahrazeno
#srcline 174 ;    END_IF;
Cascade4_L41:
#srcline 175 ;    IF not ST4 AND not ERR4 AND not nahrazeno THEN
 LDX  ST4
#debug bool ST4
 NEG
 LDX  ERR4
#debug bool ERR4
 NEG
 AND
 LDY  nahrazeno
#debug bool nahrazeno
 NEG
 AND
 JMC  Cascade4_L43
#srcline 176 ;      ST4 := true; nahrazeno := true;
 LD   bool -1       ; true
 WRX  ST4
#debug_left bool ST4
 LD   bool -1       ; true
 WRY  nahrazeno
#debug_left bool nahrazeno
#srcline 177 ;    END_IF;
Cascade4_L43:
#srcline 178 ;  END_IF;
Cascade4_L37:
#srcline 180 ;  IF ST2 AND ERR2 THEN                 //stupen 2 ma byt v provozu a je na nem porucha?
 LDX  ST2
#debug bool ST2
 LDX  ERR2
#debug bool ERR2
 AND
 JMC  Cascade4_L45
#srcline 181 ;    ST2:= false;   nahrazeno := false; //porouchany stupen odepnout
 LD   bool 0       ; false
 WRX  ST2
#debug_left bool ST2
 LD   bool 0       ; false
 WRY  nahrazeno
#debug_left bool nahrazeno
#srcline 182 ;    IF not ST3 AND not ERR3 AND not nahrazeno THEN
 LDX  ST3
#debug bool ST3
 NEG
 LDX  ERR3
#debug bool ERR3
 NEG
 AND
 LDY  nahrazeno
#debug bool nahrazeno
 NEG
 AND
 JMC  Cascade4_L47
#srcline 183 ;      ST3 := true; nahrazeno := true;
 LD   bool -1       ; true
 WRX  ST3
#debug_left bool ST3
 LD   bool -1       ; true
 WRY  nahrazeno
#debug_left bool nahrazeno
#srcline 184 ;    END_IF;
Cascade4_L47:
#srcline 185 ;    IF not ST4 AND not ERR4 AND not nahrazeno THEN
 LDX  ST4
#debug bool ST4
 NEG
 LDX  ERR4
#debug bool ERR4
 NEG
 AND
 LDY  nahrazeno
#debug bool nahrazeno
 NEG
 AND
 JMC  Cascade4_L49
#srcline 186 ;      ST4 := true; nahrazeno := true;
 LD   bool -1       ; true
 WRX  ST4
#debug_left bool ST4
 LD   bool -1       ; true
 WRY  nahrazeno
#debug_left bool nahrazeno
#srcline 187 ;    END_IF;
Cascade4_L49:
#srcline 188 ;    IF not ST1 AND not ERR1 AND not nahrazeno THEN
 LDX  ST1
#debug bool ST1
 NEG
 LDX  ERR1
#debug bool ERR1
 NEG
 AND
 LDY  nahrazeno
#debug bool nahrazeno
 NEG
 AND
 JMC  Cascade4_L51
#srcline 189 ;      ST1 := true; nahrazeno := true;
 LD   bool -1       ; true
 WRX  ST1
#debug_left bool ST1
 LD   bool -1       ; true
 WRY  nahrazeno
#debug_left bool nahrazeno
#srcline 190 ;    END_IF;
Cascade4_L51:
#srcline 191 ;  END_IF;
Cascade4_L45:
#srcline 193 ;  IF ST3 AND ERR3 THEN                 //stupen 3 ma byt v provozu a je na nem porucha?
 LDX  ST3
#debug bool ST3
 LDX  ERR3
#debug bool ERR3
 AND
 JMC  Cascade4_L53
#srcline 194 ;    ST3:= false;   nahrazeno := false; //porouchany stupen odepnout
 LD   bool 0       ; false
 WRX  ST3
#debug_left bool ST3
 LD   bool 0       ; false
 WRY  nahrazeno
#debug_left bool nahrazeno
#srcline 195 ;    IF not ST4 AND not ERR4 AND not nahrazeno THEN
 LDX  ST4
#debug bool ST4
 NEG
 LDX  ERR4
#debug bool ERR4
 NEG
 AND
 LDY  nahrazeno
#debug bool nahrazeno
 NEG
 AND
 JMC  Cascade4_L55
#srcline 196 ;      ST4 := true; nahrazeno := true;
 LD   bool -1       ; true
 WRX  ST4
#debug_left bool ST4
 LD   bool -1       ; true
 WRY  nahrazeno
#debug_left bool nahrazeno
#srcline 197 ;    END_IF;
Cascade4_L55:
#srcline 198 ;    IF not ST1 AND not ERR1 AND not nahrazeno THEN
 LDX  ST1
#debug bool ST1
 NEG
 LDX  ERR1
#debug bool ERR1
 NEG
 AND
 LDY  nahrazeno
#debug bool nahrazeno
 NEG
 AND
 JMC  Cascade4_L57
#srcline 199 ;      ST1 := true; nahrazeno := true;
 LD   bool -1       ; true
 WRX  ST1
#debug_left bool ST1
 LD   bool -1       ; true
 WRY  nahrazeno
#debug_left bool nahrazeno
#srcline 200 ;    END_IF;
Cascade4_L57:
#srcline 201 ;    IF not ST2 AND not ERR2 and not nahrazeno THEN
 LDX  ST2
#debug bool ST2
 NEG
 LDX  ERR2
#debug bool ERR2
 NEG
 AND
 LDY  nahrazeno
#debug bool nahrazeno
 NEG
 AND
 JMC  Cascade4_L59
#srcline 202 ;      ST2 := true; nahrazeno := true;
 LD   bool -1       ; true
 WRX  ST2
#debug_left bool ST2
 LD   bool -1       ; true
 WRY  nahrazeno
#debug_left bool nahrazeno
#srcline 203 ;    END_IF;
Cascade4_L59:
#srcline 204 ;  END_IF;
Cascade4_L53:
#srcline 206 ;  IF ST4 AND ERR4 THEN                 //stupen 4 ma byt v provozu a je na nem porucha?
 LDX  ST4
#debug bool ST4
 LDX  ERR4
#debug bool ERR4
 AND
 JMC  Cascade4_L61
#srcline 207 ;    ST4:= false;   nahrazeno := false; //porouchany stupen odepnout
 LD   bool 0       ; false
 WRX  ST4
#debug_left bool ST4
 LD   bool 0       ; false
 WRY  nahrazeno
#debug_left bool nahrazeno
#srcline 208 ;    IF not ST1 AND not ERR1 AND not nahrazeno THEN
 LDX  ST1
#debug bool ST1
 NEG
 LDX  ERR1
#debug bool ERR1
 NEG
 AND
 LDY  nahrazeno
#debug bool nahrazeno
 NEG
 AND
 JMC  Cascade4_L63
#srcline 209 ;      ST1 := true; nahrazeno := true;
 LD   bool -1       ; true
 WRX  ST1
#debug_left bool ST1
 LD   bool -1       ; true
 WRY  nahrazeno
#debug_left bool nahrazeno
#srcline 210 ;    END_IF;
Cascade4_L63:
#srcline 211 ;    IF not ST2 AND not ERR2 and not nahrazeno THEN
 LDX  ST2
#debug bool ST2
 NEG
 LDX  ERR2
#debug bool ERR2
 NEG
 AND
 LDY  nahrazeno
#debug bool nahrazeno
 NEG
 AND
 JMC  Cascade4_L65
#srcline 212 ;      ST2 := true; nahrazeno := true;
 LD   bool -1       ; true
 WRX  ST2
#debug_left bool ST2
 LD   bool -1       ; true
 WRY  nahrazeno
#debug_left bool nahrazeno
#srcline 213 ;    END_IF;
Cascade4_L65:
#srcline 214 ;    IF not ST3 AND not ERR3 AND not nahrazeno THEN
 LDX  ST3
#debug bool ST3
 NEG
 LDX  ERR3
#debug bool ERR3
 NEG
 AND
 LDY  nahrazeno
#debug bool nahrazeno
 NEG
 AND
 JMC  Cascade4_L67
#srcline 215 ;      ST3 := true; nahrazeno := true;
 LD   bool -1       ; true
 WRX  ST3
#debug_left bool ST3
 LD   bool -1       ; true
 WRY  nahrazeno
#debug_left bool nahrazeno
#srcline 216 ;    END_IF;
Cascade4_L67:
#srcline 217 ;  END_IF;
Cascade4_L61:
#srcline 219 ;  //casovani provoznich hodin jednotlivych stupnu
#srcline 220 ;  timer1(IN :=  WRK1, PT := T#1s);
 LDX  WRK1
#debug bool WRK1
 WRX  timer1~IN
#debug_left bool timer1~IN
 LD   time 1000
 WRX  timer1~PT
#debug_left time timer1~PT
 LEAX timer1
 CAL  TON_L0
#srcline 221 ;  timer2(IN :=  WRK2, PT := T#1s);
 LDX  WRK2
#debug bool WRK2
 WRX  timer2~IN
#debug_left bool timer2~IN
 LD   time 1000
 WRX  timer2~PT
#debug_left time timer2~PT
 LEAX timer2
 CAL  TON_L0
#srcline 222 ;  timer3(IN :=  WRK3, PT := T#1s);
 LDX  WRK3
#debug bool WRK3
 WRX  timer3~IN
#debug_left bool timer3~IN
 LD   time 1000
 WRX  timer3~PT
#debug_left time timer3~PT
 LEAX timer3
 CAL  TON_L0
#srcline 223 ;  timer4(IN :=  WRK4, PT := T#1s);
 LDX  WRK4
#debug bool WRK4
 WRX  timer4~IN
#debug_left bool timer4~IN
 LD   time 1000
 WRX  timer4~PT
#debug_left time timer4~PT
 LEAX timer4
 CAL  TON_L0
#srcline 225 ;  IF timer1.Q THEN
 LDX  timer1~Q
#debug bool timer1.Q
 JMC  Cascade4_L69
#srcline 226 ;    timer1(IN := false);             //vynulovat casovac
 LD   bool 0       ; false
 WRX  timer1~IN
#debug_left bool timer1~IN
 LEAX timer1
 CAL  TON_L0
#srcline 227 ;    STAT.WT1 := STAT.WT1 + T#1s;     //provozni citac + 1s
 LDX  STAT~WT1
#debug time STAT.WT1
 LD   time 1000
 ADD
 WRX  STAT~WT1
#debug_left time STAT.WT1
#srcline 228 ;  END_IF;
Cascade4_L69:
#srcline 229 ;  IF timer2.Q THEN
 LDX  timer2~Q
#debug bool timer2.Q
 JMC  Cascade4_L71
#srcline 230 ;    timer2(IN := false);             //vynulovat casovac
 LD   bool 0       ; false
 WRX  timer2~IN
#debug_left bool timer2~IN
 LEAX timer2
 CAL  TON_L0
#srcline 231 ;    STAT.WT2 := STAT.WT2 + T#1s;     //provozni citac + 1s
 LDX  STAT~WT2
#debug time STAT.WT2
 LD   time 1000
 ADD
 WRX  STAT~WT2
#debug_left time STAT.WT2
#srcline 232 ;  END_IF;
Cascade4_L71:
#srcline 233 ;  IF timer3.Q THEN
 LDX  timer3~Q
#debug bool timer3.Q
 JMC  Cascade4_L73
#srcline 234 ;    timer3(IN := false);             //vynulovat casovac
 LD   bool 0       ; false
 WRX  timer3~IN
#debug_left bool timer3~IN
 LEAX timer3
 CAL  TON_L0
#srcline 235 ;    STAT.WT3 := STAT.WT3 + T#1s;     //provozni citac + 1s
 LDX  STAT~WT3
#debug time STAT.WT3
 LD   time 1000
 ADD
 WRX  STAT~WT3
#debug_left time STAT.WT3
#srcline 236 ;  END_IF;
Cascade4_L73:
#srcline 237 ;  IF timer4.Q THEN
 LDX  timer4~Q
#debug bool timer4.Q
 JMC  Cascade4_L75
#srcline 238 ;    timer4(IN := false);             //vynulovat casovac
 LD   bool 0       ; false
 WRX  timer4~IN
#debug_left bool timer4~IN
 LEAX timer4
 CAL  TON_L0
#srcline 239 ;    STAT.WT4 := STAT.WT4 + T#1s;     //provozni citac + 1s
 LDX  STAT~WT4
#debug time STAT.WT4
 LD   time 1000
 ADD
 WRX  STAT~WT4
#debug_left time STAT.WT4
#srcline 240 ;  END_IF;
Cascade4_L75:
#srcline 242 ;  // nulovani provoznich hodin jednotlivych stupnu
#srcline 243 ;  IF RES THEN
 LDX  RES
#debug bool RES
 JMC  Cascade4_L77
#srcline 244 ;    STAT.WT1 := T#0s;
 LD   time 0
 WRX  STAT~WT1
#debug_left time STAT.WT1
#srcline 245 ;    STAT.WT2 := T#0s;
 LD   time 0
 WRX  STAT~WT2
#debug_left time STAT.WT2
#srcline 246 ;    STAT.WT3 := T#0s;
 LD   time 0
 WRX  STAT~WT3
#debug_left time STAT.WT3
#srcline 247 ;    STAT.WT4 := T#0s;
 LD   time 0
 WRX  STAT~WT4
#debug_left time STAT.WT4
#srcline 248 ;    STAT.SEQ := 0;
 LD   usint 0
 WRX  STAT~SEQ
#debug_left usint STAT.SEQ
#srcline 249 ;  END_IF;
Cascade4_L77:
#srcline 251 ;  // kopie vstupu na vystup
#srcline 252 ;  OUT := IN;
 LDX  IN
#debug real IN
 WRX  OUT
#debug_left real OUT
#srcline 254 ;END_FUNCTION_BLOCK
 ULNK
RET
E     61
#endpou 



 

#srcfile ''
#srcfile 'D:\TECOAPP\KNIHOVNY\REGOLIB\CASCADE5.ST'
#pou Cascade5
#srcline 25 ;FUNCTION_BLOCK Cascade5

#struct Cascade5__temp__
  real HystPul,
  time minWT,
  bool nahrazeno,
  udint P0__st__
P     61
Cascade5_L0:
 LINK __SizeOf(Cascade5__temp__)
; Initialize - dynamic variables
; End initialize - dynamic variables
; R_EDGE, F_EDGE 
 LDX  CHNG
 LETX __EDGE_R__CHNG
 WRX  CHNG
#srcline 98 ;  IF ACT THEN
 LDX  ACT
#debug bool ACT
 JMC  Cascade5_L1
#srcline 99 ;    HystPul := CFG.HYSTER / 2.0;
 LDX  CFG~HYSTER
#debug real CFG.HYSTER
 LD   real 2.0
 DIF
 WRY  HystPul
#debug_left real HystPul
#srcline 100 ;    IF (IN > (CFG.LIMIT1+HystPul)) THEN  pomSt1 := true; END_IF;
 LDX  IN
#debug real IN
 LDX  CFG~LIMIT1
#debug real CFG.LIMIT1
 LDY  HystPul
#debug real HystPul
 ADF
 GTF
 JMC  Cascade5_L3
 LD   bool -1       ; true
 WRX  pomSt1
#debug_left bool pomSt1
Cascade5_L3:
#srcline 101 ;    IF (IN > (CFG.LIMIT2+HystPul)) THEN  pomSt2 := true; END_IF;
 LDX  IN
#debug real IN
 LDX  CFG~LIMIT2
#debug real CFG.LIMIT2
 LDY  HystPul
#debug real HystPul
 ADF
 GTF
 JMC  Cascade5_L5
 LD   bool -1       ; true
 WRX  pomSt2
#debug_left bool pomSt2
Cascade5_L5:
#srcline 102 ;    IF (IN > (CFG.LIMIT3+HystPul)) THEN  pomSt3 := true; END_IF;
 LDX  IN
#debug real IN
 LDX  CFG~LIMIT3
#debug real CFG.LIMIT3
 LDY  HystPul
#debug real HystPul
 ADF
 GTF
 JMC  Cascade5_L7
 LD   bool -1       ; true
 WRX  pomSt3
#debug_left bool pomSt3
Cascade5_L7:
#srcline 103 ;    IF (IN > (CFG.LIMIT4+HystPul)) THEN  pomSt4 := true; END_IF;
 LDX  IN
#debug real IN
 LDX  CFG~LIMIT4
#debug real CFG.LIMIT4
 LDY  HystPul
#debug real HystPul
 ADF
 GTF
 JMC  Cascade5_L9
 LD   bool -1       ; true
 WRX  pomSt4
#debug_left bool pomSt4
Cascade5_L9:
#srcline 104 ;    IF (IN > (CFG.LIMIT5+HystPul)) THEN  pomSt5 := true; END_IF;
 LDX  IN
#debug real IN
 LDX  CFG~LIMIT5
#debug real CFG.LIMIT5
 LDY  HystPul
#debug real HystPul
 ADF
 GTF
 JMC  Cascade5_L11
 LD   bool -1       ; true
 WRX  pomSt5
#debug_left bool pomSt5
Cascade5_L11:
#srcline 106 ;    IF (IN < (CFG.LIMIT1-HystPul)) THEN  pomSt1 := false; END_IF;
 LDX  IN
#debug real IN
 LDX  CFG~LIMIT1
#debug real CFG.LIMIT1
 LDY  HystPul
#debug real HystPul
 SUF
 LTF
 JMC  Cascade5_L13
 LD   bool 0       ; false
 WRX  pomSt1
#debug_left bool pomSt1
Cascade5_L13:
#srcline 107 ;    IF (IN < (CFG.LIMIT2-HystPul)) THEN  pomSt2 := false; END_IF;
 LDX  IN
#debug real IN
 LDX  CFG~LIMIT2
#debug real CFG.LIMIT2
 LDY  HystPul
#debug real HystPul
 SUF
 LTF
 JMC  Cascade5_L15
 LD   bool 0       ; false
 WRX  pomSt2
#debug_left bool pomSt2
Cascade5_L15:
#srcline 108 ;    IF (IN < (CFG.LIMIT3-HystPul)) THEN  pomSt3 := false; END_IF;
 LDX  IN
#debug real IN
 LDX  CFG~LIMIT3
#debug real CFG.LIMIT3
 LDY  HystPul
#debug real HystPul
 SUF
 LTF
 JMC  Cascade5_L17
 LD   bool 0       ; false
 WRX  pomSt3
#debug_left bool pomSt3
Cascade5_L17:
#srcline 109 ;    IF (IN < (CFG.LIMIT4-HystPul)) THEN  pomSt4 := false; END_IF;
 LDX  IN
#debug real IN
 LDX  CFG~LIMIT4
#debug real CFG.LIMIT4
 LDY  HystPul
#debug real HystPul
 SUF
 LTF
 JMC  Cascade5_L19
 LD   bool 0       ; false
 WRX  pomSt4
#debug_left bool pomSt4
Cascade5_L19:
#srcline 110 ;    IF (IN < (CFG.LIMIT5-HystPul)) THEN  pomSt5 := false; END_IF;
 LDX  IN
#debug real IN
 LDX  CFG~LIMIT5
#debug real CFG.LIMIT5
 LDY  HystPul
#debug real HystPul
 SUF
 LTF
 JMC  Cascade5_L21
 LD   bool 0       ; false
 WRX  pomSt5
#debug_left bool pomSt5
Cascade5_L21:
#srcline 111 ;  ELSE
 JMP  Cascade5_L2
Cascade5_L1:
#srcline 112 ;    pomSt1 := false;   //pokud neni provoz, vsechny stupne kaskady vypnout
 LD   bool 0       ; false
 WRX  pomSt1
#debug_left bool pomSt1
#srcline 113 ;    pomSt2 := false;
 LD   bool 0       ; false
 WRX  pomSt2
#debug_left bool pomSt2
#srcline 114 ;    pomSt3 := false;
 LD   bool 0       ; false
 WRX  pomSt3
#debug_left bool pomSt3
#srcline 115 ;    pomSt4 := false;
 LD   bool 0       ; false
 WRX  pomSt4
#debug_left bool pomSt4
#srcline 116 ;    pomSt5 := false;
 LD   bool 0       ; false
 WRX  pomSt5
#debug_left bool pomSt5
#srcline 117 ;  END_IF;
Cascade5_L2:
#srcline 118 ;  
#srcline 119 ;  IF IN <= 0.0 THEN
 LDX  IN
#debug real IN
 LD   real 0.0
 GTF
 NEG
 JMC  Cascade5_L23
#srcline 120 ;    pomSt1 := false;   //pokud neni signal IN, vsechny stupne kaskady vypnout
 LD   bool 0       ; false
 WRX  pomSt1
#debug_left bool pomSt1
#srcline 121 ;    pomSt2 := false;
 LD   bool 0       ; false
 WRX  pomSt2
#debug_left bool pomSt2
#srcline 122 ;    pomSt3 := false;
 LD   bool 0       ; false
 WRX  pomSt3
#debug_left bool pomSt3
#srcline 123 ;    pomSt4 := false;
 LD   bool 0       ; false
 WRX  pomSt4
#debug_left bool pomSt4
#srcline 124 ;    pomSt5 := false;
 LD   bool 0       ; false
 WRX  pomSt5
#debug_left bool pomSt5
#srcline 125 ;  END_IF;
Cascade5_L23:
#srcline 127 ;  // stridani poradi stupnu kaskady
#srcline 128 ;  IF CHNG AND CFG.ECHNG THEN       //zadost o zmenu poradi a zmena povolena?
 LDX  CHNG
#debug bool CHNG
 LDX  CFG~ECHNG
#debug bool CFG.ECHNG
 AND
 JMC  Cascade5_L25
#srcline 129 ;    STAT.SEQ := STAT.SEQ + 1;
 LDX  STAT~SEQ
#debug usint STAT.SEQ
 LD   usint 1
 ADD
 AND  $FF
 WRX  STAT~SEQ
#debug_left usint STAT.SEQ
#srcline 130 ;    
#srcline 131 ;    IF CFG.ECHNGT THEN             //povoleno vyhodnoceni provoznich hodin pri zmene?
 LDX  CFG~ECHNGT
#debug bool CFG.ECHNGT
 JMC  Cascade5_L27
#srcline 132 ;      IF STAT.WT1 < STAT.WT2 then   //porovnat provozni hodiny jednotlivych stupnu
 LDX  STAT~WT1
#debug time STAT.WT1
 LDX  STAT~WT2
#debug time STAT.WT2
 LTS
 JMC  Cascade5_L29
#srcline 133 ;        minWT  := STAT.WT1;
 LDX  STAT~WT1
#debug time STAT.WT1
 WRY  minWT
#debug_left time minWT
#srcline 134 ;        STAT.SEQ := 0;
 LD   usint 0
 WRX  STAT~SEQ
#debug_left usint STAT.SEQ
#srcline 135 ;      ELSE
 JMP  Cascade5_L30
Cascade5_L29:
#srcline 136 ;        minWT  := STAT.WT2;
 LDX  STAT~WT2
#debug time STAT.WT2
 WRY  minWT
#debug_left time minWT
#srcline 137 ;        STAT.SEQ := 1;
 LD   usint 1
 WRX  STAT~SEQ
#debug_left usint STAT.SEQ
#srcline 138 ;      END_IF;
Cascade5_L30:
#srcline 140 ;      IF STAT.WT3 < minWT THEN
 LDX  STAT~WT3
#debug time STAT.WT3
 LDY  minWT
#debug time minWT
 LTS
 JMC  Cascade5_L31
#srcline 141 ;        minWT  := STAT.WT3;
 LDX  STAT~WT3
#debug time STAT.WT3
 WRY  minWT
#debug_left time minWT
#srcline 142 ;        STAT.SEQ := 2;
 LD   usint 2
 WRX  STAT~SEQ
#debug_left usint STAT.SEQ
#srcline 143 ;      END_IF;
Cascade5_L31:
#srcline 145 ;      IF STAT.WT4 < minWT THEN
 LDX  STAT~WT4
#debug time STAT.WT4
 LDY  minWT
#debug time minWT
 LTS
 JMC  Cascade5_L33
#srcline 146 ;        minWT  := STAT.WT4;
 LDX  STAT~WT4
#debug time STAT.WT4
 WRY  minWT
#debug_left time minWT
#srcline 147 ;        STAT.SEQ := 3;
 LD   usint 3
 WRX  STAT~SEQ
#debug_left usint STAT.SEQ
#srcline 148 ;      END_IF;
Cascade5_L33:
#srcline 150 ;      IF STAT.WT5 < minWT THEN
 LDX  STAT~WT5
#debug time STAT.WT5
 LDY  minWT
#debug time minWT
 LTS
 JMC  Cascade5_L35
#srcline 151 ;        STAT.SEQ := 4;
 LD   usint 4
 WRX  STAT~SEQ
#debug_left usint STAT.SEQ
#srcline 152 ;      END_IF;
Cascade5_L35:
#srcline 153 ;    END_IF;
Cascade5_L27:
#srcline 154 ;    
#srcline 155 ;    IF STAT.SEQ > 4 THEN         //posledni mozne poradi
 LDX  STAT~SEQ
#debug usint STAT.SEQ
 LD   usint 4
 GT
 JMC  Cascade5_L37
#srcline 156 ;      STAT.SEQ := 0;             //zacit od zacatku
 LD   usint 0
 WRX  STAT~SEQ
#debug_left usint STAT.SEQ
#srcline 157 ;    END_IF;
Cascade5_L37:
#srcline 158 ;  END_IF;
Cascade5_L25:
#srcline 159 ;  
#srcline 160 ;  // prirazeni povelu stupnum kaskady podle poradi
#srcline 161 ;  CASE STAT.SEQ OF
 LDX  STAT~SEQ
#debug usint STAT.SEQ
 WRY  P0__st__
 LD   0
 LDY  P0__st__
 EQ  
 JMC  Cascade5_L40
#srcline 162 ;    0 : ST1 := pomSt1;       //poradi 12345
 LDX  pomSt1
#debug bool pomSt1
 WRX  ST1
#debug_left bool ST1
#srcline 163 ;        ST2 := pomSt2;
 LDX  pomSt2
#debug bool pomSt2
 WRX  ST2
#debug_left bool ST2
#srcline 164 ;        ST3 := pomSt3;
 LDX  pomSt3
#debug bool pomSt3
 WRX  ST3
#debug_left bool ST3
#srcline 165 ;        ST4 := pomSt4;
 LDX  pomSt4
#debug bool pomSt4
 WRX  ST4
#debug_left bool ST4
#srcline 166 ;        ST5 := pomSt5;
 LDX  pomSt5
#debug bool pomSt5
 WRX  ST5
#debug_left bool ST5
 JMP  Cascade5_L39
Cascade5_L40:
 LD   1
 LDY  P0__st__
 EQ  
 JMC  Cascade5_L41
#srcline 167 ;        
#srcline 168 ;    1 : ST1 := pomSt5;       //poradi 23451
 LDX  pomSt5
#debug bool pomSt5
 WRX  ST1
#debug_left bool ST1
#srcline 169 ;        ST2 := pomSt1;
 LDX  pomSt1
#debug bool pomSt1
 WRX  ST2
#debug_left bool ST2
#srcline 170 ;        ST3 := pomSt2;
 LDX  pomSt2
#debug bool pomSt2
 WRX  ST3
#debug_left bool ST3
#srcline 171 ;        ST4 := pomSt3;
 LDX  pomSt3
#debug bool pomSt3
 WRX  ST4
#debug_left bool ST4
#srcline 172 ;        ST5 := pomSt4;
 LDX  pomSt4
#debug bool pomSt4
 WRX  ST5
#debug_left bool ST5
 JMP  Cascade5_L39
Cascade5_L41:
 LD   2
 LDY  P0__st__
 EQ  
 JMC  Cascade5_L42
#srcline 174 ;    2 : ST1 := pomSt4;       //poradi 34512
 LDX  pomSt4
#debug bool pomSt4
 WRX  ST1
#debug_left bool ST1
#srcline 175 ;        ST2 := pomSt5;
 LDX  pomSt5
#debug bool pomSt5
 WRX  ST2
#debug_left bool ST2
#srcline 176 ;        ST3 := pomSt1;
 LDX  pomSt1
#debug bool pomSt1
 WRX  ST3
#debug_left bool ST3
#srcline 177 ;        ST4 := pomSt2;
 LDX  pomSt2
#debug bool pomSt2
 WRX  ST4
#debug_left bool ST4
#srcline 178 ;        ST5 := pomSt3;
 LDX  pomSt3
#debug bool pomSt3
 WRX  ST5
#debug_left bool ST5
 JMP  Cascade5_L39
Cascade5_L42:
 LD   3
 LDY  P0__st__
 EQ  
 JMC  Cascade5_L43
#srcline 180 ;    3 : ST1 := pomSt3;       //poradi 45123
 LDX  pomSt3
#debug bool pomSt3
 WRX  ST1
#debug_left bool ST1
#srcline 181 ;        ST2 := pomSt4;
 LDX  pomSt4
#debug bool pomSt4
 WRX  ST2
#debug_left bool ST2
#srcline 182 ;        ST3 := pomSt5;
 LDX  pomSt5
#debug bool pomSt5
 WRX  ST3
#debug_left bool ST3
#srcline 183 ;        ST4 := pomSt1;
 LDX  pomSt1
#debug bool pomSt1
 WRX  ST4
#debug_left bool ST4
#srcline 184 ;        ST5 := pomSt2;
 LDX  pomSt2
#debug bool pomSt2
 WRX  ST5
#debug_left bool ST5
 JMP  Cascade5_L39
Cascade5_L43:
#srcline 185 ;  ELSE
#srcline 186 ;        ST1 := pomSt2;       //poradi 51234
 LDX  pomSt2
#debug bool pomSt2
 WRX  ST1
#debug_left bool ST1
#srcline 187 ;        ST2 := pomSt3;
 LDX  pomSt3
#debug bool pomSt3
 WRX  ST2
#debug_left bool ST2
#srcline 188 ;        ST3 := pomSt4;
 LDX  pomSt4
#debug bool pomSt4
 WRX  ST3
#debug_left bool ST3
#srcline 189 ;        ST4 := pomSt5;
 LDX  pomSt5
#debug bool pomSt5
 WRX  ST4
#debug_left bool ST4
#srcline 190 ;        ST5 := pomSt1;
 LDX  pomSt1
#debug bool pomSt1
 WRX  ST5
#debug_left bool ST5
#srcline 191 ;  END_CASE;
Cascade5_L39:
#srcline 192 ;  
#srcline 193 ;  // stridani stupnu kaskady pri poruse
#srcline 194 ;  IF ST1 AND ERR1 THEN                 //stupen 1 ma byt v provozu a je na nem porucha?
 LDX  ST1
#debug bool ST1
 LDX  ERR1
#debug bool ERR1
 AND
 JMC  Cascade5_L44
#srcline 195 ;    ST1:= false;   nahrazeno := false; //porouchany stupen odepnout
 LD   bool 0       ; false
 WRX  ST1
#debug_left bool ST1
 LD   bool 0       ; false
 WRY  nahrazeno
#debug_left bool nahrazeno
#srcline 196 ;    IF not ST2 AND not ERR2 AND not nahrazeno THEN
 LDX  ST2
#debug bool ST2
 NEG
 LDX  ERR2
#debug bool ERR2
 NEG
 AND
 LDY  nahrazeno
#debug bool nahrazeno
 NEG
 AND
 JMC  Cascade5_L46
#srcline 197 ;      ST2 := true; nahrazeno := true;
 LD   bool -1       ; true
 WRX  ST2
#debug_left bool ST2
 LD   bool -1       ; true
 WRY  nahrazeno
#debug_left bool nahrazeno
#srcline 198 ;    END_IF;
Cascade5_L46:
#srcline 199 ;    IF not ST3 AND not ERR3 AND not nahrazeno THEN
 LDX  ST3
#debug bool ST3
 NEG
 LDX  ERR3
#debug bool ERR3
 NEG
 AND
 LDY  nahrazeno
#debug bool nahrazeno
 NEG
 AND
 JMC  Cascade5_L48
#srcline 200 ;      ST3 := true; nahrazeno := true;
 LD   bool -1       ; true
 WRX  ST3
#debug_left bool ST3
 LD   bool -1       ; true
 WRY  nahrazeno
#debug_left bool nahrazeno
#srcline 201 ;    END_IF;
Cascade5_L48:
#srcline 202 ;    IF not ST4 AND not ERR4 AND not nahrazeno THEN
 LDX  ST4
#debug bool ST4
 NEG
 LDX  ERR4
#debug bool ERR4
 NEG
 AND
 LDY  nahrazeno
#debug bool nahrazeno
 NEG
 AND
 JMC  Cascade5_L50
#srcline 203 ;      ST4 := true; nahrazeno := true;
 LD   bool -1       ; true
 WRX  ST4
#debug_left bool ST4
 LD   bool -1       ; true
 WRY  nahrazeno
#debug_left bool nahrazeno
#srcline 204 ;    END_IF;
Cascade5_L50:
#srcline 205 ;    IF not ST5 AND not ERR5 AND not nahrazeno THEN
 LDX  ST5
#debug bool ST5
 NEG
 LDX  ERR5
#debug bool ERR5
 NEG
 AND
 LDY  nahrazeno
#debug bool nahrazeno
 NEG
 AND
 JMC  Cascade5_L52
#srcline 206 ;      ST5 := true; nahrazeno := true;
 LD   bool -1       ; true
 WRX  ST5
#debug_left bool ST5
 LD   bool -1       ; true
 WRY  nahrazeno
#debug_left bool nahrazeno
#srcline 207 ;    END_IF;
Cascade5_L52:
#srcline 208 ;  END_IF;
Cascade5_L44:
#srcline 209 ;  
#srcline 210 ;  IF ST2 AND ERR2 THEN                 //stupen 2 ma byt v provozu a je na nem porucha?
 LDX  ST2
#debug bool ST2
 LDX  ERR2
#debug bool ERR2
 AND
 JMC  Cascade5_L54
#srcline 211 ;    ST2:= false;   nahrazeno := false; //porouchany stupen odepnout
 LD   bool 0       ; false
 WRX  ST2
#debug_left bool ST2
 LD   bool 0       ; false
 WRY  nahrazeno
#debug_left bool nahrazeno
#srcline 212 ;    IF not ST3 AND not ERR3 AND not nahrazeno THEN
 LDX  ST3
#debug bool ST3
 NEG
 LDX  ERR3
#debug bool ERR3
 NEG
 AND
 LDY  nahrazeno
#debug bool nahrazeno
 NEG
 AND
 JMC  Cascade5_L56
#srcline 213 ;      ST3 := true; nahrazeno := true;
 LD   bool -1       ; true
 WRX  ST3
#debug_left bool ST3
 LD   bool -1       ; true
 WRY  nahrazeno
#debug_left bool nahrazeno
#srcline 214 ;    END_IF;
Cascade5_L56:
#srcline 215 ;    IF not ST4 AND not ERR4 AND not nahrazeno THEN
 LDX  ST4
#debug bool ST4
 NEG
 LDX  ERR4
#debug bool ERR4
 NEG
 AND
 LDY  nahrazeno
#debug bool nahrazeno
 NEG
 AND
 JMC  Cascade5_L58
#srcline 216 ;      ST4 := true; nahrazeno := true;
 LD   bool -1       ; true
 WRX  ST4
#debug_left bool ST4
 LD   bool -1       ; true
 WRY  nahrazeno
#debug_left bool nahrazeno
#srcline 217 ;    END_IF;
Cascade5_L58:
#srcline 218 ;    IF not ST5 AND not ERR5 AND not nahrazeno THEN
 LDX  ST5
#debug bool ST5
 NEG
 LDX  ERR5
#debug bool ERR5
 NEG
 AND
 LDY  nahrazeno
#debug bool nahrazeno
 NEG
 AND
 JMC  Cascade5_L60
#srcline 219 ;      ST5 := true; nahrazeno := true;
 LD   bool -1       ; true
 WRX  ST5
#debug_left bool ST5
 LD   bool -1       ; true
 WRY  nahrazeno
#debug_left bool nahrazeno
#srcline 220 ;    END_IF;
Cascade5_L60:
#srcline 221 ;    IF not ST1 AND not ERR1 AND not nahrazeno THEN
 LDX  ST1
#debug bool ST1
 NEG
 LDX  ERR1
#debug bool ERR1
 NEG
 AND
 LDY  nahrazeno
#debug bool nahrazeno
 NEG
 AND
 JMC  Cascade5_L62
#srcline 222 ;      ST1 := true; nahrazeno := true;
 LD   bool -1       ; true
 WRX  ST1
#debug_left bool ST1
 LD   bool -1       ; true
 WRY  nahrazeno
#debug_left bool nahrazeno
#srcline 223 ;    END_IF;
Cascade5_L62:
#srcline 224 ;  END_IF;
Cascade5_L54:
#srcline 226 ;  IF ST3 AND ERR3 THEN                 //stupen 3 ma byt v provozu a je na nem porucha?
 LDX  ST3
#debug bool ST3
 LDX  ERR3
#debug bool ERR3
 AND
 JMC  Cascade5_L64
#srcline 227 ;    ST3:= false;   nahrazeno := false; //porouchany stupen odepnout
 LD   bool 0       ; false
 WRX  ST3
#debug_left bool ST3
 LD   bool 0       ; false
 WRY  nahrazeno
#debug_left bool nahrazeno
#srcline 228 ;    IF not ST4 AND not ERR4 AND not nahrazeno THEN
 LDX  ST4
#debug bool ST4
 NEG
 LDX  ERR4
#debug bool ERR4
 NEG
 AND
 LDY  nahrazeno
#debug bool nahrazeno
 NEG
 AND
 JMC  Cascade5_L66
#srcline 229 ;      ST4 := true; nahrazeno := true;
 LD   bool -1       ; true
 WRX  ST4
#debug_left bool ST4
 LD   bool -1       ; true
 WRY  nahrazeno
#debug_left bool nahrazeno
#srcline 230 ;    END_IF;
Cascade5_L66:
#srcline 231 ;    IF not ST5 AND not ERR5 AND not nahrazeno THEN
 LDX  ST5
#debug bool ST5
 NEG
 LDX  ERR5
#debug bool ERR5
 NEG
 AND
 LDY  nahrazeno
#debug bool nahrazeno
 NEG
 AND
 JMC  Cascade5_L68
#srcline 232 ;      ST5 := true; nahrazeno := true;
 LD   bool -1       ; true
 WRX  ST5
#debug_left bool ST5
 LD   bool -1       ; true
 WRY  nahrazeno
#debug_left bool nahrazeno
#srcline 233 ;    END_IF;
Cascade5_L68:
#srcline 234 ;    IF not ST1 AND not ERR1 AND not nahrazeno THEN
 LDX  ST1
#debug bool ST1
 NEG
 LDX  ERR1
#debug bool ERR1
 NEG
 AND
 LDY  nahrazeno
#debug bool nahrazeno
 NEG
 AND
 JMC  Cascade5_L70
#srcline 235 ;      ST1 := true; nahrazeno := true;
 LD   bool -1       ; true
 WRX  ST1
#debug_left bool ST1
 LD   bool -1       ; true
 WRY  nahrazeno
#debug_left bool nahrazeno
#srcline 236 ;    END_IF;
Cascade5_L70:
#srcline 237 ;    IF not ST2 AND not ERR2 and not nahrazeno THEN
 LDX  ST2
#debug bool ST2
 NEG
 LDX  ERR2
#debug bool ERR2
 NEG
 AND
 LDY  nahrazeno
#debug bool nahrazeno
 NEG
 AND
 JMC  Cascade5_L72
#srcline 238 ;      ST2 := true; nahrazeno := true;
 LD   bool -1       ; true
 WRX  ST2
#debug_left bool ST2
 LD   bool -1       ; true
 WRY  nahrazeno
#debug_left bool nahrazeno
#srcline 239 ;    END_IF;
Cascade5_L72:
#srcline 240 ;  END_IF;
Cascade5_L64:
#srcline 242 ;  IF ST4 AND ERR4 THEN                 //stupen 4 ma byt v provozu a je na nem porucha?
 LDX  ST4
#debug bool ST4
 LDX  ERR4
#debug bool ERR4
 AND
 JMC  Cascade5_L74
#srcline 243 ;    ST4:= false;   nahrazeno := false; //porouchany stupen odepnout
 LD   bool 0       ; false
 WRX  ST4
#debug_left bool ST4
 LD   bool 0       ; false
 WRY  nahrazeno
#debug_left bool nahrazeno
#srcline 244 ;    IF not ST5 AND not ERR5 AND not nahrazeno THEN
 LDX  ST5
#debug bool ST5
 NEG
 LDX  ERR5
#debug bool ERR5
 NEG
 AND
 LDY  nahrazeno
#debug bool nahrazeno
 NEG
 AND
 JMC  Cascade5_L76
#srcline 245 ;      ST5 := true; nahrazeno := true;
 LD   bool -1       ; true
 WRX  ST5
#debug_left bool ST5
 LD   bool -1       ; true
 WRY  nahrazeno
#debug_left bool nahrazeno
#srcline 246 ;    END_IF;
Cascade5_L76:
#srcline 247 ;    IF not ST1 AND not ERR1 AND not nahrazeno THEN
 LDX  ST1
#debug bool ST1
 NEG
 LDX  ERR1
#debug bool ERR1
 NEG
 AND
 LDY  nahrazeno
#debug bool nahrazeno
 NEG
 AND
 JMC  Cascade5_L78
#srcline 248 ;      ST1 := true; nahrazeno := true;
 LD   bool -1       ; true
 WRX  ST1
#debug_left bool ST1
 LD   bool -1       ; true
 WRY  nahrazeno
#debug_left bool nahrazeno
#srcline 249 ;    END_IF;
Cascade5_L78:
#srcline 250 ;    IF not ST2 AND not ERR2 and not nahrazeno THEN
 LDX  ST2
#debug bool ST2
 NEG
 LDX  ERR2
#debug bool ERR2
 NEG
 AND
 LDY  nahrazeno
#debug bool nahrazeno
 NEG
 AND
 JMC  Cascade5_L80
#srcline 251 ;      ST2 := true; nahrazeno := true;
 LD   bool -1       ; true
 WRX  ST2
#debug_left bool ST2
 LD   bool -1       ; true
 WRY  nahrazeno
#debug_left bool nahrazeno
#srcline 252 ;    END_IF;
Cascade5_L80:
#srcline 253 ;    IF not ST3 AND not ERR3 AND not nahrazeno THEN
 LDX  ST3
#debug bool ST3
 NEG
 LDX  ERR3
#debug bool ERR3
 NEG
 AND
 LDY  nahrazeno
#debug bool nahrazeno
 NEG
 AND
 JMC  Cascade5_L82
#srcline 254 ;      ST3 := true; nahrazeno := true;
 LD   bool -1       ; true
 WRX  ST3
#debug_left bool ST3
 LD   bool -1       ; true
 WRY  nahrazeno
#debug_left bool nahrazeno
#srcline 255 ;    END_IF;
Cascade5_L82:
#srcline 256 ;  END_IF;
Cascade5_L74:
#srcline 258 ;  IF ST5 AND ERR5 THEN                 //stupen 5 ma byt v provozu a je na nem porucha?
 LDX  ST5
#debug bool ST5
 LDX  ERR5
#debug bool ERR5
 AND
 JMC  Cascade5_L84
#srcline 259 ;    ST5:= false;   nahrazeno := false; //porouchany stupen odepnout
 LD   bool 0       ; false
 WRX  ST5
#debug_left bool ST5
 LD   bool 0       ; false
 WRY  nahrazeno
#debug_left bool nahrazeno
#srcline 260 ;    IF not ST1 AND not ERR1 AND not nahrazeno THEN
 LDX  ST1
#debug bool ST1
 NEG
 LDX  ERR1
#debug bool ERR1
 NEG
 AND
 LDY  nahrazeno
#debug bool nahrazeno
 NEG
 AND
 JMC  Cascade5_L86
#srcline 261 ;      ST1 := true; nahrazeno := true;
 LD   bool -1       ; true
 WRX  ST1
#debug_left bool ST1
 LD   bool -1       ; true
 WRY  nahrazeno
#debug_left bool nahrazeno
#srcline 262 ;    END_IF;
Cascade5_L86:
#srcline 263 ;    IF not ST2 AND not ERR2 and not nahrazeno THEN
 LDX  ST2
#debug bool ST2
 NEG
 LDX  ERR2
#debug bool ERR2
 NEG
 AND
 LDY  nahrazeno
#debug bool nahrazeno
 NEG
 AND
 JMC  Cascade5_L88
#srcline 264 ;      ST2 := true; nahrazeno := true;
 LD   bool -1       ; true
 WRX  ST2
#debug_left bool ST2
 LD   bool -1       ; true
 WRY  nahrazeno
#debug_left bool nahrazeno
#srcline 265 ;    END_IF;
Cascade5_L88:
#srcline 266 ;    IF not ST3 AND not ERR3 AND not nahrazeno THEN
 LDX  ST3
#debug bool ST3
 NEG
 LDX  ERR3
#debug bool ERR3
 NEG
 AND
 LDY  nahrazeno
#debug bool nahrazeno
 NEG
 AND
 JMC  Cascade5_L90
#srcline 267 ;      ST3 := true; nahrazeno := true;
 LD   bool -1       ; true
 WRX  ST3
#debug_left bool ST3
 LD   bool -1       ; true
 WRY  nahrazeno
#debug_left bool nahrazeno
#srcline 268 ;    END_IF;
Cascade5_L90:
#srcline 269 ;    IF not ST4 AND not ERR4 AND not nahrazeno THEN
 LDX  ST4
#debug bool ST4
 NEG
 LDX  ERR4
#debug bool ERR4
 NEG
 AND
 LDY  nahrazeno
#debug bool nahrazeno
 NEG
 AND
 JMC  Cascade5_L92
#srcline 270 ;      ST4 := true; nahrazeno := true;
 LD   bool -1       ; true
 WRX  ST4
#debug_left bool ST4
 LD   bool -1       ; true
 WRY  nahrazeno
#debug_left bool nahrazeno
#srcline 271 ;    END_IF;
Cascade5_L92:
#srcline 272 ;  END_IF;
Cascade5_L84:
#srcline 274 ;  //casovani provoznich hodin jednotlivych stupnu
#srcline 275 ;  timer1(IN :=  WRK1, PT := T#1s);
 LDX  WRK1
#debug bool WRK1
 WRX  timer1~IN
#debug_left bool timer1~IN
 LD   time 1000
 WRX  timer1~PT
#debug_left time timer1~PT
 LEAX timer1
 CAL  TON_L0
#srcline 276 ;  timer2(IN :=  WRK2, PT := T#1s);
 LDX  WRK2
#debug bool WRK2
 WRX  timer2~IN
#debug_left bool timer2~IN
 LD   time 1000
 WRX  timer2~PT
#debug_left time timer2~PT
 LEAX timer2
 CAL  TON_L0
#srcline 277 ;  timer3(IN :=  WRK3, PT := T#1s);
 LDX  WRK3
#debug bool WRK3
 WRX  timer3~IN
#debug_left bool timer3~IN
 LD   time 1000
 WRX  timer3~PT
#debug_left time timer3~PT
 LEAX timer3
 CAL  TON_L0
#srcline 278 ;  timer4(IN :=  WRK4, PT := T#1s);
 LDX  WRK4
#debug bool WRK4
 WRX  timer4~IN
#debug_left bool timer4~IN
 LD   time 1000
 WRX  timer4~PT
#debug_left time timer4~PT
 LEAX timer4
 CAL  TON_L0
#srcline 279 ;  timer5(IN :=  WRK5, PT := T#1s);
 LDX  WRK5
#debug bool WRK5
 WRX  timer5~IN
#debug_left bool timer5~IN
 LD   time 1000
 WRX  timer5~PT
#debug_left time timer5~PT
 LEAX timer5
 CAL  TON_L0
#srcline 281 ;  IF timer1.Q THEN
 LDX  timer1~Q
#debug bool timer1.Q
 JMC  Cascade5_L94
#srcline 282 ;    timer1(IN := false);             //vynulovat casovac
 LD   bool 0       ; false
 WRX  timer1~IN
#debug_left bool timer1~IN
 LEAX timer1
 CAL  TON_L0
#srcline 283 ;    STAT.WT1 := STAT.WT1 + T#1s;     //provozni citac + 1s
 LDX  STAT~WT1
#debug time STAT.WT1
 LD   time 1000
 ADD
 WRX  STAT~WT1
#debug_left time STAT.WT1
#srcline 284 ;  END_IF;
Cascade5_L94:
#srcline 285 ;  IF timer2.Q THEN
 LDX  timer2~Q
#debug bool timer2.Q
 JMC  Cascade5_L96
#srcline 286 ;    timer2(IN := false);             //vynulovat casovac
 LD   bool 0       ; false
 WRX  timer2~IN
#debug_left bool timer2~IN
 LEAX timer2
 CAL  TON_L0
#srcline 287 ;    STAT.WT2 := STAT.WT2 + T#1s;     //provozni citac + 1s
 LDX  STAT~WT2
#debug time STAT.WT2
 LD   time 1000
 ADD
 WRX  STAT~WT2
#debug_left time STAT.WT2
#srcline 288 ;  END_IF;
Cascade5_L96:
#srcline 289 ;  IF timer3.Q THEN
 LDX  timer3~Q
#debug bool timer3.Q
 JMC  Cascade5_L98
#srcline 290 ;    timer3(IN := false);             //vynulovat casovac
 LD   bool 0       ; false
 WRX  timer3~IN
#debug_left bool timer3~IN
 LEAX timer3
 CAL  TON_L0
#srcline 291 ;    STAT.WT3 := STAT.WT3 + T#1s;     //provozni citac + 1s
 LDX  STAT~WT3
#debug time STAT.WT3
 LD   time 1000
 ADD
 WRX  STAT~WT3
#debug_left time STAT.WT3
#srcline 292 ;  END_IF;
Cascade5_L98:
#srcline 293 ;  IF timer4.Q THEN
 LDX  timer4~Q
#debug bool timer4.Q
 JMC  Cascade5_L100
#srcline 294 ;    timer4(IN := false);             //vynulovat casovac
 LD   bool 0       ; false
 WRX  timer4~IN
#debug_left bool timer4~IN
 LEAX timer4
 CAL  TON_L0
#srcline 295 ;    STAT.WT4 := STAT.WT4 + T#1s;     //provozni citac + 1s
 LDX  STAT~WT4
#debug time STAT.WT4
 LD   time 1000
 ADD
 WRX  STAT~WT4
#debug_left time STAT.WT4
#srcline 296 ;  END_IF;
Cascade5_L100:
#srcline 297 ;  IF timer5.Q THEN
 LDX  timer5~Q
#debug bool timer5.Q
 JMC  Cascade5_L102
#srcline 298 ;    timer5(IN := false);             //vynulovat casovac
 LD   bool 0       ; false
 WRX  timer5~IN
#debug_left bool timer5~IN
 LEAX timer5
 CAL  TON_L0
#srcline 299 ;    STAT.WT5 := STAT.WT5 + T#1s;     //provozni citac + 1s
 LDX  STAT~WT5
#debug time STAT.WT5
 LD   time 1000
 ADD
 WRX  STAT~WT5
#debug_left time STAT.WT5
#srcline 300 ;  END_IF;
Cascade5_L102:
#srcline 302 ;  // nulovani provoznich hodin jednotlivych stupnu
#srcline 303 ;  IF RES THEN
 LDX  RES
#debug bool RES
 JMC  Cascade5_L104
#srcline 304 ;    STAT.WT1 := T#0s;
 LD   time 0
 WRX  STAT~WT1
#debug_left time STAT.WT1
#srcline 305 ;    STAT.WT2 := T#0s;
 LD   time 0
 WRX  STAT~WT2
#debug_left time STAT.WT2
#srcline 306 ;    STAT.WT3 := T#0s;
 LD   time 0
 WRX  STAT~WT3
#debug_left time STAT.WT3
#srcline 307 ;    STAT.WT4 := T#0s;
 LD   time 0
 WRX  STAT~WT4
#debug_left time STAT.WT4
#srcline 308 ;    STAT.WT5 := T#0s;
 LD   time 0
 WRX  STAT~WT5
#debug_left time STAT.WT5
#srcline 309 ;    STAT.SEQ := 0;
 LD   usint 0
 WRX  STAT~SEQ
#debug_left usint STAT.SEQ
#srcline 310 ;  END_IF;
Cascade5_L104:
#srcline 311 ;  
#srcline 312 ;  // kopie vstupu na vystup
#srcline 313 ;  OUT := IN;
 LDX  IN
#debug real IN
 WRX  OUT
#debug_left real OUT
#srcline 314 ;  
#srcline 315 ;END_FUNCTION_BLOCK
 ULNK
RET
E     61
#endpou 



 

#srcfile ''
#srcfile 'D:\TECOAPP\KNIHOVNY\REGOLIB\EKVITERM1.ST'
#pou Ekviterm1
#srcline 14 ;FUNCTION_BLOCK Ekviterm1

#struct Ekviterm1__temp__
  real TempA,  ;pozadovana venkovni teplota bod A  	
  real TempB,  ;pozadovana venkovni teplota bod B	
  real TempC,  ;pozadovana venkovni teplota bod C	
  real TempD,  ;pozadovana venkovni teplota bod D	
  real gain,  ;zesileni vstupniho signalu
  real offset,  ;offset vystupniho signalu
  real CNTDrop  ;upraveny utlum podle casove rampy
P     61
Ekviterm1_L0:
 LINK __SizeOf(Ekviterm1__temp__)
; Initialize - dynamic variables
 LD   real -20
 WRY  TempA
 LD   real -8
 WRY  TempB
 LD   real 5
 WRY  TempC
 LD   real 15
 WRY  TempD
; End initialize - dynamic variables
#srcline 54 ;  IF In <= TempA THEN
 LDX  In
#debug real In
 LDY  TempA
#debug real TempA
 GTF
 NEG
 JMC  Ekviterm1_L1
#srcline 55 ;    Out := Cfg.TempEkvA;                              //ekvitermni teplota
 LDX  Cfg~TempEkvA
#debug real Cfg.TempEkvA
 WRX  Out
#debug_left real Out
#srcline 56 ;  END_IF;
Ekviterm1_L1:
#srcline 57 ;  IF (TempA < In) AND (In <= TempB) THEN
 LDY  TempA
#debug real TempA
 LDX  In
#debug real In
 LTF
 LDX  In
#debug real In
 LDY  TempB
#debug real TempB
 GTF
 NEG
 AND
 JMC  Ekviterm1_L3
#srcline 58 ;    gain   := (Cfg.TempEkvA - Cfg.TempEkvB) / (TempA - TempB);
 LDX  Cfg~TempEkvA
#debug real Cfg.TempEkvA
 LDX  Cfg~TempEkvB
#debug real Cfg.TempEkvB
 SUF
 LDY  TempA
#debug real TempA
 LDY  TempB
#debug real TempB
 SUF
 DIF
 WRY  gain
#debug_left real gain
#srcline 59 ;    offset := Cfg.TempEkvB - (TempB * gain);
 LDX  Cfg~TempEkvB
#debug real Cfg.TempEkvB
 LDY  TempB
#debug real TempB
 LDY  gain
#debug real gain
 MUF
 SUF
 WRY  offset
#debug_left real offset
#srcline 60 ;    Out := In * gain + offset;                //ekvitermni teplota
 LDX  In
#debug real In
 LDY  gain
#debug real gain
 MUF
 LDY  offset
#debug real offset
 ADF
 WRX  Out
#debug_left real Out
#srcline 61 ;  END_IF;
Ekviterm1_L3:
#srcline 62 ;  IF (TempB < In) AND (In <= TempC) THEN
 LDY  TempB
#debug real TempB
 LDX  In
#debug real In
 LTF
 LDX  In
#debug real In
 LDY  TempC
#debug real TempC
 GTF
 NEG
 AND
 JMC  Ekviterm1_L5
#srcline 63 ;    gain   := (Cfg.TempEkvB - Cfg.TempEkvC) / (TempB - TempC);
 LDX  Cfg~TempEkvB
#debug real Cfg.TempEkvB
 LDX  Cfg~TempEkvC
#debug real Cfg.TempEkvC
 SUF
 LDY  TempB
#debug real TempB
 LDY  TempC
#debug real TempC
 SUF
 DIF
 WRY  gain
#debug_left real gain
#srcline 64 ;    offset := Cfg.TempEkvC - (TempC * gain);
 LDX  Cfg~TempEkvC
#debug real Cfg.TempEkvC
 LDY  TempC
#debug real TempC
 LDY  gain
#debug real gain
 MUF
 SUF
 WRY  offset
#debug_left real offset
#srcline 65 ;    Out := In * gain + offset;                //ekvitermni teplota
 LDX  In
#debug real In
 LDY  gain
#debug real gain
 MUF
 LDY  offset
#debug real offset
 ADF
 WRX  Out
#debug_left real Out
#srcline 66 ;  END_IF;
Ekviterm1_L5:
#srcline 67 ;  IF (TempC < In) AND (In <= TempD) THEN
 LDY  TempC
#debug real TempC
 LDX  In
#debug real In
 LTF
 LDX  In
#debug real In
 LDY  TempD
#debug real TempD
 GTF
 NEG
 AND
 JMC  Ekviterm1_L7
#srcline 68 ;    gain   := (Cfg.TempEkvC - Cfg.TempEkvD) / (TempC - TempD);
 LDX  Cfg~TempEkvC
#debug real Cfg.TempEkvC
 LDX  Cfg~TempEkvD
#debug real Cfg.TempEkvD
 SUF
 LDY  TempC
#debug real TempC
 LDY  TempD
#debug real TempD
 SUF
 DIF
 WRY  gain
#debug_left real gain
#srcline 69 ;    offset := Cfg.TempEkvD - (TempD * gain);
 LDX  Cfg~TempEkvD
#debug real Cfg.TempEkvD
 LDY  TempD
#debug real TempD
 LDY  gain
#debug real gain
 MUF
 SUF
 WRY  offset
#debug_left real offset
#srcline 70 ;    Out := In * gain + offset;                //ekvitermni teplota
 LDX  In
#debug real In
 LDY  gain
#debug real gain
 MUF
 LDY  offset
#debug real offset
 ADF
 WRX  Out
#debug_left real Out
#srcline 71 ;  END_IF;
Ekviterm1_L7:
#srcline 72 ;  IF TempD <= In THEN
 LDY  TempD
#debug real TempD
 LDX  In
#debug real In
 GTF
 NEG
 JMC  Ekviterm1_L9
#srcline 73 ;    Out := Cfg.TempEkvD;                       //ekvitermni teplota
 LDX  Cfg~TempEkvD
#debug real Cfg.TempEkvD
 WRX  Out
#debug_left real Out
#srcline 74 ;  END_IF;
Ekviterm1_L9:
#srcline 76 ;  //snizovani (zvysovani) ekvitermni teploty podle casove rampy pri zmene rezimu utlum <-> provoz
#srcline 77 ;  IF Cfg.Ramp > 546 THEN Cfg.Ramp := 546; END_IF;   //osetreni preteceni predvolby citace (max. 32767 > (546*60=32760))
 LDX  Cfg~Ramp
#debug int Cfg.Ramp
 EXTW 
 LD   int 546
 GTS
 JMC  Ekviterm1_L11
 LD   int 546
 WRX  Cfg~Ramp
#debug_left int Cfg.Ramp
Ekviterm1_L11:
#srcline 78 ;  CNTRamp.PV := Cfg.Ramp*60;                //maximum citace (citac pak cita mezi 0 a maximem)
 LDX  Cfg~Ramp
#debug int Cfg.Ramp
 EXTW 
 LD   int 60
 MULS
 EXTW
 WRX  CNTRamp~PV
#debug_left int CNTRamp.PV
#srcline 79 ;  CNTRamp.CU := not Act and %s20.2;         //citat nahoru
 LDX  Act
#debug bool Act
 NEG
 LD   %S20.2
 AND
 WRX  CNTRamp~CU
#debug_left bool CNTRamp.CU
#srcline 80 ;  CNTRamp.CD :=     Act and %s20.2;         //citat dolu
 LDX  Act
#debug bool Act
 LD   %S20.2
 AND
 WRX  CNTRamp~CD
#debug_left bool CNTRamp.CD
#srcline 81 ;  CNTRamp();                                //citac utlumove rampy
 LEAX CNTRamp
 CAL  CTUD_L0
#srcline 83 ;  IF Cfg.Ramp<>0 THEN                       //je nejaka casova rampa utlumu
 LDX  Cfg~Ramp
#debug int Cfg.Ramp
 EXTW 
 LD   int 0
 EQ
 NEG
 JMC  Ekviterm1_L13
#srcline 84 ;    CNTDrop := Cfg.Drop * INT_TO_REAL(CNTRamp.CV)/ INT_TO_REAL(Cfg.Ramp*60);  //upraveny utlum podle rampy
 LDX  Cfg~Drop
#debug real Cfg.Drop
 LDX  CNTRamp~CV
#debug int CNTRamp.CV
 EXTW 
 ILF
 MUF
 LDX  Cfg~Ramp
#debug int Cfg.Ramp
 EXTW 
 LD   int 60
 MULS
 EXTW
 ILF
 DIF
 WRY  CNTDrop
#debug_left real CNTDrop
#srcline 85 ;  ELSE                       //neni casova rampa utlumu
 JMP  Ekviterm1_L14
Ekviterm1_L13:
#srcline 86 ;    IF Act THEN
 LDX  Act
#debug bool Act
 JMC  Ekviterm1_L15
#srcline 87 ;      CNTDrop := 0.0;       //pro "provoz" uvazovat nulovy utlum
 LD   real 0.0
 WRY  CNTDrop
#debug_left real CNTDrop
#srcline 88 ;    ELSE
 JMP  Ekviterm1_L16
Ekviterm1_L15:
#srcline 89 ;      CNTDrop := Cfg.Drop;      //pro "utlum" uvazovat cely utlum
 LDX  Cfg~Drop
#debug real Cfg.Drop
 WRY  CNTDrop
#debug_left real CNTDrop
#srcline 90 ;    END_IF;
Ekviterm1_L16:
#srcline 91 ;  END_IF;
Ekviterm1_L14:
#srcline 93 ;  IF CNTDrop > Cfg.Drop THEN CNTDrop := Cfg.Drop; END_IF; //maximalni utlum
 LDY  CNTDrop
#debug real CNTDrop
 LDX  Cfg~Drop
#debug real Cfg.Drop
 GTF
 JMC  Ekviterm1_L17
 LDX  Cfg~Drop
#debug real Cfg.Drop
 WRY  CNTDrop
#debug_left real CNTDrop
Ekviterm1_L17:
#srcline 95 ;  Out := Out - CNTDrop;    //uprava vystupni teploty o utlum
 LDX  Out
#debug real Out
 LDY  CNTDrop
#debug real CNTDrop
 SUF
 WRX  Out
#debug_left real Out
#srcline 97 ;  //kontrola rozsahu ekvitermni teploty
#srcline 98 ;  IF Out > Cfg.TempEkvA   THEN Out := Cfg.TempEkvA;   END_IF;  //maximum
 LDX  Out
#debug real Out
 LDX  Cfg~TempEkvA
#debug real Cfg.TempEkvA
 GTF
 JMC  Ekviterm1_L19
 LDX  Cfg~TempEkvA
#debug real Cfg.TempEkvA
 WRX  Out
#debug_left real Out
Ekviterm1_L19:
#srcline 99 ;  IF Out < Cfg.MinTempOut THEN Out := Cfg.MinTempOut; END_IF;  //minimum
 LDX  Out
#debug real Out
 LDX  Cfg~MinTempOut
#debug real Cfg.MinTempOut
 LTF
 JMC  Ekviterm1_L21
 LDX  Cfg~MinTempOut
#debug real Cfg.MinTempOut
 WRX  Out
#debug_left real Out
Ekviterm1_L21:
#srcline 101 ;END_FUNCTION_BLOCK
 ULNK
RET
E     61

; Initialize - variables
P     61
Ekviterm1__InstanceInit__:
 LINK 0
 ULNK
RET
E     61
; End initialize - variables
#endpou 



 

#srcfile ''
#srcfile 'D:\TECOAPP\KNIHOVNY\REGOLIB\EKVITERM2.ST'
#pou Ekviterm2
#srcline 18 ;FUNCTION_BLOCK Ekviterm2

#struct Ekviterm2__temp__
  real gain,  ;zesileni vstupniho signalu
  real offset,  ;offset vystupniho signalu
  real CNTDrop  ;upraveny utlum podle casove rampy
P     61
Ekviterm2_L0:
 LINK __SizeOf(Ekviterm2__temp__)
; Initialize - dynamic variables
; End initialize - dynamic variables
#srcline 53 ;  IF In <= Cfg.TempA THEN
 LDX  In
#debug real In
 LDX  Cfg~TempA
#debug real Cfg.TempA
 GTF
 NEG
 JMC  Ekviterm2_L1
#srcline 54 ;    Out := Cfg.TempEkvA;                              //ekvitermni teplota
 LDX  Cfg~TempEkvA
#debug real Cfg.TempEkvA
 WRX  Out
#debug_left real Out
#srcline 55 ;  END_IF;
Ekviterm2_L1:
#srcline 56 ;  IF (Cfg.TempA < In) AND (In <= Cfg.TempB) THEN
 LDX  Cfg~TempA
#debug real Cfg.TempA
 LDX  In
#debug real In
 LTF
 LDX  In
#debug real In
 LDX  Cfg~TempB
#debug real Cfg.TempB
 GTF
 NEG
 AND
 JMC  Ekviterm2_L3
#srcline 57 ;    gain   := (Cfg.TempEkvA - Cfg.TempEkvB) / (Cfg.TempA - Cfg.TempB);
 LDX  Cfg~TempEkvA
#debug real Cfg.TempEkvA
 LDX  Cfg~TempEkvB
#debug real Cfg.TempEkvB
 SUF
 LDX  Cfg~TempA
#debug real Cfg.TempA
 LDX  Cfg~TempB
#debug real Cfg.TempB
 SUF
 DIF
 WRY  gain
#debug_left real gain
#srcline 58 ;    offset := Cfg.TempEkvB - (Cfg.TempB * gain);
 LDX  Cfg~TempEkvB
#debug real Cfg.TempEkvB
 LDX  Cfg~TempB
#debug real Cfg.TempB
 LDY  gain
#debug real gain
 MUF
 SUF
 WRY  offset
#debug_left real offset
#srcline 59 ;    Out := In * gain + offset;                //ekvitermni teplota
 LDX  In
#debug real In
 LDY  gain
#debug real gain
 MUF
 LDY  offset
#debug real offset
 ADF
 WRX  Out
#debug_left real Out
#srcline 60 ;  END_IF;
Ekviterm2_L3:
#srcline 61 ;  IF (Cfg.TempB < In) AND (In <= Cfg.TempC) THEN
 LDX  Cfg~TempB
#debug real Cfg.TempB
 LDX  In
#debug real In
 LTF
 LDX  In
#debug real In
 LDX  Cfg~TempC
#debug real Cfg.TempC
 GTF
 NEG
 AND
 JMC  Ekviterm2_L5
#srcline 62 ;    gain   := (Cfg.TempEkvB - Cfg.TempEkvC) / (Cfg.TempB - Cfg.TempC);
 LDX  Cfg~TempEkvB
#debug real Cfg.TempEkvB
 LDX  Cfg~TempEkvC
#debug real Cfg.TempEkvC
 SUF
 LDX  Cfg~TempB
#debug real Cfg.TempB
 LDX  Cfg~TempC
#debug real Cfg.TempC
 SUF
 DIF
 WRY  gain
#debug_left real gain
#srcline 63 ;    offset := Cfg.TempEkvC - (Cfg.TempC * gain);
 LDX  Cfg~TempEkvC
#debug real Cfg.TempEkvC
 LDX  Cfg~TempC
#debug real Cfg.TempC
 LDY  gain
#debug real gain
 MUF
 SUF
 WRY  offset
#debug_left real offset
#srcline 64 ;    Out := In * gain + offset;                //ekvitermni teplota
 LDX  In
#debug real In
 LDY  gain
#debug real gain
 MUF
 LDY  offset
#debug real offset
 ADF
 WRX  Out
#debug_left real Out
#srcline 65 ;  END_IF;
Ekviterm2_L5:
#srcline 66 ;  IF (Cfg.TempC < In) AND (In <= Cfg.TempD) THEN
 LDX  Cfg~TempC
#debug real Cfg.TempC
 LDX  In
#debug real In
 LTF
 LDX  In
#debug real In
 LDX  Cfg~TempD
#debug real Cfg.TempD
 GTF
 NEG
 AND
 JMC  Ekviterm2_L7
#srcline 67 ;    gain   := (Cfg.TempEkvC - Cfg.TempEkvD) / (Cfg.TempC - Cfg.TempD);
 LDX  Cfg~TempEkvC
#debug real Cfg.TempEkvC
 LDX  Cfg~TempEkvD
#debug real Cfg.TempEkvD
 SUF
 LDX  Cfg~TempC
#debug real Cfg.TempC
 LDX  Cfg~TempD
#debug real Cfg.TempD
 SUF
 DIF
 WRY  gain
#debug_left real gain
#srcline 68 ;    offset := Cfg.TempEkvD - (Cfg.TempD * gain);
 LDX  Cfg~TempEkvD
#debug real Cfg.TempEkvD
 LDX  Cfg~TempD
#debug real Cfg.TempD
 LDY  gain
#debug real gain
 MUF
 SUF
 WRY  offset
#debug_left real offset
#srcline 69 ;    Out := In * gain + offset;                //ekvitermni teplota
 LDX  In
#debug real In
 LDY  gain
#debug real gain
 MUF
 LDY  offset
#debug real offset
 ADF
 WRX  Out
#debug_left real Out
#srcline 70 ;  END_IF;
Ekviterm2_L7:
#srcline 71 ;  IF Cfg.TempD <= In THEN
 LDX  Cfg~TempD
#debug real Cfg.TempD
 LDX  In
#debug real In
 GTF
 NEG
 JMC  Ekviterm2_L9
#srcline 72 ;    Out := Cfg.TempEkvD;                              //ekvitermni teplota
 LDX  Cfg~TempEkvD
#debug real Cfg.TempEkvD
 WRX  Out
#debug_left real Out
#srcline 73 ;  END_IF;
Ekviterm2_L9:
#srcline 74 ;  
#srcline 75 ;  //snizovani (zvysovani) ekvitermni teploty podle casove rampy pri zmene rezimu utlum <-> provoz
#srcline 76 ;  IF Cfg.Ramp > 546 THEN Cfg.Ramp := 546; END_IF;   //osetreni preteceni predvolby citace (max. 32767 > (546*60=32760))
 LDX  Cfg~Ramp
#debug int Cfg.Ramp
 EXTW 
 LD   int 546
 GTS
 JMC  Ekviterm2_L11
 LD   int 546
 WRX  Cfg~Ramp
#debug_left int Cfg.Ramp
Ekviterm2_L11:
#srcline 77 ;  CNTRamp.PV := Cfg.Ramp*60;                    //maximum citace (citac pak cita mezi 0 a maximem)
 LDX  Cfg~Ramp
#debug int Cfg.Ramp
 EXTW 
 LD   int 60
 MULS
 EXTW
 WRX  CNTRamp~PV
#debug_left int CNTRamp.PV
#srcline 78 ;  CNTRamp.CU := not Act and %s20.2;         //citat nahoru
 LDX  Act
#debug bool Act
 NEG
 LD   %S20.2
 AND
 WRX  CNTRamp~CU
#debug_left bool CNTRamp.CU
#srcline 79 ;  CNTRamp.CD :=     Act and %s20.2;         //citat dolu
 LDX  Act
#debug bool Act
 LD   %S20.2
 AND
 WRX  CNTRamp~CD
#debug_left bool CNTRamp.CD
#srcline 80 ;  CNTRamp();                                //citac utlumove rampy
 LEAX CNTRamp
 CAL  CTUD_L0
#srcline 82 ;  IF Cfg.Ramp<>0 THEN                                         //je nejaka casova rampa utlumu
 LDX  Cfg~Ramp
#debug int Cfg.Ramp
 EXTW 
 LD   int 0
 EQ
 NEG
 JMC  Ekviterm2_L13
#srcline 83 ;    CNTDrop := Cfg.Drop * INT_TO_REAL(CNTRamp.CV)/ INT_TO_REAL(Cfg.Ramp*60);  //upraveny utlum podle rampy
 LDX  Cfg~Drop
#debug real Cfg.Drop
 LDX  CNTRamp~CV
#debug int CNTRamp.CV
 EXTW 
 ILF
 MUF
 LDX  Cfg~Ramp
#debug int Cfg.Ramp
 EXTW 
 LD   int 60
 MULS
 EXTW
 ILF
 DIF
 WRY  CNTDrop
#debug_left real CNTDrop
#srcline 84 ;  ELSE                       //neni casova rampa utlumu
 JMP  Ekviterm2_L14
Ekviterm2_L13:
#srcline 85 ;    IF Act THEN
 LDX  Act
#debug bool Act
 JMC  Ekviterm2_L15
#srcline 86 ;      CNTDrop := 0.0;       //pro "provoz" uvazovat nulovy utlum
 LD   real 0.0
 WRY  CNTDrop
#debug_left real CNTDrop
#srcline 87 ;    ELSE
 JMP  Ekviterm2_L16
Ekviterm2_L15:
#srcline 88 ;      CNTDrop := Cfg.Drop;      //pro "utlum" uvazovat cely utlum
 LDX  Cfg~Drop
#debug real Cfg.Drop
 WRY  CNTDrop
#debug_left real CNTDrop
#srcline 89 ;    END_IF;
Ekviterm2_L16:
#srcline 90 ;  END_IF;
Ekviterm2_L14:
#srcline 91 ;  
#srcline 92 ;  IF CNTDrop > Cfg.Drop THEN CNTDrop := Cfg.Drop; END_IF; //maximalni utlum
 LDY  CNTDrop
#debug real CNTDrop
 LDX  Cfg~Drop
#debug real Cfg.Drop
 GTF
 JMC  Ekviterm2_L17
 LDX  Cfg~Drop
#debug real Cfg.Drop
 WRY  CNTDrop
#debug_left real CNTDrop
Ekviterm2_L17:
#srcline 93 ;  
#srcline 94 ;  Out := Out - CNTDrop;    //uprava vystupni teploty o utlum
 LDX  Out
#debug real Out
 LDY  CNTDrop
#debug real CNTDrop
 SUF
 WRX  Out
#debug_left real Out
#srcline 95 ;  
#srcline 96 ;  //kontrola rozsahu ekvitermni teploty
#srcline 97 ;  IF Out > Cfg.TempEkvA   THEN Out := Cfg.TempEkvA;   END_IF;  //maximum
 LDX  Out
#debug real Out
 LDX  Cfg~TempEkvA
#debug real Cfg.TempEkvA
 GTF
 JMC  Ekviterm2_L19
 LDX  Cfg~TempEkvA
#debug real Cfg.TempEkvA
 WRX  Out
#debug_left real Out
Ekviterm2_L19:
#srcline 98 ;  IF Out < Cfg.MinTempOut THEN Out := Cfg.MinTempOut; END_IF;  //minimum
 LDX  Out
#debug real Out
 LDX  Cfg~MinTempOut
#debug real Cfg.MinTempOut
 LTF
 JMC  Ekviterm2_L21
 LDX  Cfg~MinTempOut
#debug real Cfg.MinTempOut
 WRX  Out
#debug_left real Out
Ekviterm2_L21:
#srcline 100 ;END_FUNCTION_BLOCK
 ULNK
RET
E     61
#endpou 



 

#srcfile ''
#srcfile 'D:\TECOAPP\KNIHOVNY\REGOLIB\HISTORY1.ST'
#pou History1
#srcline 17 ;FUNCTION_BLOCK History1

#struct History1__temp__
  sint i,  ;pomocny index
  sint P0__st__,
  sint P1__st__,
  sint P2__st__
P     61
History1_L0:
 LINK __SizeOf(History1__temp__)
; Initialize - dynamic variables
; End initialize - dynamic variables
#srcline 43 ;  IF Res THEN
 LDX  Res
#debug bool Res
 JMC  History1_L1
#srcline 44 ;    FOR i := 0 TO 9 DO
 LD   sint 0
 WRY  i
 LD   sint 9
 WRY  P0__st__
History1_L3:
 LDY  i
 EXTB 
 LDY  P0__st__
 EXTB 
 GTS  
 JMD  History1_L4
 DBG  
#srcline 45 ;      Buf.Err[i].ETime := DT#1970-01-01-00:00:00;    //vymazat casovy udaj
 LDQ  dt 0
 LEAX Buf
 LDY  i
#debug sint i
 EXTB 
 RCHK 9   ; Range Check
 MUL  9   ; SizeOf(...)
 ADD     ; + offset 
 WRIQ 
#debug_left dt Buf.Err[i].ETime
#srcline 46 ;      Buf.Err[i].ECode := 0;                         //vymazat kod chyby
 LD   usint 0
 LEAX Buf
 LDY  i
#debug sint i
 EXTB 
 RCHK 9   ; Range Check
 MUL  9   ; SizeOf(...)
 ADD     ; + offset 
 ADD  8  ; + offset 
 WRI 
#debug_left usint Buf.Err[i].ECode
#srcline 47 ;    END_FOR;
 LDY  i
 LD   1
 ADD  
 EXTB 
 WRY  i
 JMP  History1_L3
History1_L4:
#srcline 48 ;  END_IF;
History1_L1:
#srcline 50 ;  //vyhodnoceni vzniku nove chyby
#srcline 51 ;  IF ((In1 <> LastErrCode) AND (In1 <> 0)) THEN  //vznikla nova porucha
 LDX  In1
#debug usint In1
 LDX  LastErrCode
#debug usint LastErrCode
 EQ
 NEG
 LDX  In1
#debug usint In1
 LD   usint 0
 EQ
 NEG
 AND
 JMC  History1_L5
#srcline 52 ;    FOR i := 9 TO 1 BY -1 DO                     //posun chyboveho bufferu
 LD   sint 9
 WRY  i
 LD   sint 1
 WRY  P1__st__
 LD   sint -1
 WRY  P2__st__
History1_L7:
 LDY  P2__st__
 EXTB 
 GTS  0
 JMC  History1_L9
 LDY  i
 EXTB 
 LDY  P1__st__
 EXTB 
 GTS  
 JMP  History1_L10
History1_L9:
 LDY  i
 EXTB 
 LDY  P1__st__
 EXTB 
 LTS  
History1_L10:
 JMD  History1_L8
 DBG  
#srcline 53 ;      Buf.Err[i] := Buf.Err[i-1];
 LEAX Buf
 LDY  i
#debug sint i
 EXTB 
 LD   sint 1
 SUB
 EXTB
 RCHK 9   ; Range Check
 MUL  9   ; SizeOf(...)
 ADD     ; + offset 
#debug pointer Buf.Err[i-1]
 SRC  %IB0
 LEAX Buf
 LDY  i
#debug sint i
 EXTB 
 RCHK 9   ; Range Check
 MUL  9   ; SizeOf(...)
 ADD     ; + offset 
#debug_left pointer Buf.Err[i]
 LD   9   ;SizeOf() 
 MOV  %IB0
#srcline 54 ;    END_FOR;
 LDY  i
 LDY  P2__st__
 EXTB 
 ADD  
 EXTB 
 WRY  i
 JMP  History1_L7
History1_L8:
#srcline 55 ;    Buf.Err[0].ETime := Rego_GetDateTime();     //cas vzniku poruchy zapsat na pozici 0
 LEA  __Instance__Rego_GetDateTime
 CAL  Rego_GetDateTime_L0
 LEAX Buf
 WRIQ 
#debug_left dt Buf.Err[0].ETime
#srcline 56 ;    Buf.Err[0].ECode := In1;               //kod poruchy zapsat na pozici 0
 LDX  In1
#debug usint In1
 LEAX Buf
 ADD  8  ; + offset 
 WRI 
#debug_left usint Buf.Err[0].ECode
#srcline 57 ;  END_IF;
History1_L5:
#srcline 58 ;  
#srcline 59 ;  //kopie cisla poruchy pro pristi cyklus
#srcline 60 ;  LastErrCode := In1;
 LDX  In1
#debug usint In1
 WRX  LastErrCode
#debug_left usint LastErrCode
#srcline 61 ;  
#srcline 62 ;END_FUNCTION_BLOCK
 ULNK
RET
E     61
#endpou 



 

#srcfile ''
#srcfile 'D:\TECOAPP\KNIHOVNY\REGOLIB\HISTORY5.ST'
#pou History5
#srcline 20 ;FUNCTION_BLOCK History5

#struct History5__temp__
  usint i,  ;pomocny index
  sint j,  ;pomocny index
  pointer ptrECode,  ;pointer na cislo poruchy
  pointer ptrLECode,  ;pointer na predchozi cislo poruchy
  usint P0__st__,
  usint P1__st__,
  sint P2__st__,
  sint P3__st__
P     61
History5_L0:
 LINK __SizeOf(History5__temp__)
; Initialize - dynamic variables
 LD   udint $FFFFFFFF    ; nil
 WRY  ptrECode
 LD   udint $FFFFFFFF    ; nil
 WRY  ptrLECode
; End initialize - dynamic variables
#srcline 59 ;  IF Res THEN
 LDX  Res
#debug bool Res
 JMC  History5_L1
#srcline 60 ;    FOR i := 0 TO 9 DO
 LD   usint 0
 WRY  i
 LD   usint 9
 WRY  P0__st__
History5_L3:
 LDY  i
 LDY  P0__st__
 GT   
 JMD  History5_L4
 DBG  
#srcline 61 ;      Buf.Err[i].ETime := DT#1970-01-01-00:00:00;    //vymazat casovy udaj
 LDQ  dt 0
 LEAX Buf
 LDY  i
#debug usint i
 RCHK 9   ; Range Check
 MUL  9   ; SizeOf(...)
 ADD     ; + offset 
 WRIQ 
#debug_left dt Buf.Err[i].ETime
#srcline 62 ;      Buf.Err[i].ECode := 0;                         //vymazat kod chyby
 LD   usint 0
 LEAX Buf
 LDY  i
#debug usint i
 RCHK 9   ; Range Check
 MUL  9   ; SizeOf(...)
 ADD     ; + offset 
 ADD  8  ; + offset 
 WRI 
#debug_left usint Buf.Err[i].ECode
#srcline 63 ;    END_FOR;
 LDY  i
 LD   1
 ADD  
 WRY  i
 JMP  History5_L3
History5_L4:
#srcline 64 ;  END_IF;
History5_L1:
#srcline 66 ;  //vyhodnoceni vzniku nove chyby
#srcline 67 ;  ptrECode := ADR(In1);
 LEAX In1
#debug pointer In1
 LEAY ptrECode
 WRIL 
#debug_left pointer ptrECode
#srcline 68 ;  ptrLECode := ADR(LastErrCode1);
 LEAX LastErrCode1
#debug pointer LastErrCode1
 LEAY ptrLECode
 WRIL 
#debug_left pointer ptrLECode
#srcline 69 ;  FOR i := 1 TO 5 DO                             //vsech 5 vstupu
 LD   usint 1
 WRY  i
 LD   usint 5
 WRY  P1__st__
History5_L5:
 LDY  i
 LDY  P1__st__
 GT   
 JMD  History5_L6
 DBG  
#srcline 70 ;    IF ((ptrECode^ <> ptrLECode^) AND (ptrECode^ <> 0)) THEN //vznikla nova porucha
 LEAY ptrECode
 LDIL    ; dereference 
 LDI  
#debug usint ptrECode^
 LEAY ptrLECode
 LDIL    ; dereference 
 LDI  
#debug usint ptrLECode^
 EQ
 NEG
 LEAY ptrECode
 LDIL    ; dereference 
 LDI  
#debug usint ptrECode^
 LD   usint 0
 EQ
 NEG
 AND
 JMC  History5_L7
#srcline 71 ;      FOR j := 9 TO 1 BY -1 DO                   //posun chyboveho bufferu
 LD   sint 9
 WRY  j
 LD   sint 1
 WRY  P2__st__
 LD   sint -1
 WRY  P3__st__
History5_L9:
 LDY  P3__st__
 EXTB 
 GTS  0
 JMC  History5_L11
 LDY  j
 EXTB 
 LDY  P2__st__
 EXTB 
 GTS  
 JMP  History5_L12
History5_L11:
 LDY  j
 EXTB 
 LDY  P2__st__
 EXTB 
 LTS  
History5_L12:
 JMD  History5_L10
 DBG  
#srcline 72 ;        Buf.Err[j] := Buf.Err[j-1];
 LEAX Buf
 LDY  j
#debug sint j
 EXTB 
 LD   sint 1
 SUB
 EXTB
 RCHK 9   ; Range Check
 MUL  9   ; SizeOf(...)
 ADD     ; + offset 
#debug pointer Buf.Err[j-1]
 SRC  %IB0
 LEAX Buf
 LDY  j
#debug sint j
 EXTB 
 RCHK 9   ; Range Check
 MUL  9   ; SizeOf(...)
 ADD     ; + offset 
#debug_left pointer Buf.Err[j]
 LD   9   ;SizeOf() 
 MOV  %IB0
#srcline 73 ;      END_FOR;
 LDY  j
 LDY  P3__st__
 EXTB 
 ADD  
 EXTB 
 WRY  j
 JMP  History5_L9
History5_L10:
#srcline 74 ;      Buf.Err[0].ETime := Rego_GetDateTime();     //cas vzniku poruchy zapsat na pozici 0
 LEA  __Instance__Rego_GetDateTime
 CAL  Rego_GetDateTime_L0
 LEAX Buf
 WRIQ 
#debug_left dt Buf.Err[0].ETime
#srcline 75 ;      Buf.Err[0].ECode := ptrECode^+(i-1)*8; //kod poruchy zapsat na pozici 0
 LEAY ptrECode
 LDIL    ; dereference 
 LDI  
#debug usint ptrECode^
 LDY  i
#debug usint i
 LD   usint 1
 SUB
 AND  $FF
 LD   usint 8
 MUL
 AND  $FF
 ADD
 AND  $FF
 LEAX Buf
 ADD  8  ; + offset 
 WRI 
#debug_left usint Buf.Err[0].ECode
#srcline 76 ;    END_IF;
History5_L7:
#srcline 77 ;    ptrLECode^ := ptrECode^;               //kopie cisla poruchy pro pristi cyklus
 LEAY ptrECode
 LDIL    ; dereference 
 LDI  
#debug usint ptrECode^
 LEAY ptrLECode
 LDIL    ; dereference 
 WRI 
#debug_left usint ptrLECode^
#srcline 78 ;    ptrECode   := ptrECode  + 1;           //prejit na dalsi vstup
 LEAY ptrECode
 LDIL 
#debug pointer ptrECode
 LD   udint 1
 ADD
 LEAY ptrECode
 WRIL 
#debug_left pointer ptrECode
#srcline 79 ;    ptrLECode  := ptrLECode + 1;           //
 LEAY ptrLECode
 LDIL 
#debug pointer ptrLECode
 LD   udint 1
 ADD
 LEAY ptrLECode
 WRIL 
#debug_left pointer ptrLECode
#srcline 80 ;  END_FOR;
 LDY  i
 LD   1
 ADD  
 WRY  i
 JMP  History5_L5
History5_L6:
#srcline 82 ;END_FUNCTION_BLOCK
 ULNK
RET
E     61

; Initialize - variables
P     61
History5__InstanceInit__:
 LINK 0
 ULNK
RET
E     61
; End initialize - variables
#endpou 



 

#srcfile ''
#srcfile 'D:\TECOAPP\KNIHOVNY\REGOLIB\HISTORY10.ST'
#pou History10
#srcline 19 ;FUNCTION_BLOCK History10

#struct History10__temp__
  usint i,  ;pomocny index
  sint j,  ;pomocny index
  pointer ptrECode,  ;pointer na cislo poruchy
  pointer ptrLECode,  ;pointer na predchozi cislo poruchy
  usint P0__st__,
  usint P1__st__,
  sint P2__st__,
  sint P3__st__
P     61
History10_L0:
 LINK __SizeOf(History10__temp__)
; Initialize - dynamic variables
 LD   udint $FFFFFFFF    ; nil
 WRY  ptrECode
 LD   udint $FFFFFFFF    ; nil
 WRY  ptrLECode
; End initialize - dynamic variables
#srcline 68 ;  IF Res THEN
 LDX  Res
#debug bool Res
 JMC  History10_L1
#srcline 69 ;    FOR i := 0 TO 9 DO
 LD   usint 0
 WRY  i
 LD   usint 9
 WRY  P0__st__
History10_L3:
 LDY  i
 LDY  P0__st__
 GT   
 JMD  History10_L4
 DBG  
#srcline 70 ;      Buf.Err[i].ETime := DT#1970-01-01-00:00:00;    //vymazat casovy udaj
 LDQ  dt 0
 LEAX Buf
 LDY  i
#debug usint i
 RCHK 9   ; Range Check
 MUL  9   ; SizeOf(...)
 ADD     ; + offset 
 WRIQ 
#debug_left dt Buf.Err[i].ETime
#srcline 71 ;      Buf.Err[i].ECode := 0;                         //vymazat kod chyby
 LD   usint 0
 LEAX Buf
 LDY  i
#debug usint i
 RCHK 9   ; Range Check
 MUL  9   ; SizeOf(...)
 ADD     ; + offset 
 ADD  8  ; + offset 
 WRI 
#debug_left usint Buf.Err[i].ECode
#srcline 72 ;    END_FOR;
 LDY  i
 LD   1
 ADD  
 WRY  i
 JMP  History10_L3
History10_L4:
#srcline 73 ;  END_IF;
History10_L1:
#srcline 75 ;  //vyhodnoceni vzniku nove chyby
#srcline 76 ;  ptrECode := ADR(In1);
 LEAX In1
#debug pointer In1
 LEAY ptrECode
 WRIL 
#debug_left pointer ptrECode
#srcline 77 ;  ptrLECode := ADR(LastErrCode1);
 LEAX LastErrCode1
#debug pointer LastErrCode1
 LEAY ptrLECode
 WRIL 
#debug_left pointer ptrLECode
#srcline 78 ;  FOR i := 1 TO 10 DO                               //vsech 10 vstupu
 LD   usint 1
 WRY  i
 LD   usint 10
 WRY  P1__st__
History10_L5:
 LDY  i
 LDY  P1__st__
 GT   
 JMD  History10_L6
 DBG  
#srcline 79 ;    IF ((ptrECode^ <> ptrLECode^) AND (ptrECode^ <> 0)) THEN //vznikla nova porucha
 LEAY ptrECode
 LDIL    ; dereference 
 LDI  
#debug usint ptrECode^
 LEAY ptrLECode
 LDIL    ; dereference 
 LDI  
#debug usint ptrLECode^
 EQ
 NEG
 LEAY ptrECode
 LDIL    ; dereference 
 LDI  
#debug usint ptrECode^
 LD   usint 0
 EQ
 NEG
 AND
 JMC  History10_L7
#srcline 80 ;      FOR j := 9 TO 1 BY -1 DO                   //posun chyboveho bufferu
 LD   sint 9
 WRY  j
 LD   sint 1
 WRY  P2__st__
 LD   sint -1
 WRY  P3__st__
History10_L9:
 LDY  P3__st__
 EXTB 
 GTS  0
 JMC  History10_L11
 LDY  j
 EXTB 
 LDY  P2__st__
 EXTB 
 GTS  
 JMP  History10_L12
History10_L11:
 LDY  j
 EXTB 
 LDY  P2__st__
 EXTB 
 LTS  
History10_L12:
 JMD  History10_L10
 DBG  
#srcline 81 ;        Buf.Err[j] := Buf.Err[j-1];
 LEAX Buf
 LDY  j
#debug sint j
 EXTB 
 LD   sint 1
 SUB
 EXTB
 RCHK 9   ; Range Check
 MUL  9   ; SizeOf(...)
 ADD     ; + offset 
#debug pointer Buf.Err[j-1]
 SRC  %IB0
 LEAX Buf
 LDY  j
#debug sint j
 EXTB 
 RCHK 9   ; Range Check
 MUL  9   ; SizeOf(...)
 ADD     ; + offset 
#debug_left pointer Buf.Err[j]
 LD   9   ;SizeOf() 
 MOV  %IB0
#srcline 82 ;      END_FOR;
 LDY  j
 LDY  P3__st__
 EXTB 
 ADD  
 EXTB 
 WRY  j
 JMP  History10_L9
History10_L10:
#srcline 83 ;      Buf.Err[0].ETime := Rego_GetDateTime();     //cas vzniku poruchy zapsat na pozici 0
 LEA  __Instance__Rego_GetDateTime
 CAL  Rego_GetDateTime_L0
 LEAX Buf
 WRIQ 
#debug_left dt Buf.Err[0].ETime
#srcline 84 ;      Buf.Err[0].ECode := ptrECode^+(i-1)*8; //kod poruchy zapsat na pozici 0
 LEAY ptrECode
 LDIL    ; dereference 
 LDI  
#debug usint ptrECode^
 LDY  i
#debug usint i
 LD   usint 1
 SUB
 AND  $FF
 LD   usint 8
 MUL
 AND  $FF
 ADD
 AND  $FF
 LEAX Buf
 ADD  8  ; + offset 
 WRI 
#debug_left usint Buf.Err[0].ECode
#srcline 85 ;    END_IF;
History10_L7:
#srcline 86 ;    ptrLECode^ := ptrECode^;               //kopie cisla poruchy pro pristi cyklus
 LEAY ptrECode
 LDIL    ; dereference 
 LDI  
#debug usint ptrECode^
 LEAY ptrLECode
 LDIL    ; dereference 
 WRI 
#debug_left usint ptrLECode^
#srcline 87 ;    ptrECode   := ptrECode  + 1;           //prejit na dalsi vstup
 LEAY ptrECode
 LDIL 
#debug pointer ptrECode
 LD   udint 1
 ADD
 LEAY ptrECode
 WRIL 
#debug_left pointer ptrECode
#srcline 88 ;    ptrLECode  := ptrLECode + 1;           //
 LEAY ptrLECode
 LDIL 
#debug pointer ptrLECode
 LD   udint 1
 ADD
 LEAY ptrLECode
 WRIL 
#debug_left pointer ptrLECode
#srcline 89 ;  END_FOR;
 LDY  i
 LD   1
 ADD  
 WRY  i
 JMP  History10_L5
History10_L6:
#srcline 91 ;END_FUNCTION_BLOCK
 ULNK
RET
E     61

; Initialize - variables
P     61
History10__InstanceInit__:
 LINK 0
 ULNK
RET
E     61
; End initialize - variables
#endpou 



 

#srcfile ''
#srcfile 'D:\TECOAPP\KNIHOVNY\REGOLIB\PID1.ST'
#pou PID1
#srcline 91 ;FUNCTION_BLOCK PID1
#table byte __Init___PID1_CFI = 
      0,  0,232,  3,  0,  0,  0,  0, 16, 39,232,  3, 52,  3,244,  1,232,  3,228,  2, 26,
      0, 10,  0, 16, 39, 16, 39;

#struct PID1__temp__
  usint i,
  usint P0__st__
P     61
PID1_L0:
 LINK __SizeOf(PID1__temp__)
; Initialize - dynamic variables
; End initialize - dynamic variables
#srcline 154 ;  strPID.Input1  := real_to_int(MSR);           //merena
 LDX  MSR
#debug real MSR
 RND
 IFW
 EXTW
 WRX  strPID~Input1
#debug_left int strPID.Input1
#srcline 155 ;  strPID.gW      := real_to_int(RQR);           //zadana
 LDX  RQR
#debug real RQR
 RND
 IFW
 EXTW
 WRX  strPID~gW
#debug_left int strPID.gW
#srcline 156 ;  
#srcline 157 ;  strPID.MinY    := CFI.MinY;
 LDX  CFI~MinY
#debug int CFI.MinY
 EXTW 
 WRX  strPID~MinY
#debug_left int strPID.MinY
#srcline 158 ;  strPID.MaxY    := CFI.MaxY;
 LDX  CFI~MaxY
#debug int CFI.MaxY
 EXTW 
 WRX  strPID~MaxY
#debug_left int strPID.MaxY
#srcline 159 ;  strPID.tiW     := CFI.tiW;
 LDX  CFI~tiW
#debug uint CFI.tiW
 WRX  strPID~tiW
#debug_left uint strPID.tiW
#srcline 160 ;  strPID.MinU    := CFI.MinU;
 LDX  CFI~MinU
#debug int CFI.MinU
 EXTW 
 WRX  strPID~MinU
#debug_left int strPID.MinU
#srcline 161 ;  strPID.MaxU    := CFI.MaxU;
 LDX  CFI~MaxU
#debug int CFI.MaxU
 EXTW 
 WRX  strPID~MaxU
#debug_left int strPID.MaxU
#srcline 162 ;  strPID.dMaxU   := CFI.dMaxU;
 LDX  CFI~dMaxU
#debug uint CFI.dMaxU
 WRX  strPID~dMaxU
#debug_left uint strPID.dMaxU
#srcline 163 ;  strPID.OutCycle:= CFI.OutCycle;
 LDX  CFI~OutCycle
#debug uint CFI.OutCycle
 WRX  strPID~OutCycle
#debug_left uint strPID.OutCycle
#srcline 164 ;  strPID.PBnd    := CFI.PBnd;
 LDX  CFI~PBnd
#debug uint CFI.PBnd
 WRX  strPID~PBnd
#debug_left uint strPID.PBnd
#srcline 165 ;  strPID.RelCool := CFI.RelCool;
 LDX  CFI~RelCool
#debug uint CFI.RelCool
 WRX  strPID~RelCool
#debug_left uint strPID.RelCool
#srcline 166 ;  strPID.Ti      := CFI.Ti;
 LDX  CFI~Ti
#debug uint CFI.Ti
 WRX  strPID~Ti
#debug_left uint strPID.Ti
#srcline 167 ;  strPID.Td      := CFI.Td;
 LDX  CFI~Td
#debug uint CFI.Td
 WRX  strPID~Td
#debug_left uint strPID.Td
#srcline 168 ;  strPID.EGap    := CFI.EGap;
 LDX  CFI~EGap
#debug uint CFI.EGap
 WRX  strPID~EGap
#debug_left uint strPID.EGap
#srcline 169 ;  strPID.DGap    := CFI.DGap;
 LDX  CFI~DGap
#debug uint CFI.DGap
 WRX  strPID~DGap
#debug_left uint strPID.DGap
#srcline 170 ;  strPID.IGap    := CFI.IGap;
 LDX  CFI~IGap
#debug uint CFI.IGap
 WRX  strPID~IGap
#debug_left uint strPID.IGap
#srcline 172 ;  //kopirovani vstupu/vystupu do vnitrni struktury PID instrukce
#srcline 173 ;  strPID.Control   := CFIO.Control;
 LDX  CFIO
#debug pointer CFIO.Control
 SRC  %IB0
 LEAX strPID~Control
#debug_left pointer strPID.Control
 LD   2   ;SizeOf() 
 MOV  %IB0
#srcline 175 ;  IF %S2.3 OR %S2.4 THEN        //prvy pruchod cyklem po restartu?
 LD   %S2.3
 LD   %S2.4
 OR  
 JMC  PID1_L1
#srcline 176 ;    strPID.Control := cControl; //zrestartovat regulator
 LEA  __Const__PID1_cControl
#debug pointer cControl
 SRC  %IB0
 LEAX strPID~Control
#debug_left pointer strPID.Control
 LD   2   ;SizeOf() 
 MOV  %IB0
#srcline 177 ;  END_IF;
PID1_L1:
#srcline 179 ;  IF Act THEN
 LDX  Act
#debug bool Act
 JMC  PID1_L3
#srcline 180 ;    IF strPID.Control.RC THEN  //prechod z resetu do provozu?
 LDX  strPID~Control~RC
#debug bool strPID.Control.RC
 JMC  PID1_L5
#srcline 181 ;      FOR i := 0 TO 22 DO
 LD   usint 0
 WRY  i
 LD   usint 22
 WRY  P0__st__
PID1_L7:
 LDY  i
 LDY  P0__st__
 GT   
 JMD  PID1_L8
 DBG  
#srcline 182 ;        strPID.AuxD[i] := 0;   //vynulovat pomocnou zonu
 LD   usint 0
 LEAX strPID
 ADD  49  ; + offset 
 LDY  i
#debug usint i
 RCHK 22   ; Range Check
 ADD     ; + offset 
 WRI 
#debug_left usint strPID.AuxD[i]
#srcline 183 ;      END_FOR;
 LDY  i
 LD   1
 ADD  
 WRY  i
 JMP  PID1_L7
PID1_L8:
#srcline 184 ;    END_IF;
PID1_L5:
#srcline 185 ;    {asm}
#srcline 186
    #def __R0_PID1__  %R0;     //definice pocatku zapisniku v R0
#srcline 187
    
#srcline 188
    ld  0;
#srcline 189
    ld  0;
#srcline 190
    leax strPID;
#srcline 191
    lea  __R0_PID1__;
#srcline 192
    sub;                       //index pocatku datove zony regulatoru
#srcline 193
    pid;
#srcline 194 ;    {end_asm}
#srcline 195 ;    MORE := strPID.Status.UH; //vystup kladneho akcniho zasahu
 LDX  strPID~Status~UH
#debug bool strPID.Status.UH
 WRX  MORE
#debug_left bool MORE
#srcline 196 ;    LESS := strPID.Status.UC; //vystup zaporneho akcniho zasahu
 LDX  strPID~Status~UC
#debug bool strPID.Status.UC
 WRX  LESS
#debug_left bool LESS
#srcline 197 ;  ELSE
 JMP  PID1_L4
PID1_L3:
#srcline 198 ;    MORE := false;
 LD   bool 0       ; false
 WRX  MORE
#debug_left bool MORE
#srcline 199 ;    LESS := true;
 LD   bool -1       ; true
 WRX  LESS
#debug_left bool LESS
#srcline 200 ;    strPID.Control := cControl; //resetovat regulator
 LEA  __Const__PID1_cControl
#debug pointer cControl
 SRC  %IB0
 LEAX strPID~Control
#debug_left pointer strPID.Control
 LD   2   ;SizeOf() 
 MOV  %IB0
#srcline 201 ;    strPID.LastOut := 0;        //vynulovat minulý akèní zásah (jako po resetu)
 LD   int 0
 WRX  strPID~LastOut
#debug_left int strPID.LastOut
#srcline 202 ;  END_IF;
PID1_L4:
#srcline 203 ;  
#srcline 204 ;  //kopirovani vstupu/vystupu z vnitrni struktury PID instrukce
#srcline 205 ;  CFIO.Control := StrPID.Control;
 LEAX StrPID~Control
#debug pointer StrPID.Control
 SRC  %IB0
 LDX  CFIO
#debug_left pointer CFIO.Control
 LD   2   ;SizeOf() 
 MOV  %IB0
#srcline 207 ;END_FUNCTION_BLOCK
 ULNK
RET
E     61

; Initialize - variables
P     61
PID1__InstanceInit__:
 LINK 0
 LD   0
 SRC  byte __Init___PID1_CFI
 LEAX byte CFI
 LD   28
 MOV  %X0
 ULNK
RET
E     61
; End initialize - variables
#endpou 



 

#srcfile ''
#srcfile 'D:\TECOAPP\KNIHOVNY\REGOLIB\PID11.ST'
#pou PID11
#srcline 83 ;FUNCTION_BLOCK PID11
#table byte __Init___PID11_CFI = 
      0,  0,232,  3,  0,  0, 16, 39,232,  3,232,  3,232,  3,232,  3,  0,  0, 10,  0;

#struct PID11__temp__
  usint i,
  usint P0__st__
P     61
PID11_L0:
 LINK __SizeOf(PID11__temp__)
; Initialize - dynamic variables
; End initialize - dynamic variables
#srcline 146 ;  strPID.Input1  := real_to_int(MSR);           //merena
 LDX  MSR
#debug real MSR
 RND
 IFW
 EXTW
 WRX  strPID~Input1
#debug_left int strPID.Input1
#srcline 147 ;  strPID.gW      := real_to_int(RQR);           //zadana
 LDX  RQR
#debug real RQR
 RND
 IFW
 EXTW
 WRX  strPID~gW
#debug_left int strPID.gW
#srcline 148 ;                                       //nastavitelne parametry regulace
#srcline 149 ;  strPID.MinY    := CFI.MinY;
 LDX  CFI~MinY
#debug int CFI.MinY
 EXTW 
 WRX  strPID~MinY
#debug_left int strPID.MinY
#srcline 150 ;  strPID.MaxY    := CFI.MaxY;
 LDX  CFI~MaxY
#debug int CFI.MaxY
 EXTW 
 WRX  strPID~MaxY
#debug_left int strPID.MaxY
#srcline 151 ;  strPID.MinU    := CFI.MinU;
 LDX  CFI~MinU
#debug int CFI.MinU
 EXTW 
 WRX  strPID~MinU
#debug_left int strPID.MinU
#srcline 152 ;  strPID.MaxU    := CFI.MaxU;
 LDX  CFI~MaxU
#debug int CFI.MaxU
 EXTW 
 WRX  strPID~MaxU
#debug_left int strPID.MaxU
#srcline 153 ;  strPID.dMaxU   := CFI.dMaxU;
 LDX  CFI~dMaxU
#debug uint CFI.dMaxU
 WRX  strPID~dMaxU
#debug_left uint strPID.dMaxU
#srcline 154 ;  strPID.OutCycle:= CFI.OutCycle;
 LDX  CFI~OutCycle
#debug uint CFI.OutCycle
 WRX  strPID~OutCycle
#debug_left uint strPID.OutCycle
#srcline 155 ;  strPID.PBnd    := CFI.PBnd;
 LDX  CFI~PBnd
#debug uint CFI.PBnd
 WRX  strPID~PBnd
#debug_left uint strPID.PBnd
#srcline 156 ;  strPID.Ti      := CFI.Ti;
 LDX  CFI~Ti
#debug uint CFI.Ti
 WRX  strPID~Ti
#debug_left uint strPID.Ti
#srcline 157 ;  strPID.Td      := CFI.Td;
 LDX  CFI~Td
#debug uint CFI.Td
 WRX  strPID~Td
#debug_left uint strPID.Td
#srcline 158 ;  strPID.EGap    := CFI.EGap;
 LDX  CFI~EGap
#debug uint CFI.EGap
 WRX  strPID~EGap
#debug_left uint strPID.EGap
#srcline 159 ;                                       //pevne parametry regulace
#srcline 160 ;  strPID.TiW     := 0;
 LD   uint 0
 WRX  strPID~TiW
#debug_left uint strPID.TiW
#srcline 161 ;  strPID.RelCool := 1000;
 LD   uint 1000
 WRX  strPID~RelCool
#debug_left uint strPID.RelCool
#srcline 162 ;  strPID.DGap    := 10000;
 LD   uint 10000
 WRX  strPID~DGap
#debug_left uint strPID.DGap
#srcline 163 ;  strPID.IGap    := 10000;
 LD   uint 10000
 WRX  strPID~IGap
#debug_left uint strPID.IGap
#srcline 164 ;  
#srcline 165 ;  IF %S2.3 OR %S2.4 THEN        //prvy pruchod cyklem po restartu?
 LD   %S2.3
 LD   %S2.4
 OR  
 JMC  PID11_L1
#srcline 166 ;    strPID.Control := cControl; //zrestartovat regulator
 LEA  __Const__PID11_cControl
#debug pointer cControl
 SRC  %IB0
 LEAX strPID~Control
#debug_left pointer strPID.Control
 LD   2   ;SizeOf() 
 MOV  %IB0
#srcline 167 ;  END_IF;
PID11_L1:
#srcline 169 ;  IF Act THEN
 LDX  Act
#debug bool Act
 JMC  PID11_L3
#srcline 170 ;    IF strPID.Control.RC THEN  //prechod z resetu do provozu?
 LDX  strPID~Control~RC
#debug bool strPID.Control.RC
 JMC  PID11_L5
#srcline 171 ;      FOR i := 0 TO 22 DO
 LD   usint 0
 WRY  i
 LD   usint 22
 WRY  P0__st__
PID11_L7:
 LDY  i
 LDY  P0__st__
 GT   
 JMD  PID11_L8
 DBG  
#srcline 172 ;        strPID.AuxD[i] := 0;   //vynulovat pomocnou zonu
 LD   usint 0
 LEAX strPID
 ADD  49  ; + offset 
 LDY  i
#debug usint i
 RCHK 22   ; Range Check
 ADD     ; + offset 
 WRI 
#debug_left usint strPID.AuxD[i]
#srcline 173 ;      END_FOR;
 LDY  i
 LD   1
 ADD  
 WRY  i
 JMP  PID11_L7
PID11_L8:
#srcline 174 ;    END_IF;
PID11_L5:
#srcline 175 ;    
#srcline 176 ;    strPID.Control.AM := 1; //vynuceni automatickeho rezimu Byd-2012-10-19
 LD   bool -1      ; true
 WRX  strPID~Control~AM
#debug_left bool strPID.Control.AM
#srcline 177 ;    
#srcline 178 ;    {asm}
#srcline 179
    #def __R0_PID11__  %R0;    //definice pocatku zapisniku v R0
#srcline 181
    ld  0;
#srcline 182
    ld  0;
#srcline 183
    leax strPID;
#srcline 184
    lea  __R0_PID11__;
#srcline 185
    sub;                       //index pocatku datove zony regulatoru
#srcline 186
    pid;
#srcline 187 ;    {end_asm}
#srcline 189 ;    MORE := strPID.Status.UH; //vystup kladneho akcniho zasahu
 LDX  strPID~Status~UH
#debug bool strPID.Status.UH
 WRX  MORE
#debug_left bool MORE
#srcline 190 ;    LESS := strPID.Status.UC; //vystup zaporneho akcniho zasahu
 LDX  strPID~Status~UC
#debug bool strPID.Status.UC
 WRX  LESS
#debug_left bool LESS
#srcline 191 ;  ELSE
 JMP  PID11_L4
PID11_L3:
#srcline 192 ;    MORE := false;
 LD   bool 0       ; false
 WRX  MORE
#debug_left bool MORE
#srcline 193 ;    LESS := true;
 LD   bool -1       ; true
 WRX  LESS
#debug_left bool LESS
#srcline 194 ;    strPID.Control := CControl; //resetovat regulator
 LEA  __Const__PID11_CControl
#debug pointer CControl
 SRC  %IB0
 LEAX strPID~Control
#debug_left pointer strPID.Control
 LD   2   ;SizeOf() 
 MOV  %IB0
#srcline 195 ;    strPID.LastOut := 0;        //vynulovat minulý akèní zásah (jako po resetu)
 LD   int 0
 WRX  strPID~LastOut
#debug_left int strPID.LastOut
#srcline 196 ;  END_IF;
PID11_L4:
#srcline 198 ;END_FUNCTION_BLOCK
 ULNK
RET
E     61

; Initialize - variables
P     61
PID11__InstanceInit__:
 LINK 0
 LD   0
 SRC  byte __Init___PID11_CFI
 LEAX byte CFI
 LD   20
 MOV  %X0
 ULNK
RET
E     61
; End initialize - variables
#endpou 



 

#srcfile ''
#srcfile 'D:\TECOAPP\KNIHOVNY\REGOLIB\PID2.ST'
#pou PID2
#srcline 91 ;FUNCTION_BLOCK PID2
#table byte __Init___PID2_CFI = 
      0,  0,232,  3,  0,  0,  0,  0, 16, 39,232,  3, 52,  3,244,  1,232,  3,228,  2, 26,
      0, 10,  0, 16, 39, 16, 39;

#struct PID2__temp__
  usint i,
  usint P0__st__
P     61
PID2_L0:
 LINK __SizeOf(PID2__temp__)
; Initialize - dynamic variables
; End initialize - dynamic variables
#srcline 150 ;  strPID.Input1  := real_to_int(MSR);           //merena
 LDX  MSR
#debug real MSR
 RND
 IFW
 EXTW
 WRX  strPID~Input1
#debug_left int strPID.Input1
#srcline 151 ;  strPID.gW      := real_to_int(RQR);           //zadana
 LDX  RQR
#debug real RQR
 RND
 IFW
 EXTW
 WRX  strPID~gW
#debug_left int strPID.gW
#srcline 153 ;  strPID.MinY    := CFI.MinY;
 LDX  CFI~MinY
#debug int CFI.MinY
 EXTW 
 WRX  strPID~MinY
#debug_left int strPID.MinY
#srcline 154 ;  strPID.MaxY    := CFI.MaxY;
 LDX  CFI~MaxY
#debug int CFI.MaxY
 EXTW 
 WRX  strPID~MaxY
#debug_left int strPID.MaxY
#srcline 155 ;  strPID.tiW     := CFI.tiW;
 LDX  CFI~tiW
#debug uint CFI.tiW
 WRX  strPID~tiW
#debug_left uint strPID.tiW
#srcline 156 ;  strPID.MinU    := CFI.MinU;
 LDX  CFI~MinU
#debug int CFI.MinU
 EXTW 
 WRX  strPID~MinU
#debug_left int strPID.MinU
#srcline 157 ;  strPID.MaxU    := CFI.MaxU;
 LDX  CFI~MaxU
#debug int CFI.MaxU
 EXTW 
 WRX  strPID~MaxU
#debug_left int strPID.MaxU
#srcline 158 ;  strPID.dMaxU   := CFI.dMaxU;
 LDX  CFI~dMaxU
#debug uint CFI.dMaxU
 WRX  strPID~dMaxU
#debug_left uint strPID.dMaxU
#srcline 159 ;  strPID.OutCycle:= CFI.OutCycle;
 LDX  CFI~OutCycle
#debug uint CFI.OutCycle
 WRX  strPID~OutCycle
#debug_left uint strPID.OutCycle
#srcline 160 ;  strPID.PBnd    := CFI.PBnd;
 LDX  CFI~PBnd
#debug uint CFI.PBnd
 WRX  strPID~PBnd
#debug_left uint strPID.PBnd
#srcline 161 ;  strPID.RelCool := CFI.RelCool;
 LDX  CFI~RelCool
#debug uint CFI.RelCool
 WRX  strPID~RelCool
#debug_left uint strPID.RelCool
#srcline 162 ;  strPID.Ti      := CFI.Ti;
 LDX  CFI~Ti
#debug uint CFI.Ti
 WRX  strPID~Ti
#debug_left uint strPID.Ti
#srcline 163 ;  strPID.Td      := CFI.Td;
 LDX  CFI~Td
#debug uint CFI.Td
 WRX  strPID~Td
#debug_left uint strPID.Td
#srcline 164 ;  strPID.EGap    := CFI.EGap;
 LDX  CFI~EGap
#debug uint CFI.EGap
 WRX  strPID~EGap
#debug_left uint strPID.EGap
#srcline 165 ;  strPID.DGap    := CFI.DGap;
 LDX  CFI~DGap
#debug uint CFI.DGap
 WRX  strPID~DGap
#debug_left uint strPID.DGap
#srcline 166 ;  strPID.IGap    := CFI.IGap;
 LDX  CFI~IGap
#debug uint CFI.IGap
 WRX  strPID~IGap
#debug_left uint strPID.IGap
#srcline 168 ;  //kopirovani vstupu/vystupu do vnitrni struktury PID instrukce
#srcline 169 ;  strPID.Control := CFIO.Control;
 LDX  CFIO
#debug pointer CFIO.Control
 SRC  %IB0
 LEAX strPID~Control
#debug_left pointer strPID.Control
 LD   2   ;SizeOf() 
 MOV  %IB0
#srcline 171 ;  IF %S2.3 OR %S2.4 THEN        //prvy pruchod cyklem po restartu?
 LD   %S2.3
 LD   %S2.4
 OR  
 JMC  PID2_L1
#srcline 172 ;    strPID.Control := cControl; //zrestartovat regulator
 LEA  __Const__PID2_cControl
#debug pointer cControl
 SRC  %IB0
 LEAX strPID~Control
#debug_left pointer strPID.Control
 LD   2   ;SizeOf() 
 MOV  %IB0
#srcline 173 ;  END_IF;
PID2_L1:
#srcline 174 ;  
#srcline 175 ;  IF Act THEN
 LDX  Act
#debug bool Act
 JMC  PID2_L3
#srcline 176 ;    IF strPID.Control.RC THEN  //prechod z resetu do provozu?
 LDX  strPID~Control~RC
#debug bool strPID.Control.RC
 JMC  PID2_L5
#srcline 177 ;      FOR i := 0 TO 22 DO
 LD   usint 0
 WRY  i
 LD   usint 22
 WRY  P0__st__
PID2_L7:
 LDY  i
 LDY  P0__st__
 GT   
 JMD  PID2_L8
 DBG  
#srcline 178 ;        strPID.AuxD[i] := 0;   //vynulovat pomocnou zonu
 LD   usint 0
 LEAX strPID
 ADD  49  ; + offset 
 LDY  i
#debug usint i
 RCHK 22   ; Range Check
 ADD     ; + offset 
 WRI 
#debug_left usint strPID.AuxD[i]
#srcline 179 ;      END_FOR;
 LDY  i
 LD   1
 ADD  
 WRY  i
 JMP  PID2_L7
PID2_L8:
#srcline 180 ;    END_IF;
PID2_L5:
#srcline 181 ;    {asm}
#srcline 182
    #def __R0_PID2__  %R0;     //definice pocatku zapisniku v R0
#srcline 184
    ld  0;
#srcline 185
    ld  0;
#srcline 186
    leax strPID;
#srcline 187
    lea  __R0_PID2__;
#srcline 188
    sub;                       //index pocatku datove zony regulatoru
#srcline 189
    pid;
#srcline 190 ;    {end_asm}
#srcline 191 ;    OUT := int_to_real(strPID.Output);  //akcni zasah
 LDX  strPID~Output
#debug int strPID.Output
 EXTW 
 ILF
 WRX  OUT
#debug_left real OUT
#srcline 192 ;    OUT := OUT / 100.0;                 //0-10000 -> 0-100.00%
 LDX  OUT
#debug real OUT
 LD   real 100.0
 DIF
 WRX  OUT
#debug_left real OUT
#srcline 193 ;  ELSE
 JMP  PID2_L4
PID2_L3:
#srcline 194 ;    OUT := 0.0;
 LD   real 0.0
 WRX  OUT
#debug_left real OUT
#srcline 195 ;    strPID.Control := CControl; //resetovat regulator
 LEA  __Const__PID2_CControl
#debug pointer CControl
 SRC  %IB0
 LEAX strPID~Control
#debug_left pointer strPID.Control
 LD   2   ;SizeOf() 
 MOV  %IB0
#srcline 196 ;    strPID.LastOut := 0;        //vynulovat minulý akèní zásah (jako po resetu)
 LD   int 0
 WRX  strPID~LastOut
#debug_left int strPID.LastOut
#srcline 197 ;  END_IF;
PID2_L4:
#srcline 199 ;  //kopirovani vstupu/vystupu z vnitrni struktury PID instrukce
#srcline 200 ;  CFIO.Control := StrPID.Control;
 LEAX StrPID~Control
#debug pointer StrPID.Control
 SRC  %IB0
 LDX  CFIO
#debug_left pointer CFIO.Control
 LD   2   ;SizeOf() 
 MOV  %IB0
#srcline 202 ;END_FUNCTION_BLOCK
 ULNK
RET
E     61

; Initialize - variables
P     61
PID2__InstanceInit__:
 LINK 0
 LD   0
 SRC  byte __Init___PID2_CFI
 LEAX byte CFI
 LD   28
 MOV  %X0
 ULNK
RET
E     61
; End initialize - variables
#endpou 



 

#srcfile ''
#srcfile 'D:\TECOAPP\KNIHOVNY\REGOLIB\PID21.ST'
#pou PID21
#srcline 82 ;FUNCTION_BLOCK PID21
#table byte __Init___PID21_CFI = 
      0,  0,232,  3,  0,  0, 16, 39,232,  3,232,  3,232,  3,232,  3,  0,  0, 10,  0;

#struct PID21__temp__
  usint i,
  usint P0__st__
P     61
PID21_L0:
 LINK __SizeOf(PID21__temp__)
; Initialize - dynamic variables
; End initialize - dynamic variables
#srcline 142 ;  strPID.Input1  := real_to_int(MSR); //merena
 LDX  MSR
#debug real MSR
 RND
 IFW
 EXTW
 WRX  strPID~Input1
#debug_left int strPID.Input1
#srcline 143 ;  strPID.gW      := real_to_int(RQR); //zadana
 LDX  RQR
#debug real RQR
 RND
 IFW
 EXTW
 WRX  strPID~gW
#debug_left int strPID.gW
#srcline 144 ;                                       //nastavitelne parametry regulace
#srcline 145 ;  strPID.MinY    := CFI.MinY;
 LDX  CFI~MinY
#debug int CFI.MinY
 EXTW 
 WRX  strPID~MinY
#debug_left int strPID.MinY
#srcline 146 ;  strPID.MaxY    := CFI.MaxY;
 LDX  CFI~MaxY
#debug int CFI.MaxY
 EXTW 
 WRX  strPID~MaxY
#debug_left int strPID.MaxY
#srcline 147 ;  strPID.MinU    := CFI.MinU;
 LDX  CFI~MinU
#debug int CFI.MinU
 EXTW 
 WRX  strPID~MinU
#debug_left int strPID.MinU
#srcline 148 ;  strPID.MaxU    := CFI.MaxU;
 LDX  CFI~MaxU
#debug int CFI.MaxU
 EXTW 
 WRX  strPID~MaxU
#debug_left int strPID.MaxU
#srcline 149 ;  strPID.dMaxU   := CFI.dMaxU;
 LDX  CFI~dMaxU
#debug uint CFI.dMaxU
 WRX  strPID~dMaxU
#debug_left uint strPID.dMaxU
#srcline 150 ;  strPID.OutCycle:= CFI.OutCycle;
 LDX  CFI~OutCycle
#debug uint CFI.OutCycle
 WRX  strPID~OutCycle
#debug_left uint strPID.OutCycle
#srcline 151 ;  strPID.PBnd    := CFI.PBnd;
 LDX  CFI~PBnd
#debug uint CFI.PBnd
 WRX  strPID~PBnd
#debug_left uint strPID.PBnd
#srcline 152 ;  strPID.Ti      := CFI.Ti;
 LDX  CFI~Ti
#debug uint CFI.Ti
 WRX  strPID~Ti
#debug_left uint strPID.Ti
#srcline 153 ;  strPID.Td      := CFI.Td;
 LDX  CFI~Td
#debug uint CFI.Td
 WRX  strPID~Td
#debug_left uint strPID.Td
#srcline 154 ;  strPID.EGap    := CFI.EGap;
 LDX  CFI~EGap
#debug uint CFI.EGap
 WRX  strPID~EGap
#debug_left uint strPID.EGap
#srcline 155 ;                                       //pevne parametry regulace
#srcline 156 ;  strPID.TiW     := 0;
 LD   uint 0
 WRX  strPID~TiW
#debug_left uint strPID.TiW
#srcline 157 ;  strPID.RelCool := 1000;
 LD   uint 1000
 WRX  strPID~RelCool
#debug_left uint strPID.RelCool
#srcline 158 ;  strPID.DGap    := 10000;
 LD   uint 10000
 WRX  strPID~DGap
#debug_left uint strPID.DGap
#srcline 159 ;  strPID.IGap    := 10000;
 LD   uint 10000
 WRX  strPID~IGap
#debug_left uint strPID.IGap
#srcline 161 ;  IF %S2.3 OR %S2.4 THEN       //prvy pruchod cyklem po restartu?
 LD   %S2.3
 LD   %S2.4
 OR  
 JMC  PID21_L1
#srcline 162 ;    strPID.Control := cControl; //zrestartovat regulator
 LEA  __Const__PID21_cControl
#debug pointer cControl
 SRC  %IB0
 LEAX strPID~Control
#debug_left pointer strPID.Control
 LD   2   ;SizeOf() 
 MOV  %IB0
#srcline 163 ;  END_IF;
PID21_L1:
#srcline 165 ;  IF Act THEN
 LDX  Act
#debug bool Act
 JMC  PID21_L3
#srcline 166 ;    IF strPID.Control.RC THEN  //prechod z resetu do provozu?
 LDX  strPID~Control~RC
#debug bool strPID.Control.RC
 JMC  PID21_L5
#srcline 167 ;      FOR i := 0 TO 22 DO
 LD   usint 0
 WRY  i
 LD   usint 22
 WRY  P0__st__
PID21_L7:
 LDY  i
 LDY  P0__st__
 GT   
 JMD  PID21_L8
 DBG  
#srcline 168 ;        strPID.AuxD[i] := 0;   //vynulovat pomocnou zonu
 LD   usint 0
 LEAX strPID
 ADD  49  ; + offset 
 LDY  i
#debug usint i
 RCHK 22   ; Range Check
 ADD     ; + offset 
 WRI 
#debug_left usint strPID.AuxD[i]
#srcline 169 ;      END_FOR;
 LDY  i
 LD   1
 ADD  
 WRY  i
 JMP  PID21_L7
PID21_L8:
#srcline 170 ;    END_IF;
PID21_L5:
#srcline 171 ;    
#srcline 172 ;    strPID.Control.AM := 1; //vynuceni automatickeho rezimu Byd-2012-10-19
 LD   bool -1      ; true
 WRX  strPID~Control~AM
#debug_left bool strPID.Control.AM
#srcline 173 ;    
#srcline 174 ;    {asm}
#srcline 175
    #def __R0_PID21__  %R0;     //definice pocatku zapisniku v R0
#srcline 177
    ld  0;
#srcline 178
    ld  0;
#srcline 179
    leax strPID;
#srcline 180
    lea  __R0_PID21__;
#srcline 181
    sub;                       //index pocatku datove zony regulatoru
#srcline 182
    pid;
#srcline 183 ;    {end_asm}
#srcline 184 ;    OUT := int_to_real(strPID.Output);  //akcni zasah
 LDX  strPID~Output
#debug int strPID.Output
 EXTW 
 ILF
 WRX  OUT
#debug_left real OUT
#srcline 185 ;    OUT := OUT / 100.0;              //0-10000 -> 0-100.00%
 LDX  OUT
#debug real OUT
 LD   real 100.0
 DIF
 WRX  OUT
#debug_left real OUT
#srcline 186 ;  ELSE
 JMP  PID21_L4
PID21_L3:
#srcline 187 ;    OUT := 0.0;
 LD   real 0.0
 WRX  OUT
#debug_left real OUT
#srcline 188 ;    strPID.Control := CControl; //resetovat regulator
 LEA  __Const__PID21_CControl
#debug pointer CControl
 SRC  %IB0
 LEAX strPID~Control
#debug_left pointer strPID.Control
 LD   2   ;SizeOf() 
 MOV  %IB0
#srcline 189 ;    strPID.LastOut := 0;        //vynulovat minulý akèní zásah (jako po resetu)
 LD   int 0
 WRX  strPID~LastOut
#debug_left int strPID.LastOut
#srcline 190 ;  END_IF;
PID21_L4:
#srcline 192 ;END_FUNCTION_BLOCK
 ULNK
RET
E     61

; Initialize - variables
P     61
PID21__InstanceInit__:
 LINK 0
 LD   0
 SRC  byte __Init___PID21_CFI
 LEAX byte CFI
 LD   20
 MOV  %X0
 ULNK
RET
E     61
; End initialize - variables
#endpou 



 

#srcfile ''
#srcfile 'D:\TECOAPP\KNIHOVNY\REGOLIB\PID3.ST'
#pou PID3
#srcline 103 ;FUNCTION_BLOCK PID3
#table byte __Init___PID3_CFI = 
      0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 16, 39,232,  3, 52,  3,244,  1,232,  3,228,
      2, 26,  0, 10,  0, 16, 39, 16, 39;

#struct PID3__temp__
  usint i,
  int IN2pom,
  usint P0__st__
P     61
PID3_L0:
 LINK __SizeOf(PID3__temp__)
; Initialize - dynamic variables
; End initialize - dynamic variables
#srcline 162 ;  strPID.Input1  := real_to_int(MSR);           //merena
 LDX  MSR
#debug real MSR
 RND
 IFW
 EXTW
 WRX  strPID~Input1
#debug_left int strPID.Input1
#srcline 163 ;  strPID.gW      := real_to_int(RQR);           //zadana
 LDX  RQR
#debug real RQR
 RND
 IFW
 EXTW
 WRX  strPID~gW
#debug_left int strPID.gW
#srcline 165 ;  strPID.MinY     := CFI.MinY;     // Hodnota unifikovaného rozsahu odpovídající 0%
 LDX  CFI~MinY
#debug int CFI.MinY
 EXTW 
 WRX  strPID~MinY
#debug_left int strPID.MinY
#srcline 166 ;  strPID.MaxY     := CFI.MaxY;     // Hodnota unifikovaného rozsahu odpovídající 100%
 LDX  CFI~MaxY
#debug int CFI.MaxY
 EXTW 
 WRX  strPID~MaxY
#debug_left int strPID.MaxY
#srcline 167 ;  strPID.tiW      := CFI.tiW;      // Èasová konstanta filtru žádané hodnoty
 LDX  CFI~tiW
#debug uint CFI.tiW
 WRX  strPID~tiW
#debug_left uint strPID.tiW
#srcline 168 ;  strPID.DefOut   := CFI.DefOut;   // Pøeddefinovaný akèní zásah pøi poruše (uDef)
 LDX  CFI~DefOut
#debug int CFI.DefOut
 EXTW 
 WRX  strPID~DefOut
#debug_left int strPID.DefOut
#srcline 169 ;  strPID.MinU     := CFI.MinU;     // Minimální povolený akèní zásah
 LDX  CFI~MinU
#debug int CFI.MinU
 EXTW 
 WRX  strPID~MinU
#debug_left int strPID.MinU
#srcline 170 ;  strPID.MaxU     := CFI.MaxU;     // Maximální povolený akèní zásah
 LDX  CFI~MaxU
#debug int CFI.MaxU
 EXTW 
 WRX  strPID~MaxU
#debug_left int strPID.MaxU
#srcline 171 ;  strPID.dMaxU    := CFI.dMaxU;    // Maximální pøírustek akèní velièiny za jednu periodu
 LDX  CFI~dMaxU
#debug uint CFI.dMaxU
 WRX  strPID~dMaxU
#debug_left uint strPID.dMaxU
#srcline 172 ;  strPID.OutCycle := CFI.OutCycle; // Perioda vzorkovaní regulaèního algoritmu (T)
 LDX  CFI~OutCycle
#debug uint CFI.OutCycle
 WRX  strPID~OutCycle
#debug_left uint strPID.OutCycle
#srcline 173 ;  strPID.PBnd     := CFI.PBnd;     // Pásmo proporcionality (PBnd)
 LDX  CFI~PBnd
#debug uint CFI.PBnd
 WRX  strPID~PBnd
#debug_left uint strPID.PBnd
#srcline 174 ;  strPID.RelCool  := CFI.RelCool;  // Relativní pásmo proporcionality pro záporné hodnoty regulaèní odchylky (RelCool)
 LDX  CFI~RelCool
#debug uint CFI.RelCool
 WRX  strPID~RelCool
#debug_left uint strPID.RelCool
#srcline 175 ;  strPID.Ti       := CFI.Ti;       // Integraèní èasová konstanta (Ti)
 LDX  CFI~Ti
#debug uint CFI.Ti
 WRX  strPID~Ti
#debug_left uint strPID.Ti
#srcline 176 ;  strPID.Td       := CFI.Td;       // Derivaèní èasová konstanta (Td)
 LDX  CFI~Td
#debug uint CFI.Td
 WRX  strPID~Td
#debug_left uint strPID.Td
#srcline 177 ;  strPID.EGap     := CFI.EGap;     // Symetrické pásmo necitlivosti
 LDX  CFI~EGap
#debug uint CFI.EGap
 WRX  strPID~EGap
#debug_left uint strPID.EGap
#srcline 178 ;  strPID.DGap     := CFI.DGap;     // Symetrické pásmo pùsobení derivaèní složky
 LDX  CFI~DGap
#debug uint CFI.DGap
 WRX  strPID~DGap
#debug_left uint strPID.DGap
#srcline 179 ;  strPID.IGap     := CFI.IGap;     // Symetrické pásmo pùsobení integraèní složky
 LDX  CFI~IGap
#debug uint CFI.IGap
 WRX  strPID~IGap
#debug_left uint strPID.IGap
#srcline 180 ;  
#srcline 181 ;  //kopirovani vstupu/vystupu do vnitrni struktury PID instrukce
#srcline 182 ;  strPID.ConW    := CFIO.ConW;    // Aktuální žádaná hodnota
 LDX  CFIO
 LDIW 
#debug int CFIO.ConW
 EXTW 
 WRX  strPID~ConW
#debug_left int strPID.ConW
#srcline 183 ;  strPID.Output  := CFIO.Output;  // Akèní velièina
 LDX  CFIO
 ADD  2  ; + offset 
 LDIW 
#debug int CFIO.Output
 EXTW 
 WRX  strPID~Output
#debug_left int strPID.Output
#srcline 184 ;  strPID.Control := CFIO.Control; // Øídicí slovo
 LDX  CFIO
 ADD  4  ; + offset 
#debug pointer CFIO.Control
 SRC  %IB0
 LEAX strPID~Control
#debug_left pointer strPID.Control
 LD   2   ;SizeOf() 
 MOV  %IB0
#srcline 186 ;  IF %S2.4 THEN       //prvy pruchod cyklem po studenem restartu?
 LD   %S2.4
 JMC  PID3_L1
#srcline 187 ;    strPID.Control.RC := true; //zrestartovat regulator
 LD   bool -1       ; true
 WRX  strPID~Control~RC
#debug_left bool strPID.Control.RC
#srcline 188 ;  END_IF;
PID3_L1:
#srcline 189 ;  
#srcline 190 ;  IF Act THEN
 LDX  Act
#debug bool Act
 JMC  PID3_L3
#srcline 191 ;    IF strPID.Control.RC THEN  //prechod z resetu do provozu?
 LDX  strPID~Control~RC
#debug bool strPID.Control.RC
 JMC  PID3_L5
#srcline 192 ;      FOR i := 0 TO 22 DO
 LD   usint 0
 WRY  i
 LD   usint 22
 WRY  P0__st__
PID3_L7:
 LDY  i
 LDY  P0__st__
 GT   
 JMD  PID3_L8
 DBG  
#srcline 193 ;        strPID.AuxD[i] := 0;   //vynulovat pomocnou zonu
 LD   usint 0
 LEAX strPID
 ADD  49  ; + offset 
 LDY  i
#debug usint i
 RCHK 22   ; Range Check
 ADD     ; + offset 
 WRI 
#debug_left usint strPID.AuxD[i]
#srcline 194 ;      END_FOR;
 LDY  i
 LD   1
 ADD  
 WRY  i
 JMP  PID3_L7
PID3_L8:
#srcline 195 ;    END_IF;
PID3_L5:
#srcline 196 ;    IN2pom := real_to_int(IN2);  //konverze pro volani PID
 LDX  IN2
#debug real IN2
 RND
 IFW
 EXTW
 WRY  IN2pom
#debug_left int IN2pom
#srcline 197 ;    {asm}
#srcline 198
    #def __R0_PID3__  %R0;     //definice pocatku zapisniku v R0
#srcline 200
    ld  IN3;                   //poloha servoventilu
#srcline 201
    ld  IN2pom;                //pomerova regulace
#srcline 202
    leax strPID;
#srcline 203
    lea  __R0_PID3__;
#srcline 204
    sub;                       //index pocatku datove zony regulatoru
#srcline 205
    pid;
#srcline 206 ;    {end_asm}
#srcline 207 ;    MORE := strPID.Status.UH; //vystup kladneho prirustkoveho akcniho zasahu
 LDX  strPID~Status~UH
#debug bool strPID.Status.UH
 WRX  MORE
#debug_left bool MORE
#srcline 208 ;    LESS := strPID.Status.UC; //vystup zaporneho prirustkoveho akcniho zasahu
 LDX  strPID~Status~UC
#debug bool strPID.Status.UC
 WRX  LESS
#debug_left bool LESS
#srcline 209 ;    OUT := int_to_real(strPID.Output);  //primy unifikovany akcni zasah
 LDX  strPID~Output
#debug int strPID.Output
 EXTW 
 ILF
 WRX  OUT
#debug_left real OUT
#srcline 210 ;    OUT := OUT / 100.0; //0-10000 -> 0-100.00%
 LDX  OUT
#debug real OUT
 LD   real 100.0
 DIF
 WRX  OUT
#debug_left real OUT
#srcline 211 ;  ELSE
 JMP  PID3_L4
PID3_L3:
#srcline 212 ;    MORE := false;
 LD   bool 0       ; false
 WRX  MORE
#debug_left bool MORE
#srcline 213 ;    LESS := true;
 LD   bool -1       ; true
 WRX  LESS
#debug_left bool LESS
#srcline 214 ;    OUT := 0.0;
 LD   real 0.0
 WRX  OUT
#debug_left real OUT
#srcline 215 ;    strPID.Control.RC := true; //resetovat regulator
 LD   bool -1       ; true
 WRX  strPID~Control~RC
#debug_left bool strPID.Control.RC
#srcline 216 ;    strPID.LastOut := 0;        //vynulovat minulý akèní zásah (jako po resetu)
 LD   int 0
 WRX  strPID~LastOut
#debug_left int strPID.LastOut
#srcline 217 ;  END_IF;
PID3_L4:
#srcline 219 ;  //kopirovani vystupu z vnitrni struktury PID instrukce
#srcline 220 ;  CFO.Dev     := strPID.Dev;	  // Regulaèní odchylka
 LDX  strPID~Dev
#debug int strPID.Dev
 EXTW 
 WRX  CFO~Dev
#debug_left int CFO.Dev
#srcline 221 ;  CFO.LastOut := strPID.LastOut;   // Minulý akèní zásah
 LDX  strPID~LastOut
#debug int strPID.LastOut
 EXTW 
 WRX  CFO~LastOut
#debug_left int CFO.LastOut
#srcline 222 ;  CFO.CurOut  := strPID.CurOut;    // Akèní zásah
 LDX  strPID~CurOut
#debug int strPID.CurOut
 EXTW 
 WRX  CFO~CurOut
#debug_left int CFO.CurOut
#srcline 223 ;  CFO.ConOut  := strPID.ConOut;    // Akèní zásah v absolutní hodnotì modifikovaný dle øídícího slova
 LDX  strPID~ConOut
#debug int strPID.ConOut
 EXTW 
 WRX  CFO~ConOut
#debug_left int CFO.ConOut
#srcline 224 ;  CFO.Status  := strPID.Status; 	  // Stavové slovo
 LEAX strPID~Status
#debug pointer strPID.Status
 SRC  %IB0
 LEAX CFO~Status
#debug_left pointer CFO.Status
 LD   1   ;SizeOf() 
 MOV  %IB0
#srcline 226 ;  //kopirovani vstupu/vystupu z vnitrni struktury PID instrukce
#srcline 227 ;  CFIO.ConW    := strPID.ConW;    // Aktuální žádaná hodnota
 LDX  strPID~ConW
#debug int strPID.ConW
 EXTW 
 LDX  CFIO
 WRIW 
#debug_left int CFIO.ConW
#srcline 228 ;  CFIO.Output  := strPID.Output;  // Akèní velièina
 LDX  strPID~Output
#debug int strPID.Output
 EXTW 
 LDX  CFIO
 ADD  2  ; + offset 
 WRIW 
#debug_left int CFIO.Output
#srcline 229 ;  CFIO.Control := strPID.Control; // Øídicí slovo
 LEAX strPID~Control
#debug pointer strPID.Control
 SRC  %IB0
 LDX  CFIO
 ADD  4  ; + offset 
#debug_left pointer CFIO.Control
 LD   2   ;SizeOf() 
 MOV  %IB0
#srcline 230 ;  
#srcline 231 ;END_FUNCTION_BLOCK
 ULNK
RET
E     61

; Initialize - variables
P     61
PID3__InstanceInit__:
 LINK 0
 LD   0
 SRC  byte __Init___PID3_CFI
 LEAX byte CFI
 LD   30
 MOV  %X0
 ULNK
RET
E     61
; End initialize - variables
#endpou 



 

#srcfile ''
#srcfile 'D:\TECOAPP\KNIHOVNY\REGOLIB\SIGERR1.ST'
#pou SigErr1
#srcline 19 ;FUNCTION_BLOCK SigErr1
P     61
SigErr1_L0:
 LINK 0
#srcline 66 ;  BEGIN
#srcline 68 ;  // nulovani poruch
#srcline 69 ;  {ASM}
#srcline 70
  ldx   Res
#srcline 71
  ldx   byte In1         ;nulovat pouze neaktivni poruchy
#srcline 72
  anc                    ;cela osmice
#srcline 73
  resx  byte Err1
#srcline 74 ;  {END_ASM}
#srcline 75 ;  
#srcline 76 ;  // casovani a vyhodnoceni poruch
#srcline 77 ;  Timer[1](IN := In1, PT := Cfg.PresetTime1, Q => OutTim[1]);
 LDX  In1
#debug bool In1
 WRX  Timer[0]~IN
#debug_left bool Timer[0]~IN
 LDX  Cfg~PresetTime1
#debug time Cfg.PresetTime1
 WRX  Timer[0]~PT
#debug_left time Timer[0]~PT
 LEAX Timer
 CAL  TON_L0
; output assigment 
 LDX  Timer[0]~Q
#debug bool Timer[0]~Q
 WRX  OutTim[0]
#debug_left bool OutTim[1]
#srcline 78 ;  Timer[2](IN := In2, PT := Cfg.PresetTime2, Q => OutTim[2]);
 LDX  In2
#debug bool In2
 WRX  Timer[1]~IN
#debug_left bool Timer[1]~IN
 LDX  Cfg~PresetTime2
#debug time Cfg.PresetTime2
 WRX  Timer[1]~PT
#debug_left time Timer[1]~PT
 LEAX Timer
 ADD  15  ; + offset 
 CAL  TON_L0
; output assigment 
 LDX  Timer[1]~Q
#debug bool Timer[1]~Q
 WRX  OutTim[1]
#debug_left bool OutTim[2]
#srcline 79 ;  Timer[3](IN := In3, PT := Cfg.PresetTime3, Q => OutTim[3]);
 LDX  In3
#debug bool In3
 WRX  Timer[2]~IN
#debug_left bool Timer[2]~IN
 LDX  Cfg~PresetTime3
#debug time Cfg.PresetTime3
 WRX  Timer[2]~PT
#debug_left time Timer[2]~PT
 LEAX Timer
 ADD  30  ; + offset 
 CAL  TON_L0
; output assigment 
 LDX  Timer[2]~Q
#debug bool Timer[2]~Q
 WRX  OutTim[2]
#debug_left bool OutTim[3]
#srcline 80 ;  Timer[4](IN := In4, PT := Cfg.PresetTime4, Q => OutTim[4]);
 LDX  In4
#debug bool In4
 WRX  Timer[3]~IN
#debug_left bool Timer[3]~IN
 LDX  Cfg~PresetTime4
#debug time Cfg.PresetTime4
 WRX  Timer[3]~PT
#debug_left time Timer[3]~PT
 LEAX Timer
 ADD  45  ; + offset 
 CAL  TON_L0
; output assigment 
 LDX  Timer[3]~Q
#debug bool Timer[3]~Q
 WRX  OutTim[3]
#debug_left bool OutTim[4]
#srcline 81 ;  Timer[5](IN := In5, PT := Cfg.PresetTime5, Q => OutTim[5]);
 LDX  In5
#debug bool In5
 WRX  Timer[4]~IN
#debug_left bool Timer[4]~IN
 LDX  Cfg~PresetTime5
#debug time Cfg.PresetTime5
 WRX  Timer[4]~PT
#debug_left time Timer[4]~PT
 LEAX Timer
 ADD  60  ; + offset 
 CAL  TON_L0
; output assigment 
 LDX  Timer[4]~Q
#debug bool Timer[4]~Q
 WRX  OutTim[4]
#debug_left bool OutTim[5]
#srcline 82 ;  Timer[6](IN := In6, PT := Cfg.PresetTime6, Q => OutTim[6]);
 LDX  In6
#debug bool In6
 WRX  Timer[5]~IN
#debug_left bool Timer[5]~IN
 LDX  Cfg~PresetTime6
#debug time Cfg.PresetTime6
 WRX  Timer[5]~PT
#debug_left time Timer[5]~PT
 LEAX Timer
 ADD  75  ; + offset 
 CAL  TON_L0
; output assigment 
 LDX  Timer[5]~Q
#debug bool Timer[5]~Q
 WRX  OutTim[5]
#debug_left bool OutTim[6]
#srcline 83 ;  Timer[7](IN := In7, PT := Cfg.PresetTime7, Q => OutTim[7]);
 LDX  In7
#debug bool In7
 WRX  Timer[6]~IN
#debug_left bool Timer[6]~IN
 LDX  Cfg~PresetTime7
#debug time Cfg.PresetTime7
 WRX  Timer[6]~PT
#debug_left time Timer[6]~PT
 LEAX Timer
 ADD  90  ; + offset 
 CAL  TON_L0
; output assigment 
 LDX  Timer[6]~Q
#debug bool Timer[6]~Q
 WRX  OutTim[6]
#debug_left bool OutTim[7]
#srcline 84 ;  Timer[8](IN := In8, PT := Cfg.PresetTime8, Q => OutTim[8]);
 LDX  In8
#debug bool In8
 WRX  Timer[7]~IN
#debug_left bool Timer[7]~IN
 LDX  Cfg~PresetTime8
#debug time Cfg.PresetTime8
 WRX  Timer[7]~PT
#debug_left time Timer[7]~PT
 LEAX Timer
 ADD  105  ; + offset 
 CAL  TON_L0
; output assigment 
 LDX  Timer[7]~Q
#debug bool Timer[7]~Q
 WRX  OutTim[7]
#debug_left bool OutTim[8]
#srcline 85 ;  {ASM}
#srcline 86
  ldx   byte OutTim[1]  ;cela osmice
#srcline 87
  setx  byte Err1       ;po docasovani casovace vyhlasit poruchu
#srcline 88
  letx  byte LET[1]     ;nabezne hrany
#srcline 89
  setx  blikat          ;pri vzniku nove chyby zacit blikat signalkou
#srcline 90 ;  {END_ASM}
#srcline 91 ;  
#srcline 92 ;  // kvitace poruch
#srcline 93 ;  IF Ack THEN blikat := false; END_IF;  //prestat blikat signalkou
 LDX  Ack
#debug bool Ack
 JMC  SigErr1_L1
 LD   bool 0       ; false
 WRX  blikat
#debug_left bool blikat
SigErr1_L1:
#srcline 94 ;  
#srcline 95 ;  // rizeni signalky
#srcline 96 ;  {ASM}
#srcline 97
  ldx byte Err1       ;cela osmice
#srcline 98
  wrx Sum
#srcline 99
  wrx Sig
#srcline 100 ;  {END_ASM}
#srcline 101 ;  IF blikat THEN
 LDX  blikat
#debug bool blikat
 JMC  SigErr1_L3
#srcline 102 ;    Sig := %S13.2;   //blikani signalky v rastru 1s
 LD   %S13.2
 WRX  Sig
#debug_left bool Sig
#srcline 103 ;  END_IF;
SigErr1_L3:
#srcline 105 ;END_FUNCTION_BLOCK
 ULNK
RET
E     61
#endpou 



 

#srcfile ''
#srcfile 'D:\TECOAPP\KNIHOVNY\REGOLIB\SIGERR11.ST'
#pou SigErr11
#srcline 18 ;FUNCTION_BLOCK SigErr11
P     61
SigErr11_L0:
 LINK 0
#srcline 82 ;  BEGIN
#srcline 84 ;  // nulovani poruch
#srcline 85 ;  {ASM}
#srcline 86
  ldx    Res;
#srcline 87
  ldx    In1;
#srcline 88
  anc                   ;nulovat pouze neaktivni poruchy
#srcline 89
  resx   Err1;
#srcline 90
  ldx    ErrC;
#srcline 91
  eq     1;
#srcline 92
  and;
#srcline 93
  resx   ErrC;
#srcline 95
  ldx    Res;
#srcline 96
  ldx    In2;
#srcline 97
  anc
#srcline 98
  resx   Err2;
#srcline 99
  ldx    ErrC;
#srcline 100
  eq     2;
#srcline 101
  and;
#srcline 102
  resx   ErrC;
#srcline 104
  ldx    Res;
#srcline 105
  ldx    In3;
#srcline 106
  anc
#srcline 107
  resx   Err3;
#srcline 108
  ldx    ErrC;
#srcline 109
  eq     3;
#srcline 110
  and;
#srcline 111
  resx   ErrC;
#srcline 113
  ldx    Res;
#srcline 114
  ldx    In4;
#srcline 115
  anc
#srcline 116
  resx   Err4;
#srcline 117
  ldx    ErrC;
#srcline 118
  eq     4;
#srcline 119
  and;
#srcline 120
  resx   ErrC;
#srcline 122
  ldx    Res;
#srcline 123
  ldx    In5;
#srcline 124
  anc
#srcline 125
  resx   Err5;
#srcline 126
  ldx    ErrC;
#srcline 127
  eq     5;
#srcline 128
  and;
#srcline 129
  resx   ErrC;
#srcline 131
  ldx    Res;
#srcline 132
  ldx    In6;
#srcline 133
  anc
#srcline 134
  resx   Err6;
#srcline 135
  ldx    ErrC;
#srcline 136
  eq     6;
#srcline 137
  and;
#srcline 138
  resx   ErrC;
#srcline 140
  ldx    Res;
#srcline 141
  ldx    In7;
#srcline 142
  anc
#srcline 143
  resx   Err7;
#srcline 144
  ldx    ErrC;
#srcline 145
  eq     7;
#srcline 146
  and;
#srcline 147
  resx   ErrC;
#srcline 149
  ldx    Res;
#srcline 150
  ldx    In8;
#srcline 151
  anc
#srcline 152
  resx   Err8;
#srcline 153
  ldx    ErrC;
#srcline 154
  eq     8;
#srcline 155
  and;
#srcline 156
  resx   ErrC;
#srcline 157 ;  {END_ASM}
#srcline 159 ;  // casovani a vyhodnoceni poruch
#srcline 160 ;  Timer1(IN := In1, PT := Cfg.PresetTime1);
 LDX  In1
#debug bool In1
 WRX  Timer1~IN
#debug_left bool Timer1~IN
 LDX  Cfg~PresetTime1
#debug time Cfg.PresetTime1
 WRX  Timer1~PT
#debug_left time Timer1~PT
 LEAX Timer1
 CAL  TON_L0
#srcline 161 ;  {ASM}
#srcline 162
  ldx   Timer1.Q
#srcline 163
  setx  Err1;
#srcline 164
  letx  LET1;
#srcline 165
  setx  blikat;
#srcline 166
  wr    %s1.0;
#srcline 167
  ld    1;
#srcline 168
  putx  ErrC;
#srcline 169
  js    __SE11_newerr__;
#srcline 170 ;  {END_ASM}
#srcline 172 ;  Timer2(IN := In2, PT := Cfg.PresetTime2);
 LDX  In2
#debug bool In2
 WRX  Timer2~IN
#debug_left bool Timer2~IN
 LDX  Cfg~PresetTime2
#debug time Cfg.PresetTime2
 WRX  Timer2~PT
#debug_left time Timer2~PT
 LEAX Timer2
 CAL  TON_L0
#srcline 173 ;  {ASM}
#srcline 174
  ldx   Timer2.Q
#srcline 175
  setx  Err2
#srcline 176
  letx  LET2;
#srcline 177
  setx  blikat;
#srcline 178
  wr    %s1.0;
#srcline 179
  ld    2;
#srcline 180
  putx  ErrC;
#srcline 181
  js    __SE11_newerr__;
#srcline 182 ;  {END_ASM}
#srcline 184 ;  Timer3(IN := In3, PT := Cfg.PresetTime3);
 LDX  In3
#debug bool In3
 WRX  Timer3~IN
#debug_left bool Timer3~IN
 LDX  Cfg~PresetTime3
#debug time Cfg.PresetTime3
 WRX  Timer3~PT
#debug_left time Timer3~PT
 LEAX Timer3
 CAL  TON_L0
#srcline 185 ;  {ASM}
#srcline 186
  ldx   Timer3.Q
#srcline 187
  setx  Err3;
#srcline 188
  letx  LET3;
#srcline 189
  setx  blikat;
#srcline 190
  wr    %s1.0;
#srcline 191
  ld    3;
#srcline 192
  putx  ErrC;
#srcline 193
  js    __SE11_newerr__;
#srcline 194 ;  {END_ASM}
#srcline 196 ;  Timer4(IN := In4, PT := Cfg.PresetTime4);
 LDX  In4
#debug bool In4
 WRX  Timer4~IN
#debug_left bool Timer4~IN
 LDX  Cfg~PresetTime4
#debug time Cfg.PresetTime4
 WRX  Timer4~PT
#debug_left time Timer4~PT
 LEAX Timer4
 CAL  TON_L0
#srcline 197 ;  {ASM}
#srcline 198
  ldx   Timer4.Q
#srcline 199
  setx  Err4;
#srcline 200
  letx  LET4;
#srcline 201
  setx  blikat;
#srcline 202
  wr    %s1.0;
#srcline 203
  ld    4;
#srcline 204
  putx  ErrC;
#srcline 205
  js    __SE11_newerr__;
#srcline 206 ;  {END_ASM}
#srcline 208 ;  Timer5(IN := In5, PT := Cfg.PresetTime5);
 LDX  In5
#debug bool In5
 WRX  Timer5~IN
#debug_left bool Timer5~IN
 LDX  Cfg~PresetTime5
#debug time Cfg.PresetTime5
 WRX  Timer5~PT
#debug_left time Timer5~PT
 LEAX Timer5
 CAL  TON_L0
#srcline 209 ;  {ASM}
#srcline 210
  ldx   Timer5.Q
#srcline 211
  setx  Err5;
#srcline 212
  letx  LET5;
#srcline 213
  setx  blikat;
#srcline 214
  wr    %s1.0;
#srcline 215
  ld    5;
#srcline 216
  putx  ErrC;
#srcline 217
  js    __SE11_newerr__;
#srcline 218 ;  {END_ASM}
#srcline 220 ;  Timer6(IN := In6, PT := Cfg.PresetTime6);
 LDX  In6
#debug bool In6
 WRX  Timer6~IN
#debug_left bool Timer6~IN
 LDX  Cfg~PresetTime6
#debug time Cfg.PresetTime6
 WRX  Timer6~PT
#debug_left time Timer6~PT
 LEAX Timer6
 CAL  TON_L0
#srcline 221 ;  {ASM}
#srcline 222
  ldx   Timer6.Q
#srcline 223
  setx  Err6;
#srcline 224
  letx  LET6;
#srcline 225
  setx  blikat;
#srcline 226
  wr    %s1.0;
#srcline 227
  ld    6;
#srcline 228
  putx  ErrC;
#srcline 229
  js    __SE11_newerr__;
#srcline 230 ;  {END_ASM}
#srcline 232 ;  Timer7(IN := In7, PT := Cfg.PresetTime7);
 LDX  In7
#debug bool In7
 WRX  Timer7~IN
#debug_left bool Timer7~IN
 LDX  Cfg~PresetTime7
#debug time Cfg.PresetTime7
 WRX  Timer7~PT
#debug_left time Timer7~PT
 LEAX Timer7
 CAL  TON_L0
#srcline 233 ;  {ASM}
#srcline 234
  ldx   Timer7.Q
#srcline 235
  setx  Err7;
#srcline 236
  letx  LET7;
#srcline 237
  setx  blikat;
#srcline 238
  wr    %s1.0;
#srcline 239
  ld    7;
#srcline 240
  putx  ErrC;
#srcline 241
  js    __SE11_newerr__;
#srcline 242 ;  {END_ASM}
#srcline 244 ;  Timer8(IN := In8, PT := Cfg.PresetTime8);
 LDX  In8
#debug bool In8
 WRX  Timer8~IN
#debug_left bool Timer8~IN
 LDX  Cfg~PresetTime8
#debug time Cfg.PresetTime8
 WRX  Timer8~PT
#debug_left time Timer8~PT
 LEAX Timer8
 CAL  TON_L0
#srcline 245 ;  {ASM}
#srcline 246
  ldx   Timer8.Q
#srcline 247
  setx  Err8
#srcline 248
  letx  LET8;
#srcline 249
  setx  blikat;
#srcline 250
  wr    %s1.0;
#srcline 251
  ld    8;
#srcline 252
  putx  ErrC;
#srcline 253
  __SE11_newerr__;
#srcline 254 ;  {END_ASM}
#srcline 256 ;  // kvitace poruch
#srcline 257 ;  IF ACK THEN blikat := false; END_IF;  //prestat blikat signalkou
 LDX  ACK
#debug bool ACK
 JMC  SigErr11_L1
 LD   bool 0       ; false
 WRX  blikat
#debug_left bool blikat
SigErr11_L1:
#srcline 258 ;  
#srcline 259 ;  // rizeni signalky
#srcline 260 ;  {ASM}
#srcline 261
  ldx byte Err1    ;cela osmice
#srcline 262
  wrx Sum
#srcline 263
  wrx Sig
#srcline 264 ;  {END_ASM}
#srcline 265 ;  IF blikat THEN
 LDX  blikat
#debug bool blikat
 JMC  SigErr11_L3
#srcline 266 ;    Sig := %S13.2;   //blikani signalky v rastru 1s
 LD   %S13.2
 WRX  Sig
#debug_left bool Sig
#srcline 267 ;  END_IF;
SigErr11_L3:
#srcline 268 ;  
#srcline 269 ;END_FUNCTION_BLOCK
 ULNK
RET
E     61
#endpou 



 

#srcfile ''
#srcfile 'D:\TECOAPP\KNIHOVNY\REGOLIB\SIGERR12.ST'
#pou SigErr12
#srcline 18 ;FUNCTION_BLOCK SigErr12
P     61
SigErr12_L0:
 LINK 0
#srcline 88 ;  BEGIN
#srcline 89 ;  
#srcline 90 ;  // nulování poruch
#srcline 91 ;  {ASM}
#srcline 92
  ldx    ResI;
#srcline 93
  ldx    In1;
#srcline 94
  anc
#srcline 95
  resx   Err1;
#srcline 96
  ldx    ErrC;
#srcline 97
  eq     1;
#srcline 98
  and;
#srcline 99
  resx   ErrC;
#srcline 100
  
#srcline 101
  ldx    ResI;
#srcline 102
  ldx    In2;
#srcline 103
  anc
#srcline 104
  resx   Err2;
#srcline 105
  ldx    ErrC;
#srcline 106
  eq     2;
#srcline 107
  and;
#srcline 108
  resx   ErrC;
#srcline 109
  
#srcline 110
  ldx    ResI;
#srcline 111
  ldx    In3;
#srcline 112
  anc
#srcline 113
  resx   Err3;
#srcline 114
  ldx    ErrC;
#srcline 115
  eq     3;
#srcline 116
  and;
#srcline 117
  resx   ErrC;
#srcline 118
  
#srcline 119
  ldx    ResI;
#srcline 120
  ldx    In4;
#srcline 121
  anc
#srcline 122
  resx   Err4;
#srcline 123
  ldx    ErrC;
#srcline 124
  eq     4;
#srcline 125
  and;
#srcline 126
  resx   ErrC;
#srcline 127
  
#srcline 128
  ldx    ResI;
#srcline 129
  ldx    In5;
#srcline 130
  anc
#srcline 131
  resx   Err5;
#srcline 132
  ldx    ErrC;
#srcline 133
  eq     5;
#srcline 134
  and;
#srcline 135
  resx   ErrC;
#srcline 136
  
#srcline 137
  ldx    ResI;
#srcline 138
  ldx    In6;
#srcline 139
  anc
#srcline 140
  resx   Err6;
#srcline 141
  ldx    ErrC;
#srcline 142
  eq     6;
#srcline 143
  and;
#srcline 144
  resx   ErrC;
#srcline 145
  
#srcline 146
  ldx    ResI;
#srcline 147
  ldx    In7;
#srcline 148
  anc
#srcline 149
  resx   Err7;
#srcline 150
  ldx    ErrC;
#srcline 151
  eq     7;
#srcline 152
  and;
#srcline 153
  resx   ErrC;
#srcline 154
  
#srcline 155
  ldx    ResI;
#srcline 156
  ldx    In8;
#srcline 157
  anc
#srcline 158
  resx   Err8;
#srcline 159
  ldx    ErrC;
#srcline 160
  eq     8;
#srcline 161
  and;
#srcline 162
  resx   ErrC;
#srcline 163 ;  {END_ASM}
#srcline 164 ;  
#srcline 165 ;  // casovani a vyhodnoceni poruch
#srcline 166 ;  Timer1(IN := In1, PT := Cfg.PresetTime1);
 LDX  In1
#debug bool In1
 WRX  Timer1~IN
#debug_left bool Timer1~IN
 LDX  Cfg~PresetTime1
#debug time Cfg.PresetTime1
 WRX  Timer1~PT
#debug_left time Timer1~PT
 LEAX Timer1
 CAL  TON_L0
#srcline 167 ;  {ASM}
#srcline 168
  ldx   Timer1.Q
#srcline 169
  setx  Err1;
#srcline 170
  letx  LET1;
#srcline 171
  setx  blikat;
#srcline 172
  wr    %s1.0;
#srcline 173
  ld    1;
#srcline 174
  putx  ErrC;
#srcline 175
  js    __SE12_newerr__;
#srcline 176 ;  {END_ASM}
#srcline 178 ;  Timer2(IN := In2, PT := Cfg.PresetTime2);
 LDX  In2
#debug bool In2
 WRX  Timer2~IN
#debug_left bool Timer2~IN
 LDX  Cfg~PresetTime2
#debug time Cfg.PresetTime2
 WRX  Timer2~PT
#debug_left time Timer2~PT
 LEAX Timer2
 CAL  TON_L0
#srcline 179 ;  {ASM}
#srcline 180
  ldx   Timer2.Q
#srcline 181
  setx  Err2
#srcline 182
  letx  LET2;
#srcline 183
  setx  blikat;
#srcline 184
  wr    %s1.0;
#srcline 185
  ld    2;
#srcline 186
  putx  ErrC;
#srcline 187
  js    __SE12_newerr__;
#srcline 188 ;  {END_ASM}
#srcline 190 ;  Timer3(IN := In3, PT := Cfg.PresetTime3);
 LDX  In3
#debug bool In3
 WRX  Timer3~IN
#debug_left bool Timer3~IN
 LDX  Cfg~PresetTime3
#debug time Cfg.PresetTime3
 WRX  Timer3~PT
#debug_left time Timer3~PT
 LEAX Timer3
 CAL  TON_L0
#srcline 191 ;  {ASM}
#srcline 192
  ldx   Timer3.Q
#srcline 193
  setx  Err3;
#srcline 194
  letx  LET3;
#srcline 195
  setx  blikat;
#srcline 196
  wr    %s1.0;
#srcline 197
  ld    3;
#srcline 198
  putx  ErrC;
#srcline 199
  js    __SE12_newerr__;
#srcline 200 ;  {END_ASM}
#srcline 202 ;  Timer4(IN := In4, PT := Cfg.PresetTime4);
 LDX  In4
#debug bool In4
 WRX  Timer4~IN
#debug_left bool Timer4~IN
 LDX  Cfg~PresetTime4
#debug time Cfg.PresetTime4
 WRX  Timer4~PT
#debug_left time Timer4~PT
 LEAX Timer4
 CAL  TON_L0
#srcline 203 ;  {ASM}
#srcline 204
  ldx   Timer4.Q
#srcline 205
  setx  Err4;
#srcline 206
  letx  LET4;
#srcline 207
  setx  blikat;
#srcline 208
  wr    %s1.0;
#srcline 209
  ld    4;
#srcline 210
  putx  ErrC;
#srcline 211
  js    __SE12_newerr__;
#srcline 212 ;  {END_ASM}
#srcline 214 ;  Timer5(IN := In5, PT := Cfg.PresetTime5);
 LDX  In5
#debug bool In5
 WRX  Timer5~IN
#debug_left bool Timer5~IN
 LDX  Cfg~PresetTime5
#debug time Cfg.PresetTime5
 WRX  Timer5~PT
#debug_left time Timer5~PT
 LEAX Timer5
 CAL  TON_L0
#srcline 215 ;  {ASM}
#srcline 216
  ldx   Timer5.Q
#srcline 217
  setx  Err5;
#srcline 218
  letx  LET5;
#srcline 219
  setx  blikat;
#srcline 220
  wr    %s1.0;
#srcline 221
  ld    5;
#srcline 222
  putx  ErrC;
#srcline 223
  js    __SE12_newerr__;
#srcline 224 ;  {END_ASM}
#srcline 226 ;  Timer6(IN := In6, PT := Cfg.PresetTime6);
 LDX  In6
#debug bool In6
 WRX  Timer6~IN
#debug_left bool Timer6~IN
 LDX  Cfg~PresetTime6
#debug time Cfg.PresetTime6
 WRX  Timer6~PT
#debug_left time Timer6~PT
 LEAX Timer6
 CAL  TON_L0
#srcline 227 ;  {ASM}
#srcline 228
  ldx   Timer6.Q
#srcline 229
  setx  Err6;
#srcline 230
  letx  LET6;
#srcline 231
  setx  blikat;
#srcline 232
  wr    %s1.0;
#srcline 233
  ld    6;
#srcline 234
  putx  ErrC;
#srcline 235
  js    __SE12_newerr__;
#srcline 236 ;  {END_ASM}
#srcline 238 ;  Timer7(IN := In7, PT := Cfg.PresetTime7);
 LDX  In7
#debug bool In7
 WRX  Timer7~IN
#debug_left bool Timer7~IN
 LDX  Cfg~PresetTime7
#debug time Cfg.PresetTime7
 WRX  Timer7~PT
#debug_left time Timer7~PT
 LEAX Timer7
 CAL  TON_L0
#srcline 239 ;  {ASM}
#srcline 240
  ldx   Timer7.Q
#srcline 241
  setx  Err7;
#srcline 242
  letx  LET7;
#srcline 243
  setx  blikat;
#srcline 244
  wr    %s1.0;
#srcline 245
  ld    7;
#srcline 246
  putx  ErrC;
#srcline 247
  js    __SE12_newerr__;
#srcline 248 ;  {END_ASM}
#srcline 250 ;  Timer8(IN := In8, PT := Cfg.PresetTime8);
 LDX  In8
#debug bool In8
 WRX  Timer8~IN
#debug_left bool Timer8~IN
 LDX  Cfg~PresetTime8
#debug time Cfg.PresetTime8
 WRX  Timer8~PT
#debug_left time Timer8~PT
 LEAX Timer8
 CAL  TON_L0
#srcline 251 ;  {ASM}
#srcline 252
  ldx   Timer8.Q
#srcline 253
  setx  Err8
#srcline 254
  letx  LET8;
#srcline 255
  setx  blikat;
#srcline 256
  wr    %s1.0;
#srcline 257
  ld    8;
#srcline 258
  putx  ErrC;
#srcline 259
  __SE12_newerr__;
#srcline 260 ;  {END_ASM}
#srcline 262 ;  // kvitace poruch
#srcline 263 ;  IF AckI THEN blikat := false; END_IF;  //prestat blikat signalkou
 LDX  AckI
#debug bool AckI
 JMC  SigErr12_L1
 LD   bool 0       ; false
 WRX  blikat
#debug_left bool blikat
SigErr12_L1:
#srcline 265 ;  // øízení signálky
#srcline 266 ;  {ASM}
#srcline 267
  ldx byte Err1     ;cela osmice
#srcline 268
  wrx SumO
#srcline 269
  wrx SigO
#srcline 270 ;  {END_ASM}
#srcline 271 ;  IF blikat THEN
 LDX  blikat
#debug bool blikat
 JMC  SigErr12_L3
#srcline 272 ;    SigO := %S13.2;   //blikani signalky v rastru 1s
 LD   %S13.2
 WRX  SigO
#debug_left bool SigO
#srcline 273 ;  END_IF;
SigErr12_L3:
#srcline 274 ;  SigO   := (    SumI AND     SigI AND not SumO AND not SigO) OR  //pozadavek je z kaskadovani, neni z komponenty
 LDX  SumI
#debug bool SumI
 LDX  SigI
#debug bool SigI
 AND
 LDX  SumO
#debug bool SumO
 NEG
 AND
 LDX  SigO
#debug bool SigO
 NEG
 AND
#srcline 275 ;            (not SumI AND not SigI AND     SumO AND     SigO) OR  //pozadavek neni z kaskadovani, je z komponenty
 LDX  SumI
#debug bool SumI
 NEG
 LDX  SigI
#debug bool SigI
 NEG
 AND
 LDX  SumO
#debug bool SumO
 AND
 LDX  SigO
#debug bool SigO
 AND
 OR  
#srcline 276 ;            (    SumI AND     SigI AND     SumO AND     SigO);    //pozadavek je z kaskadovani i z komponenty
 LDX  SumI
#debug bool SumI
 LDX  SigI
#debug bool SigI
 AND
 LDX  SumO
#debug bool SumO
 AND
 LDX  SigO
#debug bool SigO
 AND
 OR  
 WRX  SigO
#debug_left bool SigO
#srcline 278 ;  //sdružená porucha
#srcline 279 ;  SumO := SumO or SumI;
 LDX  SumO
#debug bool SumO
 LDX  SumI
#debug bool SumI
 OR  
 WRX  SumO
#debug_left bool SumO
#srcline 281 ;  //pøepis kvitace a nulování poruch
#srcline 282 ;  AckO := AckI;
 LDX  AckI
#debug bool AckI
 WRX  AckO
#debug_left bool AckO
#srcline 283 ;  ResO := ResI;
 LDX  ResI
#debug bool ResI
 WRX  ResO
#debug_left bool ResO
#srcline 284 ;  
#srcline 285 ;END_FUNCTION_BLOCK
 ULNK
RET
E     61
#endpou 



 

#srcfile ''
#srcfile 'D:\TECOAPP\KNIHOVNY\REGOLIB\SIGERR13.ST'
#pou SigErr13
#srcline 28 ;FUNCTION_BLOCK SigErr13

#struct SigErr13__temp__
  udint P0__st__,
  udint P1__st__,
  udint P2__st__,
  udint P3__st__,
  udint P4__st__,
  udint P5__st__,
  udint P6__st__,
  udint P7__st__
P     61
SigErr13_L0:
 LINK __SizeOf(SigErr13__temp__)
; Initialize - dynamic variables
; End initialize - dynamic variables
#srcline 134 ;  BEGIN
#srcline 135 ;  
#srcline 136 ;  // rozbetlovani kaskadovaciho vstupu na bity
#srcline 137 ;  pombit := blikat;  //odlozeni priznaku blikat
 LDX  blikat
#debug bool blikat
 WRX  pombit
#debug_left bool pombit
#srcline 138 ;  {ASM}
#srcline 139
  ldx   CasI           ;byte kaskadovaciho vstupu
#srcline 140
  wrx   byte kvitace    ;cela osmice bitu
#srcline 141 ;  {END_ASM}
#srcline 142 ;  kvitace := kvitace OR AckI;   //akceptovat primy vstup kvitace
 LDX  kvitace
#debug bool kvitace
 LDX  AckI
#debug bool AckI
 OR  
 WRX  kvitace
#debug_left bool kvitace
#srcline 143 ;  reset   := reset   OR ResI;   //akceptovat primy vstup reset
 LDX  reset
#debug bool reset
 LDX  ResI
#debug bool ResI
 OR  
 WRX  reset
#debug_left bool reset
#srcline 144 ;  blikat  := blikat  OR pombit;  //akceptovat predchozi stav promenne blikat
 LDX  blikat
#debug bool blikat
 LDX  pombit
#debug bool pombit
 OR  
 WRX  blikat
#debug_left bool blikat
#srcline 146 ;  // kontrola pripustnosti hodnot ridicich slov
#srcline 147 ;  IF Cfg.control1 > 2 THEN Cfg.control1 := 2; END_IF;
 LDX  Cfg~control1
#debug usint Cfg.control1
 LD   usint 2
 GT
 JMC  SigErr13_L1
 LD   usint 2
 WRX  Cfg~control1
#debug_left usint Cfg.control1
SigErr13_L1:
#srcline 148 ;  IF Cfg.control2 > 2 THEN Cfg.control2 := 2; END_IF;
 LDX  Cfg~control2
#debug usint Cfg.control2
 LD   usint 2
 GT
 JMC  SigErr13_L3
 LD   usint 2
 WRX  Cfg~control2
#debug_left usint Cfg.control2
SigErr13_L3:
#srcline 149 ;  IF Cfg.control3 > 2 THEN Cfg.control3 := 2; END_IF;
 LDX  Cfg~control3
#debug usint Cfg.control3
 LD   usint 2
 GT
 JMC  SigErr13_L5
 LD   usint 2
 WRX  Cfg~control3
#debug_left usint Cfg.control3
SigErr13_L5:
#srcline 150 ;  IF Cfg.control4 > 2 THEN Cfg.control4 := 2; END_IF;
 LDX  Cfg~control4
#debug usint Cfg.control4
 LD   usint 2
 GT
 JMC  SigErr13_L7
 LD   usint 2
 WRX  Cfg~control4
#debug_left usint Cfg.control4
SigErr13_L7:
#srcline 151 ;  IF Cfg.control5 > 2 THEN Cfg.control5 := 2; END_IF;
 LDX  Cfg~control5
#debug usint Cfg.control5
 LD   usint 2
 GT
 JMC  SigErr13_L9
 LD   usint 2
 WRX  Cfg~control5
#debug_left usint Cfg.control5
SigErr13_L9:
#srcline 152 ;  IF Cfg.control6 > 2 THEN Cfg.control6 := 2; END_IF;
 LDX  Cfg~control6
#debug usint Cfg.control6
 LD   usint 2
 GT
 JMC  SigErr13_L11
 LD   usint 2
 WRX  Cfg~control6
#debug_left usint Cfg.control6
SigErr13_L11:
#srcline 153 ;  IF Cfg.control7 > 2 THEN Cfg.control7 := 2; END_IF;
 LDX  Cfg~control7
#debug usint Cfg.control7
 LD   usint 2
 GT
 JMC  SigErr13_L13
 LD   usint 2
 WRX  Cfg~control7
#debug_left usint Cfg.control7
SigErr13_L13:
#srcline 154 ;  IF Cfg.control8 > 2 THEN Cfg.control8 := 2; END_IF;
 LDX  Cfg~control8
#debug usint Cfg.control8
 LD   usint 2
 GT
 JMC  SigErr13_L15
 LD   usint 2
 WRX  Cfg~control8
#debug_left usint Cfg.control8
SigErr13_L15:
#srcline 155 ;  IF Cfg.controlS > 2 THEN Cfg.controlS := 2; END_IF;
 LDX  Cfg~controlS
#debug usint Cfg.controlS
 LD   usint 2
 GT
 JMC  SigErr13_L17
 LD   usint 2
 WRX  Cfg~controlS
#debug_left usint Cfg.controlS
SigErr13_L17:
#srcline 157 ;  // nulovani poruch
#srcline 158 ;  CASE Cfg.control1 OF
 LDX  Cfg~control1
#debug usint Cfg.control1
 WRY  P0__st__
 LD   0
 LDY  P0__st__
 EQ  
 JMC  SigErr13_L20
#srcline 159 ;    0 : IF not In1 THEN          //porucha je nulovana vzdy, pokud neni aktivni (samovratna porucha)
 LDX  In1
#debug bool In1
 NEG
 JMC  SigErr13_L21
#srcline 160 ;          Err1 := false; END_IF;
 LD   bool 0       ; false
 WRX  Err1
#debug_left bool Err1
SigErr13_L21:
 JMP  SigErr13_L19
SigErr13_L20:
 LD   1
 LDY  P0__st__
 EQ  
 JMC  SigErr13_L23
#srcline 161 ;    1 : IF reset THEN               //porucha je nulovana signalem ResI vzdy
 LDX  reset
#debug bool reset
 JMC  SigErr13_L24
#srcline 162 ;          Err1 := false; In1 := false; END_IF;
 LD   bool 0       ; false
 WRX  Err1
#debug_left bool Err1
 LD   bool 0       ; false
 WRX  In1
#debug_left bool In1
SigErr13_L24:
 JMP  SigErr13_L19
SigErr13_L23:
 LD   2
 LDY  P0__st__
 EQ  
 JMC  SigErr13_L26
#srcline 163 ;    2 : IF reset & not In1 THEN  //porucha je nulovana signalem ResI, jen pokud neni aktivni
 LDX  reset
#debug bool reset
 LDX  In1
#debug bool In1
 NEG
 AND
 JMC  SigErr13_L27
#srcline 164 ;          Err1 := false; END_IF;
 LD   bool 0       ; false
 WRX  Err1
#debug_left bool Err1
SigErr13_L27:
 JMP  SigErr13_L19
SigErr13_L26:
SigErr13_L19:
#srcline 166 ;  CASE Cfg.control2 OF
 LDX  Cfg~control2
#debug usint Cfg.control2
 WRY  P1__st__
 LD   0
 LDY  P1__st__
 EQ  
 JMC  SigErr13_L30
#srcline 167 ;    0 : IF not In2 THEN          //porucha je nulovana vzdy, pokud neni aktivni (samovratna porucha)
 LDX  In2
#debug bool In2
 NEG
 JMC  SigErr13_L31
#srcline 168 ;          Err2 := false; END_IF;
 LD   bool 0       ; false
 WRX  Err2
#debug_left bool Err2
SigErr13_L31:
 JMP  SigErr13_L29
SigErr13_L30:
 LD   1
 LDY  P1__st__
 EQ  
 JMC  SigErr13_L33
#srcline 169 ;    1 : IF reset THEN               //porucha je nulovana signalem ResI vzdy
 LDX  reset
#debug bool reset
 JMC  SigErr13_L34
#srcline 170 ;          Err2 := false; In2 := false; END_IF;
 LD   bool 0       ; false
 WRX  Err2
#debug_left bool Err2
 LD   bool 0       ; false
 WRX  In2
#debug_left bool In2
SigErr13_L34:
 JMP  SigErr13_L29
SigErr13_L33:
 LD   2
 LDY  P1__st__
 EQ  
 JMC  SigErr13_L36
#srcline 171 ;    2 : IF reset & not In2 THEN  //porucha je nulovana signalem ResI, jen pokud neni aktivni
 LDX  reset
#debug bool reset
 LDX  In2
#debug bool In2
 NEG
 AND
 JMC  SigErr13_L37
#srcline 172 ;          Err2 := false; END_IF;
 LD   bool 0       ; false
 WRX  Err2
#debug_left bool Err2
SigErr13_L37:
 JMP  SigErr13_L29
SigErr13_L36:
SigErr13_L29:
#srcline 174 ;  CASE Cfg.control3 OF
 LDX  Cfg~control3
#debug usint Cfg.control3
 WRY  P2__st__
 LD   0
 LDY  P2__st__
 EQ  
 JMC  SigErr13_L40
#srcline 175 ;    0 : IF not In3 THEN          //porucha je nulovana vzdy, pokud neni aktivni (samovratna porucha)
 LDX  In3
#debug bool In3
 NEG
 JMC  SigErr13_L41
#srcline 176 ;          Err3 := false; END_IF;
 LD   bool 0       ; false
 WRX  Err3
#debug_left bool Err3
SigErr13_L41:
 JMP  SigErr13_L39
SigErr13_L40:
 LD   1
 LDY  P2__st__
 EQ  
 JMC  SigErr13_L43
#srcline 177 ;    1 : IF reset THEN               //porucha je nulovana signalem ResI vzdy
 LDX  reset
#debug bool reset
 JMC  SigErr13_L44
#srcline 178 ;          Err3 := false; In3 := false; END_IF;
 LD   bool 0       ; false
 WRX  Err3
#debug_left bool Err3
 LD   bool 0       ; false
 WRX  In3
#debug_left bool In3
SigErr13_L44:
 JMP  SigErr13_L39
SigErr13_L43:
 LD   2
 LDY  P2__st__
 EQ  
 JMC  SigErr13_L46
#srcline 179 ;    2 : IF reset & not In3 THEN  //porucha je nulovana signalem ResI, jen pokud neni aktivni
 LDX  reset
#debug bool reset
 LDX  In3
#debug bool In3
 NEG
 AND
 JMC  SigErr13_L47
#srcline 180 ;          Err3 := false; END_IF;
 LD   bool 0       ; false
 WRX  Err3
#debug_left bool Err3
SigErr13_L47:
 JMP  SigErr13_L39
SigErr13_L46:
SigErr13_L39:
#srcline 182 ;  CASE Cfg.control4 OF
 LDX  Cfg~control4
#debug usint Cfg.control4
 WRY  P3__st__
 LD   0
 LDY  P3__st__
 EQ  
 JMC  SigErr13_L50
#srcline 183 ;    0 : IF not In4 THEN          //porucha je nulovana vzdy, pokud neni aktivni (samovratna porucha)
 LDX  In4
#debug bool In4
 NEG
 JMC  SigErr13_L51
#srcline 184 ;          Err4 := false; END_IF;
 LD   bool 0       ; false
 WRX  Err4
#debug_left bool Err4
SigErr13_L51:
 JMP  SigErr13_L49
SigErr13_L50:
 LD   1
 LDY  P3__st__
 EQ  
 JMC  SigErr13_L53
#srcline 185 ;    1 : IF reset THEN               //porucha je nulovana signalem ResI vzdy
 LDX  reset
#debug bool reset
 JMC  SigErr13_L54
#srcline 186 ;          Err4 := false; In4 := false; END_IF;
 LD   bool 0       ; false
 WRX  Err4
#debug_left bool Err4
 LD   bool 0       ; false
 WRX  In4
#debug_left bool In4
SigErr13_L54:
 JMP  SigErr13_L49
SigErr13_L53:
 LD   2
 LDY  P3__st__
 EQ  
 JMC  SigErr13_L56
#srcline 187 ;    2 : IF reset & not In4 THEN  //porucha je nulovana signalem ResI, jen pokud neni aktivni
 LDX  reset
#debug bool reset
 LDX  In4
#debug bool In4
 NEG
 AND
 JMC  SigErr13_L57
#srcline 188 ;          Err4 := false; END_IF;
 LD   bool 0       ; false
 WRX  Err4
#debug_left bool Err4
SigErr13_L57:
 JMP  SigErr13_L49
SigErr13_L56:
SigErr13_L49:
#srcline 190 ;  CASE Cfg.control5 OF
 LDX  Cfg~control5
#debug usint Cfg.control5
 WRY  P4__st__
 LD   0
 LDY  P4__st__
 EQ  
 JMC  SigErr13_L60
#srcline 191 ;    0 : IF not In5 THEN          //porucha je nulovana vzdy, pokud neni aktivni (samovratna porucha)
 LDX  In5
#debug bool In5
 NEG
 JMC  SigErr13_L61
#srcline 192 ;          Err5 := false; END_IF;
 LD   bool 0       ; false
 WRX  Err5
#debug_left bool Err5
SigErr13_L61:
 JMP  SigErr13_L59
SigErr13_L60:
 LD   1
 LDY  P4__st__
 EQ  
 JMC  SigErr13_L63
#srcline 193 ;    1 : IF reset THEN               //porucha je nulovana signalem ResI vzdy
 LDX  reset
#debug bool reset
 JMC  SigErr13_L64
#srcline 194 ;          Err5 := false; In5 := false; END_IF;
 LD   bool 0       ; false
 WRX  Err5
#debug_left bool Err5
 LD   bool 0       ; false
 WRX  In5
#debug_left bool In5
SigErr13_L64:
 JMP  SigErr13_L59
SigErr13_L63:
 LD   2
 LDY  P4__st__
 EQ  
 JMC  SigErr13_L66
#srcline 195 ;    2 : IF reset & not In5 THEN  //porucha je nulovana signalem ResI, jen pokud neni aktivni
 LDX  reset
#debug bool reset
 LDX  In5
#debug bool In5
 NEG
 AND
 JMC  SigErr13_L67
#srcline 196 ;          Err5 := false; END_IF;
 LD   bool 0       ; false
 WRX  Err5
#debug_left bool Err5
SigErr13_L67:
 JMP  SigErr13_L59
SigErr13_L66:
SigErr13_L59:
#srcline 198 ;  CASE Cfg.control6 OF
 LDX  Cfg~control6
#debug usint Cfg.control6
 WRY  P5__st__
 LD   0
 LDY  P5__st__
 EQ  
 JMC  SigErr13_L70
#srcline 199 ;    0 : IF not In6 THEN          //porucha je nulovana vzdy, pokud neni aktivni (samovratna porucha)
 LDX  In6
#debug bool In6
 NEG
 JMC  SigErr13_L71
#srcline 200 ;          Err6 := false; END_IF;
 LD   bool 0       ; false
 WRX  Err6
#debug_left bool Err6
SigErr13_L71:
 JMP  SigErr13_L69
SigErr13_L70:
 LD   1
 LDY  P5__st__
 EQ  
 JMC  SigErr13_L73
#srcline 201 ;    1 : IF reset THEN               //porucha je nulovana signalem ResI vzdy
 LDX  reset
#debug bool reset
 JMC  SigErr13_L74
#srcline 202 ;          Err6 := false; In6 := false; END_IF;
 LD   bool 0       ; false
 WRX  Err6
#debug_left bool Err6
 LD   bool 0       ; false
 WRX  In6
#debug_left bool In6
SigErr13_L74:
 JMP  SigErr13_L69
SigErr13_L73:
 LD   2
 LDY  P5__st__
 EQ  
 JMC  SigErr13_L76
#srcline 203 ;    2 : IF reset & not In6 THEN  //porucha je nulovana signalem ResI, jen pokud neni aktivni
 LDX  reset
#debug bool reset
 LDX  In6
#debug bool In6
 NEG
 AND
 JMC  SigErr13_L77
#srcline 204 ;          Err6 := false; END_IF;
 LD   bool 0       ; false
 WRX  Err6
#debug_left bool Err6
SigErr13_L77:
 JMP  SigErr13_L69
SigErr13_L76:
SigErr13_L69:
#srcline 206 ;  CASE Cfg.control7 OF
 LDX  Cfg~control7
#debug usint Cfg.control7
 WRY  P6__st__
 LD   0
 LDY  P6__st__
 EQ  
 JMC  SigErr13_L80
#srcline 207 ;    0 : IF not In7 THEN          //porucha je nulovana vzdy, pokud neni aktivni (samovratna porucha)
 LDX  In7
#debug bool In7
 NEG
 JMC  SigErr13_L81
#srcline 208 ;          Err7 := false; END_IF;
 LD   bool 0       ; false
 WRX  Err7
#debug_left bool Err7
SigErr13_L81:
 JMP  SigErr13_L79
SigErr13_L80:
 LD   1
 LDY  P6__st__
 EQ  
 JMC  SigErr13_L83
#srcline 209 ;    1 : IF reset THEN               //porucha je nulovana signalem ResI vzdy
 LDX  reset
#debug bool reset
 JMC  SigErr13_L84
#srcline 210 ;          Err7 := false; In7 := false; END_IF;
 LD   bool 0       ; false
 WRX  Err7
#debug_left bool Err7
 LD   bool 0       ; false
 WRX  In7
#debug_left bool In7
SigErr13_L84:
 JMP  SigErr13_L79
SigErr13_L83:
 LD   2
 LDY  P6__st__
 EQ  
 JMC  SigErr13_L86
#srcline 211 ;    2 : IF reset & not In2 THEN  //porucha je nulovana signalem ResI, jen pokud neni aktivni
 LDX  reset
#debug bool reset
 LDX  In2
#debug bool In2
 NEG
 AND
 JMC  SigErr13_L87
#srcline 212 ;          Err7 := false; END_IF;
 LD   bool 0       ; false
 WRX  Err7
#debug_left bool Err7
SigErr13_L87:
 JMP  SigErr13_L79
SigErr13_L86:
SigErr13_L79:
#srcline 214 ;  CASE Cfg.control8 OF
 LDX  Cfg~control8
#debug usint Cfg.control8
 WRY  P7__st__
 LD   0
 LDY  P7__st__
 EQ  
 JMC  SigErr13_L90
#srcline 215 ;    0 : IF not In8 THEN          //porucha je nulovana vzdy, pokud neni aktivni (samovratna porucha)
 LDX  In8
#debug bool In8
 NEG
 JMC  SigErr13_L91
#srcline 216 ;          Err8 := false; END_IF;
 LD   bool 0       ; false
 WRX  Err8
#debug_left bool Err8
SigErr13_L91:
 JMP  SigErr13_L89
SigErr13_L90:
 LD   1
 LDY  P7__st__
 EQ  
 JMC  SigErr13_L93
#srcline 217 ;    1 : IF reset THEN               //porucha je nulovana signalem ResI vzdy
 LDX  reset
#debug bool reset
 JMC  SigErr13_L94
#srcline 218 ;          Err8 := false; In8 := false; END_IF;
 LD   bool 0       ; false
 WRX  Err8
#debug_left bool Err8
 LD   bool 0       ; false
 WRX  In8
#debug_left bool In8
SigErr13_L94:
 JMP  SigErr13_L89
SigErr13_L93:
 LD   2
 LDY  P7__st__
 EQ  
 JMC  SigErr13_L96
#srcline 219 ;    2 : IF reset & not In8 THEN  //porucha je nulovana signalem ResI, jen pokud neni aktivni
 LDX  reset
#debug bool reset
 LDX  In8
#debug bool In8
 NEG
 AND
 JMC  SigErr13_L97
#srcline 220 ;          Err8 := false; END_IF;
 LD   bool 0       ; false
 WRX  Err8
#debug_left bool Err8
SigErr13_L97:
 JMP  SigErr13_L89
SigErr13_L96:
SigErr13_L89:
#srcline 223 ;  //casovani a vyhodnoceni poruch
#srcline 224 ;  ErrC := 0;
 LD   usint 0
 WRX  ErrC
#debug_left usint ErrC
#srcline 225 ;  
#srcline 226 ;  Timer1(IN := In1, PT := Cfg.PresetTime1);
 LDX  In1
#debug bool In1
 WRX  Timer1~IN
#debug_left bool Timer1~IN
 LDX  Cfg~PresetTime1
#debug time Cfg.PresetTime1
 WRX  Timer1~PT
#debug_left time Timer1~PT
 LEAX Timer1
 CAL  TON_L0
#srcline 227 ;  {ASM}
#srcline 228
  ldx   Timer1.Q
#srcline 229
  setx  Err1;
#srcline 230
  letx  LET1;
#srcline 231
  setx  blikat;
#srcline 232
  wr    %s1.0;
#srcline 233
  ld    1;
#srcline 234
  putx  ErrC;
#srcline 235
  js    __SE13_newerr__;
#srcline 236 ;  {END_ASM}
#srcline 238 ;  Timer2(IN := In2, PT := Cfg.PresetTime2);
 LDX  In2
#debug bool In2
 WRX  Timer2~IN
#debug_left bool Timer2~IN
 LDX  Cfg~PresetTime2
#debug time Cfg.PresetTime2
 WRX  Timer2~PT
#debug_left time Timer2~PT
 LEAX Timer2
 CAL  TON_L0
#srcline 239 ;  {ASM}
#srcline 240
  ldx   Timer2.Q
#srcline 241
  setx  Err2
#srcline 242
  letx  LET2;
#srcline 243
  setx  blikat;
#srcline 244
  wr    %s1.0;
#srcline 245
  ld    2;
#srcline 246
  putx  ErrC;
#srcline 247
  js    __SE13_newerr__;
#srcline 248 ;  {END_ASM}
#srcline 250 ;  Timer3(IN := In3, PT := Cfg.PresetTime3);
 LDX  In3
#debug bool In3
 WRX  Timer3~IN
#debug_left bool Timer3~IN
 LDX  Cfg~PresetTime3
#debug time Cfg.PresetTime3
 WRX  Timer3~PT
#debug_left time Timer3~PT
 LEAX Timer3
 CAL  TON_L0
#srcline 251 ;  {ASM}
#srcline 252
  ldx   Timer3.Q
#srcline 253
  setx  Err3;
#srcline 254
  letx  LET3;
#srcline 255
  setx  blikat;
#srcline 256
  wr    %s1.0;
#srcline 257
  ld    3;
#srcline 258
  putx  ErrC;
#srcline 259
  js    __SE13_newerr__;
#srcline 260 ;  {END_ASM}
#srcline 262 ;  Timer4(IN := In4, PT := Cfg.PresetTime4);
 LDX  In4
#debug bool In4
 WRX  Timer4~IN
#debug_left bool Timer4~IN
 LDX  Cfg~PresetTime4
#debug time Cfg.PresetTime4
 WRX  Timer4~PT
#debug_left time Timer4~PT
 LEAX Timer4
 CAL  TON_L0
#srcline 263 ;  {ASM}
#srcline 264
  ldx   Timer4.Q
#srcline 265
  setx  Err4;
#srcline 266
  letx  LET4;
#srcline 267
  setx  blikat;
#srcline 268
  wr    %s1.0;
#srcline 269
  ld    4;
#srcline 270
  putx  ErrC;
#srcline 271
  js    __SE13_newerr__;
#srcline 272 ;  {END_ASM}
#srcline 274 ;  Timer5(IN := In5, PT := Cfg.PresetTime5);
 LDX  In5
#debug bool In5
 WRX  Timer5~IN
#debug_left bool Timer5~IN
 LDX  Cfg~PresetTime5
#debug time Cfg.PresetTime5
 WRX  Timer5~PT
#debug_left time Timer5~PT
 LEAX Timer5
 CAL  TON_L0
#srcline 275 ;  {ASM}
#srcline 276
  ldx   Timer5.Q
#srcline 277
  setx  Err5;
#srcline 278
  letx  LET5;
#srcline 279
  setx  blikat;
#srcline 280
  wr    %s1.0;
#srcline 281
  ld    5;
#srcline 282
  putx  ErrC;
#srcline 283
  js    __SE13_newerr__;
#srcline 284 ;  {END_ASM}
#srcline 286 ;  Timer6(IN := In6, PT := Cfg.PresetTime6);
 LDX  In6
#debug bool In6
 WRX  Timer6~IN
#debug_left bool Timer6~IN
 LDX  Cfg~PresetTime6
#debug time Cfg.PresetTime6
 WRX  Timer6~PT
#debug_left time Timer6~PT
 LEAX Timer6
 CAL  TON_L0
#srcline 287 ;  {ASM}
#srcline 288
  ldx   Timer6.Q
#srcline 289
  setx  Err6;
#srcline 290
  letx  LET6;
#srcline 291
  setx  blikat;
#srcline 292
  wr    %s1.0;
#srcline 293
  ld    6;
#srcline 294
  putx  ErrC;
#srcline 295
  js    __SE13_newerr__;
#srcline 296 ;  {END_ASM}
#srcline 298 ;  Timer7(IN := In7, PT := Cfg.PresetTime7);
 LDX  In7
#debug bool In7
 WRX  Timer7~IN
#debug_left bool Timer7~IN
 LDX  Cfg~PresetTime7
#debug time Cfg.PresetTime7
 WRX  Timer7~PT
#debug_left time Timer7~PT
 LEAX Timer7
 CAL  TON_L0
#srcline 299 ;  {ASM}
#srcline 300
  ldx   Timer7.Q
#srcline 301
  setx  Err7;
#srcline 302
  letx  LET7;
#srcline 303
  setx  blikat;
#srcline 304
  wr    %s1.0;
#srcline 305
  ld    7;
#srcline 306
  putx  ErrC;
#srcline 307
  js    __SE13_newerr__;
#srcline 308 ;  {END_ASM}
#srcline 310 ;  Timer8(IN := In8, PT := Cfg.PresetTime8);
 LDX  In8
#debug bool In8
 WRX  Timer8~IN
#debug_left bool Timer8~IN
 LDX  Cfg~PresetTime8
#debug time Cfg.PresetTime8
 WRX  Timer8~PT
#debug_left time Timer8~PT
 LEAX Timer8
 CAL  TON_L0
#srcline 311 ;  {ASM}
#srcline 312
  ldx   Timer8.Q
#srcline 313
  setx  Err8
#srcline 314
  letx  LET8;
#srcline 315
  setx  blikat;
#srcline 316
  wr    %s1.0;
#srcline 317
  ld    8;
#srcline 318
  putx  ErrC;
#srcline 319
  __SE13_newerr__:
#srcline 320 ;  {END_ASM}
#srcline 322 ;  //kvitace poruch
#srcline 323 ;  IF kvitace THEN blikat := false; END_IF;  //prestat blikat signalkou
 LDX  kvitace
#debug bool kvitace
 JMC  SigErr13_L99
 LD   bool 0       ; false
 WRX  blikat
#debug_left bool blikat
SigErr13_L99:
#srcline 325 ;  //rizeni signalky
#srcline 326 ;  {ASM}
#srcline 327
  ldx  byte Err1    ;cela osmice poruch
#srcline 328
  ldx  sdruzpor         ;sdruzena porucha ze vstupniho kaskadovani
#srcline 329
  or
#srcline 330
  wrx  SumO          ;sdruzena vystupni porucha
#srcline 331
  setx SigO           ;rozsvitit signalku
#srcline 332 ;  {END_ASM}
#srcline 333 ;  IF blikat THEN
 LDX  blikat
#debug bool blikat
 JMC  SigErr13_L101
#srcline 334 ;    SigO := %S13.2;   //blikani signalky v rastru 1s
 LD   %S13.2
 WRX  SigO
#debug_left bool SigO
#srcline 335 ;  END_IF;
SigErr13_L101:
#srcline 337 ;  //rizeni houkacky (a signalky)
#srcline 338 ;  AkuO := blikat OR akustika;    //akustika je zadost ze vstupniho kaskadovani
 LDX  blikat
#debug bool blikat
 LDX  akustika
#debug bool akustika
 OR  
 WRX  AkuO
#debug_left bool AkuO
#srcline 339 ;                                 //osetreni signalizace chyb pri zresetovani bez kvitace
#srcline 340 ;  IF Cfg.controlS = 0 THEN    //akustika i optika je v log.0
 LDX  Cfg~controlS
#debug usint Cfg.controlS
 LD   usint 0
 EQ
 JMC  SigErr13_L103
#srcline 341 ;    IF not SumO THEN AkuO := false; SigO := false; END_IF;
 LDX  SumO
#debug bool SumO
 NEG
 JMC  SigErr13_L105
 LD   bool 0       ; false
 WRX  AkuO
#debug_left bool AkuO
 LD   bool 0       ; false
 WRX  SigO
#debug_left bool SigO
SigErr13_L105:
#srcline 342 ;  END_IF;
SigErr13_L103:
#srcline 343 ;  IF Cfg.controlS = 1 THEN    //akustika je v log.0, optika blika
 LDX  Cfg~controlS
#debug usint Cfg.controlS
 LD   usint 1
 EQ
 JMC  SigErr13_L107
#srcline 344 ;    IF not SumO THEN AkuO := false; END_IF;
 LDX  SumO
#debug bool SumO
 NEG
 JMC  SigErr13_L109
 LD   bool 0       ; false
 WRX  AkuO
#debug_left bool AkuO
SigErr13_L109:
#srcline 345 ;  END_IF;
SigErr13_L107:
#srcline 346 ;  //IF Cfg.controlS = 2 THEN  //akustika je v log.1, opticka blika
#srcline 347 ;  //END_IF;                      //(funguje samo dle predchoziho algoritmu)
#srcline 349 ;  //pokracovani rizeni signalky
#srcline 350 ;  sdruzpor := false;           //jinak nefunguje blikani SigO pri kaskadovani
 LD   bool 0       ; false
 WRX  sdruzpor
#debug_left bool sdruzpor
#srcline 351 ;  pombit := blikat or SumO;
 LDX  blikat
#debug bool blikat
 LDX  SumO
#debug bool SumO
 OR  
 WRX  pombit
#debug_left bool pombit
#srcline 352 ;  SigO := (    sdruzpor AND     signalka AND not pombit AND not SigO) OR
 LDX  sdruzpor
#debug bool sdruzpor
 LDX  signalka
#debug bool signalka
 AND
 LDX  pombit
#debug bool pombit
 NEG
 AND
 LDX  SigO
#debug bool SigO
 NEG
 AND
#srcline 353 ;          (not sdruzpor AND not signalka AND     pombit AND     SigO) OR
 LDX  sdruzpor
#debug bool sdruzpor
 NEG
 LDX  signalka
#debug bool signalka
 NEG
 AND
 LDX  pombit
#debug bool pombit
 AND
 LDX  SigO
#debug bool SigO
 AND
 OR  
#srcline 354 ;          (    sdruzpor AND     signalka AND     pombit AND     SigO);
 LDX  sdruzpor
#debug bool sdruzpor
 LDX  signalka
#debug bool signalka
 AND
 LDX  pombit
#debug bool pombit
 AND
 LDX  SigO
#debug bool SigO
 AND
 OR  
 WRX  SigO
#debug_left bool SigO
#srcline 356 ;  // slozeni kaskadovaciho vystupu
#srcline 357 ;  sdruzpor := sdruzpor OR SumO;
 LDX  sdruzpor
#debug bool sdruzpor
 LDX  SumO
#debug bool SumO
 OR  
 WRX  sdruzpor
#debug_left bool sdruzpor
#srcline 358 ;  {ASM}
#srcline 359
  ldx   byte kvitace    ;cela osmice bitu
#srcline 360
  wrx   CasO            ;byte
#srcline 361 ;  {END_ASM}
#srcline 363 ;END_FUNCTION_BLOCK
 ULNK
RET
E     61
#endpou 



 

#srcfile ''
#srcfile 'D:\TECOAPP\KNIHOVNY\REGOLIB\SIGERR2.ST'
#pou SigErr2
#srcline 22 ;FUNCTION_BLOCK SigErr2
P     61
SigErr2_L0:
 LINK 0
#srcline 69 ;  IF Res THEN
 LDX  Res
#debug bool Res
 JMC  SigErr2_L1
#srcline 70 ;    EMax1 := false;   //nulovat poruchu od prekroceni maxima 1
 LD   bool 0       ; false
 WRX  EMax1
#debug_left bool EMax1
#srcline 71 ;    EMin1 := false;   //nulovat poruchu od podteceni  minima 1
 LD   bool 0       ; false
 WRX  EMin1
#debug_left bool EMin1
#srcline 72 ;    EMax2 := false;   //nulovat poruchu od prekroceni maxima 2
 LD   bool 0       ; false
 WRX  EMax2
#debug_left bool EMax2
#srcline 73 ;    EMin2 := false;   //nulovat poruchu od podteceni  minima 2
 LD   bool 0       ; false
 WRX  EMin2
#debug_left bool EMin2
#srcline 74 ;    EMax3 := false;   //nulovat poruchu od prekroceni maxima 3
 LD   bool 0       ; false
 WRX  EMax3
#debug_left bool EMax3
#srcline 75 ;    EMin3 := false;   //nulovat poruchu od podteceni  minima 3
 LD   bool 0       ; false
 WRX  EMin3
#debug_left bool EMin3
#srcline 76 ;    EMax4 := false;   //nulovat poruchu od prekroceni maxima 4
 LD   bool 0       ; false
 WRX  EMax4
#debug_left bool EMax4
#srcline 77 ;    EMin4 := false;   //nulovat poruchu od podteceni  minima 4
 LD   bool 0       ; false
 WRX  EMin4
#debug_left bool EMin4
#srcline 78 ;  END_IF;
SigErr2_L1:
#srcline 80 ;  // casovani a vyhodnoceni poruch
#srcline 81 ;  IF In1 > Cfg.PresetMax1 THEN EMax1 := true; END_IF;
 LDX  In1
#debug real In1
 LDX  Cfg~PresetMax1
#debug real Cfg.PresetMax1
 GTF
 JMC  SigErr2_L3
 LD   bool -1       ; true
 WRX  EMax1
#debug_left bool EMax1
SigErr2_L3:
#srcline 82 ;  IF In1 < Cfg.PresetMin1 THEN EMin1 := true; END_IF;
 LDX  In1
#debug real In1
 LDX  Cfg~PresetMin1
#debug real Cfg.PresetMin1
 LTF
 JMC  SigErr2_L5
 LD   bool -1       ; true
 WRX  EMin1
#debug_left bool EMin1
SigErr2_L5:
#srcline 83 ;  IF In2 > Cfg.PresetMax2 THEN EMax2 := true; END_IF;
 LDX  In2
#debug real In2
 LDX  Cfg~PresetMax2
#debug real Cfg.PresetMax2
 GTF
 JMC  SigErr2_L7
 LD   bool -1       ; true
 WRX  EMax2
#debug_left bool EMax2
SigErr2_L7:
#srcline 84 ;  IF In2 < Cfg.PresetMin2 THEN EMin2 := true; END_IF;
 LDX  In2
#debug real In2
 LDX  Cfg~PresetMin2
#debug real Cfg.PresetMin2
 LTF
 JMC  SigErr2_L9
 LD   bool -1       ; true
 WRX  EMin2
#debug_left bool EMin2
SigErr2_L9:
#srcline 85 ;  IF In3 > Cfg.PresetMax3 THEN EMax3 := true; END_IF;
 LDX  In3
#debug real In3
 LDX  Cfg~PresetMax3
#debug real Cfg.PresetMax3
 GTF
 JMC  SigErr2_L11
 LD   bool -1       ; true
 WRX  EMax3
#debug_left bool EMax3
SigErr2_L11:
#srcline 86 ;  IF In3 < Cfg.PresetMin3 THEN EMin3 := true; END_IF;
 LDX  In3
#debug real In3
 LDX  Cfg~PresetMin3
#debug real Cfg.PresetMin3
 LTF
 JMC  SigErr2_L13
 LD   bool -1       ; true
 WRX  EMin3
#debug_left bool EMin3
SigErr2_L13:
#srcline 87 ;  IF In4 > Cfg.PresetMax4 THEN EMax4 := true; END_IF;
 LDX  In4
#debug real In4
 LDX  Cfg~PresetMax4
#debug real Cfg.PresetMax4
 GTF
 JMC  SigErr2_L15
 LD   bool -1       ; true
 WRX  EMax4
#debug_left bool EMax4
SigErr2_L15:
#srcline 88 ;  IF In4 < Cfg.PresetMin4 THEN EMin4 := true; END_IF;
 LDX  In4
#debug real In4
 LDX  Cfg~PresetMin4
#debug real Cfg.PresetMin4
 LTF
 JMC  SigErr2_L17
 LD   bool -1       ; true
 WRX  EMin4
#debug_left bool EMin4
SigErr2_L17:
#srcline 90 ;  Timer[1](IN := EMax1, PT := Cfg.PresetTime1, Q => OutTim[1]);
 LDX  EMax1
#debug bool EMax1
 WRX  Timer[0]~IN
#debug_left bool Timer[0]~IN
 LDX  Cfg~PresetTime1
#debug time Cfg.PresetTime1
 WRX  Timer[0]~PT
#debug_left time Timer[0]~PT
 LEAX Timer
 CAL  TON_L0
; output assigment 
 LDX  Timer[0]~Q
#debug bool Timer[0]~Q
 WRX  OutTim[0]
#debug_left bool OutTim[1]
#srcline 91 ;  Timer[2](IN := EMin1, PT := Cfg.PresetTime1, Q => OutTim[2]);
 LDX  EMin1
#debug bool EMin1
 WRX  Timer[1]~IN
#debug_left bool Timer[1]~IN
 LDX  Cfg~PresetTime1
#debug time Cfg.PresetTime1
 WRX  Timer[1]~PT
#debug_left time Timer[1]~PT
 LEAX Timer
 ADD  15  ; + offset 
 CAL  TON_L0
; output assigment 
 LDX  Timer[1]~Q
#debug bool Timer[1]~Q
 WRX  OutTim[1]
#debug_left bool OutTim[2]
#srcline 92 ;  Timer[3](IN := EMax2, PT := Cfg.PresetTime2, Q => OutTim[3]);
 LDX  EMax2
#debug bool EMax2
 WRX  Timer[2]~IN
#debug_left bool Timer[2]~IN
 LDX  Cfg~PresetTime2
#debug time Cfg.PresetTime2
 WRX  Timer[2]~PT
#debug_left time Timer[2]~PT
 LEAX Timer
 ADD  30  ; + offset 
 CAL  TON_L0
; output assigment 
 LDX  Timer[2]~Q
#debug bool Timer[2]~Q
 WRX  OutTim[2]
#debug_left bool OutTim[3]
#srcline 93 ;  Timer[4](IN := EMin2, PT := Cfg.PresetTime2, Q => OutTim[4]);
 LDX  EMin2
#debug bool EMin2
 WRX  Timer[3]~IN
#debug_left bool Timer[3]~IN
 LDX  Cfg~PresetTime2
#debug time Cfg.PresetTime2
 WRX  Timer[3]~PT
#debug_left time Timer[3]~PT
 LEAX Timer
 ADD  45  ; + offset 
 CAL  TON_L0
; output assigment 
 LDX  Timer[3]~Q
#debug bool Timer[3]~Q
 WRX  OutTim[3]
#debug_left bool OutTim[4]
#srcline 94 ;  Timer[5](IN := EMax3, PT := Cfg.PresetTime3, Q => OutTim[5]);
 LDX  EMax3
#debug bool EMax3
 WRX  Timer[4]~IN
#debug_left bool Timer[4]~IN
 LDX  Cfg~PresetTime3
#debug time Cfg.PresetTime3
 WRX  Timer[4]~PT
#debug_left time Timer[4]~PT
 LEAX Timer
 ADD  60  ; + offset 
 CAL  TON_L0
; output assigment 
 LDX  Timer[4]~Q
#debug bool Timer[4]~Q
 WRX  OutTim[4]
#debug_left bool OutTim[5]
#srcline 95 ;  Timer[6](IN := EMin3, PT := Cfg.PresetTime3, Q => OutTim[6]);
 LDX  EMin3
#debug bool EMin3
 WRX  Timer[5]~IN
#debug_left bool Timer[5]~IN
 LDX  Cfg~PresetTime3
#debug time Cfg.PresetTime3
 WRX  Timer[5]~PT
#debug_left time Timer[5]~PT
 LEAX Timer
 ADD  75  ; + offset 
 CAL  TON_L0
; output assigment 
 LDX  Timer[5]~Q
#debug bool Timer[5]~Q
 WRX  OutTim[5]
#debug_left bool OutTim[6]
#srcline 96 ;  Timer[7](IN := EMax4, PT := Cfg.PresetTime4, Q => OutTim[7]);
 LDX  EMax4
#debug bool EMax4
 WRX  Timer[6]~IN
#debug_left bool Timer[6]~IN
 LDX  Cfg~PresetTime4
#debug time Cfg.PresetTime4
 WRX  Timer[6]~PT
#debug_left time Timer[6]~PT
 LEAX Timer
 ADD  90  ; + offset 
 CAL  TON_L0
; output assigment 
 LDX  Timer[6]~Q
#debug bool Timer[6]~Q
 WRX  OutTim[6]
#debug_left bool OutTim[7]
#srcline 97 ;  Timer[8](IN := EMin4, PT := Cfg.PresetTime4, Q => OutTim[8]);
 LDX  EMin4
#debug bool EMin4
 WRX  Timer[7]~IN
#debug_left bool Timer[7]~IN
 LDX  Cfg~PresetTime4
#debug time Cfg.PresetTime4
 WRX  Timer[7]~PT
#debug_left time Timer[7]~PT
 LEAX Timer
 ADD  105  ; + offset 
 CAL  TON_L0
; output assigment 
 LDX  Timer[7]~Q
#debug bool Timer[7]~Q
 WRX  OutTim[7]
#debug_left bool OutTim[8]
#srcline 99 ;  EMax1 := OutTim[1]; //po docasovani citace hlasit poruchu maxima
 LDX  OutTim[0]
#debug bool OutTim[1]
 WRX  EMax1
#debug_left bool EMax1
#srcline 100 ;  EMin1 := OutTim[2]; //po docasovani citace hlasit poruchu minima
 LDX  OutTim[1]
#debug bool OutTim[2]
 WRX  EMin1
#debug_left bool EMin1
#srcline 101 ;  EMax2 := OutTim[3]; //po docasovani citace hlasit poruchu maxima
 LDX  OutTim[2]
#debug bool OutTim[3]
 WRX  EMax2
#debug_left bool EMax2
#srcline 102 ;  EMin2 := OutTim[4]; //po docasovani citace hlasit poruchu minima
 LDX  OutTim[3]
#debug bool OutTim[4]
 WRX  EMin2
#debug_left bool EMin2
#srcline 103 ;  EMax3 := OutTim[5]; //po docasovani citace hlasit poruchu maxima
 LDX  OutTim[4]
#debug bool OutTim[5]
 WRX  EMax3
#debug_left bool EMax3
#srcline 104 ;  EMin3 := OutTim[6]; //po docasovani citace hlasit poruchu minima
 LDX  OutTim[5]
#debug bool OutTim[6]
 WRX  EMin3
#debug_left bool EMin3
#srcline 105 ;  EMax4 := OutTim[7]; //po docasovani citace hlasit poruchu maxima
 LDX  OutTim[6]
#debug bool OutTim[7]
 WRX  EMax4
#debug_left bool EMax4
#srcline 106 ;  EMin4 := OutTim[8]; //po docasovani citace hlasit poruchu minima
 LDX  OutTim[7]
#debug bool OutTim[8]
 WRX  EMin4
#debug_left bool EMin4
#srcline 107 ;  
#srcline 108 ;  {ASM}
#srcline 109
  ldx  byte OutTim[1]     ;cela osmice priznaku
#srcline 110
  letx byte LET[1]        ;cela osmice priznaku
#srcline 111
  setx blikat             ;pri vzniku nove chyby zacit blikat signalkou
#srcline 112 ;  {END_ASM}
#srcline 114 ;  //kvitace
#srcline 115 ;  IF Ack THEN blikat := false; END_IF;  //prestat blikat signalkou
 LDX  Ack
#debug bool Ack
 JMC  SigErr2_L19
 LD   bool 0       ; false
 WRX  blikat
#debug_left bool blikat
SigErr2_L19:
#srcline 116 ;  
#srcline 117 ;  // rizeni signalky
#srcline 118 ;  Sum :=    EMax1 OR EMin1 OR   //zdruzena porucha
 LDX  EMax1
#debug bool EMax1
 LDX  EMin1
#debug bool EMin1
 OR  
#srcline 119 ;            EMax2 OR EMin2 OR
 LDX  EMax2
#debug bool EMax2
 OR  
 LDX  EMin2
#debug bool EMin2
 OR  
#srcline 120 ;            EMax3 OR EMin3 OR
 LDX  EMax3
#debug bool EMax3
 OR  
 LDX  EMin3
#debug bool EMin3
 OR  
#srcline 121 ;            EMax4 OR EMin4;
 LDX  EMax4
#debug bool EMax4
 OR  
 LDX  EMin4
#debug bool EMin4
 OR  
 WRX  Sum
#debug_left bool Sum
#srcline 122 ;  Sig := Sum;     //stav signalky pro pripad, ze neblika
 LDX  Sum
#debug bool Sum
 WRX  Sig
#debug_left bool Sig
#srcline 123 ;  
#srcline 124 ;  IF blikat THEN
 LDX  blikat
#debug bool blikat
 JMC  SigErr2_L21
#srcline 125 ;    Sig := %S13.2;   //blikani signalky v rastru 1s
 LD   %S13.2
 WRX  Sig
#debug_left bool Sig
#srcline 126 ;  END_IF;
SigErr2_L21:
#srcline 127 ;  
#srcline 128 ;END_FUNCTION_BLOCK
 ULNK
RET
E     61
#endpou 



 

#srcfile ''
#srcfile 'D:\TECOAPP\KNIHOVNY\REGOLIB\SIGERR21.ST'
#pou SigErr21
#srcline 22 ;FUNCTION_BLOCK SigErr21
P     61
SigErr21_L0:
 LINK 0
#srcline 89 ;  IF Res THEN
 LDX  Res
#debug bool Res
 JMC  SigErr21_L1
#srcline 90 ;    EMax1 := false;   //nulovat poruchu od prekroceni maxima
 LD   bool 0       ; false
 WRX  EMax1
#debug_left bool EMax1
#srcline 91 ;    EMin1 := false;   //nulovat poruchu od podteceni  minima
 LD   bool 0       ; false
 WRX  EMin1
#debug_left bool EMin1
#srcline 92 ;    EMax2 := false;   //nulovat poruchu od prekroceni maxima
 LD   bool 0       ; false
 WRX  EMax2
#debug_left bool EMax2
#srcline 93 ;    EMin2 := false;   //nulovat poruchu od podteceni  minima
 LD   bool 0       ; false
 WRX  EMin2
#debug_left bool EMin2
#srcline 94 ;    EMax3 := false;   //nulovat poruchu od prekroceni maxima
 LD   bool 0       ; false
 WRX  EMax3
#debug_left bool EMax3
#srcline 95 ;    EMin3 := false;   //nulovat poruchu od podteceni  minima
 LD   bool 0       ; false
 WRX  EMin3
#debug_left bool EMin3
#srcline 96 ;    EMax4 := false;   //nulovat poruchu od prekroceni maxima
 LD   bool 0       ; false
 WRX  EMax4
#debug_left bool EMax4
#srcline 97 ;    EMin4 := false;   //nulovat poruchu od podteceni  minima
 LD   bool 0       ; false
 WRX  EMin4
#debug_left bool EMin4
#srcline 98 ;  END_IF;
SigErr21_L1:
#srcline 100 ;  // casovani a vyhodnoceni poruch
#srcline 101 ;  //.......................... vstup 1 .................................
#srcline 102 ;  IF In1 > Cfg.PresetMax1 THEN EMax1 := true; END_IF;
 LDX  In1
#debug real In1
 LDX  Cfg~PresetMax1
#debug real Cfg.PresetMax1
 GTF
 JMC  SigErr21_L3
 LD   bool -1       ; true
 WRX  EMax1
#debug_left bool EMax1
SigErr21_L3:
#srcline 103 ;  Timer1(IN := EMax1, PT := Cfg.PresetTime1, Q => EMax1);
 LDX  EMax1
#debug bool EMax1
 WRX  Timer1~IN
#debug_left bool Timer1~IN
 LDX  Cfg~PresetTime1
#debug time Cfg.PresetTime1
 WRX  Timer1~PT
#debug_left time Timer1~PT
 LEAX Timer1
 CAL  TON_L0
; output assigment 
 LDX  Timer1~Q
#debug bool Timer1~Q
 WRX  EMax1
#debug_left bool EMax1
#srcline 104 ;  {ASM}
#srcline 105
  ldx   EMax1;
#srcline 106
  letx  LET1;
#srcline 107
  setx  blikat;
#srcline 108
  wr    %s1.0;
#srcline 109
  ld    1;
#srcline 110
  putx  ErrC;
#srcline 111
  js    __SE21_newerr__;
#srcline 112 ;  {END_ASM}
#srcline 113 ;  IF In1 < Cfg.PresetMin1 THEN EMin1 := true; END_IF;
 LDX  In1
#debug real In1
 LDX  Cfg~PresetMin1
#debug real Cfg.PresetMin1
 LTF
 JMC  SigErr21_L5
 LD   bool -1       ; true
 WRX  EMin1
#debug_left bool EMin1
SigErr21_L5:
#srcline 114 ;  Timer2(IN := EMin1, PT := Cfg.PresetTime1, Q => EMin1);
 LDX  EMin1
#debug bool EMin1
 WRX  Timer2~IN
#debug_left bool Timer2~IN
 LDX  Cfg~PresetTime1
#debug time Cfg.PresetTime1
 WRX  Timer2~PT
#debug_left time Timer2~PT
 LEAX Timer2
 CAL  TON_L0
; output assigment 
 LDX  Timer2~Q
#debug bool Timer2~Q
 WRX  EMin1
#debug_left bool EMin1
#srcline 115 ;  {ASM}
#srcline 116
  ldx   EMin1
#srcline 117
  letx  LET2;
#srcline 118
  setx  blikat;
#srcline 119
  wr    %s1.0;
#srcline 120
  ld    2;
#srcline 121
  putx  ErrC;
#srcline 122
  js    __SE21_newerr__;
#srcline 123 ;  {END_ASM}
#srcline 124 ;  //.......................... vstup 2 .................................
#srcline 125 ;  IF In2 > Cfg.PresetMax2 THEN EMax2 := true; END_IF;
 LDX  In2
#debug real In2
 LDX  Cfg~PresetMax2
#debug real Cfg.PresetMax2
 GTF
 JMC  SigErr21_L7
 LD   bool -1       ; true
 WRX  EMax2
#debug_left bool EMax2
SigErr21_L7:
#srcline 126 ;  Timer3(IN := EMax2, PT := Cfg.PresetTime2, Q => EMax2);
 LDX  EMax2
#debug bool EMax2
 WRX  Timer3~IN
#debug_left bool Timer3~IN
 LDX  Cfg~PresetTime2
#debug time Cfg.PresetTime2
 WRX  Timer3~PT
#debug_left time Timer3~PT
 LEAX Timer3
 CAL  TON_L0
; output assigment 
 LDX  Timer3~Q
#debug bool Timer3~Q
 WRX  EMax2
#debug_left bool EMax2
#srcline 127 ;  {ASM}
#srcline 128
  ldx   EMax2;
#srcline 129
  letx  LET3;
#srcline 130
  setx  blikat;
#srcline 131
  wr    %s1.0;
#srcline 132
  ld    3;
#srcline 133
  putx  ErrC;
#srcline 134
  js    __SE21_newerr__;
#srcline 135 ;  {END_ASM}
#srcline 136 ;  IF In2 < Cfg.PresetMin2 THEN EMin2 := true; END_IF;
 LDX  In2
#debug real In2
 LDX  Cfg~PresetMin2
#debug real Cfg.PresetMin2
 LTF
 JMC  SigErr21_L9
 LD   bool -1       ; true
 WRX  EMin2
#debug_left bool EMin2
SigErr21_L9:
#srcline 137 ;  Timer4(IN := EMin2, PT := Cfg.PresetTime2, Q => EMin2);
 LDX  EMin2
#debug bool EMin2
 WRX  Timer4~IN
#debug_left bool Timer4~IN
 LDX  Cfg~PresetTime2
#debug time Cfg.PresetTime2
 WRX  Timer4~PT
#debug_left time Timer4~PT
 LEAX Timer4
 CAL  TON_L0
; output assigment 
 LDX  Timer4~Q
#debug bool Timer4~Q
 WRX  EMin2
#debug_left bool EMin2
#srcline 138 ;  {ASM}
#srcline 139
  ldx   EMin2
#srcline 140
  letx  LET4;
#srcline 141
  setx  blikat;
#srcline 142
  wr    %s1.0;
#srcline 143
  ld    4;
#srcline 144
  putx  ErrC;
#srcline 145
  js    __SE21_newerr__;
#srcline 146 ;  {END_ASM}
#srcline 147 ;  //.......................... vstup 3 .................................
#srcline 148 ;  IF In3 > Cfg.PresetMax3 THEN EMax3 := true; END_IF;
 LDX  In3
#debug real In3
 LDX  Cfg~PresetMax3
#debug real Cfg.PresetMax3
 GTF
 JMC  SigErr21_L11
 LD   bool -1       ; true
 WRX  EMax3
#debug_left bool EMax3
SigErr21_L11:
#srcline 149 ;  Timer5(IN := EMax3, PT := Cfg.PresetTime3, Q => EMax3);
 LDX  EMax3
#debug bool EMax3
 WRX  Timer5~IN
#debug_left bool Timer5~IN
 LDX  Cfg~PresetTime3
#debug time Cfg.PresetTime3
 WRX  Timer5~PT
#debug_left time Timer5~PT
 LEAX Timer5
 CAL  TON_L0
; output assigment 
 LDX  Timer5~Q
#debug bool Timer5~Q
 WRX  EMax3
#debug_left bool EMax3
#srcline 150 ;  {ASM}
#srcline 151
  ldx   EMax3;
#srcline 152
  letx  LET5;
#srcline 153
  setx  blikat;
#srcline 154
  wr    %s1.0;
#srcline 155
  ld    5;
#srcline 156
  putx  ErrC;
#srcline 157
  js    __SE21_newerr__;
#srcline 158 ;  {END_ASM}
#srcline 159 ;  IF In3 < Cfg.PresetMin3 THEN EMin3 := true; END_IF;
 LDX  In3
#debug real In3
 LDX  Cfg~PresetMin3
#debug real Cfg.PresetMin3
 LTF
 JMC  SigErr21_L13
 LD   bool -1       ; true
 WRX  EMin3
#debug_left bool EMin3
SigErr21_L13:
#srcline 160 ;  Timer6(IN := EMin3, PT := Cfg.PresetTime3, Q => EMin3);
 LDX  EMin3
#debug bool EMin3
 WRX  Timer6~IN
#debug_left bool Timer6~IN
 LDX  Cfg~PresetTime3
#debug time Cfg.PresetTime3
 WRX  Timer6~PT
#debug_left time Timer6~PT
 LEAX Timer6
 CAL  TON_L0
; output assigment 
 LDX  Timer6~Q
#debug bool Timer6~Q
 WRX  EMin3
#debug_left bool EMin3
#srcline 161 ;  {ASM}
#srcline 162
  ldx   EMin3
#srcline 163
  letx  LET6;
#srcline 164
  setx  blikat;
#srcline 165
  wr    %s1.0;
#srcline 166
  ld    6;
#srcline 167
  putx  ErrC;
#srcline 168
  js    __SE21_newerr__;
#srcline 169 ;  {END_ASM}
#srcline 170 ;  //.......................... vstup 4 .................................
#srcline 171 ;  IF In4 > Cfg.PresetMax4 THEN EMax4 := true; END_IF;
 LDX  In4
#debug real In4
 LDX  Cfg~PresetMax4
#debug real Cfg.PresetMax4
 GTF
 JMC  SigErr21_L15
 LD   bool -1       ; true
 WRX  EMax4
#debug_left bool EMax4
SigErr21_L15:
#srcline 172 ;  Timer7(IN := EMax4, PT := Cfg.PresetTime4, Q => EMax4);
 LDX  EMax4
#debug bool EMax4
 WRX  Timer7~IN
#debug_left bool Timer7~IN
 LDX  Cfg~PresetTime4
#debug time Cfg.PresetTime4
 WRX  Timer7~PT
#debug_left time Timer7~PT
 LEAX Timer7
 CAL  TON_L0
; output assigment 
 LDX  Timer7~Q
#debug bool Timer7~Q
 WRX  EMax4
#debug_left bool EMax4
#srcline 173 ;  {ASM}
#srcline 174
  ldx   EMax4;
#srcline 175
  letx  LET7;
#srcline 176
  setx  blikat;
#srcline 177
  wr    %s1.0;
#srcline 178
  ld    7;
#srcline 179
  putx  ErrC;
#srcline 180
  js    __SE21_newerr__;
#srcline 181 ;  {END_ASM}
#srcline 182 ;  IF In4 < Cfg.PresetMin4 THEN EMin4 := true; END_IF;
 LDX  In4
#debug real In4
 LDX  Cfg~PresetMin4
#debug real Cfg.PresetMin4
 LTF
 JMC  SigErr21_L17
 LD   bool -1       ; true
 WRX  EMin4
#debug_left bool EMin4
SigErr21_L17:
#srcline 183 ;  Timer8(IN := EMin4, PT := Cfg.PresetTime4, Q => EMin4);
 LDX  EMin4
#debug bool EMin4
 WRX  Timer8~IN
#debug_left bool Timer8~IN
 LDX  Cfg~PresetTime4
#debug time Cfg.PresetTime4
 WRX  Timer8~PT
#debug_left time Timer8~PT
 LEAX Timer8
 CAL  TON_L0
; output assigment 
 LDX  Timer8~Q
#debug bool Timer8~Q
 WRX  EMin4
#debug_left bool EMin4
#srcline 184 ;  {ASM}
#srcline 185
  ldx   EMin4
#srcline 186
  letx  LET8;
#srcline 187
  setx  blikat;
#srcline 188
  wr    %s1.0;
#srcline 189
  ld    8;
#srcline 190
  putx  ErrC;
#srcline 191
  __SE21_newerr__:
#srcline 192 ;  {END_ASM}
#srcline 193 ;  //....................................................................
#srcline 195 ;  // kvitace poruch
#srcline 196 ;  IF ACK THEN blikat := false; END_IF;  //prestat blikat signalkou
 LDX  ACK
#debug bool ACK
 JMC  SigErr21_L19
 LD   bool 0       ; false
 WRX  blikat
#debug_left bool blikat
SigErr21_L19:
#srcline 198 ;  // rizeni signalky
#srcline 199 ;  {ASM}
#srcline 200
  ldx byte EMax1    ;cela osmice
#srcline 201
  wrx Sum
#srcline 202
  wrx Sig
#srcline 203 ;  {END_ASM}
#srcline 204 ;  IF blikat THEN
 LDX  blikat
#debug bool blikat
 JMC  SigErr21_L21
#srcline 205 ;    Sig := %S13.2;   //blikani signalky v rastru 1s
 LD   %S13.2
 WRX  Sig
#debug_left bool Sig
#srcline 206 ;  END_IF;
SigErr21_L21:
#srcline 208 ;  //nulovani cisla poruchy (neaktivni poruchy)
#srcline 209 ;  IF Res THEN
 LDX  Res
#debug bool Res
 JMC  SigErr21_L23
#srcline 210 ;    IF not EMax1 AND ErrC = 1 THEN ErrC := 0; END_IF;
 LDX  EMax1
#debug bool EMax1
 NEG
 LDX  ErrC
#debug usint ErrC
 LD   usint 1
 EQ
 AND
 JMC  SigErr21_L25
 LD   usint 0
 WRX  ErrC
#debug_left usint ErrC
SigErr21_L25:
#srcline 211 ;    IF not EMin1 AND ErrC = 2 THEN ErrC := 0; END_IF;
 LDX  EMin1
#debug bool EMin1
 NEG
 LDX  ErrC
#debug usint ErrC
 LD   usint 2
 EQ
 AND
 JMC  SigErr21_L27
 LD   usint 0
 WRX  ErrC
#debug_left usint ErrC
SigErr21_L27:
#srcline 212 ;    IF not EMax2 AND ErrC = 3 THEN ErrC := 0; END_IF;
 LDX  EMax2
#debug bool EMax2
 NEG
 LDX  ErrC
#debug usint ErrC
 LD   usint 3
 EQ
 AND
 JMC  SigErr21_L29
 LD   usint 0
 WRX  ErrC
#debug_left usint ErrC
SigErr21_L29:
#srcline 213 ;    IF not EMin2 AND ErrC = 4 THEN ErrC := 0; END_IF;
 LDX  EMin2
#debug bool EMin2
 NEG
 LDX  ErrC
#debug usint ErrC
 LD   usint 4
 EQ
 AND
 JMC  SigErr21_L31
 LD   usint 0
 WRX  ErrC
#debug_left usint ErrC
SigErr21_L31:
#srcline 214 ;    IF not EMax3 AND ErrC = 5 THEN ErrC := 0; END_IF;
 LDX  EMax3
#debug bool EMax3
 NEG
 LDX  ErrC
#debug usint ErrC
 LD   usint 5
 EQ
 AND
 JMC  SigErr21_L33
 LD   usint 0
 WRX  ErrC
#debug_left usint ErrC
SigErr21_L33:
#srcline 215 ;    IF not EMin3 AND ErrC = 6 THEN ErrC := 0; END_IF;
 LDX  EMin3
#debug bool EMin3
 NEG
 LDX  ErrC
#debug usint ErrC
 LD   usint 6
 EQ
 AND
 JMC  SigErr21_L35
 LD   usint 0
 WRX  ErrC
#debug_left usint ErrC
SigErr21_L35:
#srcline 216 ;    IF not EMax4 AND ErrC = 7 THEN ErrC := 0; END_IF;
 LDX  EMax4
#debug bool EMax4
 NEG
 LDX  ErrC
#debug usint ErrC
 LD   usint 7
 EQ
 AND
 JMC  SigErr21_L37
 LD   usint 0
 WRX  ErrC
#debug_left usint ErrC
SigErr21_L37:
#srcline 217 ;    IF not EMin4 AND ErrC = 8 THEN ErrC := 0; END_IF;
 LDX  EMin4
#debug bool EMin4
 NEG
 LDX  ErrC
#debug usint ErrC
 LD   usint 8
 EQ
 AND
 JMC  SigErr21_L39
 LD   usint 0
 WRX  ErrC
#debug_left usint ErrC
SigErr21_L39:
#srcline 218 ;  END_IF;
SigErr21_L23:
#srcline 220 ;END_FUNCTION_BLOCK
 ULNK
RET
E     61
#endpou 



 

#srcfile ''
#srcfile 'D:\TECOAPP\KNIHOVNY\REGOLIB\SIGERR22.ST'
#pou SigErr22
#srcline 22 ;FUNCTION_BLOCK SigErr22
P     61
SigErr22_L0:
 LINK 0
#srcline 94 ;  IF ResI THEN
 LDX  ResI
#debug bool ResI
 JMC  SigErr22_L1
#srcline 95 ;    EMax1 := false;   //nulovat poruchu od prekroceni maxima
 LD   bool 0       ; false
 WRX  EMax1
#debug_left bool EMax1
#srcline 96 ;    EMin1 := false;   //nulovat poruchu od podteceni  minima
 LD   bool 0       ; false
 WRX  EMin1
#debug_left bool EMin1
#srcline 97 ;    EMax2 := false;   //nulovat poruchu od prekroceni maxima
 LD   bool 0       ; false
 WRX  EMax2
#debug_left bool EMax2
#srcline 98 ;    EMin2 := false;   //nulovat poruchu od podteceni  minima
 LD   bool 0       ; false
 WRX  EMin2
#debug_left bool EMin2
#srcline 99 ;    EMax3 := false;   //nulovat poruchu od prekroceni maxima
 LD   bool 0       ; false
 WRX  EMax3
#debug_left bool EMax3
#srcline 100 ;    EMin3 := false;   //nulovat poruchu od podteceni  minima
 LD   bool 0       ; false
 WRX  EMin3
#debug_left bool EMin3
#srcline 101 ;    EMax4 := false;   //nulovat poruchu od prekroceni maxima
 LD   bool 0       ; false
 WRX  EMax4
#debug_left bool EMax4
#srcline 102 ;    EMin4 := false;   //nulovat poruchu od podteceni  minima
 LD   bool 0       ; false
 WRX  EMin4
#debug_left bool EMin4
#srcline 103 ;  END_IF;
SigErr22_L1:
#srcline 105 ;  // casovani a vyhodnoceni poruch
#srcline 106 ;  //.......................... vstup 1 .................................
#srcline 107 ;  IF In1 > Cfg.PresetMax1 THEN EMax1 := true; END_IF;
 LDX  In1
#debug real In1
 LDX  Cfg~PresetMax1
#debug real Cfg.PresetMax1
 GTF
 JMC  SigErr22_L3
 LD   bool -1       ; true
 WRX  EMax1
#debug_left bool EMax1
SigErr22_L3:
#srcline 108 ;  Timer1(IN := EMax1, PT := Cfg.PresetTime1, Q => EMax1);
 LDX  EMax1
#debug bool EMax1
 WRX  Timer1~IN
#debug_left bool Timer1~IN
 LDX  Cfg~PresetTime1
#debug time Cfg.PresetTime1
 WRX  Timer1~PT
#debug_left time Timer1~PT
 LEAX Timer1
 CAL  TON_L0
; output assigment 
 LDX  Timer1~Q
#debug bool Timer1~Q
 WRX  EMax1
#debug_left bool EMax1
#srcline 109 ;  {ASM}
#srcline 110
  ldx   EMax1;
#srcline 111
  letx  LET1;
#srcline 112
  setx  blikat;
#srcline 113
  wr    %s1.0;
#srcline 114
  ld    1;
#srcline 115
  putx  ErrC;
#srcline 116
  js    __SE22_newerr__;
#srcline 117 ;  {END_ASM}
#srcline 118 ;  IF In1 < Cfg.PresetMin1 THEN EMin1 := true; END_IF;
 LDX  In1
#debug real In1
 LDX  Cfg~PresetMin1
#debug real Cfg.PresetMin1
 LTF
 JMC  SigErr22_L5
 LD   bool -1       ; true
 WRX  EMin1
#debug_left bool EMin1
SigErr22_L5:
#srcline 119 ;  Timer2(IN := EMin1, PT := Cfg.PresetTime1, Q => EMin1);
 LDX  EMin1
#debug bool EMin1
 WRX  Timer2~IN
#debug_left bool Timer2~IN
 LDX  Cfg~PresetTime1
#debug time Cfg.PresetTime1
 WRX  Timer2~PT
#debug_left time Timer2~PT
 LEAX Timer2
 CAL  TON_L0
; output assigment 
 LDX  Timer2~Q
#debug bool Timer2~Q
 WRX  EMin1
#debug_left bool EMin1
#srcline 120 ;  {ASM}
#srcline 121
  ldx   EMin1
#srcline 122
  letx  LET2;
#srcline 123
  setx  blikat;
#srcline 124
  wr    %s1.0;
#srcline 125
  ld    2;
#srcline 126
  putx  ErrC;
#srcline 127
  js    __SE22_newerr__;
#srcline 128 ;  {END_ASM}
#srcline 129 ;  //.......................... vstup 2 .................................
#srcline 130 ;  IF In2 > Cfg.PresetMax2 THEN EMax2 := true; END_IF;
 LDX  In2
#debug real In2
 LDX  Cfg~PresetMax2
#debug real Cfg.PresetMax2
 GTF
 JMC  SigErr22_L7
 LD   bool -1       ; true
 WRX  EMax2
#debug_left bool EMax2
SigErr22_L7:
#srcline 131 ;  Timer3(IN := EMax2, PT := Cfg.PresetTime2, Q => EMax2);
 LDX  EMax2
#debug bool EMax2
 WRX  Timer3~IN
#debug_left bool Timer3~IN
 LDX  Cfg~PresetTime2
#debug time Cfg.PresetTime2
 WRX  Timer3~PT
#debug_left time Timer3~PT
 LEAX Timer3
 CAL  TON_L0
; output assigment 
 LDX  Timer3~Q
#debug bool Timer3~Q
 WRX  EMax2
#debug_left bool EMax2
#srcline 132 ;  {ASM}
#srcline 133
  ldx   EMax2;
#srcline 134
  letx  LET3;
#srcline 135
  setx  blikat;
#srcline 136
  wr    %s1.0;
#srcline 137
  ld    3;
#srcline 138
  putx  ErrC;
#srcline 139
  js    __SE22_newerr__;
#srcline 140 ;  {END_ASM}
#srcline 141 ;  IF In2 < Cfg.PresetMin2 THEN EMin2 := true; END_IF;
 LDX  In2
#debug real In2
 LDX  Cfg~PresetMin2
#debug real Cfg.PresetMin2
 LTF
 JMC  SigErr22_L9
 LD   bool -1       ; true
 WRX  EMin2
#debug_left bool EMin2
SigErr22_L9:
#srcline 142 ;  Timer4(IN := EMin2, PT := Cfg.PresetTime2, Q => EMin2);
 LDX  EMin2
#debug bool EMin2
 WRX  Timer4~IN
#debug_left bool Timer4~IN
 LDX  Cfg~PresetTime2
#debug time Cfg.PresetTime2
 WRX  Timer4~PT
#debug_left time Timer4~PT
 LEAX Timer4
 CAL  TON_L0
; output assigment 
 LDX  Timer4~Q
#debug bool Timer4~Q
 WRX  EMin2
#debug_left bool EMin2
#srcline 143 ;  {ASM}
#srcline 144
  ldx   EMin2
#srcline 145
  letx  LET4;
#srcline 146
  setx  blikat;
#srcline 147
  wr    %s1.0;
#srcline 148
  ld    4;
#srcline 149
  putx  ErrC;
#srcline 150
  js    __SE22_newerr__;
#srcline 151 ;  {END_ASM}
#srcline 152 ;  //.......................... vstup 3 .................................
#srcline 153 ;  IF In3 > Cfg.PresetMax3 THEN EMax3 := true; END_IF;
 LDX  In3
#debug real In3
 LDX  Cfg~PresetMax3
#debug real Cfg.PresetMax3
 GTF
 JMC  SigErr22_L11
 LD   bool -1       ; true
 WRX  EMax3
#debug_left bool EMax3
SigErr22_L11:
#srcline 154 ;  Timer5(IN := EMax3, PT := Cfg.PresetTime3, Q => EMax3);
 LDX  EMax3
#debug bool EMax3
 WRX  Timer5~IN
#debug_left bool Timer5~IN
 LDX  Cfg~PresetTime3
#debug time Cfg.PresetTime3
 WRX  Timer5~PT
#debug_left time Timer5~PT
 LEAX Timer5
 CAL  TON_L0
; output assigment 
 LDX  Timer5~Q
#debug bool Timer5~Q
 WRX  EMax3
#debug_left bool EMax3
#srcline 155 ;  {ASM}
#srcline 156
  ldx   EMax3;
#srcline 157
  letx  LET5;
#srcline 158
  setx  blikat;
#srcline 159
  wr    %s1.0;
#srcline 160
  ld    5;
#srcline 161
  putx  ErrC;
#srcline 162
  js    __SE22_newerr__;
#srcline 163 ;  {END_ASM}
#srcline 164 ;  IF In3 < Cfg.PresetMin3 THEN EMin3 := true; END_IF;
 LDX  In3
#debug real In3
 LDX  Cfg~PresetMin3
#debug real Cfg.PresetMin3
 LTF
 JMC  SigErr22_L13
 LD   bool -1       ; true
 WRX  EMin3
#debug_left bool EMin3
SigErr22_L13:
#srcline 165 ;  Timer6(IN := EMin3, PT := Cfg.PresetTime3, Q => EMin3);
 LDX  EMin3
#debug bool EMin3
 WRX  Timer6~IN
#debug_left bool Timer6~IN
 LDX  Cfg~PresetTime3
#debug time Cfg.PresetTime3
 WRX  Timer6~PT
#debug_left time Timer6~PT
 LEAX Timer6
 CAL  TON_L0
; output assigment 
 LDX  Timer6~Q
#debug bool Timer6~Q
 WRX  EMin3
#debug_left bool EMin3
#srcline 166 ;  {ASM}
#srcline 167
  ldx   EMin3
#srcline 168
  letx  LET6;
#srcline 169
  setx  blikat;
#srcline 170
  wr    %s1.0;
#srcline 171
  ld    6;
#srcline 172
  putx  ErrC;
#srcline 173
  js    __SE22_newerr__;
#srcline 174 ;  {END_ASM}
#srcline 175 ;  //.......................... vstup 4 .................................
#srcline 176 ;  IF In4 > Cfg.PresetMax4 THEN EMax4 := true; END_IF;
 LDX  In4
#debug real In4
 LDX  Cfg~PresetMax4
#debug real Cfg.PresetMax4
 GTF
 JMC  SigErr22_L15
 LD   bool -1       ; true
 WRX  EMax4
#debug_left bool EMax4
SigErr22_L15:
#srcline 177 ;  Timer7(IN := EMax4, PT := Cfg.PresetTime4, Q => EMax4);
 LDX  EMax4
#debug bool EMax4
 WRX  Timer7~IN
#debug_left bool Timer7~IN
 LDX  Cfg~PresetTime4
#debug time Cfg.PresetTime4
 WRX  Timer7~PT
#debug_left time Timer7~PT
 LEAX Timer7
 CAL  TON_L0
; output assigment 
 LDX  Timer7~Q
#debug bool Timer7~Q
 WRX  EMax4
#debug_left bool EMax4
#srcline 178 ;  {ASM}
#srcline 179
  ldx   EMax4;
#srcline 180
  letx  LET7;
#srcline 181
  setx  blikat;
#srcline 182
  wr    %s1.0;
#srcline 183
  ld    7;
#srcline 184
  putx  ErrC;
#srcline 185
  js    __SE22_newerr__;
#srcline 186 ;  {END_ASM}
#srcline 187 ;  IF In4 < Cfg.PresetMin4 THEN EMin4 := true; END_IF;
 LDX  In4
#debug real In4
 LDX  Cfg~PresetMin4
#debug real Cfg.PresetMin4
 LTF
 JMC  SigErr22_L17
 LD   bool -1       ; true
 WRX  EMin4
#debug_left bool EMin4
SigErr22_L17:
#srcline 188 ;  Timer8(IN := EMin4, PT := Cfg.PresetTime4, Q => EMin4);
 LDX  EMin4
#debug bool EMin4
 WRX  Timer8~IN
#debug_left bool Timer8~IN
 LDX  Cfg~PresetTime4
#debug time Cfg.PresetTime4
 WRX  Timer8~PT
#debug_left time Timer8~PT
 LEAX Timer8
 CAL  TON_L0
; output assigment 
 LDX  Timer8~Q
#debug bool Timer8~Q
 WRX  EMin4
#debug_left bool EMin4
#srcline 189 ;  {ASM}
#srcline 190
  ldx   EMin4
#srcline 191
  letx  LET8;
#srcline 192
  setx  blikat;
#srcline 193
  wr    %s1.0;
#srcline 194
  ld    8;
#srcline 195
  putx  ErrC;
#srcline 196
  __SE22_newerr__:
#srcline 197 ;  {END_ASM}
#srcline 198 ;  //....................................................................
#srcline 199 ;  
#srcline 200 ;  // kvitace poruch
#srcline 201 ;  IF AckI THEN blikat := false; END_IF;  //prestat blikat signalkou
 LDX  AckI
#debug bool AckI
 JMC  SigErr22_L19
 LD   bool 0       ; false
 WRX  blikat
#debug_left bool blikat
SigErr22_L19:
#srcline 203 ;  // rizeni signalky
#srcline 204 ;  {ASM}
#srcline 205
  ldx byte EMax1    ;cela osmice
#srcline 206
  wrx SumO
#srcline 207
  wrx SigO
#srcline 208 ;  {END_ASM}
#srcline 209 ;  IF blikat THEN
 LDX  blikat
#debug bool blikat
 JMC  SigErr22_L21
#srcline 210 ;    SigO := %S13.2;   //blikani signalky v rastru 1s
 LD   %S13.2
 WRX  SigO
#debug_left bool SigO
#srcline 211 ;  END_IF;
SigErr22_L21:
#srcline 213 ;  //nulovani cisla poruchy (neaktivni poruchy)
#srcline 214 ;  IF ResI THEN
 LDX  ResI
#debug bool ResI
 JMC  SigErr22_L23
#srcline 215 ;    IF not EMax1 AND ErrC = 1 THEN ErrC := 0; END_IF;
 LDX  EMax1
#debug bool EMax1
 NEG
 LDX  ErrC
#debug usint ErrC
 LD   usint 1
 EQ
 AND
 JMC  SigErr22_L25
 LD   usint 0
 WRX  ErrC
#debug_left usint ErrC
SigErr22_L25:
#srcline 216 ;    IF not EMin1 AND ErrC = 2 THEN ErrC := 0; END_IF;
 LDX  EMin1
#debug bool EMin1
 NEG
 LDX  ErrC
#debug usint ErrC
 LD   usint 2
 EQ
 AND
 JMC  SigErr22_L27
 LD   usint 0
 WRX  ErrC
#debug_left usint ErrC
SigErr22_L27:
#srcline 217 ;    IF not EMax2 AND ErrC = 3 THEN ErrC := 0; END_IF;
 LDX  EMax2
#debug bool EMax2
 NEG
 LDX  ErrC
#debug usint ErrC
 LD   usint 3
 EQ
 AND
 JMC  SigErr22_L29
 LD   usint 0
 WRX  ErrC
#debug_left usint ErrC
SigErr22_L29:
#srcline 218 ;    IF not EMin2 AND ErrC = 4 THEN ErrC := 0; END_IF;
 LDX  EMin2
#debug bool EMin2
 NEG
 LDX  ErrC
#debug usint ErrC
 LD   usint 4
 EQ
 AND
 JMC  SigErr22_L31
 LD   usint 0
 WRX  ErrC
#debug_left usint ErrC
SigErr22_L31:
#srcline 219 ;    IF not EMax3 AND ErrC = 5 THEN ErrC := 0; END_IF;
 LDX  EMax3
#debug bool EMax3
 NEG
 LDX  ErrC
#debug usint ErrC
 LD   usint 5
 EQ
 AND
 JMC  SigErr22_L33
 LD   usint 0
 WRX  ErrC
#debug_left usint ErrC
SigErr22_L33:
#srcline 220 ;    IF not EMin3 AND ErrC = 6 THEN ErrC := 0; END_IF;
 LDX  EMin3
#debug bool EMin3
 NEG
 LDX  ErrC
#debug usint ErrC
 LD   usint 6
 EQ
 AND
 JMC  SigErr22_L35
 LD   usint 0
 WRX  ErrC
#debug_left usint ErrC
SigErr22_L35:
#srcline 221 ;    IF not EMax4 AND ErrC = 7 THEN ErrC := 0; END_IF;
 LDX  EMax4
#debug bool EMax4
 NEG
 LDX  ErrC
#debug usint ErrC
 LD   usint 7
 EQ
 AND
 JMC  SigErr22_L37
 LD   usint 0
 WRX  ErrC
#debug_left usint ErrC
SigErr22_L37:
#srcline 222 ;    IF not EMin4 AND ErrC = 8 THEN ErrC := 0; END_IF;
 LDX  EMin4
#debug bool EMin4
 NEG
 LDX  ErrC
#debug usint ErrC
 LD   usint 8
 EQ
 AND
 JMC  SigErr22_L39
 LD   usint 0
 WRX  ErrC
#debug_left usint ErrC
SigErr22_L39:
#srcline 223 ;  END_IF;
SigErr22_L23:
#srcline 225 ;  //rizeni signalky s ohledem na kaskadovani
#srcline 226 ;  SigO := (    SumI AND     SigI AND not SumO AND not SigO) OR
 LDX  SumI
#debug bool SumI
 LDX  SigI
#debug bool SigI
 AND
 LDX  SumO
#debug bool SumO
 NEG
 AND
 LDX  SigO
#debug bool SigO
 NEG
 AND
#srcline 227 ;          (not SumI AND not SigI AND     SumO AND     SigO) OR
 LDX  SumI
#debug bool SumI
 NEG
 LDX  SigI
#debug bool SigI
 NEG
 AND
 LDX  SumO
#debug bool SumO
 AND
 LDX  SigO
#debug bool SigO
 AND
 OR  
#srcline 228 ;          (    SumI AND     SigI AND     SumO AND     SigO);
 LDX  SumI
#debug bool SumI
 LDX  SigI
#debug bool SigI
 AND
 LDX  SumO
#debug bool SumO
 AND
 LDX  SigO
#debug bool SigO
 AND
 OR  
 WRX  SigO
#debug_left bool SigO
#srcline 230 ;  //sdruzena porucha s ohledem na kaskadovani
#srcline 231 ;  SumO := SumO or SumI;
 LDX  SumO
#debug bool SumO
 LDX  SumI
#debug bool SumI
 OR  
 WRX  SumO
#debug_left bool SumO
#srcline 233 ;  //prepis kvitace a nulovani poruch
#srcline 234 ;  AckO := AckI;
 LDX  AckI
#debug bool AckI
 WRX  AckO
#debug_left bool AckO
#srcline 235 ;  ResO := ResI;
 LDX  ResI
#debug bool ResI
 WRX  ResO
#debug_left bool ResO
#srcline 238 ;END_FUNCTION_BLOCK
 ULNK
RET
E     61
#endpou 



 

#srcfile ''
#srcfile 'D:\TECOAPP\KNIHOVNY\REGOLIB\SIGERR23.ST'
#pou SigErr23
#srcline 28 ;FUNCTION_BLOCK SigErr23

#struct SigErr23__temp__
  udint P0__st__,
  udint P1__st__,
  udint P2__st__,
  udint P3__st__,
  udint P4__st__,
  udint P5__st__,
  udint P6__st__,
  udint P7__st__
P     61
SigErr23_L0:
 LINK __SizeOf(SigErr23__temp__)
; Initialize - dynamic variables
; End initialize - dynamic variables
#srcline 139 ;  pombit := blikat;  //odlozeni priznaku blikat
 LDX  blikat
#debug bool blikat
 WRX  pombit
#debug_left bool pombit
#srcline 140 ;  {ASM}
#srcline 141
  ldx   CasI            ;byte kaskadovaciho vstupu
#srcline 142
  wrx   byte kvitace    ;cela osmice bitu
#srcline 143 ;  {END_ASM}
#srcline 144 ;  kvitace := kvitace OR AckI;   //akceptovat primy vstup kvitace
 LDX  kvitace
#debug bool kvitace
 LDX  AckI
#debug bool AckI
 OR  
 WRX  kvitace
#debug_left bool kvitace
#srcline 145 ;  reset   := reset   OR ResI;   //akceptovat primy vstup reset
 LDX  reset
#debug bool reset
 LDX  ResI
#debug bool ResI
 OR  
 WRX  reset
#debug_left bool reset
#srcline 146 ;  blikat  := blikat  OR pombit;  //akceptovat predchozi stav promenne blikat
 LDX  blikat
#debug bool blikat
 LDX  pombit
#debug bool pombit
 OR  
 WRX  blikat
#debug_left bool blikat
#srcline 148 ;  // kontrola pripustnosti hodnot ridicich slov
#srcline 149 ;  IF Cfg.control1 > 2 THEN Cfg.control1 := 2; END_IF;
 LDX  Cfg~control1
#debug usint Cfg.control1
 LD   usint 2
 GT
 JMC  SigErr23_L1
 LD   usint 2
 WRX  Cfg~control1
#debug_left usint Cfg.control1
SigErr23_L1:
#srcline 150 ;  IF Cfg.control2 > 2 THEN Cfg.control2 := 2; END_IF;
 LDX  Cfg~control2
#debug usint Cfg.control2
 LD   usint 2
 GT
 JMC  SigErr23_L3
 LD   usint 2
 WRX  Cfg~control2
#debug_left usint Cfg.control2
SigErr23_L3:
#srcline 151 ;  IF Cfg.control3 > 2 THEN Cfg.control3 := 2; END_IF;
 LDX  Cfg~control3
#debug usint Cfg.control3
 LD   usint 2
 GT
 JMC  SigErr23_L5
 LD   usint 2
 WRX  Cfg~control3
#debug_left usint Cfg.control3
SigErr23_L5:
#srcline 152 ;  IF Cfg.control4 > 2 THEN Cfg.control4 := 2; END_IF;
 LDX  Cfg~control4
#debug usint Cfg.control4
 LD   usint 2
 GT
 JMC  SigErr23_L7
 LD   usint 2
 WRX  Cfg~control4
#debug_left usint Cfg.control4
SigErr23_L7:
#srcline 153 ;  IF Cfg.controlS > 2 THEN Cfg.controlS := 2; END_IF;
 LDX  Cfg~controlS
#debug usint Cfg.controlS
 LD   usint 2
 GT
 JMC  SigErr23_L9
 LD   usint 2
 WRX  Cfg~controlS
#debug_left usint Cfg.controlS
SigErr23_L9:
#srcline 155 ;  // nulovani a vyhodnoceni vzniku poruch
#srcline 156 ;  ErrC := 0;
 LD   usint 0
 WRX  ErrC
#debug_left usint ErrC
#srcline 158 ;  //.......................... vstup 1 .................................
#srcline 159 ;  //nulovani poruchy
#srcline 160 ;  pombit := In1 > Cfg.PresetMax1;
 LDX  In1
#debug real In1
 LDX  Cfg~PresetMax1
#debug real Cfg.PresetMax1
 GTF
 WRX  pombit
#debug_left bool pombit
#srcline 161 ;  CASE Cfg.control1 OF
 LDX  Cfg~control1
#debug usint Cfg.control1
 WRY  P0__st__
 LD   0
 LDY  P0__st__
 EQ  
 JMC  SigErr23_L12
#srcline 162 ;    0 : IF not pombit THEN          //porucha je nulovana vzdy, pokud neni aktivni (samovratna porucha)
 LDX  pombit
#debug bool pombit
 NEG
 JMC  SigErr23_L13
#srcline 163 ;          EMax1 := false; END_IF;
 LD   bool 0       ; false
 WRX  EMax1
#debug_left bool EMax1
SigErr23_L13:
 JMP  SigErr23_L11
SigErr23_L12:
 LD   1
 LDY  P0__st__
 EQ  
 JMC  SigErr23_L15
#srcline 164 ;    1 : IF reset THEN               //porucha je nulovana signalem ResI vzdy
 LDX  reset
#debug bool reset
 JMC  SigErr23_L16
#srcline 165 ;          EMax1 := false; pombit := false; END_IF;
 LD   bool 0       ; false
 WRX  EMax1
#debug_left bool EMax1
 LD   bool 0       ; false
 WRX  pombit
#debug_left bool pombit
SigErr23_L16:
 JMP  SigErr23_L11
SigErr23_L15:
 LD   2
 LDY  P0__st__
 EQ  
 JMC  SigErr23_L18
#srcline 166 ;    2 : IF reset & not pombit THEN  //porucha je nulovana signalem ResI, jen pokud neni aktivni
 LDX  reset
#debug bool reset
 LDX  pombit
#debug bool pombit
 NEG
 AND
 JMC  SigErr23_L19
#srcline 167 ;          EMax1 := false; END_IF;
 LD   bool 0       ; false
 WRX  EMax1
#debug_left bool EMax1
SigErr23_L19:
 JMP  SigErr23_L11
SigErr23_L18:
SigErr23_L11:
#srcline 169 ;  //casovani a vyhodnoceni poruchy
#srcline 170 ;  Timer1(IN := pombit, PT := Cfg.PresetTime1);
 LDX  pombit
#debug bool pombit
 WRX  Timer1~IN
#debug_left bool Timer1~IN
 LDX  Cfg~PresetTime1
#debug time Cfg.PresetTime1
 WRX  Timer1~PT
#debug_left time Timer1~PT
 LEAX Timer1
 CAL  TON_L0
#srcline 171 ; {ASM}
#srcline 172
  ldx   Timer1.Q
#srcline 173
  setx  EMax1;
#srcline 174
  letx  LET1;
#srcline 175
  setx  blikat;
#srcline 176
  wr    %s1.0;
#srcline 177
  ld    1;
#srcline 178
  putx  ErrC;
#srcline 179
  js    __SE23_newerr__;
#srcline 180 ;  {END_ASM}
#srcline 181 ;  
#srcline 182 ;  //nulovani poruchy
#srcline 183 ;  pombit := In1 < Cfg.PresetMin1;
 LDX  In1
#debug real In1
 LDX  Cfg~PresetMin1
#debug real Cfg.PresetMin1
 LTF
 WRX  pombit
#debug_left bool pombit
#srcline 184 ;  CASE Cfg.control1 OF
 LDX  Cfg~control1
#debug usint Cfg.control1
 WRY  P1__st__
 LD   0
 LDY  P1__st__
 EQ  
 JMC  SigErr23_L22
#srcline 185 ;    0 : IF not pombit THEN          //porucha je nulovana vzdy, pokud neni aktivni (samovratna porucha)
 LDX  pombit
#debug bool pombit
 NEG
 JMC  SigErr23_L23
#srcline 186 ;          EMin1 := false; END_IF;
 LD   bool 0       ; false
 WRX  EMin1
#debug_left bool EMin1
SigErr23_L23:
 JMP  SigErr23_L21
SigErr23_L22:
 LD   1
 LDY  P1__st__
 EQ  
 JMC  SigErr23_L25
#srcline 187 ;    1 : IF reset THEN               //porucha je nulovana signalem ResI vzdy
 LDX  reset
#debug bool reset
 JMC  SigErr23_L26
#srcline 188 ;          EMin1 := false; pombit := false; END_IF;
 LD   bool 0       ; false
 WRX  EMin1
#debug_left bool EMin1
 LD   bool 0       ; false
 WRX  pombit
#debug_left bool pombit
SigErr23_L26:
 JMP  SigErr23_L21
SigErr23_L25:
 LD   2
 LDY  P1__st__
 EQ  
 JMC  SigErr23_L28
#srcline 189 ;    2 : IF reset & not pombit THEN  //porucha je nulovana signalem ResI, jen pokud neni aktivni
 LDX  reset
#debug bool reset
 LDX  pombit
#debug bool pombit
 NEG
 AND
 JMC  SigErr23_L29
#srcline 190 ;          EMin1 := false; END_IF;
 LD   bool 0       ; false
 WRX  EMin1
#debug_left bool EMin1
SigErr23_L29:
 JMP  SigErr23_L21
SigErr23_L28:
SigErr23_L21:
#srcline 192 ;  //casovani a vyhodnoceni poruchy
#srcline 193 ;  Timer2(IN := pombit, PT := Cfg.PresetTime1);
 LDX  pombit
#debug bool pombit
 WRX  Timer2~IN
#debug_left bool Timer2~IN
 LDX  Cfg~PresetTime1
#debug time Cfg.PresetTime1
 WRX  Timer2~PT
#debug_left time Timer2~PT
 LEAX Timer2
 CAL  TON_L0
#srcline 194 ; {ASM}
#srcline 195
  ldx   Timer2.Q
#srcline 196
  setx  EMin1;
#srcline 197
  letx  LET2;
#srcline 198
  setx  blikat;
#srcline 199
  wr    %s1.0;
#srcline 200
  ld    2;
#srcline 201
  putx  ErrC;
#srcline 202
  js    __SE23_newerr__;
#srcline 203 ;  {END_ASM}
#srcline 205 ;  //.......................... vstup 2 .................................
#srcline 206 ;  //nulovani poruchy
#srcline 207 ;  pombit := In2 > Cfg.PresetMax2;
 LDX  In2
#debug real In2
 LDX  Cfg~PresetMax2
#debug real Cfg.PresetMax2
 GTF
 WRX  pombit
#debug_left bool pombit
#srcline 208 ;  CASE Cfg.control2 OF
 LDX  Cfg~control2
#debug usint Cfg.control2
 WRY  P2__st__
 LD   0
 LDY  P2__st__
 EQ  
 JMC  SigErr23_L32
#srcline 209 ;    0 : IF not pombit THEN          //porucha je nulovana vzdy, pokud neni aktivni (samovratna porucha)
 LDX  pombit
#debug bool pombit
 NEG
 JMC  SigErr23_L33
#srcline 210 ;          EMax2 := false; END_IF;
 LD   bool 0       ; false
 WRX  EMax2
#debug_left bool EMax2
SigErr23_L33:
 JMP  SigErr23_L31
SigErr23_L32:
 LD   1
 LDY  P2__st__
 EQ  
 JMC  SigErr23_L35
#srcline 211 ;    1 : IF reset THEN               //porucha je nulovana signalem ResI vzdy
 LDX  reset
#debug bool reset
 JMC  SigErr23_L36
#srcline 212 ;          EMax2 := false; pombit := false; END_IF;
 LD   bool 0       ; false
 WRX  EMax2
#debug_left bool EMax2
 LD   bool 0       ; false
 WRX  pombit
#debug_left bool pombit
SigErr23_L36:
 JMP  SigErr23_L31
SigErr23_L35:
 LD   2
 LDY  P2__st__
 EQ  
 JMC  SigErr23_L38
#srcline 213 ;    2 : IF reset & not pombit THEN  //porucha je nulovana signalem ResI, jen pokud neni aktivni
 LDX  reset
#debug bool reset
 LDX  pombit
#debug bool pombit
 NEG
 AND
 JMC  SigErr23_L39
#srcline 214 ;          EMax2 := false; END_IF;
 LD   bool 0       ; false
 WRX  EMax2
#debug_left bool EMax2
SigErr23_L39:
 JMP  SigErr23_L31
SigErr23_L38:
SigErr23_L31:
#srcline 216 ;  //casovani a vyhodnoceni poruchy
#srcline 217 ;  Timer3(IN := pombit, PT := Cfg.PresetTime2);
 LDX  pombit
#debug bool pombit
 WRX  Timer3~IN
#debug_left bool Timer3~IN
 LDX  Cfg~PresetTime2
#debug time Cfg.PresetTime2
 WRX  Timer3~PT
#debug_left time Timer3~PT
 LEAX Timer3
 CAL  TON_L0
#srcline 218 ; {ASM}
#srcline 219
  ldx   Timer3.Q
#srcline 220
  setx  EMax2;
#srcline 221
  letx  LET3;
#srcline 222
  setx  blikat;
#srcline 223
  wr    %s1.0;
#srcline 224
  ld    3;
#srcline 225
  putx  ErrC;
#srcline 226
  js    __SE23_newerr__;
#srcline 227 ;  {END_ASM}
#srcline 229 ;  //nulovani poruchy
#srcline 230 ;  pombit := In2 < Cfg.PresetMin2;
 LDX  In2
#debug real In2
 LDX  Cfg~PresetMin2
#debug real Cfg.PresetMin2
 LTF
 WRX  pombit
#debug_left bool pombit
#srcline 231 ;  CASE Cfg.control2 OF
 LDX  Cfg~control2
#debug usint Cfg.control2
 WRY  P3__st__
 LD   0
 LDY  P3__st__
 EQ  
 JMC  SigErr23_L42
#srcline 232 ;    0 : IF not pombit THEN          //porucha je nulovana vzdy, pokud neni aktivni (samovratna porucha)
 LDX  pombit
#debug bool pombit
 NEG
 JMC  SigErr23_L43
#srcline 233 ;          EMin2 := false; END_IF;
 LD   bool 0       ; false
 WRX  EMin2
#debug_left bool EMin2
SigErr23_L43:
 JMP  SigErr23_L41
SigErr23_L42:
 LD   1
 LDY  P3__st__
 EQ  
 JMC  SigErr23_L45
#srcline 234 ;    1 : IF reset THEN               //porucha je nulovana signalem ResI vzdy
 LDX  reset
#debug bool reset
 JMC  SigErr23_L46
#srcline 235 ;          EMin2 := false; pombit := false; END_IF;
 LD   bool 0       ; false
 WRX  EMin2
#debug_left bool EMin2
 LD   bool 0       ; false
 WRX  pombit
#debug_left bool pombit
SigErr23_L46:
 JMP  SigErr23_L41
SigErr23_L45:
 LD   2
 LDY  P3__st__
 EQ  
 JMC  SigErr23_L48
#srcline 236 ;    2 : IF reset & not pombit THEN  //porucha je nulovana signalem ResI, jen pokud neni aktivni
 LDX  reset
#debug bool reset
 LDX  pombit
#debug bool pombit
 NEG
 AND
 JMC  SigErr23_L49
#srcline 237 ;          EMin2 := false; END_IF;
 LD   bool 0       ; false
 WRX  EMin2
#debug_left bool EMin2
SigErr23_L49:
 JMP  SigErr23_L41
SigErr23_L48:
SigErr23_L41:
#srcline 239 ;  //casovani a vyhodnoceni poruchy
#srcline 240 ;  Timer4(IN := pombit, PT := Cfg.PresetTime2);
 LDX  pombit
#debug bool pombit
 WRX  Timer4~IN
#debug_left bool Timer4~IN
 LDX  Cfg~PresetTime2
#debug time Cfg.PresetTime2
 WRX  Timer4~PT
#debug_left time Timer4~PT
 LEAX Timer4
 CAL  TON_L0
#srcline 241 ; {ASM}
#srcline 242
  ldx   Timer4.Q
#srcline 243
  setx  EMin2;
#srcline 244
  letx  LET4;
#srcline 245
  setx  blikat;
#srcline 246
  wr    %s1.0;
#srcline 247
  ld    4;
#srcline 248
  putx  ErrC;
#srcline 249
  js    __SE23_newerr__;
#srcline 250 ;  {END_ASM}
#srcline 252 ;  //.......................... vstup 3 .................................
#srcline 253 ;  //nulovani poruchy
#srcline 254 ;  pombit := In3 > Cfg.PresetMax3;
 LDX  In3
#debug real In3
 LDX  Cfg~PresetMax3
#debug real Cfg.PresetMax3
 GTF
 WRX  pombit
#debug_left bool pombit
#srcline 255 ;  CASE Cfg.control3 OF
 LDX  Cfg~control3
#debug usint Cfg.control3
 WRY  P4__st__
 LD   0
 LDY  P4__st__
 EQ  
 JMC  SigErr23_L52
#srcline 256 ;    0 : IF not pombit THEN          //porucha je nulovana vzdy, pokud neni aktivni (samovratna porucha)
 LDX  pombit
#debug bool pombit
 NEG
 JMC  SigErr23_L53
#srcline 257 ;          EMax3 := false; END_IF;
 LD   bool 0       ; false
 WRX  EMax3
#debug_left bool EMax3
SigErr23_L53:
 JMP  SigErr23_L51
SigErr23_L52:
 LD   1
 LDY  P4__st__
 EQ  
 JMC  SigErr23_L55
#srcline 258 ;    1 : IF reset THEN               //porucha je nulovana signalem ResI vzdy
 LDX  reset
#debug bool reset
 JMC  SigErr23_L56
#srcline 259 ;          EMax3 := false; pombit := false; END_IF;
 LD   bool 0       ; false
 WRX  EMax3
#debug_left bool EMax3
 LD   bool 0       ; false
 WRX  pombit
#debug_left bool pombit
SigErr23_L56:
 JMP  SigErr23_L51
SigErr23_L55:
 LD   2
 LDY  P4__st__
 EQ  
 JMC  SigErr23_L58
#srcline 260 ;    2 : IF reset & not pombit THEN  //porucha je nulovana signalem ResI, jen pokud neni aktivni
 LDX  reset
#debug bool reset
 LDX  pombit
#debug bool pombit
 NEG
 AND
 JMC  SigErr23_L59
#srcline 261 ;          EMax3 := false; END_IF;
 LD   bool 0       ; false
 WRX  EMax3
#debug_left bool EMax3
SigErr23_L59:
 JMP  SigErr23_L51
SigErr23_L58:
SigErr23_L51:
#srcline 263 ;  //casovani a vyhodnoceni poruchy
#srcline 264 ;  Timer5(IN := pombit, PT := Cfg.PresetTime3);
 LDX  pombit
#debug bool pombit
 WRX  Timer5~IN
#debug_left bool Timer5~IN
 LDX  Cfg~PresetTime3
#debug time Cfg.PresetTime3
 WRX  Timer5~PT
#debug_left time Timer5~PT
 LEAX Timer5
 CAL  TON_L0
#srcline 265 ; {ASM}
#srcline 266
  ldx   Timer5.Q
#srcline 267
  setx  EMax3;
#srcline 268
  letx  LET5;
#srcline 269
  setx  blikat;
#srcline 270
  wr    %s1.0;
#srcline 271
  ld    5;
#srcline 272
  putx  ErrC;
#srcline 273
  js    __SE23_newerr__;
#srcline 274 ;  {END_ASM}
#srcline 276 ;  //nulovani poruchy
#srcline 277 ;  pombit := In3 < Cfg.PresetMin3;
 LDX  In3
#debug real In3
 LDX  Cfg~PresetMin3
#debug real Cfg.PresetMin3
 LTF
 WRX  pombit
#debug_left bool pombit
#srcline 278 ;  CASE Cfg.control3 OF
 LDX  Cfg~control3
#debug usint Cfg.control3
 WRY  P5__st__
 LD   0
 LDY  P5__st__
 EQ  
 JMC  SigErr23_L62
#srcline 279 ;    0 : IF not pombit THEN          //porucha je nulovana vzdy, pokud neni aktivni (samovratna porucha)
 LDX  pombit
#debug bool pombit
 NEG
 JMC  SigErr23_L63
#srcline 280 ;          EMin3 := false; END_IF;
 LD   bool 0       ; false
 WRX  EMin3
#debug_left bool EMin3
SigErr23_L63:
 JMP  SigErr23_L61
SigErr23_L62:
 LD   1
 LDY  P5__st__
 EQ  
 JMC  SigErr23_L65
#srcline 281 ;    1 : IF reset THEN               //porucha je nulovana signalem ResI vzdy
 LDX  reset
#debug bool reset
 JMC  SigErr23_L66
#srcline 282 ;          EMin3 := false; pombit := false; END_IF;
 LD   bool 0       ; false
 WRX  EMin3
#debug_left bool EMin3
 LD   bool 0       ; false
 WRX  pombit
#debug_left bool pombit
SigErr23_L66:
 JMP  SigErr23_L61
SigErr23_L65:
 LD   2
 LDY  P5__st__
 EQ  
 JMC  SigErr23_L68
#srcline 283 ;    2 : IF reset & not pombit THEN  //porucha je nulovana signalem ResI, jen pokud neni aktivni
 LDX  reset
#debug bool reset
 LDX  pombit
#debug bool pombit
 NEG
 AND
 JMC  SigErr23_L69
#srcline 284 ;          EMin3 := false; END_IF;
 LD   bool 0       ; false
 WRX  EMin3
#debug_left bool EMin3
SigErr23_L69:
 JMP  SigErr23_L61
SigErr23_L68:
SigErr23_L61:
#srcline 286 ;  //casovani a vyhodnoceni poruchy
#srcline 287 ;  Timer6(IN := pombit, PT := Cfg.PresetTime3);
 LDX  pombit
#debug bool pombit
 WRX  Timer6~IN
#debug_left bool Timer6~IN
 LDX  Cfg~PresetTime3
#debug time Cfg.PresetTime3
 WRX  Timer6~PT
#debug_left time Timer6~PT
 LEAX Timer6
 CAL  TON_L0
#srcline 288 ; {ASM}
#srcline 289
  ldx   Timer6.Q
#srcline 290
  setx  EMin3;
#srcline 291
  letx  LET6;
#srcline 292
  setx  blikat;
#srcline 293
  wr    %s1.0;
#srcline 294
  ld    6;
#srcline 295
  putx  ErrC;
#srcline 296
  js    __SE23_newerr__;
#srcline 297 ;  {END_ASM}
#srcline 299 ;  //.......................... vstup 4 .................................
#srcline 300 ;  //nulovani poruchy
#srcline 301 ;  pombit := In4 > Cfg.PresetMax4;
 LDX  In4
#debug real In4
 LDX  Cfg~PresetMax4
#debug real Cfg.PresetMax4
 GTF
 WRX  pombit
#debug_left bool pombit
#srcline 302 ;  CASE Cfg.control4 OF
 LDX  Cfg~control4
#debug usint Cfg.control4
 WRY  P6__st__
 LD   0
 LDY  P6__st__
 EQ  
 JMC  SigErr23_L72
#srcline 303 ;    0 : IF not pombit THEN          //porucha je nulovana vzdy, pokud neni aktivni (samovratna porucha)
 LDX  pombit
#debug bool pombit
 NEG
 JMC  SigErr23_L73
#srcline 304 ;          EMax4 := false; END_IF;
 LD   bool 0       ; false
 WRX  EMax4
#debug_left bool EMax4
SigErr23_L73:
 JMP  SigErr23_L71
SigErr23_L72:
 LD   1
 LDY  P6__st__
 EQ  
 JMC  SigErr23_L75
#srcline 305 ;    1 : IF reset THEN               //porucha je nulovana signalem ResI vzdy
 LDX  reset
#debug bool reset
 JMC  SigErr23_L76
#srcline 306 ;          EMax4 := false; pombit := false; END_IF;
 LD   bool 0       ; false
 WRX  EMax4
#debug_left bool EMax4
 LD   bool 0       ; false
 WRX  pombit
#debug_left bool pombit
SigErr23_L76:
 JMP  SigErr23_L71
SigErr23_L75:
 LD   2
 LDY  P6__st__
 EQ  
 JMC  SigErr23_L78
#srcline 307 ;    2 : IF reset & not pombit THEN  //porucha je nulovana signalem ResI, jen pokud neni aktivni
 LDX  reset
#debug bool reset
 LDX  pombit
#debug bool pombit
 NEG
 AND
 JMC  SigErr23_L79
#srcline 308 ;          EMax4 := false; END_IF;
 LD   bool 0       ; false
 WRX  EMax4
#debug_left bool EMax4
SigErr23_L79:
 JMP  SigErr23_L71
SigErr23_L78:
SigErr23_L71:
#srcline 310 ;  //casovani a vyhodnoceni poruchy
#srcline 311 ;  Timer7(IN := pombit, PT := Cfg.PresetTime4);
 LDX  pombit
#debug bool pombit
 WRX  Timer7~IN
#debug_left bool Timer7~IN
 LDX  Cfg~PresetTime4
#debug time Cfg.PresetTime4
 WRX  Timer7~PT
#debug_left time Timer7~PT
 LEAX Timer7
 CAL  TON_L0
#srcline 312 ; {ASM}
#srcline 313
  ldx   Timer7.Q
#srcline 314
  setx  EMax4;
#srcline 315
  letx  LET7;
#srcline 316
  setx  blikat;
#srcline 317
  wr    %s1.0;
#srcline 318
  ld    7;
#srcline 319
  putx  ErrC;
#srcline 320
  js    __SE23_newerr__;
#srcline 321 ;  {END_ASM}
#srcline 323 ;  //nulovani poruchy
#srcline 324 ;  pombit := In4 < Cfg.PresetMin4;
 LDX  In4
#debug real In4
 LDX  Cfg~PresetMin4
#debug real Cfg.PresetMin4
 LTF
 WRX  pombit
#debug_left bool pombit
#srcline 325 ;  CASE Cfg.control4 OF
 LDX  Cfg~control4
#debug usint Cfg.control4
 WRY  P7__st__
 LD   0
 LDY  P7__st__
 EQ  
 JMC  SigErr23_L82
#srcline 326 ;    0 : IF not pombit THEN          //porucha je nulovana vzdy, pokud neni aktivni (samovratna porucha)
 LDX  pombit
#debug bool pombit
 NEG
 JMC  SigErr23_L83
#srcline 327 ;          EMin4 := false; END_IF;
 LD   bool 0       ; false
 WRX  EMin4
#debug_left bool EMin4
SigErr23_L83:
 JMP  SigErr23_L81
SigErr23_L82:
 LD   1
 LDY  P7__st__
 EQ  
 JMC  SigErr23_L85
#srcline 328 ;    1 : IF reset THEN               //porucha je nulovana signalem ResI vzdy
 LDX  reset
#debug bool reset
 JMC  SigErr23_L86
#srcline 329 ;          EMin4 := false; pombit := false; END_IF;
 LD   bool 0       ; false
 WRX  EMin4
#debug_left bool EMin4
 LD   bool 0       ; false
 WRX  pombit
#debug_left bool pombit
SigErr23_L86:
 JMP  SigErr23_L81
SigErr23_L85:
 LD   2
 LDY  P7__st__
 EQ  
 JMC  SigErr23_L88
#srcline 330 ;    2 : IF reset & not pombit THEN  //porucha je nulovana signalem ResI, jen pokud neni aktivni
 LDX  reset
#debug bool reset
 LDX  pombit
#debug bool pombit
 NEG
 AND
 JMC  SigErr23_L89
#srcline 331 ;          EMin4 := false; END_IF;
 LD   bool 0       ; false
 WRX  EMin4
#debug_left bool EMin4
SigErr23_L89:
 JMP  SigErr23_L81
SigErr23_L88:
SigErr23_L81:
#srcline 333 ;  //casovani a vyhodnoceni poruchy
#srcline 334 ;  Timer8(IN := pombit, PT := Cfg.PresetTime4);
 LDX  pombit
#debug bool pombit
 WRX  Timer8~IN
#debug_left bool Timer8~IN
 LDX  Cfg~PresetTime4
#debug time Cfg.PresetTime4
 WRX  Timer8~PT
#debug_left time Timer8~PT
 LEAX Timer8
 CAL  TON_L0
#srcline 335 ; {ASM}
#srcline 336
  ldx   Timer8.Q
#srcline 337
  setx  EMin4;
#srcline 338
  letx  LET8;
#srcline 339
  setx  blikat;
#srcline 340
  wr    %s1.0;
#srcline 341
  ld    8;
#srcline 342
  putx  ErrC;
#srcline 343
   __SE23_newerr__:
#srcline 344 ;  {END_ASM}
#srcline 345 ;  //....................................................................
#srcline 347 ;  //kvitace poruch
#srcline 348 ;  IF kvitace THEN blikat := false; END_IF;  //prestat blikat signalkou
 LDX  kvitace
#debug bool kvitace
 JMC  SigErr23_L91
 LD   bool 0       ; false
 WRX  blikat
#debug_left bool blikat
SigErr23_L91:
#srcline 349 ;  
#srcline 350 ;  //rizeni signalky
#srcline 351 ;  {ASM}
#srcline 352
  ldx  byte EMax1   ;cela osmice poruch
#srcline 353
  ldx  sdruzpor         ;sdruzena porucha ze vstupniho kaskadovani
#srcline 354
  or
#srcline 355
  wrx  SumO          ;sdruzena vystupni porucha
#srcline 356
  setx SigO           ;rozsvitit signalku
#srcline 357 ;  {END_ASM}
#srcline 358 ;  IF blikat THEN
 LDX  blikat
#debug bool blikat
 JMC  SigErr23_L93
#srcline 359 ;    SigO := %S13.2;   //blikani signalky v rastru 1s
 LD   %S13.2
 WRX  SigO
#debug_left bool SigO
#srcline 360 ;  END_IF;
SigErr23_L93:
#srcline 362 ;  //rizeni houkacky (a signalky)
#srcline 363 ;  AkuO := blikat OR akustika;  //akustika je zadost ze vstupniho kaskadovani
 LDX  blikat
#debug bool blikat
 LDX  akustika
#debug bool akustika
 OR  
 WRX  AkuO
#debug_left bool AkuO
#srcline 365 ;                                 //osetreni signalizace chyb pri zresetovani bez kvitace
#srcline 366 ;  IF Cfg.controlS = 0 THEN    //akustika i optika je v log.0
 LDX  Cfg~controlS
#debug usint Cfg.controlS
 LD   usint 0
 EQ
 JMC  SigErr23_L95
#srcline 367 ;    IF not SumO THEN AkuO := false; SigO := false; END_IF;
 LDX  SumO
#debug bool SumO
 NEG
 JMC  SigErr23_L97
 LD   bool 0       ; false
 WRX  AkuO
#debug_left bool AkuO
 LD   bool 0       ; false
 WRX  SigO
#debug_left bool SigO
SigErr23_L97:
#srcline 368 ;  END_IF;
SigErr23_L95:
#srcline 369 ;  IF Cfg.controlS = 1 THEN    //akustika je v log.0, optika blika
 LDX  Cfg~controlS
#debug usint Cfg.controlS
 LD   usint 1
 EQ
 JMC  SigErr23_L99
#srcline 370 ;    IF not SumO THEN AkuO := false; END_IF;
 LDX  SumO
#debug bool SumO
 NEG
 JMC  SigErr23_L101
 LD   bool 0       ; false
 WRX  AkuO
#debug_left bool AkuO
SigErr23_L101:
#srcline 371 ;  END_IF;
SigErr23_L99:
#srcline 372 ;  //IF Cfg.controlS = 2 THEN  //akustika je v log.1, opticka blika
#srcline 373 ;  //END_IF;                      //(funguje samo dle predchoziho algoritmu)
#srcline 375 ;  //pokracovani rizeni signalky
#srcline 376 ;  sdruzpor := false;           //jinak nefunguje blikani SigO pri kaskadovani
 LD   bool 0       ; false
 WRX  sdruzpor
#debug_left bool sdruzpor
#srcline 377 ;  pombit := blikat or SumO;
 LDX  blikat
#debug bool blikat
 LDX  SumO
#debug bool SumO
 OR  
 WRX  pombit
#debug_left bool pombit
#srcline 378 ;  SigO := (    sdruzpor AND     signalka AND not pombit AND not SigO) OR
 LDX  sdruzpor
#debug bool sdruzpor
 LDX  signalka
#debug bool signalka
 AND
 LDX  pombit
#debug bool pombit
 NEG
 AND
 LDX  SigO
#debug bool SigO
 NEG
 AND
#srcline 379 ;          (not sdruzpor AND not signalka AND     pombit AND     SigO) OR
 LDX  sdruzpor
#debug bool sdruzpor
 NEG
 LDX  signalka
#debug bool signalka
 NEG
 AND
 LDX  pombit
#debug bool pombit
 AND
 LDX  SigO
#debug bool SigO
 AND
 OR  
#srcline 380 ;          (    sdruzpor AND     signalka AND     pombit AND     SigO);
 LDX  sdruzpor
#debug bool sdruzpor
 LDX  signalka
#debug bool signalka
 AND
 LDX  pombit
#debug bool pombit
 AND
 LDX  SigO
#debug bool SigO
 AND
 OR  
 WRX  SigO
#debug_left bool SigO
#srcline 382 ;  // slozeni kaskadovaciho vystupu
#srcline 383 ;  sdruzpor := sdruzpor OR SumO;
 LDX  sdruzpor
#debug bool sdruzpor
 LDX  SumO
#debug bool SumO
 OR  
 WRX  sdruzpor
#debug_left bool sdruzpor
#srcline 384 ;  {ASM}
#srcline 385
  ldx   byte kvitace    ;cela osmice bitu
#srcline 386
  wrx   CasO          ;byte
#srcline 387 ;  {END_ASM}
#srcline 389 ;END_FUNCTION_BLOCK
 ULNK
RET
E     61
#endpou 



 

#srcfile ''
#srcfile 'D:\TECOAPP\KNIHOVNY\REGOLIB\FILTRACE.ST'
#pou Hyst1
#srcline 1 ;FUNCTION_BLOCK Hyst1
P     61
Hyst1_L0:
 LINK 0
#srcline 19 ;  IF IN > PV+HV/2.0 THEN
 LDX  IN
#debug real IN
 LDX  PV
#debug real PV
 LDX  HV
#debug real HV
 LD   real 2.0
 DIF
 ADF
 GTF
 JMC  Hyst1_L1
#srcline 20 ;    OUT := true;
 LD   bool -1       ; true
 WRX  OUT
#debug_left bool OUT
#srcline 21 ;  END_IF;
Hyst1_L1:
#srcline 22 ;  
#srcline 23 ;  IF IN < PV-HV/2.0 THEN
 LDX  IN
#debug real IN
 LDX  PV
#debug real PV
 LDX  HV
#debug real HV
 LD   real 2.0
 DIF
 SUF
 LTF
 JMC  Hyst1_L3
#srcline 24 ;    OUT := false;
 LD   bool 0       ; false
 WRX  OUT
#debug_left bool OUT
#srcline 25 ;  END_IF;
Hyst1_L3:
#srcline 26 ;END_FUNCTION_BLOCK
 ULNK
RET
E     61
#endpou 

#pou Hyst2
#srcline 30 ;FUNCTION_BLOCK Hyst2
P     61
Hyst2_L0:
 LINK 0
#srcline 49 ;  IF IN > MX THEN
 LDX  IN
#debug real IN
 LDX  MX
#debug real MX
 GTF
 JMC  Hyst2_L1
#srcline 50 ;    OUT := true;
 LD   bool -1       ; true
 WRX  OUT
#debug_left bool OUT
#srcline 51 ;  END_IF;
Hyst2_L1:
#srcline 53 ;  IF IN < MN THEN
 LDX  IN
#debug real IN
 LDX  MN
#debug real MN
 LTF
 JMC  Hyst2_L3
#srcline 54 ;    OUT := false;
 LD   bool 0       ; false
 WRX  OUT
#debug_left bool OUT
#srcline 55 ;  END_IF;
Hyst2_L3:
#srcline 56 ;END_FUNCTION_BLOCK
 ULNK
RET
E     61
#endpou 

#pou Hyst3
#srcline 60 ;FUNCTION_BLOCK Hyst3
P     61
Hyst3_L0:
 LINK 0
#srcline 86 ;  IF IN < MN1 THEN
 LDX  IN
#debug real IN
 LDX  MN1
#debug real MN1
 LTF
 JMC  Hyst3_L1
#srcline 87 ;    MORE := true;
 LD   bool -1       ; true
 WRX  MORE
#debug_left bool MORE
#srcline 88 ;  END_IF;
Hyst3_L1:
#srcline 90 ;  IF IN > MX1 THEN
 LDX  IN
#debug real IN
 LDX  MX1
#debug real MX1
 GTF
 JMC  Hyst3_L3
#srcline 91 ;    MORE := false;
 LD   bool 0       ; false
 WRX  MORE
#debug_left bool MORE
#srcline 92 ;  END_IF;
Hyst3_L3:
#srcline 93 ;  
#srcline 94 ;  IF IN < MN2 THEN
 LDX  IN
#debug real IN
 LDX  MN2
#debug real MN2
 LTF
 JMC  Hyst3_L5
#srcline 95 ;    LESS := false;
 LD   bool 0       ; false
 WRX  LESS
#debug_left bool LESS
#srcline 96 ;  END_IF;
Hyst3_L5:
#srcline 98 ;  IF IN > MX2 THEN
 LDX  IN
#debug real IN
 LDX  MX2
#debug real MX2
 GTF
 JMC  Hyst3_L7
#srcline 99 ;    LESS := true;
 LD   bool -1       ; true
 WRX  LESS
#debug_left bool LESS
#srcline 100 ;  END_IF;
Hyst3_L7:
#srcline 101 ;END_FUNCTION_BLOCK
 ULNK
RET
E     61
#endpou 

#pou Hyst31
#srcline 105 ;FUNCTION_BLOCK Hyst31
P     61
Hyst31_L0:
 LINK 0
#srcline 136 ;  IF ACT THEN
 LDX  ACT
#debug bool ACT
 JMC  Hyst31_L1
#srcline 137 ;    IF IN < MN1 THEN
 LDX  IN
#debug real IN
 LDX  MN1
#debug real MN1
 LTF
 JMC  Hyst31_L3
#srcline 138 ;      MORE := true;
 LD   bool -1       ; true
 WRX  MORE
#debug_left bool MORE
#srcline 139 ;    END_IF;
Hyst31_L3:
#srcline 141 ;    IF IN > MX1 THEN
 LDX  IN
#debug real IN
 LDX  MX1
#debug real MX1
 GTF
 JMC  Hyst31_L5
#srcline 142 ;      MORE := false;
 LD   bool 0       ; false
 WRX  MORE
#debug_left bool MORE
#srcline 143 ;    END_IF;
Hyst31_L5:
#srcline 145 ;    IF IN < MN2 THEN
 LDX  IN
#debug real IN
 LDX  MN2
#debug real MN2
 LTF
 JMC  Hyst31_L7
#srcline 146 ;      LESS := false;
 LD   bool 0       ; false
 WRX  LESS
#debug_left bool LESS
#srcline 147 ;    END_IF;
Hyst31_L7:
#srcline 149 ;    IF IN > MX2 THEN
 LDX  IN
#debug real IN
 LDX  MX2
#debug real MX2
 GTF
 JMC  Hyst31_L9
#srcline 150 ;      LESS := true;
 LD   bool -1       ; true
 WRX  LESS
#debug_left bool LESS
#srcline 151 ;    END_IF;
Hyst31_L9:
#srcline 152 ;  ELSE
 JMP  Hyst31_L2
Hyst31_L1:
#srcline 153 ;    LESS := false;
 LD   bool 0       ; false
 WRX  LESS
#debug_left bool LESS
#srcline 154 ;    MORE := false;
 LD   bool 0       ; false
 WRX  MORE
#debug_left bool MORE
#srcline 155 ;  END_IF;
Hyst31_L2:
#srcline 156 ;END_FUNCTION_BLOCK
 ULNK
RET
E     61
#endpou 



 

#srcfile ''
#srcfile 'D:\TECOAPP\KNIHOVNY\REGOLIB\TPROG1.ST'
#pou TProg1
#srcline 20 ;FUNCTION_BLOCK TProg1

#struct TProg1__temp__
  time CurrentTime,  ;soucasny cas
  time TimeON,  ;cas sepnuti
  time TimeOFF,  ;cas vypnuti
  udint P0__st__
P     61
TProg1_L0:
 LINK __SizeOf(TProg1__temp__)
; Initialize - dynamic variables
; End initialize - dynamic variables
#srcline 46 ;  CurrentTime := Rego_GetTime();  //nacteni soucasneho casu
 LEA  __Instance__Rego_GetTime
 CAL  Rego_GetTime_L0
 WRY  CurrentTime
#debug_left time CurrentTime
#srcline 47 ;  
#srcline 48 ;  CASE %S9 OF                //den v tydnu
 LD   %S9
 WRY  P0__st__
 LD   1
 LDY  P0__st__
 EQ  
 JMC  TProg1_L2
#srcline 49 ;    1 : TimeON := TPg.Mon.T_ON; TimeOFF := TPg.Mon.T_OFF;
 LDX  TPg~Mon~T_ON
#debug time TPg.Mon.T_ON
 WRY  TimeON
#debug_left time TimeON
 LDX  TPg~Mon~T_OFF
#debug time TPg.Mon.T_OFF
 WRY  TimeOFF
#debug_left time TimeOFF
 JMP  TProg1_L1
TProg1_L2:
 LD   2
 LDY  P0__st__
 EQ  
 JMC  TProg1_L3
#srcline 50 ;    2 : TimeON := TPg.Tue.T_ON; TimeOFF := TPg.Tue.T_OFF;
 LDX  TPg~Tue~T_ON
#debug time TPg.Tue.T_ON
 WRY  TimeON
#debug_left time TimeON
 LDX  TPg~Tue~T_OFF
#debug time TPg.Tue.T_OFF
 WRY  TimeOFF
#debug_left time TimeOFF
 JMP  TProg1_L1
TProg1_L3:
 LD   3
 LDY  P0__st__
 EQ  
 JMC  TProg1_L4
#srcline 51 ;    3 : TimeON := TPg.Wed.T_ON; TimeOFF := TPg.Wed.T_OFF;
 LDX  TPg~Wed~T_ON
#debug time TPg.Wed.T_ON
 WRY  TimeON
#debug_left time TimeON
 LDX  TPg~Wed~T_OFF
#debug time TPg.Wed.T_OFF
 WRY  TimeOFF
#debug_left time TimeOFF
 JMP  TProg1_L1
TProg1_L4:
 LD   4
 LDY  P0__st__
 EQ  
 JMC  TProg1_L5
#srcline 52 ;    4 : TimeON := TPg.Thu.T_ON; TimeOFF := TPg.Thu.T_OFF;
 LDX  TPg~Thu~T_ON
#debug time TPg.Thu.T_ON
 WRY  TimeON
#debug_left time TimeON
 LDX  TPg~Thu~T_OFF
#debug time TPg.Thu.T_OFF
 WRY  TimeOFF
#debug_left time TimeOFF
 JMP  TProg1_L1
TProg1_L5:
 LD   5
 LDY  P0__st__
 EQ  
 JMC  TProg1_L6
#srcline 53 ;    5 : TimeON := TPg.Fri.T_ON; TimeOFF := TPg.Fri.T_OFF;
 LDX  TPg~Fri~T_ON
#debug time TPg.Fri.T_ON
 WRY  TimeON
#debug_left time TimeON
 LDX  TPg~Fri~T_OFF
#debug time TPg.Fri.T_OFF
 WRY  TimeOFF
#debug_left time TimeOFF
 JMP  TProg1_L1
TProg1_L6:
 LD   6
 LDY  P0__st__
 EQ  
 JMC  TProg1_L7
#srcline 54 ;    6 : TimeON := TPg.Sat.T_ON; TimeOFF := TPg.Sat.T_OFF;
 LDX  TPg~Sat~T_ON
#debug time TPg.Sat.T_ON
 WRY  TimeON
#debug_left time TimeON
 LDX  TPg~Sat~T_OFF
#debug time TPg.Sat.T_OFF
 WRY  TimeOFF
#debug_left time TimeOFF
 JMP  TProg1_L1
TProg1_L7:
 LD   7
 LDY  P0__st__
 EQ  
 JMC  TProg1_L8
#srcline 55 ;    7 : TimeON := TPg.Sun.T_ON; TimeOFF := TPg.Sun.T_OFF;
 LDX  TPg~Sun~T_ON
#debug time TPg.Sun.T_ON
 WRY  TimeON
#debug_left time TimeON
 LDX  TPg~Sun~T_OFF
#debug time TPg.Sun.T_OFF
 WRY  TimeOFF
#debug_left time TimeOFF
 JMP  TProg1_L1
TProg1_L8:
TProg1_L1:
#srcline 57 ;  
#srcline 58 ;  IF (TimeON <= CurrentTime) AND (CurrentTime < TimeOFF) THEN
 LDY  TimeON
#debug time TimeON
 LDY  CurrentTime
#debug time CurrentTime
 GTS
 NEG
 LDY  CurrentTime
#debug time CurrentTime
 LDY  TimeOFF
#debug time TimeOFF
 LTS
 AND
 JMC  TProg1_L9
#srcline 59 ;    Out := true;          //sepnout vystup
 LD   bool -1       ; true
 WRX  Out
#debug_left bool Out
#srcline 60 ;  ELSE
 JMP  TProg1_L10
TProg1_L9:
#srcline 61 ;    Out := false;         //rozepnout vystup
 LD   bool 0       ; false
 WRX  Out
#debug_left bool Out
#srcline 62 ;  END_IF;
TProg1_L10:
#srcline 64 ;END_FUNCTION_BLOCK
 ULNK
RET
E     61
#endpou 



 

#srcfile ''
#srcfile 'D:\TECOAPP\KNIHOVNY\REGOLIB\TPROG2.ST'
#pou TProg2
#srcline 22 ;FUNCTION_BLOCK TProg2

#struct TProg2__temp__
  time CurrentTime,  ;soucasny cas
  time TimeON1,  ;cas sepnuti 1
  time TimeOFF1,  ;cas vypnuti 1
  time TimeON2,  ;cas sepnuti 2
  time TimeOFF2,  ;cas vypnuti 2
  udint P0__st__
P     61
TProg2_L0:
 LINK __SizeOf(TProg2__temp__)
; Initialize - dynamic variables
; End initialize - dynamic variables
#srcline 50 ;  CurrentTime := Rego_GetTime();  //nacteni soucasneho casu
 LEA  __Instance__Rego_GetTime
 CAL  Rego_GetTime_L0
 WRY  CurrentTime
#debug_left time CurrentTime
#srcline 52 ;  CASE %S9 OF                //den v tydnu
 LD   %S9
 WRY  P0__st__
 LD   1
 LDY  P0__st__
 EQ  
 JMC  TProg2_L2
#srcline 53 ;    1 : TimeON1 := TPg.Mon.T_ON1; TimeOFF1 := TPg.Mon.T_OFF1;
 LDX  TPg~Mon~T_ON1
#debug time TPg.Mon.T_ON1
 WRY  TimeON1
#debug_left time TimeON1
 LDX  TPg~Mon~T_OFF1
#debug time TPg.Mon.T_OFF1
 WRY  TimeOFF1
#debug_left time TimeOFF1
#srcline 54 ;        TimeON2 := TPg.Mon.T_ON2; TimeOFF2 := TPg.Mon.T_OFF2;
 LDX  TPg~Mon~T_ON2
#debug time TPg.Mon.T_ON2
 WRY  TimeON2
#debug_left time TimeON2
 LDX  TPg~Mon~T_OFF2
#debug time TPg.Mon.T_OFF2
 WRY  TimeOFF2
#debug_left time TimeOFF2
 JMP  TProg2_L1
TProg2_L2:
 LD   2
 LDY  P0__st__
 EQ  
 JMC  TProg2_L3
#srcline 55 ;    2 : TimeON1 := TPg.Tue.T_ON1; TimeOFF1 := TPg.Tue.T_OFF1;
 LDX  TPg~Tue~T_ON1
#debug time TPg.Tue.T_ON1
 WRY  TimeON1
#debug_left time TimeON1
 LDX  TPg~Tue~T_OFF1
#debug time TPg.Tue.T_OFF1
 WRY  TimeOFF1
#debug_left time TimeOFF1
#srcline 56 ;        TimeON2 := TPg.Tue.T_ON2; TimeOFF2 := TPg.Tue.T_OFF2;
 LDX  TPg~Tue~T_ON2
#debug time TPg.Tue.T_ON2
 WRY  TimeON2
#debug_left time TimeON2
 LDX  TPg~Tue~T_OFF2
#debug time TPg.Tue.T_OFF2
 WRY  TimeOFF2
#debug_left time TimeOFF2
 JMP  TProg2_L1
TProg2_L3:
 LD   3
 LDY  P0__st__
 EQ  
 JMC  TProg2_L4
#srcline 57 ;    3 : TimeON1 := TPg.Wed.T_ON1; TimeOFF1 := TPg.Wed.T_OFF1;
 LDX  TPg~Wed~T_ON1
#debug time TPg.Wed.T_ON1
 WRY  TimeON1
#debug_left time TimeON1
 LDX  TPg~Wed~T_OFF1
#debug time TPg.Wed.T_OFF1
 WRY  TimeOFF1
#debug_left time TimeOFF1
#srcline 58 ;        TimeON2 := TPg.Wed.T_ON2; TimeOFF2 := TPg.Wed.T_OFF2;
 LDX  TPg~Wed~T_ON2
#debug time TPg.Wed.T_ON2
 WRY  TimeON2
#debug_left time TimeON2
 LDX  TPg~Wed~T_OFF2
#debug time TPg.Wed.T_OFF2
 WRY  TimeOFF2
#debug_left time TimeOFF2
 JMP  TProg2_L1
TProg2_L4:
 LD   4
 LDY  P0__st__
 EQ  
 JMC  TProg2_L5
#srcline 59 ;    4 : TimeON1 := TPg.Thu.T_ON1; TimeOFF1 := TPg.Thu.T_OFF1;
 LDX  TPg~Thu~T_ON1
#debug time TPg.Thu.T_ON1
 WRY  TimeON1
#debug_left time TimeON1
 LDX  TPg~Thu~T_OFF1
#debug time TPg.Thu.T_OFF1
 WRY  TimeOFF1
#debug_left time TimeOFF1
#srcline 60 ;        TimeON2 := TPg.Thu.T_ON2; TimeOFF2 := TPg.Thu.T_OFF2;
 LDX  TPg~Thu~T_ON2
#debug time TPg.Thu.T_ON2
 WRY  TimeON2
#debug_left time TimeON2
 LDX  TPg~Thu~T_OFF2
#debug time TPg.Thu.T_OFF2
 WRY  TimeOFF2
#debug_left time TimeOFF2
 JMP  TProg2_L1
TProg2_L5:
 LD   5
 LDY  P0__st__
 EQ  
 JMC  TProg2_L6
#srcline 61 ;    5 : TimeON1 := TPg.Fri.T_ON1; TimeOFF1 := TPg.Fri.T_OFF1;
 LDX  TPg~Fri~T_ON1
#debug time TPg.Fri.T_ON1
 WRY  TimeON1
#debug_left time TimeON1
 LDX  TPg~Fri~T_OFF1
#debug time TPg.Fri.T_OFF1
 WRY  TimeOFF1
#debug_left time TimeOFF1
#srcline 62 ;        TimeON2 := TPg.Fri.T_ON2; TimeOFF2 := TPg.Fri.T_OFF2;
 LDX  TPg~Fri~T_ON2
#debug time TPg.Fri.T_ON2
 WRY  TimeON2
#debug_left time TimeON2
 LDX  TPg~Fri~T_OFF2
#debug time TPg.Fri.T_OFF2
 WRY  TimeOFF2
#debug_left time TimeOFF2
 JMP  TProg2_L1
TProg2_L6:
 LD   6
 LDY  P0__st__
 EQ  
 JMC  TProg2_L7
#srcline 63 ;    6 : TimeON1 := TPg.Sat.T_ON1; TimeOFF1 := TPg.Sat.T_OFF1;
 LDX  TPg~Sat~T_ON1
#debug time TPg.Sat.T_ON1
 WRY  TimeON1
#debug_left time TimeON1
 LDX  TPg~Sat~T_OFF1
#debug time TPg.Sat.T_OFF1
 WRY  TimeOFF1
#debug_left time TimeOFF1
#srcline 64 ;        TimeON2 := TPg.Sat.T_ON2; TimeOFF2 := TPg.Sat.T_OFF2;
 LDX  TPg~Sat~T_ON2
#debug time TPg.Sat.T_ON2
 WRY  TimeON2
#debug_left time TimeON2
 LDX  TPg~Sat~T_OFF2
#debug time TPg.Sat.T_OFF2
 WRY  TimeOFF2
#debug_left time TimeOFF2
 JMP  TProg2_L1
TProg2_L7:
 LD   7
 LDY  P0__st__
 EQ  
 JMC  TProg2_L8
#srcline 65 ;    7 : TimeON1 := TPg.Sun.T_ON1; TimeOFF1 := TPg.Sun.T_OFF1;
 LDX  TPg~Sun~T_ON1
#debug time TPg.Sun.T_ON1
 WRY  TimeON1
#debug_left time TimeON1
 LDX  TPg~Sun~T_OFF1
#debug time TPg.Sun.T_OFF1
 WRY  TimeOFF1
#debug_left time TimeOFF1
#srcline 66 ;        TimeON2 := TPg.Sun.T_ON2; TimeOFF2 := TPg.Sun.T_OFF2;
 LDX  TPg~Sun~T_ON2
#debug time TPg.Sun.T_ON2
 WRY  TimeON2
#debug_left time TimeON2
 LDX  TPg~Sun~T_OFF2
#debug time TPg.Sun.T_OFF2
 WRY  TimeOFF2
#debug_left time TimeOFF2
 JMP  TProg2_L1
TProg2_L8:
TProg2_L1:
#srcline 68 ;  
#srcline 69 ;  IF ((TimeON1 <= CurrentTime) AND (CurrentTime < TimeOFF1)) OR
 LDY  TimeON1
#debug time TimeON1
 LDY  CurrentTime
#debug time CurrentTime
 GTS
 NEG
 LDY  CurrentTime
#debug time CurrentTime
 LDY  TimeOFF1
#debug time TimeOFF1
 LTS
 AND
#srcline 70 ;     ((TimeON2 <= CurrentTime) AND (CurrentTime < TimeOFF2)) THEN
 LDY  TimeON2
#debug time TimeON2
 LDY  CurrentTime
#debug time CurrentTime
 GTS
 NEG
 LDY  CurrentTime
#debug time CurrentTime
 LDY  TimeOFF2
#debug time TimeOFF2
 LTS
 AND
 OR  
 JMC  TProg2_L9
#srcline 71 ;    Out := true;          //sepnout vystup
 LD   bool -1       ; true
 WRX  Out
#debug_left bool Out
#srcline 72 ;  ELSE
 JMP  TProg2_L10
TProg2_L9:
#srcline 73 ;    Out := false;         //rozepnout vystup
 LD   bool 0       ; false
 WRX  Out
#debug_left bool Out
#srcline 74 ;  END_IF;
TProg2_L10:
#srcline 76 ;END_FUNCTION_BLOCK
 ULNK
RET
E     61
#endpou 



 

#srcfile ''
#srcfile 'D:\TECOAPP\KNIHOVNY\REGOLIB\TPROG31.ST'
#pou TProg31
#srcline 20 ;FUNCTION_BLOCK TProg31

#struct TProg31__temp__
  time CurrentTime,  ;soucasny cas
  time TimeON,  ;cas sepnuti
  time TimeDuration,  ;prodleva sepnuti
  time TimeOFF,  ;cas vypnuti
  udint P0__st__
P     61
TProg31_L0:
 LINK __SizeOf(TProg31__temp__)
; Initialize - dynamic variables
; End initialize - dynamic variables
#srcline 48 ;  CurrentTime := Rego_GetTime();  //nacteni soucasneho casu
 LEA  __Instance__Rego_GetTime
 CAL  Rego_GetTime_L0
 WRY  CurrentTime
#debug_left time CurrentTime
#srcline 50 ;  CASE %S9 OF                //den v tydnu
 LD   %S9
 WRY  P0__st__
 LD   1
 LDY  P0__st__
 EQ  
 JMC  TProg31_L2
#srcline 51 ;    1 : TimeON := TPg.Mon.T_ON; TimeDuration := TPg.Mon.T_DUR;
 LDX  TPg~Mon~T_ON
#debug time TPg.Mon.T_ON
 WRY  TimeON
#debug_left time TimeON
 LDX  TPg~Mon~T_DUR
#debug time TPg.Mon.T_DUR
 WRY  TimeDuration
#debug_left time TimeDuration
 JMP  TProg31_L1
TProg31_L2:
 LD   2
 LDY  P0__st__
 EQ  
 JMC  TProg31_L3
#srcline 52 ;    2 : TimeON := TPg.Tue.T_ON; TimeDuration := TPg.Tue.T_DUR;
 LDX  TPg~Tue~T_ON
#debug time TPg.Tue.T_ON
 WRY  TimeON
#debug_left time TimeON
 LDX  TPg~Tue~T_DUR
#debug time TPg.Tue.T_DUR
 WRY  TimeDuration
#debug_left time TimeDuration
 JMP  TProg31_L1
TProg31_L3:
 LD   3
 LDY  P0__st__
 EQ  
 JMC  TProg31_L4
#srcline 53 ;    3 : TimeON := TPg.Wed.T_ON; TimeDuration := TPg.Wed.T_DUR;
 LDX  TPg~Wed~T_ON
#debug time TPg.Wed.T_ON
 WRY  TimeON
#debug_left time TimeON
 LDX  TPg~Wed~T_DUR
#debug time TPg.Wed.T_DUR
 WRY  TimeDuration
#debug_left time TimeDuration
 JMP  TProg31_L1
TProg31_L4:
 LD   4
 LDY  P0__st__
 EQ  
 JMC  TProg31_L5
#srcline 54 ;    4 : TimeON := TPg.Thu.T_ON; TimeDuration := TPg.Thu.T_DUR;
 LDX  TPg~Thu~T_ON
#debug time TPg.Thu.T_ON
 WRY  TimeON
#debug_left time TimeON
 LDX  TPg~Thu~T_DUR
#debug time TPg.Thu.T_DUR
 WRY  TimeDuration
#debug_left time TimeDuration
 JMP  TProg31_L1
TProg31_L5:
 LD   5
 LDY  P0__st__
 EQ  
 JMC  TProg31_L6
#srcline 55 ;    5 : TimeON := TPg.Fri.T_ON; TimeDuration := TPg.Fri.T_DUR;
 LDX  TPg~Fri~T_ON
#debug time TPg.Fri.T_ON
 WRY  TimeON
#debug_left time TimeON
 LDX  TPg~Fri~T_DUR
#debug time TPg.Fri.T_DUR
 WRY  TimeDuration
#debug_left time TimeDuration
 JMP  TProg31_L1
TProg31_L6:
 LD   6
 LDY  P0__st__
 EQ  
 JMC  TProg31_L7
#srcline 56 ;    6 : TimeON := TPg.Sat.T_ON; TimeDuration := TPg.Sat.T_DUR;
 LDX  TPg~Sat~T_ON
#debug time TPg.Sat.T_ON
 WRY  TimeON
#debug_left time TimeON
 LDX  TPg~Sat~T_DUR
#debug time TPg.Sat.T_DUR
 WRY  TimeDuration
#debug_left time TimeDuration
 JMP  TProg31_L1
TProg31_L7:
 LD   7
 LDY  P0__st__
 EQ  
 JMC  TProg31_L8
#srcline 57 ;    7 : TimeON := TPg.Sun.T_ON; TimeDuration := TPg.Sun.T_DUR;
 LDX  TPg~Sun~T_ON
#debug time TPg.Sun.T_ON
 WRY  TimeON
#debug_left time TimeON
 LDX  TPg~Sun~T_DUR
#debug time TPg.Sun.T_DUR
 WRY  TimeDuration
#debug_left time TimeDuration
 JMP  TProg31_L1
TProg31_L8:
TProg31_L1:
#srcline 60 ;  TimeOFF := TimeON + TimeDuration;  //cas vypnuti
 LDY  TimeON
#debug time TimeON
 LDY  TimeDuration
#debug time TimeDuration
 ADD
 WRY  TimeOFF
#debug_left time TimeOFF
#srcline 61 ;  IF TimeOFF > T#24:00:00 THEN
 LDY  TimeOFF
#debug time TimeOFF
 LD   time 86400000
 GTS
 JMC  TProg31_L9
#srcline 62 ;    TimeOFF := T#24:00:00;           //oriznout na pulnoci
 LD   time 86400000
 WRY  TimeOFF
#debug_left time TimeOFF
#srcline 63 ;  END_IF;
TProg31_L9:
#srcline 64 ;  
#srcline 65 ;  IF (TimeON <= CurrentTime) AND (CurrentTime < TimeOFF) THEN
 LDY  TimeON
#debug time TimeON
 LDY  CurrentTime
#debug time CurrentTime
 GTS
 NEG
 LDY  CurrentTime
#debug time CurrentTime
 LDY  TimeOFF
#debug time TimeOFF
 LTS
 AND
 JMC  TProg31_L11
#srcline 66 ;    Out := true;          //sepnout vystup
 LD   bool -1       ; true
 WRX  Out
#debug_left bool Out
#srcline 67 ;  ELSE
 JMP  TProg31_L12
TProg31_L11:
#srcline 68 ;    Out := false;         //rozepnout vystup
 LD   bool 0       ; false
 WRX  Out
#debug_left bool Out
#srcline 69 ;  END_IF;
TProg31_L12:
#srcline 70 ;  
#srcline 71 ;END_FUNCTION_BLOCK
 ULNK
RET
E     61
#endpou 



 

#srcfile ''
#srcfile 'D:\TECOAPP\KNIHOVNY\REGOLIB\TPROG41.ST'
#pou TProg41
#srcline 22 ;FUNCTION_BLOCK TProg41

#struct TProg41__temp__
  time CurrentTime,  ;soucasny cas
  time TimeON1,  ;cas sepnuti 1
  time TimeON2,  ;cas sepnuti 2
  time TimeDuration1,  ;prodleva sepnuti 1
  time TimeDuration2,  ;prodleva sepnuti 2
  time TimeOFF1,  ;cas vypnuti 1
  time TimeOFF2,  ;cas vypnuti 2
  udint P0__st__
P     61
TProg41_L0:
 LINK __SizeOf(TProg41__temp__)
; Initialize - dynamic variables
; End initialize - dynamic variables
#srcline 53 ;  CurrentTime := Rego_GetTime();  //nacteni soucasneho casu
 LEA  __Instance__Rego_GetTime
 CAL  Rego_GetTime_L0
 WRY  CurrentTime
#debug_left time CurrentTime
#srcline 55 ;  CASE %S9 OF                //den v tydnu
 LD   %S9
 WRY  P0__st__
 LD   1
 LDY  P0__st__
 EQ  
 JMC  TProg41_L2
#srcline 56 ;    1 : TimeON1 := TPg.Mon.T_ON1; TimeDuration1 := TPg.Mon.T_DUR1;
 LDX  TPg~Mon~T_ON1
#debug time TPg.Mon.T_ON1
 WRY  TimeON1
#debug_left time TimeON1
 LDX  TPg~Mon~T_DUR1
#debug time TPg.Mon.T_DUR1
 WRY  TimeDuration1
#debug_left time TimeDuration1
#srcline 57 ;        TimeON2 := TPg.Mon.T_ON2; TimeDuration2 := TPg.Mon.T_DUR2;
 LDX  TPg~Mon~T_ON2
#debug time TPg.Mon.T_ON2
 WRY  TimeON2
#debug_left time TimeON2
 LDX  TPg~Mon~T_DUR2
#debug time TPg.Mon.T_DUR2
 WRY  TimeDuration2
#debug_left time TimeDuration2
 JMP  TProg41_L1
TProg41_L2:
 LD   2
 LDY  P0__st__
 EQ  
 JMC  TProg41_L3
#srcline 58 ;    2 : TimeON1 := TPg.Tue.T_ON1; TimeDuration1 := TPg.Tue.T_DUR1;
 LDX  TPg~Tue~T_ON1
#debug time TPg.Tue.T_ON1
 WRY  TimeON1
#debug_left time TimeON1
 LDX  TPg~Tue~T_DUR1
#debug time TPg.Tue.T_DUR1
 WRY  TimeDuration1
#debug_left time TimeDuration1
#srcline 59 ;        TimeON2 := TPg.Tue.T_ON2; TimeDuration2 := TPg.Tue.T_DUR2;
 LDX  TPg~Tue~T_ON2
#debug time TPg.Tue.T_ON2
 WRY  TimeON2
#debug_left time TimeON2
 LDX  TPg~Tue~T_DUR2
#debug time TPg.Tue.T_DUR2
 WRY  TimeDuration2
#debug_left time TimeDuration2
 JMP  TProg41_L1
TProg41_L3:
 LD   3
 LDY  P0__st__
 EQ  
 JMC  TProg41_L4
#srcline 60 ;    3 : TimeON1 := TPg.Wed.T_ON1; TimeDuration1 := TPg.Wed.T_DUR1;
 LDX  TPg~Wed~T_ON1
#debug time TPg.Wed.T_ON1
 WRY  TimeON1
#debug_left time TimeON1
 LDX  TPg~Wed~T_DUR1
#debug time TPg.Wed.T_DUR1
 WRY  TimeDuration1
#debug_left time TimeDuration1
#srcline 61 ;        TimeON2 := TPg.Wed.T_ON2; TimeDuration2 := TPg.Wed.T_DUR2;
 LDX  TPg~Wed~T_ON2
#debug time TPg.Wed.T_ON2
 WRY  TimeON2
#debug_left time TimeON2
 LDX  TPg~Wed~T_DUR2
#debug time TPg.Wed.T_DUR2
 WRY  TimeDuration2
#debug_left time TimeDuration2
 JMP  TProg41_L1
TProg41_L4:
 LD   4
 LDY  P0__st__
 EQ  
 JMC  TProg41_L5
#srcline 62 ;    4 : TimeON1 := TPg.Thu.T_ON1; TimeDuration1 := TPg.Thu.T_DUR1;
 LDX  TPg~Thu~T_ON1
#debug time TPg.Thu.T_ON1
 WRY  TimeON1
#debug_left time TimeON1
 LDX  TPg~Thu~T_DUR1
#debug time TPg.Thu.T_DUR1
 WRY  TimeDuration1
#debug_left time TimeDuration1
#srcline 63 ;        TimeON2 := TPg.Thu.T_ON2; TimeDuration2 := TPg.Thu.T_DUR2;
 LDX  TPg~Thu~T_ON2
#debug time TPg.Thu.T_ON2
 WRY  TimeON2
#debug_left time TimeON2
 LDX  TPg~Thu~T_DUR2
#debug time TPg.Thu.T_DUR2
 WRY  TimeDuration2
#debug_left time TimeDuration2
 JMP  TProg41_L1
TProg41_L5:
 LD   5
 LDY  P0__st__
 EQ  
 JMC  TProg41_L6
#srcline 64 ;    5 : TimeON1 := TPg.Fri.T_ON1; TimeDuration1 := TPg.Fri.T_DUR1;
 LDX  TPg~Fri~T_ON1
#debug time TPg.Fri.T_ON1
 WRY  TimeON1
#debug_left time TimeON1
 LDX  TPg~Fri~T_DUR1
#debug time TPg.Fri.T_DUR1
 WRY  TimeDuration1
#debug_left time TimeDuration1
#srcline 65 ;        TimeON2 := TPg.Fri.T_ON2; TimeDuration2 := TPg.Fri.T_DUR2;
 LDX  TPg~Fri~T_ON2
#debug time TPg.Fri.T_ON2
 WRY  TimeON2
#debug_left time TimeON2
 LDX  TPg~Fri~T_DUR2
#debug time TPg.Fri.T_DUR2
 WRY  TimeDuration2
#debug_left time TimeDuration2
 JMP  TProg41_L1
TProg41_L6:
 LD   6
 LDY  P0__st__
 EQ  
 JMC  TProg41_L7
#srcline 66 ;    6 : TimeON1 := TPg.Sat.T_ON1; TimeDuration1 := TPg.Sat.T_DUR1;
 LDX  TPg~Sat~T_ON1
#debug time TPg.Sat.T_ON1
 WRY  TimeON1
#debug_left time TimeON1
 LDX  TPg~Sat~T_DUR1
#debug time TPg.Sat.T_DUR1
 WRY  TimeDuration1
#debug_left time TimeDuration1
#srcline 67 ;        TimeON2 := TPg.Sat.T_ON2; TimeDuration2 := TPg.Sat.T_DUR2;
 LDX  TPg~Sat~T_ON2
#debug time TPg.Sat.T_ON2
 WRY  TimeON2
#debug_left time TimeON2
 LDX  TPg~Sat~T_DUR2
#debug time TPg.Sat.T_DUR2
 WRY  TimeDuration2
#debug_left time TimeDuration2
 JMP  TProg41_L1
TProg41_L7:
 LD   7
 LDY  P0__st__
 EQ  
 JMC  TProg41_L8
#srcline 68 ;    7 : TimeON1 := TPg.Sun.T_ON1; TimeDuration1 := TPg.Sun.T_DUR1;
 LDX  TPg~Sun~T_ON1
#debug time TPg.Sun.T_ON1
 WRY  TimeON1
#debug_left time TimeON1
 LDX  TPg~Sun~T_DUR1
#debug time TPg.Sun.T_DUR1
 WRY  TimeDuration1
#debug_left time TimeDuration1
#srcline 69 ;        TimeON2 := TPg.Sun.T_ON2; TimeDuration2 := TPg.Sun.T_DUR2;
 LDX  TPg~Sun~T_ON2
#debug time TPg.Sun.T_ON2
 WRY  TimeON2
#debug_left time TimeON2
 LDX  TPg~Sun~T_DUR2
#debug time TPg.Sun.T_DUR2
 WRY  TimeDuration2
#debug_left time TimeDuration2
 JMP  TProg41_L1
TProg41_L8:
TProg41_L1:
#srcline 72 ;  TimeOFF1 := TimeON1 + TimeDuration1;  //cas vypnuti
 LDY  TimeON1
#debug time TimeON1
 LDY  TimeDuration1
#debug time TimeDuration1
 ADD
 WRY  TimeOFF1
#debug_left time TimeOFF1
#srcline 73 ;  IF TimeOFF1 > T#24:00:00 THEN
 LDY  TimeOFF1
#debug time TimeOFF1
 LD   time 86400000
 GTS
 JMC  TProg41_L9
#srcline 74 ;    TimeOFF1 := T#24:00:00;             //oriznout na pulnoci
 LD   time 86400000
 WRY  TimeOFF1
#debug_left time TimeOFF1
#srcline 75 ;  END_IF;
TProg41_L9:
#srcline 76 ;  
#srcline 77 ;  TimeOFF2 := TimeON2 + TimeDuration2;  //cas vypnuti
 LDY  TimeON2
#debug time TimeON2
 LDY  TimeDuration2
#debug time TimeDuration2
 ADD
 WRY  TimeOFF2
#debug_left time TimeOFF2
#srcline 78 ;  IF TimeOFF2 > T#24:00:00 THEN
 LDY  TimeOFF2
#debug time TimeOFF2
 LD   time 86400000
 GTS
 JMC  TProg41_L11
#srcline 79 ;    TimeOFF2 := T#24:00:00;             //oriznout na pulnoci
 LD   time 86400000
 WRY  TimeOFF2
#debug_left time TimeOFF2
#srcline 80 ;  END_IF;
TProg41_L11:
#srcline 82 ;  IF ((TimeON1 <= CurrentTime) AND (CurrentTime < TimeOFF1)) OR
 LDY  TimeON1
#debug time TimeON1
 LDY  CurrentTime
#debug time CurrentTime
 GTS
 NEG
 LDY  CurrentTime
#debug time CurrentTime
 LDY  TimeOFF1
#debug time TimeOFF1
 LTS
 AND
#srcline 83 ;     ((TimeON2 <= CurrentTime) AND (CurrentTime < TimeOFF2)) THEN
 LDY  TimeON2
#debug time TimeON2
 LDY  CurrentTime
#debug time CurrentTime
 GTS
 NEG
 LDY  CurrentTime
#debug time CurrentTime
 LDY  TimeOFF2
#debug time TimeOFF2
 LTS
 AND
 OR  
 JMC  TProg41_L13
#srcline 84 ;    Out := true;          //sepnout vystup
 LD   bool -1       ; true
 WRX  Out
#debug_left bool Out
#srcline 85 ;  ELSE
 JMP  TProg41_L14
TProg41_L13:
#srcline 86 ;    Out := false;         //rozepnout vystup
 LD   bool 0       ; false
 WRX  Out
#debug_left bool Out
#srcline 87 ;  END_IF;
TProg41_L14:
#srcline 89 ;END_FUNCTION_BLOCK
 ULNK
RET
E     61
#endpou 



 

#srcfile ''
oq ê  ž