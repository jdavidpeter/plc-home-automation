(*` {CSY}Knihovna vıvojového systému Mosaic{ENU}Mosaic IDE library *)
(*` {CSY}Jméno souboru{ENU}File name{} : C:\TecoLibSrc\ModbusRTU\ModbusRTU_V40_20210826.mlb *)
(*` {CSY}Knihovna : ModbusRTU{ENU}Library : ModbusRTU{} 4.0 *)
(*` {CSY}Autor{ENU}Author{} : Teco a.s. *)
(*` {CSY}Autorská práva{ENU}Copyright{} : Teco (c) 2011 - 2021 *)
(*` {CSY}Verze IEC pøekladaèe{ENU}IEC compiler version{} : 4.2.13.0 *)
(*` {CSY}Verze assembleru{ENU}Assembler version{} : 4.3.00 *)

//{Knihovna : ModbusRTU 4.0  }
(*` {CSY}Historie{ENU}History{}: *)
(*`
{CSY}
v1.2 18.02.2010 pet - opraveno zobrazení ErrorCode predavane z fce RecvFrom() 
     18.02.2010 nem - upraveno chováni vıstupu Done z FB ModbusRTUmas()
v1.3 17.08.2010 nem - doplnìn FB ModbusTCPmas() a funkce ModbusCmdTCP()
     02.09.2010 nem - Doplnìny závislosti na knihovnách, vyaduje Mosaic v2.0.25 a vyšší
v1.4 19.11.2010 pet - zapnuty závislosti na knihovnách, pracuje se všemi verzemi Mosaic
v1.5 06.12.2010 pet - Upraveny komentáøe
v1.6 06.09.2011 nem - Do struktury TCmdStructTCP doplnena polozka UnitID
v1.7 21.08.2013 byd - opravena max. delka DataR a DataT +6 bytù (protoe tam musí bıt místo také pro Eth Header), doplnìn test COM_ERR5, opraven RecvFrom(lenRx := 255+6 -k)
v1.8 27.08.2013 byd - opravena max. delka Write Multiple Registers na 123 objektù
v1.9 03.10.2013 byd - pøidáno nulování nevyuitıch bitù pøi odpovìdi na Read Coils a Read Discrete Inputs opraveny pøíznaky ètení a zápisu a poèítadla zpráv u blokù fbModbusTCPslave a fbModbusRTUslave 
		      Read Coils a Read Discrete Inputs vrací pouze tolik bitù kolik bylo ve vızvì (døíve vracela mnoství zaokrouhléne nahoru na celé osmice)
v2.0 08.10.2013 byd - Opraveno poøadí bytù v délce odpovìdi fbModbusTCPslave
v2.1 30.09.2014 byd - Opravena délka odpovìdi na Force Single Coil
                      Opraven manuální reim v MdbTCP_selCommand() 
v2.2 12.02.2015 byd - Potlaèena detekce ETH spojení ve FB ModbusRTUmas()
v2.3 09.03.2015 byd - GetModbusErrTxt vrací text k chybì 16#C6 - seriovı kanál neni v poadovaném reimu
v2.4 11.05.2015 byd - opravena chyba z verze 2.2, která zpùsobila nefunkènost ModbusTCPmas
v2.5 09.07.2015 byd - pøidána informace o adrese a poètu objektù ètenıch/zapisovanıch funkèními bloky fbModbusTCPslave a fbModbusRTUslave
v2.6 10.07.2015 byd - vylepšena práce s pointery
v2.7 20.08.2015 byd - pøidána monost spustit pøíkaz v ruèním reimu v ten samı cyklus, kdy je blok ModbusTCPmas povolen vstupem EN
v2.8 01.09.2015 byd - pøidány bloky s prodlevou mezi zprávami
v2.9 03.10.2016 byd - fbModbusRTUmas2 zmìnìn typ pro èísla pøíkazù ze SINT na USINT
v3.0 17.10.2016 byd - fbModbusRTUmas2 opravena chyba, kdy pøi vyhodnocení chyby na pøíjmu nebyla prodleva po vykonaném pøíkazu
v3.1 18.04.2017 byd - doplnìna podpora funkce Mask Write Register
                      zmìna nastavení IP adresy v blocích ModbusTCPmas a fbModbusTCPmas2, tak aby nebyla ovlivnìna nastavením UNI spojení
v3.2 03.11.2017 byd - pøidán blok fbModbusUDPmas pro Modbus UDP
                      odstranìny mezistavy prodluující prodlevy mezi pøíjmem a vysíláním ve všech blocích
v3.3 09.01.2018 byd - odstranìno zacyklení v pøípadì, e pøíkazy neobsahovaly ani jeden pøíkaz vyhovující hodnotì GrSel (zaneseno ve verzi 3.2)
v3.4 03.04.2018 byd - odstranìno omezení Modbus TCP master na rozhraní ETH1, na ETH2, ETH3,... lze provozovat s tím, e port a IP adresa musí bıt nastavena v konfiguraci HW (IP adresa v ModbusCmdTCP se ignoruje)
v3.5 23.01.2019 byd - fbModbusTCPslave zmìní port, i kdy existuje aktivní spojení
v3.6 04.05.2019 byd - funkèní bloky fbModbusRTUmas a fbModbusRTUmas2 nezavírají spojení pokud odpovìï od podøízeného zaøízení obsahuje vıjimku
v3.7 20.04.2020 byd - funkèní blok fbModbusTCPslave je nyní schopen zpracovat pøikazy fragmentované TCP protokolem a více pøíkazù v jednom paketu
                    - pøi zpracování odpovìdí na zprávy Read holding/input registr je kontrolováno zda nepøišlo více dat ne o kolik bylo ádáno a do uivatelské promìnné se kopíruje vdy jen poèet zadanı ve vızvì
		    - pauza mezi komunikacemi v bloku fbModbusTCPmas2 se aplikuje jen v rámci spojení se stejnım zaøízením
v3.8 08.07.2020 byd - ošetøen hazard, kdy pøi online zmìnì mohl blok ModbusTCPmas a fbModbusTCPmas2 zapsat pøijatá data na pozici podle starého mapování registrù
v3.9 02.08.2021 byd - fbModbusTCPslave s nastavenım UnitID na nula pøijímá všechny zprávy bez ohledu na identifikátor podøízené stanice
                      doplnìny funkce pro konverzi typù pøenášenıch ve více registrech
v4.0 26.08.2021 byd - fbModbusTCPslave - pro ETH2 a vyšší u CPM øady K a L potlaèeno nastavení portu UNI spojení, kde zmìna z uivatelského programu není podporována. Blok je moné pouít, pokud se port vyplní v HW konfiguraci. 
{ENU}
v1.2 2010-02-18 pet - seamless connection of ErrorCode from ComLib function RecvFrom() 
     2010-02-18 nem - new behavior of output Done (see FB ModbusRTUmas())
v1.3 2010-08-17 nem - new function block ModbusTCPmas() and new function ModbusCmdTCP()
     2010-09-02 nem - Dependency on the libraries added. Library requires Mosaic version 2.0.25 or higher
v1.4 2010-11-19 pet - switched depending on the libraries works with all versions of Mosaic
v1.5 2010-12-06 pet - Adjusted comments
v1.6 2011-09-06 nem - item UnitID added to structure TCmdStructTCP
v1.7 2013-08-21 byd - Adjusted max. length DataR a DataT +6 byte, added test COM_ERR5, adjusted RecvFrom(lenRx := 255 +6 -k)
v1.8 2013-08-27 byd - Adjusted max. length for Write Multiple Registers to 123 objects
v1.9 2013-10-03 byd - Added clearing of unused bits in answers to Read Coils and Read Discrete Inputs
                      Fixed flags of reading and writing and counter of messages in blocks fbModbusTCPslave and fbModbusRTUslave 
		      Read Coils and Read Discrete Inputs returns only number of read bits according to request (before it returned number of bits round up to whole eights)
v2.0 2013-10-08 byd - Fixed order of bytes in reply from fbModbusTCPslave
v2.1 2014-09-30 byd - Fixed length of answer to Force Single Coil
                      Fixed manual mode in Opraven manuální reim v ModbusCmdTCP()
v2.2 2015-02-12 byd - Supressed detection of ETH connection in FB ModbusRTUmas()
v2.3 2015-03-09 byd - GetModbusErrTxt returns text for 16#C6 error - Invalid channel mode
v2.4 2015-05-11 byd - fixed error from version 2.2, which caused ModbusTCPmas not working
v2.5 2015-07-09 byd - added information about address and quantitny of objects read/written by function block fbModbusTCPslave and fbModbusRTUslave v2.6 2015-07-10 byd - improved work with pointers
v2.7 2015-08-20 byd - added possibility to run a command in the same cycle, in which is a block ModbusTCPmas enabled by input EN in manual mode
v2.8 2015-09-01 byd - added blocks with delay between messages
v2.9 2016-10-03 byd - type for number of commands changed from SINT to USINT for function block fbModbusRTUmas2
v3.0 2016-10-17 byd - fbModbusRTUmas2 fix error, when there was no delay between commands after detecting error on reception
v3.1 2017-04-18 byd - added support for function Mask Write Register
                      changed setting of IP address in function blocks ModbusTCPmas and fbModbusTCPmas2, so it's no longer influenced by UNI connection settings
v3.2 2017-11-03 byd - added block fbModbusUDPmas for Modbus UDP
                      removed intermediate states prolonging delays between receiving and transmitting in all blocks
v3.3 2018-01-09 byd - fixed endless loop when commands did't contain any comnand to be selected by GrSel (from version 3.2)
v3.4 2018-04-03 byd - removed limitation of Modbus TCP master to run only on ETH1 interface. Now it can run on ETH2, ETH3,... if the IP address and port is set in HW configuration (IP address in ModbusCmdTCP is ignored)
v3.5 2019-01-23 byd - fbModbusTCPslave changes port even if there is a active connection
v3.6 2019-30-04 byd - function blocks fbModbusRTUmas and fbModbusRTUmas2 doesn't close connection when reply from slave device contains exception
v3.7 2020-04-20 byd - function block fbModbusTCPslave is now able to handle commands fragmented by TCP protocol and multiple commands in a single packet
                    - when processing responses to messages Read holding/input register, there is additional check if there are not more data than what was requested. Only the number of register specified in the request is copied to the user variable
                    - pause between the communications in the fbModbusTCPmas2 function block is only applied in connection with the same device
v3.8 2020-07-08 byd - fixed hazard when during online change the function blocks ModbusTCPmas and fbModbusTCPmas2 could write received data to position from previous memory mapping
v3.9 2021-08-02 byd - fbModbusTCPslave with UnitID set to zero receives all messages regardless of slave ID
                      added functions for conversion of types transferred in multiple registers
v4.0 2021-08-26 byd - fbModbusTCPslave - the setting of the UNI connection port is suppressed for ETH2 and higher on CPMs K and L series, where there the change from a user program is not supported. It is possible to use the block if the port is specified in the HW configuration.
*)

(*----------------------------------------------------------------------------*)
{LIBRARY="LOCALLIB\STDLIB_V22_20180619.MLB"}
{LIBRARY="LOCALLIB\SYSLIB_V44_20200302.MLB"}
{LIBRARY="LOCALLIB\CRCLIB_V13_20170224.MLB"}
{LIBRARY="LOCALLIB\COMLIB_V32_20191210.MLB"}

TYPE TCmdStruct :
  STRUCT  (*`{ENU} Structure for control of Modbus RTU master FB Struktura pro øízení funkèního bloku Modbus RTU master*)
    Gr               : usint;  (*`{ENU} The command can be grouped for sending an auto mode or manual mode.. {CSY} Èíslo skupiny pøíkazù pro automatickı nebo manuální reim*)
    SNo              : usint;  (*`{ENU} Station number of slave device 1 to 247  (0 is broadcast) {CSY} Adresa slave zaøízení 1 a 247 (0 je broadcast)*)
    FNC              : usint;  (*`{ENU} Command code Modbus 01,02,03,04,05,06,15,16,17,22 {CSY} Èíslo pøíkazu Modbus protokolu 01,02,03,04,05,06,15,16,17,22*)
    StAdr            : uint;  (*`{ENU} Address of Modbus object 0000..65535 (Coil,InpBits,InpRegs,HoldRegs) {CSY} Adresa Modbus objektu 0000..65535 (Coil,InpBits,InpRegs,HoldRegs)*)
    NoPoint          : uint;  (*`{ENU} Number of data types (BOOL or WORD) to be read or written  {CSY} Poèet objektù (BOOL nebo WORD), které budou èteny nebo zapisovány*)
    PtrData          : udint;  (*`{ENU} Pointer to sent or received data (ARRAY[] OF BOOL or ARRAY[] OF INT) {CSY} Adresa promìnné, do které budou uloena pøijatá data nebo ze které budou data odeslána*)
  END_STRUCT;
END_TYPE

__DECL FUNCTION ModbusCmd : bool
(*`{ENU} The Function writes communication parameters into array of commands.
  Communication with Modbus slave devices will be controlled by this array.
  This function prepares commands for function block ModbusRTUmas() and fbModbusRTUmas2.
  Function returns TRUE if Gr is not equal to zero

{CSY} Funkce nastaví parametry komunikace do pole pøíkazù,
  kterımi se pak øídí komunikace se zaøízeními Modbus slave.
  Tato funkce slouí pro nastavení pøíkazù pro funkèní blok ModbusRTUmas a fbModbusRTUmas2.
  Funkce vrací TRUE pokud je Gr rùzné od nula*)
  VAR_INPUT
    Gr               : usint;  (*`{ENU} The command can be grouped for sending for auto mode or manual mode (1..255) {CSY} Èíslo skupiny pøíkazù pro automatickı nebo manuální reim (1..255)*)
    SNo              : usint;  (*`{ENU} Station number of slave device 1 to 247  (0 is broadcast) {CSY} Adresa slave zaøízení 1 a 247; Nula je urèena pro broadcast a vìtší ne èísla 247 jsou rezervována pro jiné pouití.*)
    FNC              : usint;  (*`{ENU} Command code Modbus 01,02,03,04,05,06,15,16,17,22 {CSY} Èíslo pøíkazu Modbus protokolu 01,02,03,04,05,06,15,16,17,22*)
    StAdr            : uint;  (*`{ENU} Start address of Modbus object 0..65535 (Coil, Inputs, Input registers, Holding registers) {CSY} Poèáteèní adresa Modbus objektu 0..65535 (Coil, Inputs, Input registers, Holding registers)*)
    NoPoint          : uint;  (*`{ENU} Number of data types (BOOL or WORD) to be read or written {CSY} Poèet objektù (BOOL nebo WORD), které budou èteny nebo zapisovány*)
    PtrData          : PTR_TO usint;  (*`{ENU} Pointer to sent or received data !!Warning!! If FNC is equal to 1, 2 or 5 pointer has to be to BOOL or ARRAY OF BOOL {CSY} Ukazatel na poèátek pole promìnnıch v PLC Tecomat pøenášenıch tímto pøíkazem !! Pozor !! Je-li FCN rovno 1, 2 nebo 5 musí pointer ukazovat na typ BOOL nebo pole typu BOOL*)
  END_VAR
  VAR_IN_OUT
    Cmd              : TCmdStruct;  (*`{ENU} Command, which will be set {CSY} Vıslednı pøíkaz pro øízení jedné komunikace, kterı bude funkcí nastaven*)
  END_VAR
END_FUNCTION

TYPE TCmdStructTCP :
  STRUCT  (*`{ENU} Structure for control of Modbus TCP master FB {CSY} Struktura pro øízení funkèního bloku Modbus TCP master*)
    Gr               : usint;  (*`{ENU} The command can be grouped for sending an auto mode or manual mode.. {CSY} Èíslo skupiny pøíkazù pro automatickı nebo manuální reim*)
    IP               : string [22];  (*`{ENU} IP address (and port if needed) of slave device (for example '192.168.1.1' or '192.168.1.1:512') {CSY} IP adresa (a pøípadnì port) slave zaøízení (napø. '192.168.1.1' nebo '192.168.1.1:512')*)
    UnitID           : usint;  (*`{ENU} Unit identifier of remote slave device {CSY} Identifikátor slave zaøízení*)
    FNC              : usint;  (*`{ENU} command code Modbus 01,02,03,04,05,06,15,16,17,22 {CSY} Èíslo pøíkazu Modbus protokolu 01,02,03,04,05,06,15,16,17,22*)
    StAdr            : uint;  (*`{ENU} address of Modbus object 0000..65535 (Coil,InpBits,InpRegs,HoldRegs) {CSY} Adresa Modbus objektu 0000..65535 (Coil,InpBits,InpRegs,HoldRegs)*)
    NoPoint          : uint;  (*`{ENU} number of data types (BOOL or WORD) to be read or written {CSY} Poèet objektù (BOOL nebo WORD), které budou èteny nebo zapisovány*)
    PtrData          : udint;  (*`{ENU} pointer to sent or received data (ARRAY[] OF BOOL or ARRAY[] OF INT) {CSY} Adresa promìnné, do které budou uloena pøijatá data nebo ze které budou data odeslána*)
  END_STRUCT;
END_TYPE

__DECL FUNCTION ModbusCmdTCP : bool
(*`{ENU} The Function writes communication parameters into array of commands.
  Communication with Modbus slave devices will be controlled by this array.
  This function prepares commands for function block ModbusTCPmas(), fbModbusTCPmas2 and fbModbusUDPmas.
  Function returns TRUE if Gr is not equal to zero

  {CSY} Funkce nastaví parametry komunikace do pole pøíkazù,
  kterımi se pak øídí komunikace se zaøízeními Modbus slave.
  Tato funkce slouí pro nastavení pøíkazù pro funkèní blok ModbusTCPmas(), fbModbusTCPmas2 a fbModbusUDPmas.
  Funkce vrací TRUE pokud je Gr rùzné od nula*)
  VAR_INPUT
    Gr               : usint;  (*`{ENU} The commands can be grouped for sending at auto mode or manual mode {CSY} Èíslo skupiny pøíkazù pro automatickı nebo manuální reim (1..255)*)
    IP               : string [80];  (*`{ENU} IP address (and port if needed) of slave device {CSY} IP adresa (a pøípadnì port) slave zaøízení  (napø. '192.168.1.1' nebo '192.168.1.1:512')*)
    UnitID           : usint;  (*`{ENU} Unit identifier of remote slave device {CSY} Identifikátor slave zaøízení*)
    FNC              : usint;  (*`{ENU} Command code Modbus 01,02,03,04,05,06,15,16,22 {CSY} Èíslo pøíkazu Modbus protokolu 01,02,03,04,05,06,15,16,22*)
    StAdr            : uint;  (*`{ENU} Address of Modbus object 0000..65535 (Coil,InpBits,InpRegs,HoldRegs) {CSY} Adresa Modbus objektu 0000..65535 (Coil,InpBits,InpRegs,HoldRegs)*)
    NoPoint          : uint;  (*`{ENU} Number of data types (BOOL or WORD) to be read or written 0..9999 {CSY} Poèet objektù (BOOL nebo WORD), které budou èteny nebo zapisovány*)
    PtrData          : PTR_TO usint;  (*`{ENU} Pointer to sent or received data !!Warning!! If FNC is equal to 1, 2 or 5 pointer has to be to BOOL or ARRAY OF BOOL {CSY} Ukazatel na poèátek pole promìnnıch v PLC Tecomat pøenášenıch tímto pøíkazem !! Pozor !! Je-li FCN rovno 1, 2 nebo 5 musí pointer ukazovat na typ BOOL nebo pole typu BOOL*)
  END_VAR
  VAR_IN_OUT
    Cmd              : TCmdStructTCP;  (*`{ENU} Command, which will be set {CSY} pøíkaz, kterı bude nastaven*)
  END_VAR
END_FUNCTION

VAR_GLOBAL CONSTANT
 ModbusRTUlib_MDBErrorStrings {HIDDEN} : ARRAY [0..24] OF string [40] :=  [
    'No error                                ',   //0
    'Response with other slave address       ',   //1 +128 Response with other station number of slave device
    'Response with other FNC                 ',   //2 +128 Response with other FNC
    'Checksum error in reception             ',   //3 +128 Checksum error in reception
    'Unknown FNC in transmit command         ',   //4 +128 Unknown FNC in transmit command
    'Response with Unknown FNC               ',   //5 +128 Response with Unknown FNC
    '                                        ',   //6 +128
    'Response Timeout Error                  ',   //7 +128 Response Timeout Error
    '                                        ',   //8 +128
    'Exception: ILLEGAL FUNCTION             ',   //1 +136 Exception from slave device
    'Exception: ILLEGAL DATA ADDRESS         ',   //2 +136 Exception from slave device
    'Exception: ILLEGAL DATA VALUE           ',   //3 +136 Exception from slave device
    'Exception: SLAVE DEVICE FAILURE         ',   //4 +136 Exception from slave device
    'Exception: ACKNOWLEDGE                  ',   //5 +136 Exception from slave device
    'Exception: SLAVE DEVICE BUSY            ',   //6 +136 Exception from slave device
    '                                        ',   //7 +136
    'Exception: MEMORY PARITY ERROR          ',   //8 +136 Exception from slave device
    '                                        ',   //9 +136
    'Exception: GATEWAY PATH UNAVAILABLE     ',   //A +136 Exception from slave device
    'GATEWAY TARGET DEVICE FAILED TO RESPOND ',   //B +136 Exception from slave device
    'Invalid parameter chanCode              ',   //20+128 Channel can be ETH1_uni0, ..., ETH1_uni7 only
    'Can not establish a TCP connection      ',   //21+128
    'Invalid IP address of slave device      ',   //22+128 IP address can not be 0.0.0.0
    'Change of IP address failed             ',   //23+128 IP address can not be changed
    'Unknown ERROR                           '];
 GrMan : usint :=  0;  (*`{CSY}Èíslo skupiny vyhrazené pro ruèní øízení{ENU}Group number reserved for manual control*)
 GrInit : usint :=  255;  (*`{CSY}Èíslo skupiny vyhrazené pro inicializaèní pøíkazy{ENU}Group number reserved for initialization commands*)
 MDB_FNC_ReadCoilStatus : usint :=  01;  (*`{ENU}Read Coil Status          {CSY}ètení vıstupù (pamì 0X)*)
 MDB_FNC_ReadInputStatus : usint :=  02;  (*`{ENU}Read Input Status         {CSY}ètení vstupù (pamì 1X)*)
 MDB_FNC_ReadHoldingRegisters : usint :=  03;  (*`{ENU}Read Holding Registers    {CSY}ètení registrù (pamì 4X)*)
 MDB_FNC_ReadInputRegisters : usint :=  04;  (*`{ENU}Read Input Registers      {CSY}ètení vstupních registrù (pamì 3X)*)
 MDB_FNC_ForceSingleCoil : usint :=  05;  (*`{ENU}Force Single Coil         {CSY}nastavení jednoho vıstupu (pamì 0X)*)
 MDB_FNC_PresetSingleRegister : usint :=  06;  (*`{ENU}Preset Single Register    {CSY}nastavení jednoho registru (pamì 4X)*)
 MDB_FNC_ReadExceptionStatus : usint :=  07;  (*`{ENU}Read Exception Status     {CSY}informace o stavu automatu*)
 MDB_FNC_Diagnostics : usint :=  08;  (*`{ENU}Diagnostics               {CSY}diagnostické funkce*)
 MDB_FNC_ForceMultipleCoils : usint :=  15;  (*`{ENU}Force Multiple Coils      {CSY}nastavování vıstupù (pamì 0X)*)
 MDB_FNC_PresetMultipleRegisters : usint :=  16;  (*`{ENU}Preset Multiple Registers {CSY}nastavování holding registrù (pamì 4X)*)
 MDB_FNC_ReportSlaveID : usint :=  17;  (*`{ENU}Report Slave ID           {CSY}vrací identifikaèní èíslo serveru*)
 MDB_FNC_MaskWrite : usint :=  22;  (*`{ENU}Mask Write                {CSY}nastavení registru pomocí masky (pamì 4X)*)

END_VAR

__DECL FUNCTION GetModbusErrTxt : bool
(*`{ENU} Converts error code returned by function blocks fbModbusRTUslave, fbModbusTCPslave, ModbusRTUmas, ModbusTCPmas to text description in English language
  Function returns true if ErrorCode is not equal to zero
{CSY} Pøevádí kód chyby vrácenı funkèními bloky fbModbusRTUslave, fbModbusTCPslave, ModbusRTUmas, ModbusTCPmas na textovı popis v anglickém jazyce.
  Funkce vrací true je-li ErrorCode nenulovı*)
  VAR_INPUT
    ErrorCode        : usint;  (*`{ENU} Error code  {CSY} Chybovı kód*)
  END_VAR
  VAR_IN_OUT
    ErrTxt           : string [80];  (*`{ENU} Error description {CSY} Popis chyby*)
  END_VAR
END_FUNCTION

__DECL FUNCTION UINT2_TO_REAL : real
(*`{ENG}Converts two modbus registers holding IEEE 754 32 bit floating point number to REAL
  {CSY}Pøevede 2 modbusové registry obsahující 32 bitové èíslo s plovoucí èárkou dle IEEE 754 na REAL*)
  VAR_INPUT
    IN1              : uint;  (*`{ENG}more significant register{CSY}více vıznamnı registr*)
    IN2              : uint;  (*`{ENG}less significant register{CSY}ménì vıznamnı registr*)
  END_VAR
END_FUNCTION

__DECL FUNCTION UINT2_TO_UDINT : udint
(*`{ENG}Converts two modbus registers holding 32bit integer to UDINT
  {CSY}Pøevede 2 modbusové registry obsahující 32 bitovou celoèíselnou hodnotu na UDINT*)
  VAR_INPUT
    IN1              : uint;  (*`{ENG}more significant register{CSY}více vıznamnı registr*)
    IN2              : uint;  (*`{ENG}less significant register{CSY}ménì vıznamnı registr*)
  END_VAR
END_FUNCTION

__DECL FUNCTION UINT2_TO_DINT : dint
(*`{ENG}Converts two modbus registers holding 32bit integer to UDINT
  {CSY}Pøevede 2 modbusové registry obsahující 32 bitovou celoèíselnou hodnotu na DINT*)
  VAR_INPUT
    IN1              : uint;  (*`{ENG}more significant register{CSY}více vıznamnı registr*)
    IN2              : uint;  (*`{ENG}less significant register{CSY}ménì vıznamnı registr*)
  END_VAR
END_FUNCTION

__DECL FUNCTION UINT4_TO_LREAL : lreal
(*`{ENG}Converts four modbus registers holding IEEE 754 64 bit floating point number to LREAL
  {CSY}Pøevede 4 modbusové registry obsahující 64 bitové èíslo s plovoucí èárkou dle IEEE 754 na LREAL*)
  VAR_INPUT
    IN1              : uint;  (*`{ENG}most significant register{CSY}nejvíce vıznamnı registr*)
    IN2              : uint;  (*`{ENG}more significant register{CSY}více vıznamnı registr*)
    IN3              : uint;  (*`{ENG}less significant register{CSY}ménì vıznamnı registr*)
    IN4              : uint;  (*`{ENG}least significant register{CSY}nejménì vıznamnı registr*)
  END_VAR
END_FUNCTION

TYPE ModbusRTUlib_TStateMB {HIDDEN} : 
  (StartMB,
   SndMB,
   SndMBt,
   WaitRespMB,
   RecMB,
   ErrMB,
   DelayMB 
  );
END_TYPE

__DECL FUNCTION_BLOCK ModbusRTUmas
(*`{ENU} Communicates with the slave devices by protocol Modbus RTU.
{CSY} Sestavuje komunikaèní relace podle pole pøipravenıch øídících pøíkazù a prostøednictvím zvoleného komunikaèního kanálu vymìòuje data mezi PLC master a pøipojenımi zaøízeními typu Modbus RTU slave.*)
  VAR_INPUT
    EN               : bool;  (*`{ENU} Enable {CSY} Povolení èinnosti funkèního bloku*)
    GrSel            : usint;  (*`{ENU} Select the sequence of sending commands defined by array of commands of type TCmdStruct. {CSY} Vıbìr reimu komunikace. Nastavuje zpùsob vysílání zpráv, které jsou definovány v poli pøíkazù typu TCmdStruct.*)
    CmdNo            : sint;  (*`{ENU} Command number in array of commands of type TCmdStruct to be send in manual mode. In auto mode, this is ignored. {CSY} Èíslo pøíkazu, kterı bude odeslán z pole pøíkazù v manuálním reimu. V automatickém reimu bude tento vstup ignorován.*)
    Start            : bool R_EDGE;  (*`{ENU} Sends command defined by CmdNo in manual mode. In auto mode, this is ignored. {CSY} V manuálním reimu se na nábìnou hranu tohoto vstupu odešle pøíkaz danı vstupem CmdNo. V automatickém reimu bude tento vstup ignorován.*)
    MaxCmd           : sint;  (*`{ENU} Total number of commands in an array. {CSY} Celkovı poèet pøíkazù, které jsou prohledávány v øídicím poli pøíkazù*)
    chanCode         : uint;  (*`{ENU} Channel code (CH1_uni, ..., CH10_uni) {CSY} Komunikaèní kanál, kterım probíhá komunikace ( CH1_uni, ..., CH10_uni)*)
    Endian           : bool;  (*`{ENU} Storage of word object in communication; BigEndian = 0, LittleEndian = 1  {CSY} Uloení wordovıch registrù v komunikaci; 0 - BigEndian; 1 - LittleEndian*)
    MBtimeOut        : time :=  T#2s;  (*`{ENU} ModBus time out (default=2[sec]) {CSY} Modbus timeout (implicitnì = 2 [sec])*)
  END_VAR
  VAR_OUTPUT
    Done             : bool;  (*`{ENU} communication command was completed succesfully (R_Edge pulse) {CSY} Komunikaèní pøíkaz byl úspìšnì vykonán (pulz délky 1 cyklu PLC)*)
    LastCmd          : sint;  (*`{ENU} Index of command which is recently executed. 0=none,[1..MaxRec] {CSY} Èíslo naposledy vykonaného pøíkazu 0=ádnı,[1..MaxRec]*)
    ErrCode          : usint;  (*`{ENU} Error code {CSY} Chybovı kód*)
  END_VAR
  VAR_IN_OUT
    Commands         : TCmdStruct;  (*`{ENU} Array of commands to manage Modbus communications {CSY} Pole pøíkazù pro øízení komunikace Modbus*)
  END_VAR
  VAR
    SendTo           : fbSendTo;
    RecvFrom         : fbRecvFrom;
    DataR            : ARRAY [0..261] OF usint;  (*`reciv data    !!! // Byd rev.1.7*)
    NUMR             : uint;  (*`number of reciv data*)
    ERRr             : usint;  (*`Error of reciv data*)
    DataT            : ARRAY [0..261] OF usint;  (*`transmit data  !!! // Byd rev.1.7*)
    StateMB          : ModbusRTUlib_TStateMB;
    InitMB_Done      : bool;  (*`inicialization records was completed*)
    isTcp            : bool;
    RespTimeOut      : TON;
    traNum           : uint;
    autoCmd          : sint;
  END_VAR
END_FUNCTION_BLOCK

TYPE ModbusRTUlib_TStatesMdbTCP :   (*`{CSY}Inicializace{ENU}Initialization*)
  (MdbTCP_init,  (*`{CSY}Inicializace{ENU}Initialization*)
   MdbTCP_start,  (*`{CSY}Èekání na Start v manuální reimu, vıbìr dalšího pøíkazu v automatickém reimu{ENU}Waiting for Start in manual mode, looking for next command in auto mode*)
   MdbTCP_selCommand,  (*`{CSY}Vıbìr pøíkazu nastaveného automatickım nebo manuálním reimem{ENU}Selecting command set by auto or manual mode*)
   MdbTCP_setIPadr,  (*`{CSY}Nastavení IP adresy podle vybraného pøíkazu{ENU}Setting IP address acording to selected command*)
   MdbTCP_estabCon,  (*`{CSY}Navázání spojení s vybranou IP adresou{ENU}Establishing connection with selected IP*)
   MdbTCP_sendData,  (*`{CSY}Vysílání pøíkazu{ENU}Sending command*)
   MdbTCP_recData,  (*`{CSY}Pøíjem odpovìdi podøízené stanice{ENU}Receiving slave answer*)
   MdbTCP_error   (*`{CSY}Zavírání spojení po detekci chyby{ENU}Closing connecting after detecting error*)
  );
END_TYPE

__DECL FUNCTION_BLOCK ModbusTCPmas
(*`{ENU} Communicates via selected TCP connection with the slave devices by protocol Modbus TCP.
{CSY} Sestavuje komunikaèní relace podle pole pøipravenıch øídících pøíkazù a prostøednictvím zvoleného TCP spojení vymìòuje data mezi PLC master a pøipojenımi zaøízeními typu Modbus slave.*)
  VAR_INPUT
    EN               : bool;  (*`{ENU} Enable {CSY} Povolení èinnosti funkèního bloku*)
    GrSel            : usint;  (*`{ENU} Select the sequence of sending commands defined by array of commands of type TCmdStructTCP.{CSY} Vıbìr reimu komunikace. Nastavuje zpùsob vysílání zpráv, které jsou definovány v poli pøíkazù typu TCmdStructTCP.*)
    CmdNo            : usint;  (*`{ENU} Command number in array of commands of type TCmdStructTCP to be send in manual mode. In auto mode, this is ignored. {CSY} Èíslo pøíkazu, kterı bude odeslán z pole pøíkazù v manuálním reimu. V automatickém reimu bude tento vstup ignorován.*)
    Start            : bool R_EDGE;  (*`{ENU} Sends command defined by CmdNo in manual mode. In auto mode, this is ignored. {CSY} V manuálním reimu se na nábìnou hranu tohoto vstupu odešle pøíkaz danı vstupem CmdNo. V automatickém reimu bude tento vstup ignorován.*)
    MaxCmd           : usint;  (*`{ENU} Total number of commands in an array. {CSY} Celkovı poèet pøíkazù v poli pøíkazù*)
    chanCode         : uint;  (*`{ENU} Channel code (ETH1_uni0, ..., ETH1_uni7) {CSY} Èíslo komunikaèního kanálu (ETH1_uni0, ..., ETH1_uni7)*)
    Endian           : bool;  (*`{ENU} Storage of word object in communication; BigEndian = 0, LittleEndian = 1  {CSY} Uloení wordovıch registrù v komunikaci; 0 - BigEndian; 1 - LittleEndian*)
    MBtimeOut        : time :=  T#2s;  (*`{ENU} ModBus time out (default=2[sec]) {CSY} Modbus timeout (implicitnì=2[sec])*)
  END_VAR
  VAR_OUTPUT
    Done             : bool;  (*`{ENU} Communication command was completed (pulse for 1 PLC cycle) {CSY} Pøíkaz byl zpracován ( pulz délky 1 cyklu PLC)*)
    LastCmd          : usint;  (*`{ENU} Index of command which is recently executed. 0=none,[1..MaxRec] {CSY} Poøadové èíslo naposledy vykonaného pøíkazu 0=ádnı,[1..MaxRec]*)
    ErrCode          : usint;  (*`{ENU} Error code {CSY} Chybovı kód*)
    State            : ModbusRTUlib_TStatesMdbTCP;  (*`{ENU} State of communication {CSY} Stav komunikace*)
  END_VAR
  VAR_IN_OUT
    Commands         : TCmdStructTCP;  (*`{ENU} Array of commands to manage communications {CSY} Pole pøíkazù pro øízení komunikace*)
  END_VAR
  VAR
    initDone         : bool;  (*`inicialization records was completed*)
    wasStart         : bool;  (*`zachyceni startu*)
    isEstab          : bool;
    autoCmd          : usint;
    newEthAdr        : TRemoteEthAdr;
    localCmd         : TCmdStruct;
    modbusRTU        : ModbusRTUmas :=  (isTcp := 1);
    chkTim           : TON;
    lastState        : ModbusRTUlib_TStatesMdbTCP;
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION_BLOCK fbModbusRTUmas2
(*`{ENU} Communicates with the slave devices by protocol Modbus RTU.
{CSY} Sestavuje komunikaèní relace podle pole pøipravenıch øídících pøíkazù a prostøednictvím zvoleného komunikaèního kanálu vymìòuje data mezi PLC master a pøipojenımi zaøízeními typu Modbus RTU slave.*)
  VAR_INPUT
    EN               : bool;  (*`{ENU} Enable {CSY} Povolení èinnosti funkèního bloku*)
    GrSel            : usint;  (*`{ENU} Select the sequence of sending commands defined by array of commands of type TCmdStruct. {CSY} Vıbìr reimu komunikace. Nastavuje zpùsob vysílání zpráv, které jsou definovány v poli pøíkazù typu TCmdStruct.*)
    CmdNo            : usint;  (*`{ENU} Command number in array of commands of type TCmdStruct to be send in manual mode. In auto mode, this is ignored. {CSY} Èíslo pøíkazu, kterı bude odeslán z pole pøíkazù v manuálním reimu. V automatickém reimu bude tento vstup ignorován.*)
    Start            : bool R_EDGE;  (*`{ENU} Sends command defined by CmdNo in manual mode. In auto mode, this is ignored. {CSY} V manuálním reimu se na nábìnou hranu tohoto vstupu odešle pøíkaz danı vstupem CmdNo. V automatickém reimu bude tento vstup ignorován.*)
    MaxCmd           : usint;  (*`{ENU} Total number of commands in an array. {CSY} Celkovı poèet pøíkazù, které jsou prohledávány v øídicím poli pøíkazù*)
    chanCode         : uint;  (*`{ENU} Channel code (CH1_uni, ..., CH10_uni) {CSY} Komunikaèní kanál, kterım probíhá komunikace ( CH1_uni, ..., CH10_uni)*)
    Endian           : bool;  (*`{ENU} Storage of word object in communication; BigEndian = 0, LittleEndian = 1  {CSY} Uloení wordovıch registrù v komunikaci; 0 - BigEndian; 1 - LittleEndian*)
    MBtimeOut        : time :=  T#2s;  (*`{ENU} ModBus time out (default=2[sec]) {CSY} Modbus timeout (implicitnì = 2 [sec])*)
    Delay            : time;  (*`{ENU} Delay between received message and new message {CSY} Prodleva mezi pøijatou zprávou a novou zprávou*)
  END_VAR
  VAR_OUTPUT
    Done             : bool;  (*`{ENU} communication command was completed succesfully (R_Edge pulse) {CSY} Komunikaèní pøíkaz byl úspìšnì vykonán (pulz délky 1 cyklu PLC)*)
    LastCmd          : usint;  (*`{ENU} Index of command which is recently executed. 0=none,[1..MaxRec] {CSY} Èíslo naposledy vykonaného pøíkazu 0=ádnı,[1..MaxRec]*)
    ErrCode          : usint;  (*`{ENU} Error code {CSY} Chybovı kód*)
  END_VAR
  VAR_IN_OUT
    Commands         : TCmdStruct;  (*`{ENU} Array of commands to manage Modbus communications {CSY} Pole pøíkazù pro øízení komunikace Modbus*)
  END_VAR
  VAR
    SendTo           : fbSendTo;
    RecvFrom         : fbRecvFrom;
    DataR            : ARRAY [0..261] OF usint;  (*`reciv data    !!! // Byd rev.1.7*)
    NUMR             : uint;  (*`number of reciv data*)
    ERRr             : usint;  (*`Error of reciv data*)
    DataT            : ARRAY [0..261] OF usint;  (*`transmit data  !!! // Byd rev.1.7*)
    StateMB          : ModbusRTUlib_TStateMB;
    InitMB_Done      : bool;  (*`inicialization records was completed*)
    isTcp            : bool;
    wasStart         : bool;
    RespTimeOut      : TON;
    DelayTimeOut     : TON;
    traNum           : uint;
    autoCmd          : usint;
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION_BLOCK fbModbusTCPmas2
(*`{ENU} Communicates via selected TCP connection with the slave devices by protocol Modbus TCP.
{CSY} Sestavuje komunikaèní relace podle pole pøipravenıch øídících pøíkazù a prostøednictvím zvoleného TCP spojení vymìòuje data mezi PLC master a pøipojenımi zaøízeními typu Modbus slave.*)
  VAR_INPUT
    EN               : bool;  (*`{ENU} Enable {CSY} Povolení èinnosti funkèního bloku*)
    GrSel            : usint;  (*`{ENU} Select the sequence of sending commands defined by array of commands of type TCmdStructTCP.{CSY} Vıbìr reimu komunikace. Nastavuje zpùsob vysílání zpráv, které jsou definovány v poli pøíkazù typu TCmdStructTCP.*)
    CmdNo            : usint;  (*`{ENU} Command number in array of commands of type TCmdStructTCP to be send in manual mode. In auto mode, this is ignored. {CSY} Èíslo pøíkazu, kterı bude odeslán z pole pøíkazù v manuálním reimu. V automatickém reimu bude tento vstup ignorován.*)
    Start            : bool R_EDGE;  (*`{ENU} Sends command defined by CmdNo in manual mode. In auto mode, this is ignored. {CSY} V manuálním reimu se na nábìnou hranu tohoto vstupu odešle pøíkaz danı vstupem CmdNo. V automatickém reimu bude tento vstup ignorován.*)
    MaxCmd           : usint;  (*`{ENU} Total number of commands in an array. {CSY} Celkovı poèet pøíkazù v poli pøíkazù*)
    chanCode         : uint;  (*`{ENU} Channel code (ETH1_uni0, ..., ETH1_uni7) {CSY} Èíslo komunikaèního kanálu (ETH1_uni0, ..., ETH1_uni7)*)
    Endian           : bool;  (*`{ENU} Storage of word object in communication; BigEndian = 0, LittleEndian = 1  {CSY} Uloení wordovıch registrù v komunikaci; 0 - BigEndian; 1 - LittleEndian*)
    MBtimeOut        : time :=  T#2s;  (*`{ENU} ModBus time out (default=2[sec]) {CSY} Modbus timeout (implicitnì=2[sec])*)
    Delay            : time;  (*`{ENU} Delay between received message and new message {CSY} Prodleva mezi pøíjatou zprávou a novou zprávou*)
  END_VAR
  VAR_OUTPUT
    Done             : bool;  (*`{ENU} Communication command was completed (pulse for 1 PLC cycle) {CSY} Pøíkaz byl zpracován ( pulz délky 1 cyklu PLC)*)
    LastCmd          : usint;  (*`{ENU} Index of command which is recently executed. 0=none,[1..MaxRec] {CSY} Poøadové èíslo naposledy vykonaného pøíkazu 0=ádnı,[1..MaxRec]*)
    ErrCode          : usint;  (*`{ENU} Error code {CSY} Chybovı kód*)
    State            : ModbusRTUlib_TStatesMdbTCP;  (*`{ENU} State of communication {CSY} Stav komunikace*)
  END_VAR
  VAR_IN_OUT
    Commands         : TCmdStructTCP;  (*`{ENU} Array of commands to manage communications {CSY} Pole pøíkazù pro øízení komunikace*)
  END_VAR
  VAR
    initDone         : bool;  (*`inicialization records was completed*)
    wasStart         : bool;  (*`zachyceni startu*)
    isEstab          : bool;
    delayActive      : bool;
    send             : bool;
    autoCmd          : usint;
    ptr              : PTR_TO TCmdStructTCP;
    newEthAdr        : TRemoteEthAdr;
    localCmd         : TCmdStruct;
    modbusRTU        : fbModbusRTUmas2 :=  (isTcp := 1);
    chkTim           : TON;
    lastState        : ModbusRTUlib_TStatesMdbTCP;
    DelayTimeOut     : TON;
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION_BLOCK fbRecvFromModbus
(*`Pøíjem dat z komunikaèního kanálu

   Funkèní blok pøijímá data z komunikaèního kanálu,
   kterı je specifikován promìnnou chanCode.
   Pøijatá data jsou uloena do pole data[].
   Délku pøijatıch dat udává promìnná lenData.

   Funkèní blok vrací informace o stavu pøíjmu.
   Pokud pøi pøíjmu nedojde k chybì, vıstupní promìnná
   error je 0, jinak obsahuje kód chyby.*)
  VAR_INPUT
    rq               : bool;  (*`ádost o pøíjem*)
    reset            : bool;
    chanCode         : uint;  (*`kód kanálu (CH1_uni, ..., CH10_uni, ETH1_uni0, ..., ETH1_uni7, ETH2_uni0, ..., ETH4_uni7)*)
    lenRx            : uint;  (*`max. moná délka pøijatıch dat*)
    sizeBuf          : uint;  (*`velikost mezipamìti pro zprávy*)
  END_VAR
  VAR_IN_OUT
    data             : TUni_BUFF;  (*`buffer pro pøijatou zprávu*)
    buffer           : usint;  (*`první byte mezipamìti pro zprávy*)
  END_VAR
  VAR_OUTPUT
    mesRec           : bool;  (*`pøíznak novì pøijaté zprávy*)
    bufFul           : bool;  (*`došlo k pøeplnìní bufferu*)
    error            : usint;  (*`chybovı kód*)
    lenData          : uint;  (*`velikost skuteènì pøijaté zprávy (poèet bytù)*)
    lenBuf           : uint;  (*`obsazení mezipamìti*)
  END_VAR
  VAR
    oldARC           : bool;
    recvFrom         : fbRecvFrom;
    ptrToUint        : PTR_TO uint;
    lenBufNet        : uint;
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION_BLOCK ModbusTcpDelaySendmas {HIDDEN}
(*`{ENU} Communicates via selected TCP connection with the slave devices by protocol Modbus TCP.
{CSY} Sestavuje komunikaèní relace podle pole pøipravenıch øídících pøíkazù a prostøednictvím zvoleného TCP spojení vymìòuje data mezi PLC master a pøipojenımi zaøízeními typu Modbus slave.*)
  VAR_INPUT
    EN               : bool;  (*`{ENU} Enable {CSY} Povolení èinnosti funkèního bloku*)
    GrSel            : usint;  (*`{ENU} Select the sequence of sending commands defined by array of commands of type TCmdStructTCP.{CSY} Vıbìr reimu komunikace. Nastavuje zpùsob vysílání zpráv, které jsou definovány v poli pøíkazù typu TCmdStructTCP.*)
    CmdNo            : usint;  (*`{ENU} Command number in array of commands of type TCmdStructTCP to be send in manual mode. In auto mode, this is ignored. {CSY} Èíslo pøíkazu, kterı bude odeslán z pole pøíkazù v manuálním reimu. V automatickém reimu bude tento vstup ignorován.*)
    Start            : bool R_EDGE;  (*`{ENU} Sends command defined by CmdNo in manual mode. In auto mode, this is ignored. {CSY} V manuálním reimu se na nábìnou hranu tohoto vstupu odešle pøíkaz danı vstupem CmdNo. V automatickém reimu bude tento vstup ignorován.*)
    MaxCmd           : usint;  (*`{ENU} Total number of commands in an array. {CSY} Celkovı poèet pøíkazù v poli pøíkazù*)
    chanCode         : uint;  (*`{ENU} Channel code (ETH1_uni0, ..., ETH1_uni7) {CSY} Èíslo komunikaèního kanálu (ETH1_uni0, ..., ETH1_uni7)*)
    Endian           : bool;  (*`{ENU} Storage of word object in communication; BigEndian = 0, LittleEndian = 1  {CSY} Uloení wordovıch registrù v komunikaci; 0 - BigEndian; 1 - LittleEndian*)
    MBtimeOut        : time :=  T#2s;  (*`{ENU} ModBus time out (default=2[sec]) {CSY} Modbus timeout (implicitnì=2[sec])*)
    MBdelay          : time :=  T#1s;  (*`{ENU} Delay before sending data after establishing TCP connection (default=1[sec]) {CSY} Zpodìní od navázání spojení po vyslání dat (implicitnì=1[sec])*)
  END_VAR
  VAR_OUTPUT
    Done             : bool;  (*`{ENU} Communication command was completed (pulse for 1 PLC cycle) {CSY} Pøíkaz byl zpracován ( pulz délky 1 cyklu PLC)*)
    LastCmd          : usint;  (*`{ENU} Index of command which is recently executed. 0=none,[1..MaxRec] {CSY} Poøadové èíslo naposledy vykonaného pøíkazu 0=ádnı,[1..MaxRec]*)
    ErrCode          : usint;  (*`{ENU} Error code {CSY} Chybovı kód*)
    State            : ModbusRTUlib_TStatesMdbTCP;  (*`{ENU} State of communication {CSY} Stav komunikace*)
  END_VAR
  VAR_IN_OUT
    Commands         : TCmdStructTCP;  (*`{ENU} Array of commands to manage communications {CSY} Pole pøíkazù pro øízení komunikace*)
  END_VAR
  VAR
    initDone         : bool;  (*`inicialization records was completed*)
    wasStart         : bool;  (*`zachyceni startu*)
    isEstab          : bool;
    autoCmd          : usint;
    newEthAdr        : TRemoteEthAdr;
    localCmd         : TCmdStruct;
    modbusRTU {HIDDEN} : ModbusRTUmas :=  (isTcp := 1);
    chkTim           : TON;
    delaySend        : TON;
    lastState        : ModbusRTUlib_TStatesMdbTCP;
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION_BLOCK fbModbusUDPmas
(*`{ENU} Communicates via selected UDP connection with the slave devices by protocol Modbus UDP.
{CSY} Sestavuje komunikaèní relace podle pole pøipravenıch øídících pøíkazù a prostøednictvím zvoleného UDP spojení vymìòuje data mezi PLC master a pøipojenımi zaøízeními typu Modbus slave.*)
  VAR_INPUT
    EN               : bool;  (*`{ENU} Enable {CSY} Povolení èinnosti funkèního bloku*)
    GrSel            : usint;  (*`{ENU} Select the sequence of sending commands defined by array of commands of type TCmdStructTCP.{CSY} Vıbìr reimu komunikace. Nastavuje zpùsob vysílání zpráv, které jsou definovány v poli pøíkazù typu TCmdStructTCP.*)
    CmdNo            : usint;  (*`{ENU} Command number in array of commands of type TCmdStructTCP to be send in manual mode. In auto mode, this is ignored. {CSY} Èíslo pøíkazu, kterı bude odeslán z pole pøíkazù v manuálním reimu. V automatickém reimu bude tento vstup ignorován.*)
    Start            : bool R_EDGE;  (*`{ENU} Sends command defined by CmdNo in manual mode. In auto mode, this is ignored. {CSY} V manuálním reimu se na nábìnou hranu tohoto vstupu odešle pøíkaz danı vstupem CmdNo. V automatickém reimu bude tento vstup ignorován.*)
    MaxCmd           : usint;  (*`{ENU} Total number of commands in an array. {CSY} Celkovı poèet pøíkazù v poli pøíkazù*)
    chanCode         : uint;  (*`{ENU} Channel code (ETH1_uni0, ..., ETH1_uni7) {CSY} Èíslo komunikaèního kanálu (ETH1_uni0, ..., ETH1_uni7)*)
    Endian           : bool;  (*`{ENU} Storage of word object in communication; BigEndian = 0, LittleEndian = 1  {CSY} Uloení wordovıch registrù v komunikaci; 0 - BigEndian; 1 - LittleEndian*)
    MBtimeOut        : time :=  T#2s;  (*`{ENU} ModBus time out (default=2[sec]) {CSY} Modbus timeout (implicitnì=2[sec])*)
    Delay            : time;  (*`{ENU} Delay between received message and new message {CSY} Prodleva mezi pøíjatou zprávou a novou zprávou*)
    localPort        : uint :=  61502;  (*`{ENU} Local port for sending messages, each instance must have different one {CSY} Místní port pro odesílání zpráv, kadá instance musí mít jinı*)
  END_VAR
  VAR_OUTPUT
    Done             : bool;  (*`{ENU} Communication command was completed (pulse for 1 PLC cycle) {CSY} Pøíkaz byl zpracován ( pulz délky 1 cyklu PLC)*)
    LastCmd          : usint;  (*`{ENU} Index of command which is recently executed. 0=none,[1..MaxRec] {CSY} Poøadové èíslo naposledy vykonaného pøíkazu 0=ádnı,[1..MaxRec]*)
    ErrCode          : usint;  (*`{ENU} Error code {CSY} Chybovı kód*)
    State            : ModbusRTUlib_TStatesMdbTCP;  (*`{ENU} State of communication {CSY} Stav komunikace*)
  END_VAR
  VAR_IN_OUT
    Commands         : TCmdStructTCP;  (*`{ENU} Array of commands to manage communications {CSY} Pole pøíkazù pro øízení komunikace*)
  END_VAR
  VAR
    initDone         : bool;  (*`inicialization records was completed*)
    autoCmd          : usint;
    ptr              : PTR_TO TCmdStructTCP;
    newEthAdr        : TRemoteEthAdr;
    localCmd         : TCmdStruct;
    modbusRTU        : fbModbusRTUmas2 :=  (isTcp := 1);
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION fcModbusUdpOff : bool
(*`{ENG}Disables Modbus UDP driver
  The presence of function call in code of user program disables UDP driver. For reenabling driver is necessary to upload code without function call and switch off/on CPM.
  {CSY}Vypíná Modbus UDP ovladaè
  Pøítomnost volání funkce v kódu uivatelském programu vypíná Modbus UDP ovladaè. Pro znovu zapnutí ovladaèe je nutné nahrát kód bez volání funkce a restartovat centrálu.*)
END_FUNCTION

__DECL FUNCTION fcModbusTcpOff : bool
(*`{ENG}Disables Modbus TCP driver
  The presence of function call in code of user program disables TCP driver. For reenabling driver is necessary to upload code without function call and switch off/on CPM.
  This function overrides setting made by fcModbusUdpOff. For disabling both drivers use fcModbusTcpUdpOff.
  {CSY}Vypíná Modbus TCP ovladaè
  Pøítomnost volání funkce v kódu uivatelském programu vypíná Modbus TCP ovladaè. Pro znovu zapnutí ovladaèe je nutné nahrát kód bez volání funkce a restartovat centrálu.
  Tato funkce ruší nastavení provedené pomocí fcModbusUdpOff. Pro vypnutí obou ovladaèù pouijte fcModbusTcpUdpOff.*)
END_FUNCTION

__DECL FUNCTION fcModbusTcpUdpOff : bool
(*`{ENG}Disables Modbus TCP and UDP driver
  The presence of function call in code of user program disables TCP and UDP driver. For reenabling driver is necessary to upload code without function call and switch off/on CPM.
  {CSY}Vypíná Modbus TCP a UDP ovladaè
  Pøítomnost volání funkce v kódu uivatelském programu vypíná Modbus TCP a UDP ovladaè. Pro znovu zapnutí ovladaèe je nutné nahrát kód bez volání funkce a restartovat centrálu.*)
END_FUNCTION

__DECL FUNCTION_BLOCK fbModbusSlave {HIDDEN}
  VAR_INPUT
    Buf              : ARRAY [0..256] OF usint;
    inputsCnt        : uint;  (*`{ENG}Number of inputs (number of BOOLs)*)
    coilsCnt         : uint;  (*`{ENG}Number of coils (number of BOOLs)*)
    inputRegCnt      : uint;  (*`{ENG}Number of input   registers (number of WORDs)*)
    holdingRegCnt    : uint;  (*`{ENG}Number of holding registers (number of WORDs)*)
    Exception        : usint;
    Broadcast        : bool;
  END_VAR
  VAR_OUTPUT
    Read             : bool;
    Write            : bool;
    SendTo_rq        : bool;
    SendTo_lenTx     : uint;
    Addr             : uint;
    Quantity         : uint;
  END_VAR
  VAR_IN_OUT
    inputs           : bool;  (*`{ENG}First input in array (must be BOOL)*)
    coils            : bool;  (*`{ENG}First coil in array (must be BOOL)*)
    inputRegs        : uint;  (*`{ENG}First input register in array*)
    holdingRegs      : uint;  (*`{ENG}First holding register in array*)
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION_BLOCK fbModbusRTUslave
(*`{ENG}Interprets Modbus RTU commands on serial channel
     Supported commands:
     01 Read Coils
     02 Read Discrete Inputs
     03 Read Holding Register
     04 Read Input Register
     05 Force Single Coil
     06 Preset Single Register
     15 Force Multiple Coils
     16 Preset Multiple Registers
     22 Mask Write Register
     Number and location of coils, discrete inputs, holding registers and input registers are user defined. Data block can be overlapped.
     Communication speed, data format and parity have to be set according to Modbus master, minimum idle time between receiving and sending messages should be 4 bytes
     Minimum length of receiving zone is 256 bytes.
     Minimum length of transmiting zone  is 255 bytes.
{CSY}Interpretuje pøíkazy Modbus RTU na sériovém kanálu
     Podporované pøíkazy:
     01 Ètení cívek/diskrétních vıstupù
     02 Ètení diskrétních vstupù
     03 Ètení registrù
     04 Ètení vstupních registrù
     05 Zápis jedné cívky/diskrétního vıstupu
     06 Zápis jednoho registru
     15 Zápis více cívek/diskrétního vıstupu
     16 Zápis více registru
     22 Maskovanı zápis registru
     Poèet a umístìní diskrétních vıstupù, vıstupù, vstupních a vıstupních registrù jsou uivatelsky definována. Datové bloky se mohou pøekrıvat.
     Komunikaèní rychlost, formát dat a parita musí bıt nastavena podle Modbus mastera, minimální doba klidu na lince mezi pøijímanımi a vysílanımi zprávami by mìla bıt 4 byty
     Minimální délka pøijímací zóny je 256 bytù.
     Minimální délka vysílací zóny je 255 bytù.*)
  VAR_INPUT
    sAdr             : usint;  (*`{ENG}Address 1-247{CSY}Adresa 1-247*)
    chanCode         : uint;  (*`{ENG}Channel code (CH1_uni, ..., CH10_uni){CSY}kód kanálu (CH1_uni, ..., CH10_uni)*)
    inputsCnt        : uint;  (*`{ENG}Number of inputs (number of BOOLs){CSY}Poèet diskrétních vstupù (poèet BOOLù)*)
    coilsCnt         : uint;  (*`{ENG}Number of coils (number of BOOLs){CSY}Poèet cívek/diskrétních vıstupù (poèet BOOLù)*)
    inputRegCnt      : uint;  (*`{ENG}Number of input   registers (number of WORDs){CSY}Poèet vstupních registrù (poèet WORDù)*)
    holdingRegCnt    : uint;  (*`{ENG}Number of holding registers (number of WORDs){CSY}Poèet vnitøních registrù (poèet WORDù)*)
  END_VAR
  VAR_OUTPUT
    read             : bool;  (*`{ENG}Data was read{CSY}Byla ètena data*)
    write            : bool;  (*`{ENG}New data was written{CSY}Byla zapsána data*)
    brdcst           : bool;  (*`{ENG}Broadcast received{CSY}Byl pøijat broadcast*)
    lastCmd          : usint;  (*`{ENG}Last command received{CSY}Poslední pøijatı pøíkaz*)
    lastAddr         : uint;  (*`{ENG}Last address read/written{CSY}Poslední ètená/zapisovaná adresa*)
    lastQuantity     : uint;  (*`{ENG}Last quantity of object read/written{CSY}Poslední poèet ètenıch/zapisovanıch objektù*)
    err              : bool;  (*`{ENG}Error{CSY}Chyba*)
    errCode          : usint;  (*`{ENG}Error code{CSY}Chybovı kód*)
    msgCnt           : udint;  (*`{ENG}Processed message count{CSY}Poèet zpracovanıch zpráv*)
    errCnt           : udint;  (*`{ENG}Error count (crc, parity,..){CSY}Poèet chyb (crc, parita,..)*)
    excCnt           : udint;  (*`{ENG}Exception count{CSY}Poèet vıjimek*)
  END_VAR
  VAR_IN_OUT
    inputs           : bool;  (*`{ENG}First input in array (must be BOOL){CSY}První diskrétní vstup v poli (musí bıt BOOL)*)
    coils            : bool;  (*`{ENG}First coil in array (must be BOOL){CSY}První cívka/diskrétní vıstup v poli (musí bıt BOOL)*)
    inputRegs        : uint;  (*`{ENG}First input register in array{CSY}První vstupní registr v poli*)
    holdingRegs      : uint;  (*`{ENG}First holding register in array{CSY}První vnitøní registr v poli*)
  END_VAR
  VAR
    RecvFrom         : fbRecvFrom;
    SendTo           : fbSendTo;
    Mdb              : fbModbusSlave;
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION_BLOCK fbModbusTCPslave
(*`{ENG}Interprets Modbus RTU commands on TCP connection
     Supported commands:
     01 Read Coils
     02 Read Discrete Inputs
     03 Read Holding Register
     04 Read Input Register
     05 Write Single Coil
     06 Write Single Register
     15 Write Multiple Coils
     16 Write Multiple registers
     22 Mask Write Register
     Number and location of coils, discrete inputs, holding registers and input registers are user defined. Data block can be overlapped.
     TCP connection has to TCP slave, local port is set by function block.
     Minimum length of receiving zone is 259 bytes.
     Minimum length of transmiting zone  is 259 bytes.
     Function block disable default Modbus TCP driver.
{CSY}Interpretuje pøíkazy Modbus RTU na TCP spojení
     Podporované pøíkazy:
     01 Ètení diskrétních vıstupù
     02 Ètení diskrétních vstupù
     03 Ètení registrù
     04 Ètení vstupních registrù
     05 Zápis jednoho diskrétního vıstupu
     06 Zápis jednoho registru
     15 Zápis více diskrétního vıstupu
     16 Zápis více registru
     22 Maskovanı zápis registru
     Poèet a umístìní diskrétních vıstupù, vıstupù, vstupních a vıstupních registrù jsou uivatelsky definována. Datové bloky se mohou pøekrıvat.
     TCP spojení musí bıt nastaveno jako TCP slave, lokální port je nastaven funèním blokem.
     Minimální délka pøijímací zóny je 259 bytù.
     Minimální délka vysílací zóny je 259 bytù.
     Funkèní blok vypíná vıchozí ovladaè Modbus TCP.*)
  VAR_INPUT
    UnitID           : usint;  (*`{ENU}Unit identifier of slave device {CSY} Identifikátor slave zaøízení*)
    chanCode         : uint;  (*`{ENG}Channel code (CH1_uni, ..., CH10_uni){CSY}kód kanálu (CH1_uni, ..., CH10_uni)*)
    port             : uint :=  502;  (*`{ENG}Local port number (502){CSY}Èíslo místního portu (502)*)
    inputsCnt        : uint;  (*`{ENG}Number of inputs (number of BOOLs){CSY}Poèet diskrétních vstupù (poèet BOOLù)*)
    coilsCnt         : uint;  (*`{ENG}Number of coils (number of BOOLs){CSY}Poèet diskrétních vıstupù (poèet BOOLù)*)
    inputRegCnt      : uint;  (*`{ENG}Number of input   registers (number of WORDs){CSY}Poèet vstupních registrù (poèet WORDù)*)
    holdingRegCnt    : uint;  (*`{ENG}Number of holding registers (number of WORDs){CSY}Poèet registrù (poèet WORDù)*)
  END_VAR
  VAR_OUTPUT
    read             : bool;  (*`{ENG}Data was read{CSY}Byla ètena data*)
    write            : bool;  (*`{ENG}New data was written{CSY}Byla zapsána data*)
    established      : bool;  (*`{ENG}TCP connection established{CSY}TCP spojení navázáno*)
    lastCmd          : usint;  (*`{ENG}Last command received{CSY}Poslední pøijatı pøíkaz*)
    lastAddr         : uint;  (*`{ENG}Last address read/written{CSY}Poslední ètená/zapisovaná adresa*)
    lastQuantity     : uint;  (*`{ENG}Last quantity of object read/written{CSY}Poslední poèet ètenıch/zapisovanıch objektù*)
    err              : bool;  (*`{ENG}Error{CSY}Chyba*)
    errCode          : usint;  (*`{ENG}Error code{CSY}Chybovı kód*)
    msgCnt           : udint;  (*`{ENG}Processed message count{CSY}Poèet zpracovanıch zpráv*)
    errCnt           : udint;  (*`{ENG}Error count{CSY}Poèet chyb*)
    excCnt           : udint;  (*`{ENG}Exception count{CSY}Poèet vıjimek*)
  END_VAR
  VAR_IN_OUT
    inputs           : bool;  (*`{ENG}First input in array (must be BOOL){CSY}První diskrétní vstup v poli (musí bıt BOOL)*)
    coils            : bool;  (*`{ENG}First coil in array (must be BOOL){CSY}První diskrétní vıstup v poli (musí bıt BOOL)*)
    inputRegs        : uint;  (*`{ENG}First input register in array{CSY}První vstupní registr v poli*)
    holdingRegs      : uint;  (*`{ENG}First holding register in array{CSY}První registr v poli*)
  END_VAR
  VAR
    RecvFrom         : fbRecvFromModbus;
    buffer           : ARRAY [0..1035] OF usint;
    SendTo           : fbSendTo;
    TrascactionIndent : uint;
    ProtocolIndent   : uint;
    Length           : uint;
    Mdb              : fbModbusSlave;
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION_BLOCK fbModbusTCPslave2 {HIDDEN}
(*`{ENG}Interprets Modbus RTU commands on TCP connection
     Supported commands:
     01 Read Coils
     02 Read Discrete Inputs
     03 Read Holding Register
     04 Read Input Register
     05 Write Single Coil
     06 Write Single Register
     15 Write Multiple Coils
     16 Write Multiple registers
     22 Mask Write Register
     Number and location of coils, discrete inputs, holding registers and input registers are user defined. Data block can be overlapped.
     TCP connection has to TCP slave, local port is set by function block.
     Minimum length of receiving zone is 259 bytes.
     Minimum length of transmiting zone  is 259 bytes.
     Function block disable default Modbus TCP driver.
{CSY}Interpretuje pøíkazy Modbus RTU na TCP spojení
     Podporované pøíkazy:
     01 Ètení diskrétních vıstupù
     02 Ètení diskrétních vstupù
     03 Ètení registrù
     04 Ètení vstupních registrù
     05 Zápis jednoho diskrétního vıstupu
     06 Zápis jednoho registru
     15 Zápis více diskrétního vıstupu
     16 Zápis více registru
     22 Maskovanı zápis registru
     Poèet a umístìní diskrétních vıstupù, vıstupù, vstupních a vıstupních registrù jsou uivatelsky definována. Datové bloky se mohou pøekrıvat.
     TCP spojení musí bıt nastaveno jako TCP slave, lokální port je nastaven funèním blokem.
     Minimální délka pøijímací zóny je 259 bytù.
     Minimální délka vysílací zóny je 259 bytù.
     Funkèní blok vypíná vıchozí ovladaè Modbus TCP.*)
  VAR_INPUT
    UnitID1          : usint;  (*`{ENU}Unit identifier of slave device {CSY} Identifikátor slave zaøízení*)
    UnitID2          : usint;  (*`{ENU}Unit identifier of slave device {CSY} Identifikátor slave zaøízení*)
    chanCode         : uint;  (*`{ENG}Channel code (CH1_uni, ..., CH10_uni){CSY}kód kanálu (CH1_uni, ..., CH10_uni)*)
    port             : uint :=  502;  (*`{ENG}Local port number (502){CSY}Èíslo místního portu (502)*)
    inputsCnt1       : uint;  (*`{ENG}Number of inputs (number of BOOLs){CSY}Poèet diskrétních vstupù (poèet BOOLù)*)
    coilsCnt1        : uint;  (*`{ENG}Number of coils (number of BOOLs){CSY}Poèet diskrétních vıstupù (poèet BOOLù)*)
    inputRegCnt1     : uint;  (*`{ENG}Number of input   registers (number of WORDs){CSY}Poèet vstupních registrù (poèet WORDù)*)
    holdingRegCnt1   : uint;  (*`{ENG}Number of holding registers (number of WORDs){CSY}Poèet registrù (poèet WORDù)*)
    inputsCnt2       : uint;  (*`{ENG}Number of inputs (number of BOOLs){CSY}Poèet diskrétních vstupù (poèet BOOLù)*)
    coilsCnt2        : uint;  (*`{ENG}Number of coils (number of BOOLs){CSY}Poèet diskrétních vıstupù (poèet BOOLù)*)
    inputRegCnt2     : uint;  (*`{ENG}Number of input   registers (number of WORDs){CSY}Poèet vstupních registrù (poèet WORDù)*)
    holdingRegCnt2   : uint;  (*`{ENG}Number of holding registers (number of WORDs){CSY}Poèet registrù (poèet WORDù)*)
  END_VAR
  VAR_OUTPUT
    read             : bool;  (*`{ENG}Data was read{CSY}Byla ètena data*)
    write            : bool;  (*`{ENG}New data was written{CSY}Byla zapsána data*)
    established      : bool;  (*`{ENG}TCP connection established{CSY}TCP spojení navázáno*)
    lastCmd          : usint;  (*`{ENG}Last command received{CSY}Poslední pøijatı pøíkaz*)
    lastAddr         : uint;  (*`{ENG}Last address read/written{CSY}Poslední ètená/zapisovaná adresa*)
    lastQuantity     : uint;  (*`{ENG}Last quantity of object read/written{CSY}Poslední poèet ètenıch/zapisovanıch objektù*)
    err              : bool;  (*`{ENG}Error{CSY}Chyba*)
    errCode          : usint;  (*`{ENG}Error code{CSY}Chybovı kód*)
    msgCnt           : udint;  (*`{ENG}Processed message count{CSY}Poèet zpracovanıch zpráv*)
    errCnt           : udint;  (*`{ENG}Error count{CSY}Poèet chyb*)
    excCnt           : udint;  (*`{ENG}Exception count{CSY}Poèet vıjimek*)
    lastUnitID       : usint;  (*`{ENG}Last received unit ID{CSY}Poslední pøijaté unitID*)
  END_VAR
  VAR_IN_OUT
    inputs1          : bool;  (*`{ENG}First input in array (must be BOOL){CSY}První diskrétní vstup v poli (musí bıt BOOL)*)
    coils1           : bool;  (*`{ENG}First coil in array (must be BOOL){CSY}První diskrétní vıstup v poli (musí bıt BOOL)*)
    inputRegs1       : uint;  (*`{ENG}First input register in array{CSY}První vstupní registr v poli*)
    holdingRegs1     : uint;  (*`{ENG}First holding register in array{CSY}První registr v poli*)
    inputs2          : bool;  (*`{ENG}First input in array (must be BOOL){CSY}První diskrétní vstup v poli (musí bıt BOOL)*)
    coils2           : bool;  (*`{ENG}First coil in array (must be BOOL){CSY}První diskrétní vıstup v poli (musí bıt BOOL)*)
    inputRegs2       : uint;  (*`{ENG}First input register in array{CSY}První vstupní registr v poli*)
    holdingRegs2     : uint;  (*`{ENG}First holding register in array{CSY}První registr v poli*)
  END_VAR
  VAR
    RecvFrom {HIDDEN} : fbRecvFrom;
    SendTo {HIDDEN}  : fbSendTo;
    TrascactionIndent : uint;
    ProtocolIndent   : uint;
    Length           : uint;
    Mdb {HIDDEN}     : fbModbusSlave;
  END_VAR
END_FUNCTION_BLOCK



{USES=GetModbusErrTxt:GetLastComErrTxt}
{USES=ModbusRTUmas:CheckCRC_16}
{USES=ModbusTCPmas:IsEstabTCPconnection,ProgramIsChanged,CloseTCPconnection,EstabTCPconnection,STRING_TO_IPADR,GetRemoteIPaddress,SetRemoteIPaddress}
{USES=fbModbusRTUmas2:CheckCRC_16}
{USES=fbModbusTCPmas2:IsEstabTCPconnection,ProgramIsChanged,CloseTCPconnection,EstabTCPconnection,STRING_TO_IPADR,GetRemoteIPaddress,SetRemoteIPaddress}
{USES=fbRecvFromModbus:IsEstabTCPconnection,Memcpy,MemcpyEx}
{USES=ModbusTcpDelaySendmas:IsEstabTCPconnection,ProgramIsChanged,CloseTCPconnection,EstabTCPconnection,STRING_TO_IPADR,GetRemoteIPaddress,SetRemoteIPaddress}
{USES=fbModbusUDPmas:STRING_TO_IPADR,GetRemoteIPaddress,SetRemoteIPaddress}
{USES=fbModbusSlave:Memset,MemcpyEx}
{USES=fbModbusRTUslave:GetChanDesc,CheckCRC_16}
{USES=fbModbusTCPslave:fcModbusTcpOff,EstabTCPconnection,IsEstabTCPconnection,GetChanIndex,GetChanDesc,CloseTCPconnection,GetRemoteIPaddress,SetRemoteIPaddress}
{USES=fbModbusTCPslave2:fcModbusTcpOff,IsEstabTCPconnection,GetChanDesc,GetRemoteIPaddress,SetRemoteIPaddress}
#srcfile 'C:\TECOLIBSRC\MODBUSRTU\MODBUSRTU\MODBUSCMD.ST'
#pou ModbusCmd
#srcline 15 ;FUNCTION ModbusCmd : BOOL
P     61
ModbusCmd_L0:
 LINK 0
 NXT
; Initialize - variables
 LD   0
 WRX  __fc__ModbusCmd
; End initialize - variables
#srcline 38 ;  IF PTR_TO_UDINT( PtrData) = 16#FFFFFFFF THEN ModbusCmd := FALSE; RETURN; END_IF;
 LEAX PtrData
 LDIL 
#debug pointer PtrData
 LD   udint $FFFFFFFF
 EQ
 JMC  ModbusCmd_L1
 LD   bool 0       ; false
 WRX  __fc__ModbusCmd
#debug_left bool ModbusCmd
 JMP  ModbusCmd_RET
ModbusCmd_L1:
#srcline 39 ;  Cmd.Gr      := Gr;
 LDX  Gr
#debug usint Gr
 LDX  Cmd
 WRI 
#debug_left usint Cmd.Gr
#srcline 40 ;  Cmd.SNo     := SNo;
 LDX  SNo
#debug usint SNo
 LDX  Cmd
 ADD  1  ; + offset 
 WRI 
#debug_left usint Cmd.SNo
#srcline 41 ;  Cmd.FNC     := FNC;
 LDX  FNC
#debug usint FNC
 LDX  Cmd
 ADD  2  ; + offset 
 WRI 
#debug_left usint Cmd.FNC
#srcline 42 ;  Cmd.StAdr   := StAdr;
 LDX  StAdr
#debug uint StAdr
 LDX  Cmd
 ADD  3  ; + offset 
 WRIW 
#debug_left uint Cmd.StAdr
#srcline 43 ;  Cmd.NoPoint := NoPoint;
 LDX  NoPoint
#debug uint NoPoint
 LDX  Cmd
 ADD  5  ; + offset 
 WRIW 
#debug_left uint Cmd.NoPoint
#srcline 44 ;  Cmd.PtrData := PTR_TO_UDINT(PtrData);
 LEAX PtrData
 LDIL 
#debug pointer PtrData
 LDX  Cmd
 ADD  7  ; + offset 
 WRIL 
#debug_left udint Cmd.PtrData
#srcline 45 ;  ModbusCmd   := Gr <>0;
 LDX  Gr
#debug usint Gr
 LD   usint 0
 EQ
 NEG
 WRX  __fc__ModbusCmd
#debug_left bool ModbusCmd
#srcline 46 ;END_FUNCTION
ModbusCmd_RET:
 PRV  
 LDX  __fc__ModbusCmd
 ULNK
RET
E     61
#endpou 



 

#srcfile ''
#srcfile 'C:\TECOLIBSRC\MODBUSRTU\MODBUSRTU\MODBUSCMDTCP.ST'
#pou ModbusCmdTCP
#srcline 13 ;FUNCTION ModbusCmdTCP : BOOL

#struct ModbusCmdTCP__temp__
  string[24] PS0__st__
P     61
ModbusCmdTCP_L0:
 LINK __SizeOf(ModbusCmdTCP__temp__)
 NXT
; Initialize - variables
 LD   0
 WRX  __fc__ModbusCmdTCP
; End initialize - variables
#srcline 36 ;  IF PTR_TO_UDINT( PtrData) = 16#FFFFFFFF THEN ModbusCmdTCP := FALSE; RETURN; END_IF;
 LEAX PtrData
 LDIL 
#debug pointer PtrData
 LD   udint $FFFFFFFF
 EQ
 JMC  ModbusCmdTCP_L1
 LD   bool 0       ; false
 WRX  __fc__ModbusCmdTCP
#debug_left bool ModbusCmdTCP
 JMP  ModbusCmdTCP_RET
ModbusCmdTCP_L1:
#srcline 37 ;  Cmd.Gr       := Gr;
 LDX  Gr
#debug usint Gr
 LDX  Cmd
 WRI 
#debug_left usint Cmd.Gr
#srcline 38 ;  Cmd.IP       := IP;
 LD   0   ; null string
 LDX  Cmd
 ADD  1  ; + offset 
 WRI  
 LDX  Cmd
 ADD  1  ; + offset 
 LD   22
 DST    ; Level 1
 LEAX IP
#debug string IP
 SCON 
#debug_left string Cmd.IP
 PDST   ; Level 1
#srcline 39 ;  Cmd.UnitID   := UnitID;
 LDX  UnitID
#debug usint UnitID
 LDX  Cmd
 ADD  24  ; + offset 
 WRI 
#debug_left usint Cmd.UnitID
#srcline 40 ;  Cmd.FNC      := FNC;
 LDX  FNC
#debug usint FNC
 LDX  Cmd
 ADD  25  ; + offset 
 WRI 
#debug_left usint Cmd.FNC
#srcline 41 ;  Cmd.StAdr    := StAdr;
 LDX  StAdr
#debug uint StAdr
 LDX  Cmd
 ADD  26  ; + offset 
 WRIW 
#debug_left uint Cmd.StAdr
#srcline 42 ;  Cmd.NoPoint  := NoPoint;
 LDX  NoPoint
#debug uint NoPoint
 LDX  Cmd
 ADD  28  ; + offset 
 WRIW 
#debug_left uint Cmd.NoPoint
#srcline 43 ;  Cmd.PtrData  := PTR_TO_UDINT( PtrData);
 LEAX PtrData
 LDIL 
#debug pointer PtrData
 LDX  Cmd
 ADD  30  ; + offset 
 WRIL 
#debug_left udint Cmd.PtrData
#srcline 44 ;  ModbusCmdTCP := Gr <> 0;
 LDX  Gr
#debug usint Gr
 LD   usint 0
 EQ
 NEG
 WRX  __fc__ModbusCmdTCP
#debug_left bool ModbusCmdTCP
#srcline 45 ;END_FUNCTION
ModbusCmdTCP_RET:
 PRV  
 LDX  __fc__ModbusCmdTCP
 ULNK
RET
E     61
#endpou 



 

#srcfile ''
#srcfile 'C:\TECOLIBSRC\MODBUSRTU\MODBUSRTU\GETMODBUSERRTXT.ST'
#pou GetModbusErrTxt
#srcline 47 ;FUNCTION GetModbusErrTxt : BOOL

#struct GetModbusErrTxt__temp__
  string[82] PS0__st__
P     61
GetModbusErrTxt_L0:
 LINK __SizeOf(GetModbusErrTxt__temp__)
 NXT
; Initialize - variables
 LD   0
 WRX  __fc__GetModbusErrTxt
; End initialize - variables
#srcline 59 ;   IF ErrorCode < 128 OR ErrorCode = COM_ERRc6 THEN
 LDX  ErrorCode
#debug usint ErrorCode
 LD   usint 128
 LT
 LDX  ErrorCode
#debug usint ErrorCode
 LD   usint 198
 EQ
 OR  
 JMC  GetModbusErrTxt_L1
#srcline 60 ;     ErrTxt := GetLastComErrTxt(errCode := ErrorCode);
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   80
 DST    ; Level 1
 NXT
 LDX  ErrorCode
#debug usint ErrorCode
 WR   __Instance__GetLastComErrTxt~errCode
#debug_left usint __Instance__GetLastComErrTxt~errCode
 PRV
 LEA  __Instance__GetLastComErrTxt
 CAL  GetLastComErrTxt_L0

 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LDX  ErrTxt
 WRI  
 LDX  ErrTxt
 LD   80
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string ErrTxt
 PDST   ; Level 1
#srcline 61 ;   ELSIF ErrorCode < 128 + 24 THEN
 JMP  GetModbusErrTxt_L2
GetModbusErrTxt_L1:
 LDX  ErrorCode
#debug usint ErrorCode
 LD   usint 128
 LD   usint 24
 ADD
 AND  $FF
 LT
 JMC  GetModbusErrTxt_L3
#srcline 62 ;     ErrTxt := ModbusRTUlib_MDBErrorStrings[ErrorCode-128];
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   80
 DST    ; Level 1
 LEA  ModbusRTUlib_MDBErrorStrings
 LDX  ErrorCode
#debug usint ErrorCode
 LD   usint 128
 SUB
 AND  $FF
 RCHK 24   ; Range Check
 MUL  41   ; SizeOf(...)
 ADD     ; + offset 
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LDX  ErrTxt
 WRI  
 LDX  ErrTxt
 LD   80
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string ErrTxt
 PDST   ; Level 1
#srcline 63 ;   ELSE
 JMP  GetModbusErrTxt_L2
GetModbusErrTxt_L3:
#srcline 64 ;     ErrTxt := ModbusRTUlib_MDBErrorStrings[24];
 LD   0   ; null string
 LDX  ErrTxt
 WRI  
 LDX  ErrTxt
 LD   80
 DST    ; Level 1
 LEA  ModbusRTUlib_MDBErrorStrings
 LD   int 24
 SUB  0
 MUL  41   ; SizeOf(...)
 ADD     ; + offset 
 SCON 
#debug_left string ErrTxt
 PDST   ; Level 1
#srcline 65 ;   END_IF;
GetModbusErrTxt_L2:
#srcline 66 ;   GetModbusErrTxt := ErrorCode <> 0;
 LDX  ErrorCode
#debug usint ErrorCode
 LD   usint 0
 EQ
 NEG
 WRX  __fc__GetModbusErrTxt
#debug_left bool GetModbusErrTxt
#srcline 67 ;END_FUNCTION
 PRV  
 LDX  __fc__GetModbusErrTxt
 ULNK
RET
E     61
#endpou 



 

#srcfile ''
#srcfile 'C:\TECOLIBSRC\MODBUSRTU\MODBUSRTU\UNIT2_TO_REAL.ST'
#pou UINT2_TO_REAL
#srcline 1 ;FUNCTION UINT2_TO_REAL : REAL
P     61
UINT2_TO_REAL_L0:
 LINK 0
 NXT
; Initialize - variables
 LD   0.0
 WRX  __fc__UINT2_TO_REAL
; End initialize - variables
#srcline 8 ;  BEGIN
#srcline 9 ;  {ASM}
#srcline 10
     LDX UDINT IN1
#srcline 11
     SWL
#srcline 12
     WRX __fc__UINT2_TO_REAL
#srcline 13 ;  {END_ASM}
#srcline 14 ;END_FUNCTION
 PRV  
 LDX  __fc__UINT2_TO_REAL
 ULNK
RET
E     61
#endpou 

#pou UINT2_TO_UDINT
#srcline 16 ;FUNCTION UINT2_TO_UDINT : UDINT
P     61
UINT2_TO_UDINT_L0:
 LINK 0
 NXT
; Initialize - variables
 LD   0
 WRX  __fc__UINT2_TO_UDINT
; End initialize - variables
#srcline 24 ;  BEGIN
#srcline 25 ;  {ASM}
#srcline 26
     LDX UDINT IN1
#srcline 27
     SWL
#srcline 28
     WRX __fc__UINT2_TO_UDINT
#srcline 29 ;  {END_ASM}
#srcline 30 ;END_FUNCTION
 PRV  
 LDX  __fc__UINT2_TO_UDINT
 ULNK
RET
E     61
#endpou 

#pou UINT2_TO_DINT
#srcline 32 ;FUNCTION UINT2_TO_DINT : DINT
P     61
UINT2_TO_DINT_L0:
 LINK 0
 NXT
; Initialize - variables
 LD   0
 WRX  __fc__UINT2_TO_DINT
; End initialize - variables
#srcline 39 ;  BEGIN
#srcline 40 ;  {ASM}
#srcline 41
     LDX UDINT IN1
#srcline 42
     SWL
#srcline 43
     WRX __fc__UINT2_TO_DINT
#srcline 44 ;  {END_ASM}
#srcline 45 ;END_FUNCTION
 PRV  
 LDX  __fc__UINT2_TO_DINT
 ULNK
RET
E     61
#endpou 

#pou UINT4_TO_LREAL
#srcline 47 ;FUNCTION UINT4_TO_LREAL : LREAL
P     61
UINT4_TO_LREAL_L0:
 LINK 0
 NXT
; Initialize - variables
 LDQ  0.0
 WRX  __fc__UINT4_TO_LREAL
; End initialize - variables
#srcline 56 ;  BEGIN
#srcline 57 ;  {ASM}
#srcline 58
     LDX UDINT IN1
#srcline 59
     SWL
#srcline 60
     LDX UDINT IN3
#srcline 61
     SWL
#srcline 62
     WRX __fc__UINT4_TO_LREAL
#srcline 63 ;  {END_ASM}
#srcline 64 ;END_FUNCTION
 PRV  
 LDX  __fc__UINT4_TO_LREAL
 ULNK
RET
E     61
#endpou 



 

#srcfile ''
#srcfile 'C:\TECOLIBSRC\MODBUSRTU\MODBUSRTU\MODBUSRTUMAS.ST'
#pou ModbusRTUmas
#srcline 8 ;FUNCTION_BLOCK ModbusRTUmas

#struct ModbusRTUmas__temp__
  pointer ptr,  ; {ENU} Structure for control of Modbus RTU master FB Struktura pro øízení funkèního bloku Modbus RTU master
  uint pomUINT,
  bool CmdFind,  ; GrSel find
  bool notRepeat,
  sint tempCmd,
  pointer sptr,  ; substitute of pointer
  uint i,
  uint k,  ; offset in DataBuffers for: 0..Eth., 6..Serial channels
  uint ByteCount,
  pointer pdata,
  uint NoPoints,
  pointer BOptr,
  pointer pBOptr,
  pointer BYptr,
  pointer pBYptr,
  sint P0__st__,
  usint P1__st__,
  udint P2__st__,
  uint P3__st__,
  uint P4__st__,
  uint P5__st__,
  udint P6__st__,
  uint P7__st__,
  uint P8__st__
P     61
ModbusRTUmas_L0:
 LINK __SizeOf(ModbusRTUmas__temp__)
; Initialize - dynamic variables
 LD   udint $FFFFFFFF    ; nil
 WRY  ptr
 LD   udint $FFFFFFFF    ; nil
 WRY  sptr
 LD   uint 6
 WRY  k
 LD   udint $FFFFFFFF    ; nil
 WRY  pdata
 LD   udint $FFFFFFFF    ; nil
 WRY  BOptr
 LD   udint $FFFFFFFF    ; nil
 WRY  pBOptr
 LD   udint $FFFFFFFF    ; nil
 WRY  BYptr
 LD   udint $FFFFFFFF    ; nil
 WRY  pBYptr
; End initialize - dynamic variables
; R_EDGE, F_EDGE 
 LDX  Start
 LETX __EDGE_R__Start
 WRX  Start
#srcline 94 ;  IF not EN THEN
 LDX  EN
#debug bool EN
 NEG
 JMC  ModbusRTUmas_L1
#srcline 95 ;    InitMB_Done := false;
 LD   bool 0       ; false
 WRX  InitMB_Done
#debug_left bool InitMB_Done
#srcline 96 ;    LastCmd := 0; autoCmd := 0; ErrCode := 0;           // clear error code
 LD   sint 0
 WRX  LastCmd
#debug_left sint LastCmd
 LD   sint 0
 WRX  autoCmd
#debug_left sint autoCmd
 LD   usint 0
 WRX  ErrCode
#debug_left usint ErrCode
#srcline 97 ;    Done := false;
 LD   bool 0       ; false
 WRX  Done
#debug_left bool Done
#srcline 98 ;    StateMB := StartMB;
 LD   udint 0  ; ModbusRTUlib_TStateMB#StartMB
 WRX  StateMB
#debug_left usint StateMB
#srcline 99 ;  ELSE
 JMP  ModbusRTUmas_L2
ModbusRTUmas_L1:
#srcline 100 ;    notRepeat := true;
 LD   bool -1       ; true
 WRY  notRepeat
#debug_left bool notRepeat
#srcline 101 ;    REPEAT
ModbusRTUmas_L3:
 DBG
#srcline 102 ;      //IF UINT_TO_WORD(chanCode) and 16#00F0 = 16#00E0 THEN k :=0; ELSE k :=6; END_IF;  // TCP
#srcline 103 ;      IF isTcp THEN k :=0; ELSE k :=6; END_IF;  // TCP
 LDX  isTcp
#debug bool isTcp
 JMC  ModbusRTUmas_L5
 LD   uint 0
 WRY  k
#debug_left uint k
 JMP  ModbusRTUmas_L6
ModbusRTUmas_L5:
 LD   uint 6
 WRY  k
#debug_left uint k
ModbusRTUmas_L6:
#srcline 104 ;      IF StateMB = StartMB THEN
 LDX  StateMB
#debug usint StateMB
 LD   udint 0  ; ModbusRTUlib_TStateMB#StartMB
 EQ
 JMC  ModbusRTUmas_L7
#srcline 105 ;        Done := false;
 LD   bool 0       ; false
 WRX  Done
#debug_left bool Done
#srcline 106 ;        ErrCode := 0; //!!!
 LD   usint 0
 WRX  ErrCode
#debug_left usint ErrCode
#srcline 107 ;        IF GrSel=0 THEN                               // manual
 LDX  GrSel
#debug usint GrSel
 LD   usint 0
 EQ
 JMC  ModbusRTUmas_L9
#srcline 108 ;          IF Start THEN
 LDX  Start
#debug bool Start
 JMC  ModbusRTUmas_L11
#srcline 109 ;            LastCmd := CmdNo;
 LDX  CmdNo
#debug sint CmdNo
 EXTB 
 WRX  LastCmd
#debug_left sint LastCmd
#srcline 110 ;            IF CmdNo > 0 and CmdNo <= MaxCmd THEN StateMB := SndMB; END_IF;
 LDX  CmdNo
#debug sint CmdNo
 EXTB 
 LD   sint 0
 GTS
 LDX  CmdNo
#debug sint CmdNo
 EXTB 
 LDX  MaxCmd
#debug sint MaxCmd
 EXTB 
 GTS
 NEG
 AND
 JMC  ModbusRTUmas_L13
 LD   udint 1  ; ModbusRTUlib_TStateMB#SndMB
 WRX  StateMB
#debug_left usint StateMB
ModbusRTUmas_L13:
#srcline 111 ;          END_IF;
ModbusRTUmas_L11:
#srcline 112 ;        ELSE                                          // auto
 JMP  ModbusRTUmas_L10
ModbusRTUmas_L9:
#srcline 113 ;          StateMB := SndMB;
 LD   udint 1  ; ModbusRTUlib_TStateMB#SndMB
 WRX  StateMB
#debug_left usint StateMB
#srcline 114 ;          CmdFind :=false;
 LD   bool 0       ; false
 WRY  CmdFind
#debug_left bool CmdFind
#srcline 115 ;          autoCmd := autoCmd + 1;
 LDX  autoCmd
#debug sint autoCmd
 EXTB 
 LD   sint 1
 ADD
 EXTB
 WRX  autoCmd
#debug_left sint autoCmd
#srcline 116 ;          FOR tempCmd := autoCmd TO MaxCmd DO
 LDX  autoCmd
#debug sint autoCmd
 EXTB 
 WRY  tempCmd
 LDX  MaxCmd
#debug sint MaxCmd
 EXTB 
 WRY  P0__st__
ModbusRTUmas_L15:
 LDY  tempCmd
 EXTB 
 LDY  P0__st__
 EXTB 
 GTS  
 JMD  ModbusRTUmas_L16
 DBG  
#srcline 117 ;            ptr := ADR(Commands) + SINT_TO_UDINT(tempCmd-1) * sizeof(TCmdStruct);
 LDX  Commands
#debug pointer Commands
 LDY  tempCmd
#debug sint tempCmd
 EXTB 
 LD   sint 1
 SUB
 EXTB
 LD   11  ; SizeOf()
 MUL
 ADD
 LEAY ptr
 WRIL 
#debug_left pointer ptr
#srcline 118 ;            IF (((ptr^.Gr = GrSel) or (ptr^.Gr = 1)) and InitMB_Done) or
 LEAY ptr
 LDIL    ; dereference 
 LDI  
#debug usint ptr^.Gr
 LDX  GrSel
#debug usint GrSel
 EQ
 LEAY ptr
 LDIL    ; dereference 
 LDI  
#debug usint ptr^.Gr
 LD   usint 1
 EQ
 OR  
 LDX  InitMB_Done
#debug bool InitMB_Done
 AND
#srcline 119 ;                ((ptr^.Gr = 255)  and not InitMB_Done) THEN
 LEAY ptr
 LDIL    ; dereference 
 LDI  
#debug usint ptr^.Gr
 LD   usint 255
 EQ
 LDX  InitMB_Done
#debug bool InitMB_Done
 NEG
 AND
 OR  
 JMC  ModbusRTUmas_L17
#srcline 120 ;              autoCmd :=tempCmd;
 LDY  tempCmd
#debug sint tempCmd
 EXTB 
 WRX  autoCmd
#debug_left sint autoCmd
#srcline 121 ;              notRepeat := true;
 LD   bool -1       ; true
 WRY  notRepeat
#debug_left bool notRepeat
#srcline 122 ;              CmdFind :=true;
 LD   bool -1       ; true
 WRY  CmdFind
#debug_left bool CmdFind
#srcline 123 ;              EXIT;
 JMP  ModbusRTUmas_L16
#srcline 124 ;            END_IF;
ModbusRTUmas_L17:
#srcline 125 ;  //!!!            IF (ptr^.Gr = 0) THEN EXIT; END_IF; // any record
#srcline 126 ;          END_FOR;
 LDY  tempCmd
 LD   1
 ADD  
 EXTB 
 WRY  tempCmd
 JMP  ModbusRTUmas_L15
ModbusRTUmas_L16:
 NOP  -1
#srcline 127 ;          IF not CmdFind THEN
 LDY  CmdFind
#debug bool CmdFind
 NEG
 JMC  ModbusRTUmas_L19
#srcline 128 ;            IF not InitMB_Done THEN
 LDX  InitMB_Done
#debug bool InitMB_Done
 NEG
 JMC  ModbusRTUmas_L21
#srcline 129 ;              InitMB_Done := true;
 LD   bool -1       ; true
 WRX  InitMB_Done
#debug_left bool InitMB_Done
#srcline 130 ;            END_IF;
ModbusRTUmas_L21:
#srcline 131 ;            autoCmd :=0;
 LD   sint 0
 WRX  autoCmd
#debug_left sint autoCmd
#srcline 132 ;            StateMB := StartMB;
 LD   udint 0  ; ModbusRTUlib_TStateMB#StartMB
 WRX  StateMB
#debug_left usint StateMB
#srcline 133 ;            notRepeat := NOT notRepeat; //pokud se nenaslo zkusit jeste jednou
 LDY  notRepeat
#debug bool notRepeat
 NEG
 WRY  notRepeat
#debug_left bool notRepeat
#srcline 134 ;          END_IF;
ModbusRTUmas_L19:
#srcline 135 ;          lastCmd := autoCmd;
 LDX  autoCmd
#debug sint autoCmd
 EXTB 
 WRX  lastCmd
#debug_left sint lastCmd
#srcline 136 ;        END_IF;
ModbusRTUmas_L10:
#srcline 137 ;      END_IF;
ModbusRTUmas_L7:
#srcline 138 ;    UNTIL notRepeat
#srcline 139 ;    END_REPEAT;
 LDY  notRepeat
#debug bool notRepeat
 JMC  ModbusRTUmas_L3
ModbusRTUmas_L4:
 NOP  -1
#srcline 140 ;    CASE StateMB OF
 LDX  StateMB
#debug usint StateMB
 WRY  P1__st__
 LD   1
 LDY  P1__st__
 EQ  
 JMC  ModbusRTUmas_L24
#srcline 141 ;      //------------------------------------------------------------------------
#srcline 142 ;      //------------------------------------------------------------------------
#srcline 143 ;      SndMB     : // Send Message
#srcline 144 ;        SendTo.rq := true;
 LD   bool -1       ; true
 WRX  SendTo~rq
#debug_left bool SendTo.rq
#srcline 145 ;        StateMB := SndMBt;
 LD   udint 2  ; ModbusRTUlib_TStateMB#SndMBt
 WRX  StateMB
#debug_left usint StateMB
#srcline 146 ;        ptr := ADR(Commands) + SINT_TO_UDINT(LastCmd-1) * sizeof(TCmdStruct);
 LDX  Commands
#debug pointer Commands
 LDX  LastCmd
#debug sint LastCmd
 EXTB 
 LD   sint 1
 SUB
 EXTB
 LD   11  ; SizeOf()
 MUL
 ADD
 LEAY ptr
 WRIL 
#debug_left pointer ptr
#srcline 148 ;        IF ptr^.PtrData = 16#FFFF_FFFF THEN
 LEAY ptr
 LDIL    ; dereference 
 ADD  7  ; + offset 
 LDIL 
#debug udint ptr^.PtrData
 LD   udint $FFFFFFFF
 EQ
 JMC  ModbusRTUmas_L25
#srcline 149 ;          ErrCode := 23 + 128;               // Invalid pointer
 LD   usint 23
 LD   usint 128
 ADD
 AND  $FF
 WRX  ErrCode
#debug_left usint ErrCode
#srcline 150 ;          SendTo.rq := false;
 LD   bool 0       ; false
 WRX  SendTo~rq
#debug_left bool SendTo.rq
#srcline 151 ;          StateMB := ErrMB;
 LD   udint 5  ; ModbusRTUlib_TStateMB#ErrMB
 WRX  StateMB
#debug_left usint StateMB
#srcline 152 ;        ELSE
 JMP  ModbusRTUmas_L26
ModbusRTUmas_L25:
#srcline 153 ;          DataT[6] := ptr^.SNo;               // slave adress
 LEAY ptr
 LDIL    ; dereference 
 ADD  1  ; + offset 
 LDI  
#debug usint ptr^.SNo
 WRX  DataT[6]
#debug_left usint DataT[6]
#srcline 154 ;          DataT[7] := ptr^.FNC;                    // command code Modbus 01,02,03,04,05,06,15,16,17,22
 LEAY ptr
 LDIL    ; dereference 
 ADD  2  ; + offset 
 LDI  
#debug usint ptr^.FNC
 WRX  DataT[7]
#debug_left usint DataT[7]
#srcline 155 ;          CASE (ptr^.FNC) OF
 LEAY ptr
 LDIL    ; dereference 
 ADD  2  ; + offset 
 LDI  
#debug usint ptr^.FNC
 WRY  P2__st__
 LDY  P2__st__
 LD   2
 GT  
 JMD ModbusRTUmas_L28
 LDY  P2__st__
 LD   1
 LT  
 JMD ModbusRTUmas_L28
#srcline 156 ;            1..2 :   // 01 Read Coils
#srcline 157 ;                     // 02 Read Discrete Inputs
#srcline 158 ;              NoPoints:= LIMIT(MN :=1,IN := ptr^.NoPoint,MX :=2000);
 LEAY ptr
 LDIL    ; dereference 
 ADD  5  ; + offset 
 LDIW 
#debug uint ptr^.NoPoint
 LD   uint 1
 MAX
 LD   uint 2000
 MIN
 WRY  NoPoints
#debug_left uint NoPoints
#srcline 159 ;              DataT[8] := WORD_TO_USINT(SHR(UINT_TO_WORD(ptr^.StAdr),8));//Hi
 LEAY ptr
 LDIL    ; dereference 
 ADD  3  ; + offset 
 LDIW 
#debug uint ptr^.StAdr
 LD   uint 8
 SHR
 AND  $FFFF
 AND  $FF
 WRX  DataT[8]
#debug_left usint DataT[8]
#srcline 160 ;              DataT[9] := UINT_TO_USINT(ptr^.StAdr);// Lo adresa reg ve slave
 LEAY ptr
 LDIL    ; dereference 
 ADD  3  ; + offset 
 LDIW 
#debug uint ptr^.StAdr
 AND  $FF
 WRX  DataT[9]
#debug_left usint DataT[9]
#srcline 161 ;              DataT[10] := WORD_TO_USINT(SHR(UINT_TO_WORD(NoPoints),8));//Hi
 LDY  NoPoints
#debug uint NoPoints
 LD   uint 8
 SHR
 AND  $FFFF
 AND  $FF
 WRX  DataT[10]
#debug_left usint DataT[10]
#srcline 162 ;              DataT[11] := UINT_TO_USINT(NoPoints);// Lo len reg ve slave
 LDY  NoPoints
#debug uint NoPoints
 AND  $FF
 WRX  DataT[11]
#debug_left usint DataT[11]
#srcline 163 ;              i := 12;
 LD   uint 12
 WRY  i
#debug_left uint i
#srcline 164 ;            ;
 JMP  ModbusRTUmas_L27
ModbusRTUmas_L28:
 LDY  P2__st__
 LD   4
 GT  
 JMD ModbusRTUmas_L29
 LDY  P2__st__
 LD   3
 LT  
 JMD ModbusRTUmas_L29
#srcline 165 ;            3..4 : // 03 Read Holding Registers
#srcline 166 ;                   // 04 Read Input Registers
#srcline 167 ;              NoPoints:= LIMIT(MN :=1,IN := ptr^.NoPoint,MX :=125);
 LEAY ptr
 LDIL    ; dereference 
 ADD  5  ; + offset 
 LDIW 
#debug uint ptr^.NoPoint
 LD   uint 1
 MAX
 LD   uint 125
 MIN
 WRY  NoPoints
#debug_left uint NoPoints
#srcline 168 ;              DataT[8] := WORD_TO_USINT(SHR(UINT_TO_WORD(ptr^.StAdr),8));//Hi
 LEAY ptr
 LDIL    ; dereference 
 ADD  3  ; + offset 
 LDIW 
#debug uint ptr^.StAdr
 LD   uint 8
 SHR
 AND  $FFFF
 AND  $FF
 WRX  DataT[8]
#debug_left usint DataT[8]
#srcline 169 ;              DataT[9] := UINT_TO_USINT(ptr^.StAdr);// Lo adresa reg ve slave
 LEAY ptr
 LDIL    ; dereference 
 ADD  3  ; + offset 
 LDIW 
#debug uint ptr^.StAdr
 AND  $FF
 WRX  DataT[9]
#debug_left usint DataT[9]
#srcline 170 ;              DataT[10] := WORD_TO_USINT(SHR(UINT_TO_WORD(NoPoints),8));//Hi
 LDY  NoPoints
#debug uint NoPoints
 LD   uint 8
 SHR
 AND  $FFFF
 AND  $FF
 WRX  DataT[10]
#debug_left usint DataT[10]
#srcline 171 ;              DataT[11] := UINT_TO_USINT(NoPoints);// Lo len reg ve slave
 LDY  NoPoints
#debug uint NoPoints
 AND  $FF
 WRX  DataT[11]
#debug_left usint DataT[11]
#srcline 172 ;              i := 12;
 LD   uint 12
 WRY  i
#debug_left uint i
#srcline 173 ;            ;
 JMP  ModbusRTUmas_L27
ModbusRTUmas_L29:
 LD   5
 LDY  P2__st__
 EQ  
 JMC  ModbusRTUmas_L30
#srcline 174 ;            5 :    // 05 Write Single Coil
#srcline 175 ;              DataT[8] := WORD_TO_USINT(SHR(UINT_TO_WORD(ptr^.StAdr),8));// Hi
 LEAY ptr
 LDIL    ; dereference 
 ADD  3  ; + offset 
 LDIW 
#debug uint ptr^.StAdr
 LD   uint 8
 SHR
 AND  $FFFF
 AND  $FF
 WRX  DataT[8]
#debug_left usint DataT[8]
#srcline 176 ;              DataT[9] := UINT_TO_USINT(ptr^.StAdr);           // Lo adresa reg ve slave
 LEAY ptr
 LDIL    ; dereference 
 ADD  3  ; + offset 
 LDIW 
#debug uint ptr^.StAdr
 AND  $FF
 WRX  DataT[9]
#debug_left usint DataT[9]
#srcline 177 ;              //sptr:= UDINT_TO_PTR(ptr^.PtrData);          // substitute of pointer
#srcline 179 ;              //BOptr   := sptr;
#srcline 180 ;              BOptr   := UDINT_TO_PTR(ptr^.PtrData);
 LEAY ptr
 LDIL    ; dereference 
 ADD  7  ; + offset 
 LDIL 
#debug udint ptr^.PtrData
; UDINT -> PTR
 LEAY BOptr
 WRIL 
#debug_left pointer BOptr
#srcline 181 ;              IF BOptr^ THEN               // test of BOOL
 LEAY BOptr
 LDIL    ; dereference 
 LDIB 
#debug bool BOptr^
 JMC  ModbusRTUmas_L31
#srcline 182 ;                DataT[10] := 16#FF;          // true  Hi
 LD   usint $FF
 WRX  DataT[10]
#debug_left usint DataT[10]
#srcline 183 ;              ELSE
 JMP  ModbusRTUmas_L32
ModbusRTUmas_L31:
#srcline 184 ;                DataT[10] := 0;              // false Hi
 LD   usint 0
 WRX  DataT[10]
#debug_left usint DataT[10]
#srcline 185 ;              END_IF;
ModbusRTUmas_L32:
#srcline 186 ;              DataT[11] := 0;                // Lo
 LD   usint 0
 WRX  DataT[11]
#debug_left usint DataT[11]
#srcline 187 ;              i := 12;
 LD   uint 12
 WRY  i
#debug_left uint i
#srcline 188 ;            ;
 JMP  ModbusRTUmas_L27
ModbusRTUmas_L30:
 LD   6
 LDY  P2__st__
 EQ  
 JMC  ModbusRTUmas_L33
#srcline 189 ;            6 :    // 06 Write Single Register
#srcline 190 ;              DataT[8] := WORD_TO_USINT(SHR(UINT_TO_WORD(ptr^.StAdr),8)); //Hi
 LEAY ptr
 LDIL    ; dereference 
 ADD  3  ; + offset 
 LDIW 
#debug uint ptr^.StAdr
 LD   uint 8
 SHR
 AND  $FFFF
 AND  $FF
 WRX  DataT[8]
#debug_left usint DataT[8]
#srcline 191 ;              DataT[9] := UINT_TO_USINT(ptr^.StAdr);                      // Lo adresa reg ve slave
 LEAY ptr
 LDIL    ; dereference 
 ADD  3  ; + offset 
 LDIW 
#debug uint ptr^.StAdr
 AND  $FF
 WRX  DataT[9]
#debug_left usint DataT[9]
#srcline 192 ;              pdata := UDINT_TO_PTR(ptr^.PtrData);
 LEAY ptr
 LDIL    ; dereference 
 ADD  7  ; + offset 
 LDIL 
#debug udint ptr^.PtrData
; UDINT -> PTR
 LEAY pdata
 WRIL 
#debug_left pointer pdata
#srcline 193 ;              DataT[10] := WORD_TO_USINT(SHR(UINT_TO_WORD(pdata^),8));// Hi
 LEAY pdata
 LDIL    ; dereference 
 LDIW 
#debug uint pdata^
 LD   uint 8
 SHR
 AND  $FFFF
 AND  $FF
 WRX  DataT[10]
#debug_left usint DataT[10]
#srcline 194 ;              DataT[11] := UINT_TO_USINT(pdata^);                     // Lo data reg ve slave
 LEAY pdata
 LDIL    ; dereference 
 LDIW 
#debug uint pdata^
 AND  $FF
 WRX  DataT[11]
#debug_left usint DataT[11]
#srcline 195 ;              i := 12;
 LD   uint 12
 WRY  i
#debug_left uint i
#srcline 196 ;            ;
 JMP  ModbusRTUmas_L27
ModbusRTUmas_L33:
 LD   7
 LDY  P2__st__
 EQ  
 JMC  ModbusRTUmas_L34
#srcline 197 ;            7 :    // 07 Read Exception Status
#srcline 198 ;              i := 8;
 LD   uint 8
 WRY  i
#debug_left uint i
#srcline 199 ;            ;
 JMP  ModbusRTUmas_L27
ModbusRTUmas_L34:
 LD   8
 LDY  P2__st__
 EQ  
 JMC  ModbusRTUmas_L35
#srcline 200 ;            8 :    // 08 Diagnostic
#srcline 201 ;              DataT[8] := WORD_TO_USINT(SHR(UINT_TO_WORD(ptr^.StAdr),8)); //Hi
 LEAY ptr
 LDIL    ; dereference 
 ADD  3  ; + offset 
 LDIW 
#debug uint ptr^.StAdr
 LD   uint 8
 SHR
 AND  $FFFF
 AND  $FF
 WRX  DataT[8]
#debug_left usint DataT[8]
#srcline 202 ;              DataT[9] := UINT_TO_USINT(ptr^.StAdr);                      // Lo Sub-function code do slave
 LEAY ptr
 LDIL    ; dereference 
 ADD  3  ; + offset 
 LDIW 
#debug uint ptr^.StAdr
 AND  $FF
 WRX  DataT[9]
#debug_left usint DataT[9]
#srcline 203 ;              pdata := UDINT_TO_PTR(ptr^.PtrData);
 LEAY ptr
 LDIL    ; dereference 
 ADD  7  ; + offset 
 LDIL 
#debug udint ptr^.PtrData
; UDINT -> PTR
 LEAY pdata
 WRIL 
#debug_left pointer pdata
#srcline 204 ;              DataT[10] := WORD_TO_USINT(SHR(UINT_TO_WORD(pdata^),8));// Hi
 LEAY pdata
 LDIL    ; dereference 
 LDIW 
#debug uint pdata^
 LD   uint 8
 SHR
 AND  $FFFF
 AND  $FF
 WRX  DataT[10]
#debug_left usint DataT[10]
#srcline 205 ;              DataT[11] := UINT_TO_USINT(pdata^);                     // Lo data field do slave
 LEAY pdata
 LDIL    ; dereference 
 LDIW 
#debug uint pdata^
 AND  $FF
 WRX  DataT[11]
#debug_left usint DataT[11]
#srcline 206 ;              i := 12;
 LD   uint 12
 WRY  i
#debug_left uint i
#srcline 207 ;            ;
 JMP  ModbusRTUmas_L27
ModbusRTUmas_L35:
 LD   15
 LDY  P2__st__
 EQ  
 JMC  ModbusRTUmas_L36
#srcline 208 ;            15 :   // 15 Write Multiple Coils
#srcline 209 ;              NoPoints  := LIMIT(MN :=1,IN := ptr^.NoPoint,MX :=1968);
 LEAY ptr
 LDIL    ; dereference 
 ADD  5  ; + offset 
 LDIW 
#debug uint ptr^.NoPoint
 LD   uint 1
 MAX
 LD   uint 1968
 MIN
 WRY  NoPoints
#debug_left uint NoPoints
#srcline 210 ;              DataT[8]  := WORD_TO_USINT(SHR(UINT_TO_WORD(ptr^.StAdr),8));//Hi
 LEAY ptr
 LDIL    ; dereference 
 ADD  3  ; + offset 
 LDIW 
#debug uint ptr^.StAdr
 LD   uint 8
 SHR
 AND  $FFFF
 AND  $FF
 WRX  DataT[8]
#debug_left usint DataT[8]
#srcline 211 ;              DataT[9]  := UINT_TO_USINT(ptr^.StAdr);     // Lo adresa reg ve slave
 LEAY ptr
 LDIL    ; dereference 
 ADD  3  ; + offset 
 LDIW 
#debug uint ptr^.StAdr
 AND  $FF
 WRX  DataT[9]
#debug_left usint DataT[9]
#srcline 212 ;              DataT[10]  := WORD_TO_USINT(SHR(UINT_TO_WORD(NoPoints),8));//Hi
 LDY  NoPoints
#debug uint NoPoints
 LD   uint 8
 SHR
 AND  $FFFF
 AND  $FF
 WRX  DataT[10]
#debug_left usint DataT[10]
#srcline 213 ;              DataT[11]  := UINT_TO_USINT(NoPoints);   // Lo len reg ve slave
 LDY  NoPoints
#debug uint NoPoints
 AND  $FF
 WRX  DataT[11]
#debug_left usint DataT[11]
#srcline 214 ;              ByteCount:= NoPoints / 8 ;
 LDY  NoPoints
#debug uint NoPoints
 LD   uint 8
 DIVL
 AND  $FFFF
 WRY  ByteCount
#debug_left uint ByteCount
#srcline 215 ;              IF MOD(NoPoints,8) <> 0 then ByteCount := ByteCount + 1; END_IF;
 LDY  NoPoints
#debug uint NoPoints
 LD   uint 8
 MOD
 AND  $FFFF
 LD   uint 0
 EQ
 NEG
 JMC  ModbusRTUmas_L37
 LDY  ByteCount
#debug uint ByteCount
 LD   uint 1
 ADD
 AND  $FFFF
 WRY  ByteCount
#debug_left uint ByteCount
ModbusRTUmas_L37:
#srcline 216 ;              DataT[12]  := UINT_TO_USINT(ByteCount); // ByteCount
 LDY  ByteCount
#debug uint ByteCount
 AND  $FF
 WRX  DataT[12]
#debug_left usint DataT[12]
#srcline 217 ;              //sptr:= UDINT_TO_PTR(ptr^.PtrData);          // substitute of pointer
#srcline 218 ;              //BOptr    := sptr;                     // source
#srcline 219 ;              BOptr    := UDINT_TO_PTR(ptr^.PtrData); // source
 LEAY ptr
 LDIL    ; dereference 
 ADD  7  ; + offset 
 LDIL 
#debug udint ptr^.PtrData
; UDINT -> PTR
 LEAY BOptr
 WRIL 
#debug_left pointer BOptr
#srcline 220 ;              pBOptr   := ADR(DataT[13]) * 8;         // destination
 LEAX DataT
 ADD  13  ; + offset 
#debug pointer DataT[13]
 LD   udint 8
 MUL
 LEAY pBOptr
 WRIL 
#debug_left pointer pBOptr
#srcline 221 ;              FOR i := 0 TO NoPoints DO              // Bit stream
 LD   uint 0
 WRY  i
 LDY  NoPoints
#debug uint NoPoints
 WRY  P3__st__
ModbusRTUmas_L39:
 LDY  i
 LDY  P3__st__
 GT   
 JMD  ModbusRTUmas_L40
 DBG  
#srcline 222 ;                pBOptr^:= BOptr^; BOptr := BOptr+1; pBOptr := pBOptr+1;
 LEAY BOptr
 LDIL    ; dereference 
 LDIB 
#debug bool BOptr^
 LEAY pBOptr
 LDIL    ; dereference 
 WRIB 
#debug_left bool pBOptr^
 LEAY BOptr
 LDIL 
#debug pointer BOptr
 LD   udint 1
 ADD
 LEAY BOptr
 WRIL 
#debug_left pointer BOptr
 LEAY pBOptr
 LDIL 
#debug pointer pBOptr
 LD   udint 1
 ADD
 LEAY pBOptr
 WRIL 
#debug_left pointer pBOptr
#srcline 223 ;              END_FOR;
 LDY  i
 LD   1
 ADD  
 WRY  i
 JMP  ModbusRTUmas_L39
ModbusRTUmas_L40:
 NOP  -1
#srcline 224 ;              i        := 13 + ByteCount;  // +6
 LD   uint 13
 LDY  ByteCount
#debug uint ByteCount
 ADD
 AND  $FFFF
 WRY  i
#debug_left uint i
#srcline 225 ;            ;
 JMP  ModbusRTUmas_L27
ModbusRTUmas_L36:
 LD   16
 LDY  P2__st__
 EQ  
 JMC  ModbusRTUmas_L41
#srcline 226 ;            16 :   // 16 Write Multiple Registers
#srcline 227 ;              NoPoints  := LIMIT(MN :=1,IN := ptr^.NoPoint,MX :=123); //Byd rev.1.8
 LEAY ptr
 LDIL    ; dereference 
 ADD  5  ; + offset 
 LDIW 
#debug uint ptr^.NoPoint
 LD   uint 1
 MAX
 LD   uint 123
 MIN
 WRY  NoPoints
#debug_left uint NoPoints
#srcline 228 ;              DataT[8]  := WORD_TO_USINT(SHR(UINT_TO_WORD(ptr^.StAdr),8));//Hi
 LEAY ptr
 LDIL    ; dereference 
 ADD  3  ; + offset 
 LDIW 
#debug uint ptr^.StAdr
 LD   uint 8
 SHR
 AND  $FFFF
 AND  $FF
 WRX  DataT[8]
#debug_left usint DataT[8]
#srcline 229 ;              DataT[9]  := UINT_TO_USINT(ptr^.StAdr);     // Lo adresa reg ve slave
 LEAY ptr
 LDIL    ; dereference 
 ADD  3  ; + offset 
 LDIW 
#debug uint ptr^.StAdr
 AND  $FF
 WRX  DataT[9]
#debug_left usint DataT[9]
#srcline 230 ;              DataT[10]  := WORD_TO_USINT(SHR(UINT_TO_WORD(NoPoints),8));//Hi
 LDY  NoPoints
#debug uint NoPoints
 LD   uint 8
 SHR
 AND  $FFFF
 AND  $FF
 WRX  DataT[10]
#debug_left usint DataT[10]
#srcline 231 ;              DataT[11]  := UINT_TO_USINT(NoPoints);     // Lo len reg ve slave
 LDY  NoPoints
#debug uint NoPoints
 AND  $FF
 WRX  DataT[11]
#debug_left usint DataT[11]
#srcline 232 ;              ByteCount:= NoPoints * 2;
 LDY  NoPoints
#debug uint NoPoints
 LD   uint 2
 MUL
 AND  $FFFF
 WRY  ByteCount
#debug_left uint ByteCount
#srcline 233 ;              DataT[12]  := UINT_TO_USINT(ByteCount);    // ByteCount
 LDY  ByteCount
#debug uint ByteCount
 AND  $FF
 WRX  DataT[12]
#debug_left usint DataT[12]
#srcline 234 ;              BYptr:= UDINT_TO_PTR(ptr^.PtrData);         // source pointer
 LEAY ptr
 LDIL    ; dereference 
 ADD  7  ; + offset 
 LDIL 
#debug udint ptr^.PtrData
; UDINT -> PTR
 LEAY BYptr
 WRIL 
#debug_left pointer BYptr
#srcline 235 ;              pBYptr   := ADR(DataT[13]);                // destination pointer
 LEAX DataT
 ADD  13  ; + offset 
#debug pointer DataT[13]
 LEAY pBYptr
 WRIL 
#debug_left pointer pBYptr
#srcline 236 ;              FOR i := 0 TO NoPoints DO                 // Word stream big endian
 LD   uint 0
 WRY  i
 LDY  NoPoints
#debug uint NoPoints
 WRY  P4__st__
ModbusRTUmas_L42:
 LDY  i
 LDY  P4__st__
 GT   
 JMD  ModbusRTUmas_L43
 DBG  
#srcline 237 ;                IF Endian THEN                          // Little Endian
 LDX  Endian
#debug bool Endian
 JMC  ModbusRTUmas_L44
#srcline 238 ;                  pBYptr^:= BYptr^;                     // first byte to Lo
 LEAY BYptr
 LDIL    ; dereference 
 LDI  
#debug byte BYptr^
 LEAY pBYptr
 LDIL    ; dereference 
 WRI 
#debug_left byte pBYptr^
#srcline 239 ;                  pBYptr := pBYptr+1; BYptr := BYptr+1;
 LEAY pBYptr
 LDIL 
#debug pointer pBYptr
 LD   udint 1
 ADD
 LEAY pBYptr
 WRIL 
#debug_left pointer pBYptr
 LEAY BYptr
 LDIL 
#debug pointer BYptr
 LD   udint 1
 ADD
 LEAY BYptr
 WRIL 
#debug_left pointer BYptr
#srcline 240 ;                  pBYptr^:= BYptr^;                     // second byte to Hi
 LEAY BYptr
 LDIL    ; dereference 
 LDI  
#debug byte BYptr^
 LEAY pBYptr
 LDIL    ; dereference 
 WRI 
#debug_left byte pBYptr^
#srcline 241 ;                  pBYptr := pBYptr+1; BYptr := BYptr+1;
 LEAY pBYptr
 LDIL 
#debug pointer pBYptr
 LD   udint 1
 ADD
 LEAY pBYptr
 WRIL 
#debug_left pointer pBYptr
 LEAY BYptr
 LDIL 
#debug pointer BYptr
 LD   udint 1
 ADD
 LEAY BYptr
 WRIL 
#debug_left pointer BYptr
#srcline 242 ;                ELSE                                    // Big Endian
 JMP  ModbusRTUmas_L45
ModbusRTUmas_L44:
#srcline 243 ;                  pBYptr := pBYptr+1;
 LEAY pBYptr
 LDIL 
#debug pointer pBYptr
 LD   udint 1
 ADD
 LEAY pBYptr
 WRIL 
#debug_left pointer pBYptr
#srcline 244 ;                  pBYptr^:= BYptr^;                     // first byte to Hi
 LEAY BYptr
 LDIL    ; dereference 
 LDI  
#debug byte BYptr^
 LEAY pBYptr
 LDIL    ; dereference 
 WRI 
#debug_left byte pBYptr^
#srcline 245 ;                  pBYptr := pBYptr-1; BYptr := BYptr+1;
 LEAY pBYptr
 LDIL 
#debug pointer pBYptr
 LD   udint 1
 SUB
 LEAY pBYptr
 WRIL 
#debug_left pointer pBYptr
 LEAY BYptr
 LDIL 
#debug pointer BYptr
 LD   udint 1
 ADD
 LEAY BYptr
 WRIL 
#debug_left pointer BYptr
#srcline 246 ;                  pBYptr^:= BYptr^;                     // second byte to Lo
 LEAY BYptr
 LDIL    ; dereference 
 LDI  
#debug byte BYptr^
 LEAY pBYptr
 LDIL    ; dereference 
 WRI 
#debug_left byte pBYptr^
#srcline 247 ;                  pBYptr := pBYptr+2; BYptr := BYptr+1;
 LEAY pBYptr
 LDIL 
#debug pointer pBYptr
 LD   udint 2
 ADD
 LEAY pBYptr
 WRIL 
#debug_left pointer pBYptr
 LEAY BYptr
 LDIL 
#debug pointer BYptr
 LD   udint 1
 ADD
 LEAY BYptr
 WRIL 
#debug_left pointer BYptr
#srcline 248 ;                END_IF;
ModbusRTUmas_L45:
#srcline 249 ;              END_FOR;
 LDY  i
 LD   1
 ADD  
 WRY  i
 JMP  ModbusRTUmas_L42
ModbusRTUmas_L43:
 NOP  -1
#srcline 250 ;              i         := 13 + ByteCount;
 LD   uint 13
 LDY  ByteCount
#debug uint ByteCount
 ADD
 AND  $FFFF
 WRY  i
#debug_left uint i
#srcline 251 ;            ;
 JMP  ModbusRTUmas_L27
ModbusRTUmas_L41:
 LD   17
 LDY  P2__st__
 EQ  
 JMC  ModbusRTUmas_L46
#srcline 252 ;            17 :   // 17 Report Slave ID
#srcline 253 ;              i :=8;
 LD   uint 8
 WRY  i
#debug_left uint i
#srcline 254 ;            ;
 JMP  ModbusRTUmas_L27
ModbusRTUmas_L46:
 LD   22
 LDY  P2__st__
 EQ  
 JMC  ModbusRTUmas_L47
#srcline 255 ;            22 :
#srcline 256 ;              DataT[8]  := WORD_TO_USINT(SHR(UINT_TO_WORD(ptr^.StAdr),8));//Hi
 LEAY ptr
 LDIL    ; dereference 
 ADD  3  ; + offset 
 LDIW 
#debug uint ptr^.StAdr
 LD   uint 8
 SHR
 AND  $FFFF
 AND  $FF
 WRX  DataT[8]
#debug_left usint DataT[8]
#srcline 257 ;              DataT[9]  := UINT_TO_USINT(ptr^.StAdr);     // Lo adresa reg ve slave
 LEAY ptr
 LDIL    ; dereference 
 ADD  3  ; + offset 
 LDIW 
#debug uint ptr^.StAdr
 AND  $FF
 WRX  DataT[9]
#debug_left usint DataT[9]
#srcline 258 ;              BYptr:= UDINT_TO_PTR(ptr^.PtrData);         // source pointer
 LEAY ptr
 LDIL    ; dereference 
 ADD  7  ; + offset 
 LDIL 
#debug udint ptr^.PtrData
; UDINT -> PTR
 LEAY BYptr
 WRIL 
#debug_left pointer BYptr
#srcline 259 ;              pBYptr   := ADR(DataT[10]);                 // destination pointer
 LEAX DataT
 ADD  10  ; + offset 
#debug pointer DataT[10]
 LEAY pBYptr
 WRIL 
#debug_left pointer pBYptr
#srcline 260 ;              FOR i := 0 TO 1 DO                          // Word stream big endian
 LD   uint 0
 WRY  i
 LD   uint 1
 WRY  P5__st__
ModbusRTUmas_L48:
 LDY  i
 LDY  P5__st__
 GT   
 JMD  ModbusRTUmas_L49
 DBG  
#srcline 261 ;                IF Endian THEN                            // Little Endian
 LDX  Endian
#debug bool Endian
 JMC  ModbusRTUmas_L50
#srcline 262 ;                  pBYptr^:= BYptr^;                       // first byte to Lo
 LEAY BYptr
 LDIL    ; dereference 
 LDI  
#debug byte BYptr^
 LEAY pBYptr
 LDIL    ; dereference 
 WRI 
#debug_left byte pBYptr^
#srcline 263 ;                  pBYptr := pBYptr+1; BYptr := BYptr+1;
 LEAY pBYptr
 LDIL 
#debug pointer pBYptr
 LD   udint 1
 ADD
 LEAY pBYptr
 WRIL 
#debug_left pointer pBYptr
 LEAY BYptr
 LDIL 
#debug pointer BYptr
 LD   udint 1
 ADD
 LEAY BYptr
 WRIL 
#debug_left pointer BYptr
#srcline 264 ;                  pBYptr^:= BYptr^;                       // second byte to Hi
 LEAY BYptr
 LDIL    ; dereference 
 LDI  
#debug byte BYptr^
 LEAY pBYptr
 LDIL    ; dereference 
 WRI 
#debug_left byte pBYptr^
#srcline 265 ;                  pBYptr := pBYptr+1; BYptr := BYptr+1;
 LEAY pBYptr
 LDIL 
#debug pointer pBYptr
 LD   udint 1
 ADD
 LEAY pBYptr
 WRIL 
#debug_left pointer pBYptr
 LEAY BYptr
 LDIL 
#debug pointer BYptr
 LD   udint 1
 ADD
 LEAY BYptr
 WRIL 
#debug_left pointer BYptr
#srcline 266 ;                ELSE                                      // Big Endian
 JMP  ModbusRTUmas_L51
ModbusRTUmas_L50:
#srcline 267 ;                  pBYptr := pBYptr+1;
 LEAY pBYptr
 LDIL 
#debug pointer pBYptr
 LD   udint 1
 ADD
 LEAY pBYptr
 WRIL 
#debug_left pointer pBYptr
#srcline 268 ;                  pBYptr^:= BYptr^;                       // first byte to Hi
 LEAY BYptr
 LDIL    ; dereference 
 LDI  
#debug byte BYptr^
 LEAY pBYptr
 LDIL    ; dereference 
 WRI 
#debug_left byte pBYptr^
#srcline 269 ;                  pBYptr := pBYptr-1; BYptr := BYptr+1;
 LEAY pBYptr
 LDIL 
#debug pointer pBYptr
 LD   udint 1
 SUB
 LEAY pBYptr
 WRIL 
#debug_left pointer pBYptr
 LEAY BYptr
 LDIL 
#debug pointer BYptr
 LD   udint 1
 ADD
 LEAY BYptr
 WRIL 
#debug_left pointer BYptr
#srcline 270 ;                  pBYptr^:= BYptr^;                       // second byte to Lo
 LEAY BYptr
 LDIL    ; dereference 
 LDI  
#debug byte BYptr^
 LEAY pBYptr
 LDIL    ; dereference 
 WRI 
#debug_left byte pBYptr^
#srcline 271 ;                  pBYptr := pBYptr+2; BYptr := BYptr+1;
 LEAY pBYptr
 LDIL 
#debug pointer pBYptr
 LD   udint 2
 ADD
 LEAY pBYptr
 WRIL 
#debug_left pointer pBYptr
 LEAY BYptr
 LDIL 
#debug pointer BYptr
 LD   udint 1
 ADD
 LEAY BYptr
 WRIL 
#debug_left pointer BYptr
#srcline 272 ;                END_IF;
ModbusRTUmas_L51:
#srcline 273 ;              END_FOR;
 LDY  i
 LD   1
 ADD  
 WRY  i
 JMP  ModbusRTUmas_L48
ModbusRTUmas_L49:
 NOP  -1
#srcline 274 ;              i         := 14;
 LD   uint 14
 WRY  i
#debug_left uint i
 JMP  ModbusRTUmas_L27
ModbusRTUmas_L47:
#srcline 275 ;          ELSE
#srcline 276 ;            ErrCode := 4 + 128;               // Unknown FNC in transmit command
 LD   usint 4
 LD   usint 128
 ADD
 AND  $FF
 WRX  ErrCode
#debug_left usint ErrCode
#srcline 277 ;            SendTo.rq := false;
 LD   bool 0       ; false
 WRX  SendTo~rq
#debug_left bool SendTo.rq
#srcline 278 ;            StateMB := ErrMB;
 LD   udint 5  ; ModbusRTUlib_TStateMB#ErrMB
 WRX  StateMB
#debug_left usint StateMB
#srcline 280 ;          END_CASE;
ModbusRTUmas_L27:
#srcline 282 ;          IF k =6 THEN                        // no TCP
 LDY  k
#debug uint k
 LD   uint 6
 EQ
 JMC  ModbusRTUmas_L52
#srcline 283 ;            pomUINT   := CheckCRC_16(ptr := ADR(DataT[6]), length := i-6);
 NXT
 LEAX DataT
 ADD  6  ; + offset 
#debug pointer DataT[6]
 LEA  __Instance__CheckCRC_16~ptr
 WRIL 
#debug_left udint __Instance__CheckCRC_16~ptr
 LDY  i
#debug uint i
 LD   uint 6
 SUB
 AND  $FFFF
 WR   __Instance__CheckCRC_16~length
#debug_left uint __Instance__CheckCRC_16~length
 PRV
 LEA  __Instance__CheckCRC_16
 CAL  CheckCRC_16_L0
 WRY  pomUINT
#debug_left uint pomUINT
#srcline 284 ;            DataT[i]  := UINT_TO_USINT(pomUINT);                     //Lo
 LDY  pomUINT
#debug uint pomUINT
 AND  $FF
 LEAX DataT
 LDY  i
#debug uint i
 RCHK 261   ; Range Check
 ADD     ; + offset 
 WRI 
#debug_left usint DataT[i]
#srcline 285 ;            DataT[i+1]:= WORD_TO_USINT(SHR(UINT_TO_WORD(pomUINT),8));//Hi
 LDY  pomUINT
#debug uint pomUINT
 LD   uint 8
 SHR
 AND  $FFFF
 AND  $FF
 LEAX DataT
 LDY  i
#debug uint i
 LD   uint 1
 ADD
 AND  $FFFF
 RCHK 261   ; Range Check
 ADD     ; + offset 
 WRI 
#debug_left usint DataT[i+1]
#srcline 286 ;            DataT[5]  := UINT_TO_USINT(i-4);  // NUMT  no TCP
 LDY  i
#debug uint i
 LD   uint 4
 SUB
 AND  $FFFF
 AND  $FF
 WRX  DataT[5]
#debug_left usint DataT[5]
#srcline 287 ;          ELSE
 JMP  ModbusRTUmas_L53
ModbusRTUmas_L52:
#srcline 288 ;            traNum := traNum + 1;
 LDX  traNum
#debug uint traNum
 LD   uint 1
 ADD
 AND  $FFFF
 WRX  traNum
#debug_left uint traNum
#srcline 289 ;            DataT[0]  := WORD_TO_USINT(SHR(UINT_TO_WORD(pomUINT),8));  // transaction number Hi
 LDY  pomUINT
#debug uint pomUINT
 LD   uint 8
 SHR
 AND  $FFFF
 AND  $FF
 WRX  DataT[0]
#debug_left usint DataT[0]
#srcline 290 ;            DataT[1]  := UINT_TO_USINT(traNum);                        // transaction number Lo
 LDX  traNum
#debug uint traNum
 AND  $FF
 WRX  DataT[1]
#debug_left usint DataT[1]
#srcline 291 ;            DataT[5]  := UINT_TO_USINT(i-6);  // NUMT  TCP
 LDY  i
#debug uint i
 LD   uint 6
 SUB
 AND  $FFFF
 AND  $FF
 WRX  DataT[5]
#debug_left usint DataT[5]
#srcline 292 ;          END_IF;
ModbusRTUmas_L53:
#srcline 293 ;        END_IF;
ModbusRTUmas_L26:
 JMP  ModbusRTUmas_L23
ModbusRTUmas_L24:
 LD   2
 LDY  P1__st__
 EQ  
 JMC  ModbusRTUmas_L54
#srcline 294 ;      //------------------------------------------------------------------------
#srcline 295 ;      SndMBt :                                 // Send Message test
#srcline 296 ;        IF SendTo.error <> COM_ERR5 THEN             // Byd rev.1.7
 LDX  SendTo~error
#debug usint SendTo.error
 LD   usint 5
 EQ
 NEG
 JMC  ModbusRTUmas_L55
#srcline 297 ;          SendTo.rq := false;
 LD   bool 0       ; false
 WRX  SendTo~rq
#debug_left bool SendTo.rq
#srcline 298 ;          IF SendTo.mesSent THEN
 LDX  SendTo~mesSent
#debug bool SendTo.mesSent
 JMC  ModbusRTUmas_L57
#srcline 299 ;            StateMB := WaitRespMB;
 LD   udint 3  ; ModbusRTUlib_TStateMB#WaitRespMB
 WRX  StateMB
#debug_left usint StateMB
#srcline 300 ;          END_IF;
ModbusRTUmas_L57:
#srcline 301 ;          IF SendTo.error <> 0 THEN
 LDX  SendTo~error
#debug usint SendTo.error
 LD   usint 0
 EQ
 NEG
 JMC  ModbusRTUmas_L59
#srcline 302 ;            ErrCode := SendTo.error ;               // transm chanel error
 LDX  SendTo~error
#debug usint SendTo.error
 WRX  ErrCode
#debug_left usint ErrCode
#srcline 303 ;            StateMB := ErrMB;                       // Hard Error
 LD   udint 5  ; ModbusRTUlib_TStateMB#ErrMB
 WRX  StateMB
#debug_left usint StateMB
#srcline 304 ;          END_IF;
ModbusRTUmas_L59:
#srcline 305 ;        END_IF;
ModbusRTUmas_L55:
 JMP  ModbusRTUmas_L23
ModbusRTUmas_L54:
 LD   5
 LDY  P1__st__
 EQ  
 JMC  ModbusRTUmas_L61
#srcline 306 ;      //------------------------------------------------------------------------
#srcline 307 ;      ErrMB     :
#srcline 308 ;        Done := true; //!!!
 LD   bool -1       ; true
 WRX  Done
#debug_left bool Done
#srcline 309 ;        StateMB := StartMB;                       // Hard Error
 LD   udint 0  ; ModbusRTUlib_TStateMB#StartMB
 WRX  StateMB
#debug_left usint StateMB
 JMP  ModbusRTUmas_L23
ModbusRTUmas_L61:
ModbusRTUmas_L23:
#srcline 312 ;    RecvFrom(rq := StateMB = WaitRespMB, lenRx := 255 +6 -k, chanCode := chanCode, data := void(DataR[k]));            // Byd rev.1.7
 LDX  StateMB
#debug usint StateMB
 LD   udint 3  ; ModbusRTUlib_TStateMB#WaitRespMB
 EQ
 WRX  RecvFrom~rq
#debug_left bool RecvFrom~rq
 LD   uint 255
 LD   uint 6
 ADD
 AND  $FFFF
 LDY  k
#debug uint k
 SUB
 AND  $FFFF
 WRX  RecvFrom~lenRx
#debug_left uint RecvFrom~lenRx
 LDX  chanCode
#debug uint chanCode
 WRX  RecvFrom~chanCode
#debug_left uint RecvFrom~chanCode
 LEAX DataR
 LDY  k
#debug uint k
 RCHK 261   ; Range Check
 ADD     ; + offset 
 WRX  RecvFrom~data
#debug_left pointer RecvFrom.data
 LEAX RecvFrom
 CAL  fbRecvFrom_L0
#srcline 314 ;    IF RecvFrom.rq THEN //prijem
 LDX  RecvFrom~rq
#debug bool RecvFrom.rq
 JMC  ModbusRTUmas_L62
#srcline 315 ;      IF k <> 0 THEN  // TCP nemá broadcast
 LDY  k
#debug uint k
 LD   uint 0
 EQ
 NEG
 JMC  ModbusRTUmas_L64
#srcline 316 ;        IF DataT[6] = 0 THEN                   // broadcast
 LDX  DataT[6]
#debug usint DataT[6]
 LD   usint 0
 EQ
 JMC  ModbusRTUmas_L66
#srcline 317 ;          StateMB := StartMB;
 LD   udint 0  ; ModbusRTUlib_TStateMB#StartMB
 WRX  StateMB
#debug_left usint StateMB
#srcline 318 ;          Done := true;
 LD   bool -1       ; true
 WRX  Done
#debug_left bool Done
#srcline 319 ;        END_IF;
ModbusRTUmas_L66:
#srcline 320 ;      END_IF;
ModbusRTUmas_L64:
#srcline 321 ;      IF RecvFrom.mesRec THEN                  // receive
 LDX  RecvFrom~mesRec
#debug bool RecvFrom.mesRec
 JMC  ModbusRTUmas_L68
#srcline 322 ;        NUMR := RecvFrom.lenData;
 LDX  RecvFrom~lenData
#debug uint RecvFrom.lenData
 WRX  NUMR
#debug_left uint NUMR
#srcline 323 ;        ERRr := RecvFrom.error;
 LDX  RecvFrom~error
#debug usint RecvFrom.error
 WRX  ERRr
#debug_left usint ERRr
#srcline 324 ;        StateMB := RecMB;
 LD   udint 4  ; ModbusRTUlib_TStateMB#RecMB
 WRX  StateMB
#debug_left usint StateMB
#srcline 325 ;      ELSE
 JMP  ModbusRTUmas_L69
ModbusRTUmas_L68:
#srcline 326 ;        IF RespTimeOut.Q THEN
 LDX  RespTimeOut~Q
#debug bool RespTimeOut.Q
 JMC  ModbusRTUmas_L70
#srcline 327 ;          ErrCode := 7 + 128;                   // Respond Timeout Error
 LD   usint 7
 LD   usint 128
 ADD
 AND  $FF
 WRX  ErrCode
#debug_left usint ErrCode
#srcline 328 ;          StateMB := ErrMB;                     // Hard Error
 LD   udint 5  ; ModbusRTUlib_TStateMB#ErrMB
 WRX  StateMB
#debug_left usint StateMB
#srcline 329 ;        END_IF;
ModbusRTUmas_L70:
#srcline 330 ;      END_IF;
ModbusRTUmas_L69:
#srcline 331 ;    END_IF;
ModbusRTUmas_L62:
#srcline 333 ;    IF StateMB = RecMB THEN                     // recive
 LDX  StateMB
#debug usint StateMB
 LD   udint 4  ; ModbusRTUlib_TStateMB#RecMB
 EQ
 JMC  ModbusRTUmas_L72
#srcline 334 ;      IF ERRr <> 0 THEN                         // no error
 LDX  ERRr
#debug usint ERRr
 LD   usint 0
 EQ
 NEG
 JMC  ModbusRTUmas_L74
#srcline 335 ;        ErrCode := ERRr;                        // Error recive chanel
 LDX  ERRr
#debug usint ERRr
 WRX  ErrCode
#debug_left usint ErrCode
#srcline 336 ;        StateMB := ErrMB;                       // Hard Error
 LD   udint 5  ; ModbusRTUlib_TStateMB#ErrMB
 WRX  StateMB
#debug_left usint StateMB
#srcline 337 ;      ELSE
 JMP  ModbusRTUmas_L75
ModbusRTUmas_L74:
#srcline 338 ;        ErrCode := 0;
 LD   usint 0
 WRX  ErrCode
#debug_left usint ErrCode
#srcline 339 ;        IF DataR[6] <> DataT[6] THEN
 LDX  DataR[6]
#debug usint DataR[6]
 LDX  DataT[6]
#debug usint DataT[6]
 EQ
 NEG
 JMC  ModbusRTUmas_L76
#srcline 340 ;          ErrCode := 1 + 128;                   // Respond with other station
 LD   usint 1
 LD   usint 128
 ADD
 AND  $FF
 WRX  ErrCode
#debug_left usint ErrCode
#srcline 341 ;                                                //     number of slave device
#srcline 342 ;          StateMB := ErrMB;                     // Hard Error
 LD   udint 5  ; ModbusRTUlib_TStateMB#ErrMB
 WRX  StateMB
#debug_left usint StateMB
#srcline 343 ;        ELSE
 JMP  ModbusRTUmas_L77
ModbusRTUmas_L76:
#srcline 344 ;          IF (DataR[7] <> DataT[7]) and         //FNC
 LDX  DataR[7]
#debug usint DataR[7]
 LDX  DataT[7]
#debug usint DataT[7]
 EQ
 NEG
#srcline 345 ;             (DataR[7] <> DataT[7] + 128) THEN  //FNC+Exception
 LDX  DataR[7]
#debug usint DataR[7]
 LDX  DataT[7]
#debug usint DataT[7]
 LD   usint 128
 ADD
 AND  $FF
 EQ
 NEG
 AND
 JMC  ModbusRTUmas_L78
#srcline 346 ;            ErrCode := 2 + 128;                 // Respond with other FNC ever ask
 LD   usint 2
 LD   usint 128
 ADD
 AND  $FF
 WRX  ErrCode
#debug_left usint ErrCode
#srcline 347 ;            StateMB := ErrMB;                   // Hard Error
 LD   udint 5  ; ModbusRTUlib_TStateMB#ErrMB
 WRX  StateMB
#debug_left usint StateMB
#srcline 348 ;          ELSE
 JMP  ModbusRTUmas_L79
ModbusRTUmas_L78:
#srcline 349 ;            IF k = 0 THEN  // TCP nemá CRC
 LDY  k
#debug uint k
 LD   uint 0
 EQ
 JMC  ModbusRTUmas_L80
#srcline 350 ;              pomUINT:=0;
 LD   uint 0
 WRY  pomUINT
#debug_left uint pomUINT
#srcline 351 ;            ELSE
 JMP  ModbusRTUmas_L81
ModbusRTUmas_L80:
#srcline 352 ;              pomUINT:=CheckCRC_16(ptr := ADR( DataR[6]),length:= NUMR);// CRC
 NXT
 LEAX DataR
 ADD  6  ; + offset 
#debug pointer DataR[6]
 LEA  __Instance__CheckCRC_16~ptr
 WRIL 
#debug_left udint __Instance__CheckCRC_16~ptr
 LDX  NUMR
#debug uint NUMR
 WR   __Instance__CheckCRC_16~length
#debug_left uint __Instance__CheckCRC_16~length
 PRV
 LEA  __Instance__CheckCRC_16
 CAL  CheckCRC_16_L0
 WRY  pomUINT
#debug_left uint pomUINT
#srcline 353 ;            END_IF;
ModbusRTUmas_L81:
#srcline 354 ;            IF (pomUINT <> 0) THEN
 LDY  pomUINT
#debug uint pomUINT
 LD   uint 0
 EQ
 NEG
 JMC  ModbusRTUmas_L82
#srcline 355 ;              ErrCode := 3 + 128;               // Checksum error in reception
 LD   usint 3
 LD   usint 128
 ADD
 AND  $FF
 WRX  ErrCode
#debug_left usint ErrCode
#srcline 356 ;              StateMB := ErrMB;                 // Hard Error
 LD   udint 5  ; ModbusRTUlib_TStateMB#ErrMB
 WRX  StateMB
#debug_left usint StateMB
#srcline 357 ;            ELSE
 JMP  ModbusRTUmas_L83
ModbusRTUmas_L82:
#srcline 358 ;              ptr := ADR(Commands) + SINT_TO_UDINT(LastCmd-1) * sizeof(TCmdStruct);
 LDX  Commands
#debug pointer Commands
 LDX  LastCmd
#debug sint LastCmd
 EXTB 
 LD   sint 1
 SUB
 EXTB
 LD   11  ; SizeOf()
 MUL
 ADD
 LEAY ptr
 WRIL 
#debug_left pointer ptr
#srcline 359 ;              sptr:= UDINT_TO_PTR(ptr^.PtrData);// substitute of pointer
 LEAY ptr
 LDIL    ; dereference 
 ADD  7  ; + offset 
 LDIL 
#debug udint ptr^.PtrData
; UDINT -> PTR
 LEAY sptr
 WRIL 
#debug_left pointer sptr
#srcline 360 ;              StateMB := StartMB;
 LD   udint 0  ; ModbusRTUlib_TStateMB#StartMB
 WRX  StateMB
#debug_left usint StateMB
#srcline 361 ;              Done := true;
 LD   bool -1       ; true
 WRX  Done
#debug_left bool Done
#srcline 362 ;              IF DataR[7]>127 THEN
 LDX  DataR[7]
#debug usint DataR[7]
 LD   usint 127
 GT
 JMC  ModbusRTUmas_L84
#srcline 363 ;                ErrCode := DataR[8]+ 136;       // Exception from slave device 1,2,3,4,5,6,8,A,B
 LDX  DataR[8]
#debug usint DataR[8]
 LD   usint 136
 ADD
 AND  $FF
 WRX  ErrCode
#debug_left usint ErrCode
#srcline 364 ;              ELSE
 JMP  ModbusRTUmas_L85
ModbusRTUmas_L84:
#srcline 365 ;                CASE DataR[7]  OF               // Respondse FNC
 LDX  DataR[7]
#debug usint DataR[7]
 WRY  P6__st__
 LDY  P6__st__
 LD   2
 GT  
 JMD ModbusRTUmas_L87
 LDY  P6__st__
 LD   1
 LT  
 JMD ModbusRTUmas_L87
#srcline 366 ;                  1..2 :   // 01 Read Colls
#srcline 367 ;                           // 02 Read Discrete Inputs
#srcline 368 ;                     BOptr := sptr;
 LEAY sptr
 LDIL 
#debug pointer sptr
 LEAY BOptr
 WRIL 
#debug_left pointer BOptr
#srcline 369 ;                     pBOptr := ADR(DataR[9]) * 8;
 LEAX DataR
 ADD  9  ; + offset 
#debug pointer DataR[9]
 LD   udint 8
 MUL
 LEAY pBOptr
 WRIL 
#debug_left pointer pBOptr
#srcline 370 ;                     NoPoints:= LIMIT(MN :=1,IN := ptr^.NoPoint,MX :=2000);
 LEAY ptr
 LDIL    ; dereference 
 ADD  5  ; + offset 
 LDIW 
#debug uint ptr^.NoPoint
 LD   uint 1
 MAX
 LD   uint 2000
 MIN
 WRY  NoPoints
#debug_left uint NoPoints
#srcline 371 ;                     FOR i := 1 TO NoPoints DO    // Bit stream   // ByteCount
 LD   uint 1
 WRY  i
 LDY  NoPoints
#debug uint NoPoints
 WRY  P7__st__
ModbusRTUmas_L88:
 LDY  i
 LDY  P7__st__
 GT   
 JMD  ModbusRTUmas_L89
 DBG  
#srcline 372 ;                       BOptr^ := pBOptr^; BOptr := BOptr+1; pBOptr := pBOptr+1;
 LEAY pBOptr
 LDIL    ; dereference 
 LDIB 
#debug bool pBOptr^
 LEAY BOptr
 LDIL    ; dereference 
 WRIB 
#debug_left bool BOptr^
 LEAY BOptr
 LDIL 
#debug pointer BOptr
 LD   udint 1
 ADD
 LEAY BOptr
 WRIL 
#debug_left pointer BOptr
 LEAY pBOptr
 LDIL 
#debug pointer pBOptr
 LD   udint 1
 ADD
 LEAY pBOptr
 WRIL 
#debug_left pointer pBOptr
#srcline 373 ;                     END_FOR;
 LDY  i
 LD   1
 ADD  
 WRY  i
 JMP  ModbusRTUmas_L88
ModbusRTUmas_L89:
 NOP  -1
 JMP  ModbusRTUmas_L86
ModbusRTUmas_L87:
 LD   3
 LDY  P6__st__
 EQ   
 JMD  ModbusRTUmas_L90
 LD   4
 LDY  P6__st__
 EQ   
 JMD  ModbusRTUmas_L90
 LD   17
 LDY  P6__st__
 EQ   
 JMC  ModbusRTUmas_L91
ModbusRTUmas_L90:
#srcline 374 ;                  3,4,17 : // 03 Read Holding Registers
#srcline 375 ;                           // 04 Read Input Registers
#srcline 376 ;                           // 17 Report Slave ID
#srcline 377 ;                     BYptr  := ADR(DataR[9]);                  // source pointer
 LEAX DataR
 ADD  9  ; + offset 
#debug pointer DataR[9]
 LEAY BYptr
 WRIL 
#debug_left pointer BYptr
#srcline 378 ;                     pBYptr := sptr;                           // destination pointer
 LEAY sptr
 LDIL 
#debug pointer sptr
 LEAY pBYptr
 WRIL 
#debug_left pointer pBYptr
#srcline 379 ;                     NoPoints:= USINT_TO_UINT(DataR[8])/2;
 LDX  DataR[8]
#debug usint DataR[8]
 AND  $FFFF
 LD   uint 2
 DIVL
 AND  $FFFF
 WRY  NoPoints
#debug_left uint NoPoints
#srcline 380 ;                     IF DataR[7] <> 17 THEN
 LDX  DataR[7]
#debug usint DataR[7]
 LD   usint 17
 EQ
 NEG
 JMC  ModbusRTUmas_L92
#srcline 381 ;                       NoPoints:= LIMIT(MN := 1, IN := MIN(NoPoints, ptr^.NoPoint), MX := 125);
 LDY  NoPoints
#debug uint NoPoints
 LEAY ptr
 LDIL    ; dereference 
 ADD  5  ; + offset 
 LDIW 
#debug uint ptr^.NoPoint
 MIN
 LD   uint 1
 MAX
 LD   uint 125
 MIN
 WRY  NoPoints
#debug_left uint NoPoints
#srcline 382 ;                     END_IF;
ModbusRTUmas_L92:
#srcline 383 ;                     FOR i := 1 TO NoPoints DO// Word stream big endian
 LD   uint 1
 WRY  i
 LDY  NoPoints
#debug uint NoPoints
 WRY  P8__st__
ModbusRTUmas_L94:
 LDY  i
 LDY  P8__st__
 GT   
 JMD  ModbusRTUmas_L95
 DBG  
#srcline 384 ;                       IF Endian THEN                          // Little Endian
 LDX  Endian
#debug bool Endian
 JMC  ModbusRTUmas_L96
#srcline 385 ;                         pBYptr^:= BYptr^;                     // first byte to Lo
 LEAY BYptr
 LDIL    ; dereference 
 LDI  
#debug byte BYptr^
 LEAY pBYptr
 LDIL    ; dereference 
 WRI 
#debug_left byte pBYptr^
#srcline 386 ;                         pBYptr := pBYptr+1; BYptr := BYptr+1;
 LEAY pBYptr
 LDIL 
#debug pointer pBYptr
 LD   udint 1
 ADD
 LEAY pBYptr
 WRIL 
#debug_left pointer pBYptr
 LEAY BYptr
 LDIL 
#debug pointer BYptr
 LD   udint 1
 ADD
 LEAY BYptr
 WRIL 
#debug_left pointer BYptr
#srcline 387 ;                         pBYptr^:= BYptr^;                     // second byte to Hi
 LEAY BYptr
 LDIL    ; dereference 
 LDI  
#debug byte BYptr^
 LEAY pBYptr
 LDIL    ; dereference 
 WRI 
#debug_left byte pBYptr^
#srcline 388 ;                         pBYptr := pBYptr+1; BYptr := BYptr+1;
 LEAY pBYptr
 LDIL 
#debug pointer pBYptr
 LD   udint 1
 ADD
 LEAY pBYptr
 WRIL 
#debug_left pointer pBYptr
 LEAY BYptr
 LDIL 
#debug pointer BYptr
 LD   udint 1
 ADD
 LEAY BYptr
 WRIL 
#debug_left pointer BYptr
#srcline 389 ;                       ELSE                                    // Big Endian
 JMP  ModbusRTUmas_L97
ModbusRTUmas_L96:
#srcline 390 ;                         pBYptr := pBYptr+1;
 LEAY pBYptr
 LDIL 
#debug pointer pBYptr
 LD   udint 1
 ADD
 LEAY pBYptr
 WRIL 
#debug_left pointer pBYptr
#srcline 391 ;                         pBYptr^:= BYptr^;                     // first byte to Hi
 LEAY BYptr
 LDIL    ; dereference 
 LDI  
#debug byte BYptr^
 LEAY pBYptr
 LDIL    ; dereference 
 WRI 
#debug_left byte pBYptr^
#srcline 392 ;                         pBYptr := pBYptr-1; BYptr := BYptr+1;
 LEAY pBYptr
 LDIL 
#debug pointer pBYptr
 LD   udint 1
 SUB
 LEAY pBYptr
 WRIL 
#debug_left pointer pBYptr
 LEAY BYptr
 LDIL 
#debug pointer BYptr
 LD   udint 1
 ADD
 LEAY BYptr
 WRIL 
#debug_left pointer BYptr
#srcline 393 ;                         pBYptr^:= BYptr^;                     // second byte to Lo
 LEAY BYptr
 LDIL    ; dereference 
 LDI  
#debug byte BYptr^
 LEAY pBYptr
 LDIL    ; dereference 
 WRI 
#debug_left byte pBYptr^
#srcline 394 ;                         pBYptr := pBYptr+2; BYptr := BYptr+1;
 LEAY pBYptr
 LDIL 
#debug pointer pBYptr
 LD   udint 2
 ADD
 LEAY pBYptr
 WRIL 
#debug_left pointer pBYptr
 LEAY BYptr
 LDIL 
#debug pointer BYptr
 LD   udint 1
 ADD
 LEAY BYptr
 WRIL 
#debug_left pointer BYptr
#srcline 395 ;                       END_IF;
ModbusRTUmas_L97:
#srcline 396 ;                     END_FOR;
 LDY  i
 LD   1
 ADD  
 WRY  i
 JMP  ModbusRTUmas_L94
ModbusRTUmas_L95:
 NOP  -1
 JMP  ModbusRTUmas_L86
ModbusRTUmas_L91:
 LD   5
 LDY  P6__st__
 EQ  
 JMC  ModbusRTUmas_L98
#srcline 397 ;                  5 :       // 05 Write Single Coil
#srcline 398 ;                  ;
 JMP  ModbusRTUmas_L86
ModbusRTUmas_L98:
 LD   6
 LDY  P6__st__
 EQ  
 JMC  ModbusRTUmas_L99
#srcline 399 ;                  6 :       // 06 Write Single Register
#srcline 400 ;                  ;
 JMP  ModbusRTUmas_L86
ModbusRTUmas_L99:
 LD   7
 LDY  P6__st__
 EQ  
 JMC  ModbusRTUmas_L100
#srcline 401 ;                  7 :       // 07 Read Exception Status
#srcline 402 ;                     sptr^:= DataR[9];                       // first byte to Lo
 LDX  DataR[9]
#debug usint DataR[9]
 LEAY sptr
 LDIL    ; dereference 
 WRI 
#debug_left usint sptr^
#srcline 403 ;                  ;
 JMP  ModbusRTUmas_L86
ModbusRTUmas_L100:
 LD   8
 LDY  P6__st__
 EQ  
 JMC  ModbusRTUmas_L101
#srcline 404 ;                  8 :       // 08 Diagnostic
#srcline 405 ;                     IF Endian THEN                          // Little Endian
 LDX  Endian
#debug bool Endian
 JMC  ModbusRTUmas_L102
#srcline 406 ;                       sptr^:= DataR[10];                    // first byte to Lo
 LDX  DataR[10]
#debug usint DataR[10]
 LEAY sptr
 LDIL    ; dereference 
 WRI 
#debug_left usint sptr^
#srcline 407 ;                       sptr := sptr+1;
 LEAY sptr
 LDIL 
#debug pointer sptr
 LD   udint 1
 ADD
 LEAY sptr
 WRIL 
#debug_left pointer sptr
#srcline 408 ;                       sptr^:= DataR[11];                    // second byte to Hi
 LDX  DataR[11]
#debug usint DataR[11]
 LEAY sptr
 LDIL    ; dereference 
 WRI 
#debug_left usint sptr^
#srcline 409 ;                     ELSE                                    // Big Endian
 JMP  ModbusRTUmas_L103
ModbusRTUmas_L102:
#srcline 410 ;                       sptr^:= DataR[11];                    // first byte to Hi
 LDX  DataR[11]
#debug usint DataR[11]
 LEAY sptr
 LDIL    ; dereference 
 WRI 
#debug_left usint sptr^
#srcline 411 ;                       sptr := sptr+1;
 LEAY sptr
 LDIL 
#debug pointer sptr
 LD   udint 1
 ADD
 LEAY sptr
 WRIL 
#debug_left pointer sptr
#srcline 412 ;                       sptr^:= DataR[10];                    // second byte to Lo
 LDX  DataR[10]
#debug usint DataR[10]
 LEAY sptr
 LDIL    ; dereference 
 WRI 
#debug_left usint sptr^
#srcline 413 ;                     END_IF;
ModbusRTUmas_L103:
#srcline 414 ;                  ;
 JMP  ModbusRTUmas_L86
ModbusRTUmas_L101:
 LD   15
 LDY  P6__st__
 EQ  
 JMC  ModbusRTUmas_L104
#srcline 415 ;                  15:       // 15 Write Multiple Coils
#srcline 416 ;                  ;
 JMP  ModbusRTUmas_L86
ModbusRTUmas_L104:
 LD   16
 LDY  P6__st__
 EQ  
 JMC  ModbusRTUmas_L105
#srcline 417 ;                  16:       // 16 Write Multiple Registers
#srcline 418 ;                  ;
 JMP  ModbusRTUmas_L86
ModbusRTUmas_L105:
 LD   22
 LDY  P6__st__
 EQ  
 JMC  ModbusRTUmas_L106
#srcline 419 ;                  22:       // 22 Mask Write Registers
#srcline 420 ;                  ;
 JMP  ModbusRTUmas_L86
ModbusRTUmas_L106:
#srcline 421 ;                  ELSE
#srcline 422 ;                     ErrCode := 5 + 128;           // Respond with Unknown FNC
 LD   usint 5
 LD   usint 128
 ADD
 AND  $FF
 WRX  ErrCode
#debug_left usint ErrCode
#srcline 423 ;                     StateMB := ErrMB;             // Hard Error
 LD   udint 5  ; ModbusRTUlib_TStateMB#ErrMB
 WRX  StateMB
#debug_left usint StateMB
#srcline 424 ;                     //!!! Done := false;
#srcline 425 ;                END_CASE;
ModbusRTUmas_L86:
#srcline 426 ;              END_IF;
ModbusRTUmas_L85:
#srcline 427 ;            END_IF;
ModbusRTUmas_L83:
#srcline 428 ;          END_IF;
ModbusRTUmas_L79:
#srcline 429 ;        END_IF;
ModbusRTUmas_L77:
#srcline 430 ;      END_IF;
ModbusRTUmas_L75:
#srcline 431 ;    END_IF;
ModbusRTUmas_L72:
#srcline 434 ;    SendTo( lenTx := USINT_TO_UINT(DataT[5]) +6 -k, chanCode := chanCode, data := void(DataT[k]) );                      //
 LDX  DataT[5]
#debug usint DataT[5]
 AND  $FFFF
 LD   uint 6
 ADD
 AND  $FFFF
 LDY  k
#debug uint k
 SUB
 AND  $FFFF
 WRX  SendTo~lenTx
#debug_left uint SendTo~lenTx
 LDX  chanCode
#debug uint chanCode
 WRX  SendTo~chanCode
#debug_left uint SendTo~chanCode
 LEAX DataT
 LDY  k
#debug uint k
 RCHK 261   ; Range Check
 ADD     ; + offset 
 WRX  SendTo~data
#debug_left pointer SendTo.data
 LEAX SendTo
 CAL  fbSendTo_L0
#srcline 435 ;  END_IF;
ModbusRTUmas_L2:
#srcline 437 ;  RespTimeOut(IN := (StateMB= WaitRespMB), PT := MBtimeOut); // respond timeout timer
 LDX  StateMB
#debug usint StateMB
 LD   udint 3  ; ModbusRTUlib_TStateMB#WaitRespMB
 EQ
 WRX  RespTimeOut~IN
#debug_left bool RespTimeOut~IN
 LDX  MBtimeOut
#debug time MBtimeOut
 WRX  RespTimeOut~PT
#debug_left time RespTimeOut~PT
 LEAX RespTimeOut
 CAL  TON_L0
#srcline 438 ;END_FUNCTION_BLOCK
 ULNK
RET
E     61

; Initialize - variables
P     61
ModbusRTUmas__InstanceInit__:
 LINK 0
 LD   time 2000
 WRX  MBtimeOut
 LEAX SendTo
 CAL  fbSendTo__InstanceInit__
 LEAX RecvFrom
 CAL  fbRecvFrom__InstanceInit__
 ULNK
RET
E     61
; End initialize - variables
#endpou 



 

#srcfile ''
#srcfile 'C:\TECOLIBSRC\MODBUSRTU\MODBUSRTU\MODBUSTCPMAS.ST'
#pou ModbusTCPmas
#srcline 14 ;FUNCTION_BLOCK ModbusTCPmas
#table byte __Init___ModbusTCPmas_modbusRTU = 
      0,  0,  0,  0,  0,  0,  0,  0,208,  7,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  2;

#struct ModbusTCPmas__temp__
  pointer ptr,  ; {ENU} Structure for control of Modbus TCP master FB {CSY} Struktura pro øízení funkèního bloku Modbus TCP master
  bool CmdFind,  ; GrSel find
  bool cantChangeIP,
  usint tempCmd,
  int tempPos,
  string[81] tempStr,
  TRemoteEthAdr lastEthAdr,
  usint P0__st__,
  usint P1__st__,
  usint P2__st__,
  string[82] PS0__st__
#data byte _str_ModbusTCPmas_0 = 
  ':',0
P     61
ModbusTCPmas_L0:
 LINK __SizeOf(ModbusTCPmas__temp__)
; Initialize - dynamic variables
 LD   udint $FFFFFFFF    ; nil
 WRY  ptr
; End initialize - dynamic variables
; R_EDGE, F_EDGE 
 LDX  Start
 LETX __EDGE_R__Start
 WRX  Start
#srcline 87 ;  cantChangeIP := (UINT_TO_WORD(chanCode) and 16#00FF <> 16#00E1) AND ((System_S.S42 = 16#4B) OR (System_S.S42 = 16#4C));
 LDX  chanCode
#debug uint chanCode
 LD   word $00FF
 AND
 LD   word $00E1
 EQ
 NEG
 LD   System_S~S42
#debug byte System_S.S42
 LD   byte $4B
 EQ
 LD   System_S~S42
#debug byte System_S.S42
 LD   byte $4C
 EQ
 OR  
 AND
 WRY  cantChangeIP
#debug_left bool cantChangeIP
#srcline 88 ;  //  ErrCode := 20 + 128; RETURN;                     // kod kanalu musi byt ETH1_uni
#srcline 89 ;  //END_IF;  // TCP
#srcline 91 ;  isEstab := IsEstabTCPconnection(chanCode := chanCode);
 NXT
 LDX  chanCode
#debug uint chanCode
 WR   __Instance__IsEstabTCPconnection~chanCode
#debug_left uint __Instance__IsEstabTCPconnection~chanCode
 PRV
 LEA  __Instance__IsEstabTCPconnection
 CAL  IsEstabTCPconnection_L0
 WRX  isEstab
#debug_left bool isEstab
#srcline 93 ;  IF ProgramIsChanged() THEN
 LEA  __Instance__ProgramIsChanged
 CAL  ProgramIsChanged_L0
 JMC  ModbusTCPmas_L1
#srcline 94 ;    IF LastCmd > 0 AND LastCmd <= MaxCmd THEN
 LDX  LastCmd
#debug usint LastCmd
 LD   usint 0
 GT
 LDX  LastCmd
#debug usint LastCmd
 LDX  MaxCmd
#debug usint MaxCmd
 GT
 NEG
 AND
 JMC  ModbusTCPmas_L3
#srcline 95 ;      ptr := ADR(Commands) + USINT_TO_UDINT(LastCmd-1) * sizeof(TCmdStructTCP);
 LDX  Commands
#debug pointer Commands
 LDX  LastCmd
#debug usint LastCmd
 LD   usint 1
 SUB
 AND  $FF
 LD   34  ; SizeOf()
 MUL
 ADD
 LEAY ptr
 WRIL 
#debug_left pointer ptr
#srcline 96 ;      // prepare localCmd
#srcline 97 ;      localCmd.Gr  := ptr^.Gr;
 LEAY ptr
 LDIL    ; dereference 
 LDI  
#debug usint ptr^.Gr
 WRX  localCmd~Gr
#debug_left usint localCmd.Gr
#srcline 98 ;      localCmd.SNo := ptr^.UnitID;    // od verze 1.6, starsi verze mely natvrdo 0
 LEAY ptr
 LDIL    ; dereference 
 ADD  24  ; + offset 
 LDI  
#debug usint ptr^.UnitID
 WRX  localCmd~SNo
#debug_left usint localCmd.SNo
#srcline 99 ;      localCmd.FNC := ptr^.FNC;
 LEAY ptr
 LDIL    ; dereference 
 ADD  25  ; + offset 
 LDI  
#debug usint ptr^.FNC
 WRX  localCmd~FNC
#debug_left usint localCmd.FNC
#srcline 100 ;      localCmd.StAdr := ptr^.StAdr;
 LEAY ptr
 LDIL    ; dereference 
 ADD  26  ; + offset 
 LDIW 
#debug uint ptr^.StAdr
 WRX  localCmd~StAdr
#debug_left uint localCmd.StAdr
#srcline 101 ;      localCmd.NoPoint := ptr^.NoPoint;
 LEAY ptr
 LDIL    ; dereference 
 ADD  28  ; + offset 
 LDIW 
#debug uint ptr^.NoPoint
 WRX  localCmd~NoPoint
#debug_left uint localCmd.NoPoint
#srcline 102 ;      localCmd.PtrData := ptr^.PtrData;
 LEAY ptr
 LDIL    ; dereference 
 ADD  30  ; + offset 
 LDIL 
#debug udint ptr^.PtrData
 WRX  localCmd~PtrData
#debug_left udint localCmd.PtrData
#srcline 103 ;    END_IF;
ModbusTCPmas_L3:
#srcline 104 ;  END_IF;
ModbusTCPmas_L1:
#srcline 106 ;  IF not EN THEN
 LDX  EN
#debug bool EN
 NEG
 JMC  ModbusTCPmas_L5
#srcline 107 ;    InitDone := false; LastCmd := 0; autoCmd := 0;
 LD   bool 0       ; false
 WRX  InitDone
#debug_left bool InitDone
 LD   usint 0
 WRX  LastCmd
#debug_left usint LastCmd
 LD   usint 0
 WRX  autoCmd
#debug_left usint autoCmd
#srcline 108 ;    Done := FALSE; ErrCode := 0;                     // clear error code
 LD   bool 0       ; false
 WRX  Done
#debug_left bool Done
 LD   usint 0
 WRX  ErrCode
#debug_left usint ErrCode
#srcline 109 ;    CloseTCPconnection( chanCode);
 NXT
 LDX  chanCode
#debug uint chanCode
 WR   __Instance__CloseTCPconnection~chanCode
#debug_left uint __Instance__CloseTCPconnection~chanCode
 PRV
 LEA  __Instance__CloseTCPconnection
 CAL  CloseTCPconnection_L0
#srcline 110 ;    State := MdbTCP_init;
 LD   udint 0  ; ModbusRTUlib_TStatesMdbTCP#MdbTCP_init
 WRX  State
#debug_left usint State
#srcline 111 ;    chkTim( IN := FALSE);                            // switch timer OFF
 LD   bool 0       ; false
 WRX  chkTim~IN
#debug_left bool chkTim~IN
 LEAX chkTim
 CAL  TON_L0
#srcline 112 ;  ELSE
 JMP  ModbusTCPmas_L6
ModbusTCPmas_L5:
#srcline 113 ;    chkTim( IN := state = lastState AND (state = MdbTCP_setIPadr OR state = MdbTCP_sendData), PT := MBtimeOut);  // check timer
 LDX  state
#debug usint state
 LDX  lastState
#debug usint lastState
 EQ
 LDX  state
#debug usint state
 LD   udint 3  ; ModbusRTUlib_TStatesMdbTCP#MdbTCP_setIPadr
 EQ
 LDX  state
#debug usint state
 LD   udint 5  ; ModbusRTUlib_TStatesMdbTCP#MdbTCP_sendData
 EQ
 OR  
 AND
 WRX  chkTim~IN
#debug_left bool chkTim~IN
 LDX  MBtimeOut
#debug time MBtimeOut
 WRX  chkTim~PT
#debug_left time chkTim~PT
 LEAX chkTim
 CAL  TON_L0
#srcline 114 ;    IF chkTim.Q THEN
 LDX  chkTim~Q
#debug bool chkTim.Q
 JMC  ModbusTCPmas_L7
#srcline 115 ;      CASE state OF
 LDX  state
#debug usint state
 WRY  P0__st__
 LD   3
 LDY  P0__st__
 EQ  
 JMC  ModbusTCPmas_L10
#srcline 116 ;        MdbTCP_setIPadr : ErrCode := 23 + 128;       // nelze nastavit IP adresu
 LD   usint 23
 LD   usint 128
 ADD
 AND  $FF
 WRX  ErrCode
#debug_left usint ErrCode
 JMP  ModbusTCPmas_L9
ModbusTCPmas_L10:
 LD   5
 LDY  P0__st__
 EQ  
 JMC  ModbusTCPmas_L11
#srcline 117 ;        MdbTCP_sendData : ErrCode := 21 + 128;       // nelze navazat TCP spojeni
 LD   usint 21
 LD   usint 128
 ADD
 AND  $FF
 WRX  ErrCode
#debug_left usint ErrCode
 JMP  ModbusTCPmas_L9
ModbusTCPmas_L11:
ModbusTCPmas_L9:
#srcline 119 ;      State := MdbTCP_error;
 LD   udint 7  ; ModbusRTUlib_TStatesMdbTCP#MdbTCP_error
 WRX  State
#debug_left usint State
#srcline 120 ;    END_IF;
ModbusTCPmas_L7:
#srcline 121 ;    lastState := state;
 LDX  state
#debug usint state
 WRX  lastState
#debug_left usint lastState
#srcline 123 ;    CASE state OF
 LDX  state
#debug usint state
 WRY  P1__st__
 LD   0
 LDY  P1__st__
 EQ  
 JMC  ModbusTCPmas_L13
#srcline 124 ;      //---------------------------------------------
#srcline 125 ;      MdbTCP_init :
#srcline 126 ;         //nasledujici dva radky byly zbytecne a mohly zavlect do newEthAdr localport nenulovou hodnotu
#srcline 127 ;         //ta mohla zpusobit problemy nize pokud byla vyplnena vzdalena IP a port v ini tabulce
#srcline 128 ;         //GetRemoteIPaddress( chanCode, newEthAdr);
#srcline 129 ;         //SetRemoteIPaddress( TRUE, chanCode, newEthAdr); // to be sure, what is starting IP address
#srcline 130 ;         CloseTCPconnection();   //pokud je EN aktivni jiz v prvnim cyklu, predejdeme zbytecnemu navazovani
 NXT
 LD   0
 WR   __Instance__CloseTCPconnection~chanCode
 PRV
 LEA  __Instance__CloseTCPconnection
 CAL  CloseTCPconnection_L0
#srcline 131 ;         wasStart := Start;
 LDX  Start
#debug bool Start
 WRX  wasStart
#debug_left bool wasStart
#srcline 132 ;         State := MdbTCP_start;
 LD   udint 1  ; ModbusRTUlib_TStatesMdbTCP#MdbTCP_start
 WRX  State
#debug_left usint State
 JMP  ModbusTCPmas_L12
ModbusTCPmas_L13:
 LD   1
 LDY  P1__st__
 EQ  
 JMC  ModbusTCPmas_L14
#srcline 133 ;         
#srcline 134 ;      //---------------------------------------------
#srcline 135 ;      MdbTCP_start :
#srcline 136 ;        Done := FALSE; ErrCode := 0;
 LD   bool 0       ; false
 WRX  Done
#debug_left bool Done
 LD   usint 0
 WRX  ErrCode
#debug_left usint ErrCode
#srcline 137 ;        IF GrSel = 0 THEN                            // manual
 LDX  GrSel
#debug usint GrSel
 LD   usint 0
 EQ
 JMC  ModbusTCPmas_L15
#srcline 138 ;          IF Start OR wasStart THEN
 LDX  Start
#debug bool Start
 LDX  wasStart
#debug bool wasStart
 OR  
 JMC  ModbusTCPmas_L17
#srcline 139 ;            lastCmd := CmdNo;
 LDX  CmdNo
#debug usint CmdNo
 WRX  lastCmd
#debug_left usint lastCmd
#srcline 140 ;            IF CmdNo > 0 and CmdNo <= MaxCmd THEN state := MdbTCP_selCommand; END_IF;
 LDX  CmdNo
#debug usint CmdNo
 LD   usint 0
 GT
 LDX  CmdNo
#debug usint CmdNo
 LDX  MaxCmd
#debug usint MaxCmd
 GT
 NEG
 AND
 JMC  ModbusTCPmas_L19
 LD   udint 2  ; ModbusRTUlib_TStatesMdbTCP#MdbTCP_selCommand
 WRX  state
#debug_left usint state
ModbusTCPmas_L19:
#srcline 141 ;          END_IF;
ModbusTCPmas_L17:
#srcline 142 ;        ELSE                                          // auto
 JMP  ModbusTCPmas_L16
ModbusTCPmas_L15:
#srcline 143 ;          state := MdbTCP_selCommand;
 LD   udint 2  ; ModbusRTUlib_TStatesMdbTCP#MdbTCP_selCommand
 WRX  state
#debug_left usint state
#srcline 144 ;          CmdFind := false;
 LD   bool 0       ; false
 WRY  CmdFind
#debug_left bool CmdFind
#srcline 145 ;          autoCmd := autoCmd + 1;
 LDX  autoCmd
#debug usint autoCmd
 LD   usint 1
 ADD
 AND  $FF
 WRX  autoCmd
#debug_left usint autoCmd
#srcline 146 ;          FOR tempCmd := autoCmd TO MaxCmd DO
 LDX  autoCmd
#debug usint autoCmd
 WRY  tempCmd
 LDX  MaxCmd
#debug usint MaxCmd
 WRY  P2__st__
ModbusTCPmas_L21:
 LDY  tempCmd
 LDY  P2__st__
 GT   
 JMD  ModbusTCPmas_L22
 DBG  
#srcline 147 ;            ptr := ADR(Commands) + USINT_TO_UDINT(tempCmd-1) * sizeof(TCmdStructTCP);
 LDX  Commands
#debug pointer Commands
 LDY  tempCmd
#debug usint tempCmd
 LD   usint 1
 SUB
 AND  $FF
 LD   34  ; SizeOf()
 MUL
 ADD
 LEAY ptr
 WRIL 
#debug_left pointer ptr
#srcline 148 ;            IF (((ptr^.Gr = GrSel) or (ptr^.Gr = 1)) and initDone) or
 LEAY ptr
 LDIL    ; dereference 
 LDI  
#debug usint ptr^.Gr
 LDX  GrSel
#debug usint GrSel
 EQ
 LEAY ptr
 LDIL    ; dereference 
 LDI  
#debug usint ptr^.Gr
 LD   usint 1
 EQ
 OR  
 LDX  initDone
#debug bool initDone
 AND
#srcline 149 ;                ((ptr^.Gr = 255)  and not initDone) THEN
 LEAY ptr
 LDIL    ; dereference 
 LDI  
#debug usint ptr^.Gr
 LD   usint 255
 EQ
 LDX  initDone
#debug bool initDone
 NEG
 AND
 OR  
 JMC  ModbusTCPmas_L23
#srcline 150 ;              autoCmd := tempCmd;
 LDY  tempCmd
#debug usint tempCmd
 WRX  autoCmd
#debug_left usint autoCmd
#srcline 151 ;              CmdFind := true;
 LD   bool -1       ; true
 WRY  CmdFind
#debug_left bool CmdFind
#srcline 152 ;              EXIT;
 JMP  ModbusTCPmas_L22
#srcline 153 ;            END_IF;
ModbusTCPmas_L23:
#srcline 154 ;//!!!            IF (ptr^.Gr = 0) THEN EXIT; END_IF;       // no record
#srcline 155 ;          END_FOR;
 LDY  tempCmd
 LD   1
 ADD  
 WRY  tempCmd
 JMP  ModbusTCPmas_L21
ModbusTCPmas_L22:
 NOP  -1
#srcline 156 ;          IF not CmdFind THEN
 LDY  CmdFind
#debug bool CmdFind
 NEG
 JMC  ModbusTCPmas_L25
#srcline 157 ;            IF not initDone THEN
 LDX  initDone
#debug bool initDone
 NEG
 JMC  ModbusTCPmas_L27
#srcline 158 ;              initDone := true;
 LD   bool -1       ; true
 WRX  initDone
#debug_left bool initDone
#srcline 159 ;            END_IF;
ModbusTCPmas_L27:
#srcline 160 ;            autoCmd := 0;
 LD   usint 0
 WRX  autoCmd
#debug_left usint autoCmd
#srcline 161 ;            state := MdbTCP_start;
 LD   udint 1  ; ModbusRTUlib_TStatesMdbTCP#MdbTCP_start
 WRX  state
#debug_left usint state
#srcline 162 ;          END_IF;
ModbusTCPmas_L25:
#srcline 163 ;          LastCmd := autoCmd;
 LDX  autoCmd
#debug usint autoCmd
 WRX  LastCmd
#debug_left usint LastCmd
#srcline 164 ;        END_IF;
ModbusTCPmas_L16:
#srcline 165 ;        wasStart := 0;
 LD   bool 0       ; false
 WRX  wasStart
#debug_left bool wasStart
 JMP  ModbusTCPmas_L12
ModbusTCPmas_L14:
 LD   2
 LDY  P1__st__
 EQ  
 JMC  ModbusTCPmas_L29
#srcline 166 ;      //---------------------------------------------
#srcline 167 ;      MdbTCP_selCommand :
#srcline 168 ;        ptr := ADR(Commands) + USINT_TO_UDINT(LastCmd-1) * sizeof(TCmdStructTCP);
 LDX  Commands
#debug pointer Commands
 LDX  LastCmd
#debug usint LastCmd
 LD   usint 1
 SUB
 AND  $FF
 LD   34  ; SizeOf()
 MUL
 ADD
 LEAY ptr
 WRIL 
#debug_left pointer ptr
#srcline 169 ;        // prepare localCmd
#srcline 170 ;        localCmd.Gr  := ptr^.Gr;
 LEAY ptr
 LDIL    ; dereference 
 LDI  
#debug usint ptr^.Gr
 WRX  localCmd~Gr
#debug_left usint localCmd.Gr
#srcline 171 ;        localCmd.SNo := ptr^.UnitID;    // od verze 1.6, starsi verze mely natvrdo 0
 LEAY ptr
 LDIL    ; dereference 
 ADD  24  ; + offset 
 LDI  
#debug usint ptr^.UnitID
 WRX  localCmd~SNo
#debug_left usint localCmd.SNo
#srcline 172 ;        localCmd.FNC := ptr^.FNC;
 LEAY ptr
 LDIL    ; dereference 
 ADD  25  ; + offset 
 LDI  
#debug usint ptr^.FNC
 WRX  localCmd~FNC
#debug_left usint localCmd.FNC
#srcline 173 ;        localCmd.StAdr := ptr^.StAdr;
 LEAY ptr
 LDIL    ; dereference 
 ADD  26  ; + offset 
 LDIW 
#debug uint ptr^.StAdr
 WRX  localCmd~StAdr
#debug_left uint localCmd.StAdr
#srcline 174 ;        localCmd.NoPoint := ptr^.NoPoint;
 LEAY ptr
 LDIL    ; dereference 
 ADD  28  ; + offset 
 LDIW 
#debug uint ptr^.NoPoint
 WRX  localCmd~NoPoint
#debug_left uint localCmd.NoPoint
#srcline 175 ;        localCmd.PtrData := ptr^.PtrData;
 LEAY ptr
 LDIL    ; dereference 
 ADD  30  ; + offset 
 LDIL 
#debug udint ptr^.PtrData
 WRX  localCmd~PtrData
#debug_left udint localCmd.PtrData
#srcline 176 ;        // prepare IP address
#srcline 177 ;        IF cantChangeIP THEN
 LDY  cantChangeIP
#debug bool cantChangeIP
 JMC  ModbusTCPmas_L30
#srcline 178 ;          IF isEstab THEN
 LDX  isEstab
#debug bool isEstab
 JMC  ModbusTCPmas_L32
#srcline 179 ;            modbusRTU.Start := TRUE;
 LD   bool -1       ; true
 WRX  modbusRTU~Start
#debug_left bool modbusRTU.Start
#srcline 180 ;            state := MdbTCP_recData;
 LD   udint 6  ; ModbusRTUlib_TStatesMdbTCP#MdbTCP_recData
 WRX  state
#debug_left usint state
#srcline 181 ;          ELSE
 JMP  ModbusTCPmas_L33
ModbusTCPmas_L32:
#srcline 182 ;            EstabTCPconnection( chanCode);
 NXT
 LDX  chanCode
#debug uint chanCode
 WR   __Instance__EstabTCPconnection~chanCode
#debug_left uint __Instance__EstabTCPconnection~chanCode
 PRV
 LEA  __Instance__EstabTCPconnection
 CAL  EstabTCPconnection_L0
#srcline 183 ;            state := MdbTCP_sendData;
 LD   udint 5  ; ModbusRTUlib_TStatesMdbTCP#MdbTCP_sendData
 WRX  state
#debug_left usint state
#srcline 184 ;          END_IF;
ModbusTCPmas_L33:
#srcline 185 ;        ELSE
 JMP  ModbusTCPmas_L31
ModbusTCPmas_L30:
#srcline 186 ;          tempPos := FIND( ptr^.IP, ':');
 LEAY ptr
 LDIL    ; dereference 
 ADD  1  ; + offset 
#debug string ptr^.IP
 LEA  _str_ModbusTCPmas_0
 SFND 
 WRY  tempPos
#debug_left int tempPos
#srcline 187 ;          IF tempPos = 0 THEN
 LDY  tempPos
#debug int tempPos
 EXTW 
 LD   int 0
 EQ
 JMC  ModbusTCPmas_L34
#srcline 188 ;            newEthAdr.remoteIP := STRING_TO_IPADR( ptr^.IP); newEthAdr.remotePort := 502;
 NXT
 LD   0   ; null string
 LEA  __Instance__STRING_TO_IPADR~IPAdr
 WRI 
 LEA  __Instance__STRING_TO_IPADR~IPAdr
 LD   80
 DST    ; Level 1
 LEAY ptr
 LDIL    ; dereference 
 ADD  1  ; + offset 
#debug string ptr^.IP
 SCON 
#debug_left string __Instance__STRING_TO_IPADR~IPAdr
 PDST   ; Level 1
 PRV
 LEA  __Instance__STRING_TO_IPADR
 CAL  STRING_TO_IPADR_L0
 LEAX newEthAdr~remoteIP
#debug_left pointer newEthAdr.remoteIP
 LD   4   ;SizeOf() 
 MOV  %IB0
 LD   uint 502
 WRX  newEthAdr~remotePort
#debug_left uint newEthAdr.remotePort
#srcline 189 ;          ELSE
 JMP  ModbusTCPmas_L35
ModbusTCPmas_L34:
#srcline 190 ;            tempStr := LEFT( ptr^.IP, tempPos-1); newEthAdr.remoteIP := STRING_TO_IPADR( tempStr);
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   80
 DST    ; Level 1
 LEAY ptr
 LDIL    ; dereference 
 ADD  1  ; + offset 
#debug string ptr^.IP
 LDY  tempPos
#debug int tempPos
 EXTW 
 LD   int 1
 SUB
 EXTW
 SLFT 
 PDST   ; Level 1
 LD   0   ; null string
 LEAY tempStr
 WRI  
 LEAY tempStr
 LD   80
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string tempStr
 PDST   ; Level 1
 NXT
 LD   0   ; null string
 LEA  __Instance__STRING_TO_IPADR~IPAdr
 WRI 
 LEA  __Instance__STRING_TO_IPADR~IPAdr
 LD   80
 DST    ; Level 1
 LEAY tempStr
#debug string tempStr
 SCON 
#debug_left string __Instance__STRING_TO_IPADR~IPAdr
 PDST   ; Level 1
 PRV
 LEA  __Instance__STRING_TO_IPADR
 CAL  STRING_TO_IPADR_L0
 LEAX newEthAdr~remoteIP
#debug_left pointer newEthAdr.remoteIP
 LD   4   ;SizeOf() 
 MOV  %IB0
#srcline 191 ;            tempStr := MID( ptr^.IP, 5, tempPos+1); newEthAdr.remotePort := STRING_TO_UINT(tempStr);
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   80
 DST    ; Level 1
 LEAY ptr
 LDIL    ; dereference 
 ADD  1  ; + offset 
#debug string ptr^.IP
 LD   5
 LDY  tempPos
#debug int tempPos
 EXTW 
 LD   int 1
 ADD
 EXTW
 SUB  1
 SMID 
 PDST   ; Level 1
 LD   0   ; null string
 LEAY tempStr
 WRI  
 LEAY tempStr
 LD   80
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string tempStr
 PDST   ; Level 1
 LEAY tempStr
#debug string tempStr
 SCNV $300A;  IEC_STRING _TO_ IEC_UINT
 WRX  newEthAdr~remotePort
#debug_left uint newEthAdr.remotePort
#srcline 192 ;          END_IF;
ModbusTCPmas_L35:
#srcline 193 ;          // check new IP address
#srcline 194 ;          IF newEthAdr.remoteIP[0] = 0 AND newEthAdr.remoteIP[1] = 0 AND newEthAdr.remoteIP[2] = 0 AND newEthAdr.remoteIP[3] = 0 THEN
 LDX  newEthAdr~remoteIP[0]
#debug usint newEthAdr.remoteIP[0]
 LD   usint 0
 EQ
 LDX  newEthAdr~remoteIP[1]
#debug usint newEthAdr.remoteIP[1]
 LD   usint 0
 EQ
 AND
 LDX  newEthAdr~remoteIP[2]
#debug usint newEthAdr.remoteIP[2]
 LD   usint 0
 EQ
 AND
 LDX  newEthAdr~remoteIP[3]
#debug usint newEthAdr.remoteIP[3]
 LD   usint 0
 EQ
 AND
 JMC  ModbusTCPmas_L36
#srcline 195 ;            ErrCode := 22 + 128;                           // chybna IP adresa
 LD   usint 22
 LD   usint 128
 ADD
 AND  $FF
 WRX  ErrCode
#debug_left usint ErrCode
#srcline 196 ;            state := MdbTCP_error;
 LD   udint 7  ; ModbusRTUlib_TStatesMdbTCP#MdbTCP_error
 WRX  state
#debug_left usint state
#srcline 197 ;          ELSE
 JMP  ModbusTCPmas_L37
ModbusTCPmas_L36:
#srcline 198 ;            // set IP address
#srcline 199 ;            GetRemoteIPaddress( chanCode, lastEthAdr);
 NXT
 LDX  chanCode
#debug uint chanCode
 WR   __Instance__GetRemoteIPaddress~chanCode
#debug_left uint __Instance__GetRemoteIPaddress~chanCode
 LEAY lastEthAdr
 WR   __Instance__GetRemoteIPaddress~ethAdr
#debug_left pointer __Instance__GetRemoteIPaddress.ethAdr
 PRV
 LEA  __Instance__GetRemoteIPaddress
 CAL  GetRemoteIPaddress_L0
#srcline 200 ;            IF lastEthAdr.remoteIP <> newEthAdr.remoteIP OR lastEthAdr.remotePort <> newEthAdr.remotePort THEN
 LEAY lastEthAdr~remoteIP
 LEAX newEthAdr~remoteIP
 LD   4   ; SizeOf()
 BCMP 
 EQ   0
 NEG
 LDY  lastEthAdr~remotePort
#debug uint lastEthAdr.remotePort
 LDX  newEthAdr~remotePort
#debug uint newEthAdr.remotePort
 EQ
 NEG
 OR  
 JMC  ModbusTCPmas_L38
#srcline 201 ;              newEthAdr.localPort := 0;                    // local port is done by TCP driver
 LD   uint 0
 WRX  newEthAdr~localPort
#debug_left uint newEthAdr.localPort
#srcline 202 ;              CloseTCPconnection( chanCode);               // then we must close it
 NXT
 LDX  chanCode
#debug uint chanCode
 WR   __Instance__CloseTCPconnection~chanCode
#debug_left uint __Instance__CloseTCPconnection~chanCode
 PRV
 LEA  __Instance__CloseTCPconnection
 CAL  CloseTCPconnection_L0
#srcline 203 ;              state := MdbTCP_setIPadr;
 LD   udint 3  ; ModbusRTUlib_TStatesMdbTCP#MdbTCP_setIPadr
 WRX  state
#debug_left usint state
#srcline 204 ;            ELSE
 JMP  ModbusTCPmas_L39
ModbusTCPmas_L38:
#srcline 205 ;              IF isEstab THEN
 LDX  isEstab
#debug bool isEstab
 JMC  ModbusTCPmas_L40
#srcline 206 ;                modbusRTU.Start := TRUE;
 LD   bool -1       ; true
 WRX  modbusRTU~Start
#debug_left bool modbusRTU.Start
#srcline 207 ;                state := MdbTCP_recData;
 LD   udint 6  ; ModbusRTUlib_TStatesMdbTCP#MdbTCP_recData
 WRX  state
#debug_left usint state
#srcline 208 ;              ELSE
 JMP  ModbusTCPmas_L41
ModbusTCPmas_L40:
#srcline 209 ;                EstabTCPconnection( chanCode);
 NXT
 LDX  chanCode
#debug uint chanCode
 WR   __Instance__EstabTCPconnection~chanCode
#debug_left uint __Instance__EstabTCPconnection~chanCode
 PRV
 LEA  __Instance__EstabTCPconnection
 CAL  EstabTCPconnection_L0
#srcline 210 ;                state := MdbTCP_sendData;
 LD   udint 5  ; ModbusRTUlib_TStatesMdbTCP#MdbTCP_sendData
 WRX  state
#debug_left usint state
#srcline 211 ;              END_IF;
ModbusTCPmas_L41:
#srcline 212 ;            END_IF;
ModbusTCPmas_L39:
#srcline 213 ;          END_IF;
ModbusTCPmas_L37:
#srcline 214 ;        END_IF;
ModbusTCPmas_L31:
 JMP  ModbusTCPmas_L12
ModbusTCPmas_L29:
 LD   3
 LDY  P1__st__
 EQ  
 JMC  ModbusTCPmas_L42
#srcline 216 ;      //---------------------------------------------
#srcline 217 ;      MdbTCP_setIPadr :
#srcline 218 ;        IF NOT isEstab THEN        // if connection closed
 LDX  isEstab
#debug bool isEstab
 NEG
 JMC  ModbusTCPmas_L43
#srcline 219 ;          SetRemoteIPaddress( TRUE, chanCode, newEthAdr);  // set new IP address
 NXT
 LD   bool -1       ; true
 WR   __Instance__SetRemoteIPaddress~rq
#debug_left bool __Instance__SetRemoteIPaddress~rq
 LDX  chanCode
#debug uint chanCode
 WR   __Instance__SetRemoteIPaddress~chanCode
#debug_left uint __Instance__SetRemoteIPaddress~chanCode
 LEAX newEthAdr
 WR   __Instance__SetRemoteIPaddress~ethAdr
#debug_left pointer __Instance__SetRemoteIPaddress.ethAdr
 PRV
 LEA  __Instance__SetRemoteIPaddress
 CAL  SetRemoteIPaddress_L0
#srcline 220 ;          state := MdbTCP_estabCon;
 LD   udint 4  ; ModbusRTUlib_TStatesMdbTCP#MdbTCP_estabCon
 WRX  state
#debug_left usint state
#srcline 221 ;        END_IF;
ModbusTCPmas_L43:
 JMP  ModbusTCPmas_L12
ModbusTCPmas_L42:
 LD   4
 LDY  P1__st__
 EQ  
 JMC  ModbusTCPmas_L45
#srcline 223 ;      //---------------------------------------------
#srcline 224 ;      MdbTCP_estabCon :
#srcline 225 ;        EstabTCPconnection( chanCode);                   // establish connection
 NXT
 LDX  chanCode
#debug uint chanCode
 WR   __Instance__EstabTCPconnection~chanCode
#debug_left uint __Instance__EstabTCPconnection~chanCode
 PRV
 LEA  __Instance__EstabTCPconnection
 CAL  EstabTCPconnection_L0
#srcline 226 ;        state := MdbTCP_sendData;
 LD   udint 5  ; ModbusRTUlib_TStatesMdbTCP#MdbTCP_sendData
 WRX  state
#debug_left usint state
 JMP  ModbusTCPmas_L12
ModbusTCPmas_L45:
 LD   5
 LDY  P1__st__
 EQ  
 JMC  ModbusTCPmas_L46
#srcline 228 ;      //---------------------------------------------
#srcline 229 ;      MdbTCP_sendData :
#srcline 230 ;        IF isEstab THEN            // if connection established
 LDX  isEstab
#debug bool isEstab
 JMC  ModbusTCPmas_L47
#srcline 231 ;          modbusRTU.Start := TRUE;                         // send message
 LD   bool -1       ; true
 WRX  modbusRTU~Start
#debug_left bool modbusRTU.Start
#srcline 232 ;          state := MdbTCP_recData;
 LD   udint 6  ; ModbusRTUlib_TStatesMdbTCP#MdbTCP_recData
 WRX  state
#debug_left usint state
#srcline 233 ;        END_IF;
ModbusTCPmas_L47:
 JMP  ModbusTCPmas_L12
ModbusTCPmas_L46:
 LD   6
 LDY  P1__st__
 EQ  
 JMC  ModbusTCPmas_L49
#srcline 235 ;      //---------------------------------------------
#srcline 236 ;      MdbTCP_recData :
#srcline 237 ;        modbusRTU.Start := FALSE;
 LD   bool 0       ; false
 WRX  modbusRTU~Start
#debug_left bool modbusRTU.Start
#srcline 238 ;        IF modbusRTU.Done THEN                             // wait for answer
 LDX  modbusRTU~Done
#debug bool modbusRTU.Done
 JMC  ModbusTCPmas_L50
#srcline 239 ;          ErrCode := modbusRTU.ErrCode;
 LDX  modbusRTU~ErrCode
#debug usint modbusRTU.ErrCode
 WRX  ErrCode
#debug_left usint ErrCode
#srcline 240 ;          IF ErrCode = 0 OR (ErrCode > 136 & ErrCode < 143) THEN
 LDX  ErrCode
#debug usint ErrCode
 LD   usint 0
 EQ
 LDX  ErrCode
#debug usint ErrCode
 LD   usint 136
 GT
 LDX  ErrCode
#debug usint ErrCode
 LD   usint 143
 LT
 AND
 OR  
 JMC  ModbusTCPmas_L52
#srcline 241 ;            state := MdbTCP_start; Done := TRUE;
 LD   udint 1  ; ModbusRTUlib_TStatesMdbTCP#MdbTCP_start
 WRX  state
#debug_left usint state
 LD   bool -1       ; true
 WRX  Done
#debug_left bool Done
#srcline 242 ;          ELSE
 JMP  ModbusTCPmas_L53
ModbusTCPmas_L52:
#srcline 243 ;            state := MdbTCP_error;
 LD   udint 7  ; ModbusRTUlib_TStatesMdbTCP#MdbTCP_error
 WRX  state
#debug_left usint state
#srcline 244 ;          END_IF;
ModbusTCPmas_L53:
#srcline 245 ;        END_IF;
ModbusTCPmas_L50:
 JMP  ModbusTCPmas_L12
ModbusTCPmas_L49:
 LD   7
 LDY  P1__st__
 EQ  
 JMC  ModbusTCPmas_L54
#srcline 247 ;      //---------------------------------------------
#srcline 248 ;      MdbTCP_error :
#srcline 249 ;        CloseTCPconnection( chanCode);                     // then we must close it
 NXT
 LDX  chanCode
#debug uint chanCode
 WR   __Instance__CloseTCPconnection~chanCode
#debug_left uint __Instance__CloseTCPconnection~chanCode
 PRV
 LEA  __Instance__CloseTCPconnection
 CAL  CloseTCPconnection_L0
#srcline 250 ;        IF NOT isEstab THEN        // if connection closed
 LDX  isEstab
#debug bool isEstab
 NEG
 JMC  ModbusTCPmas_L55
#srcline 251 ;Done := TRUE;  //!!!
 LD   bool -1       ; true
 WRX  Done
#debug_left bool Done
#srcline 252 ;          State := MdbTCP_start;                           // another slave device
 LD   udint 1  ; ModbusRTUlib_TStatesMdbTCP#MdbTCP_start
 WRX  State
#debug_left usint State
#srcline 253 ;        END_IF;
ModbusTCPmas_L55:
 JMP  ModbusTCPmas_L12
ModbusTCPmas_L54:
#srcline 255 ;    ELSE
#srcline 256 ;      state := MdbTCP_start;
 LD   udint 1  ; ModbusRTUlib_TStatesMdbTCP#MdbTCP_start
 WRX  state
#debug_left usint state
#srcline 257 ;    END_CASE;
ModbusTCPmas_L12:
#srcline 258 ;  END_IF;
ModbusTCPmas_L6:
#srcline 260 ;//  GetRemoteIPaddress( chanCode, curEthAdr);
#srcline 261 ;  modbusRTU( EN := EN,  GrSel := 0(*manualne*), CmdNo := 1(*index v localCmd*), //Start := (*BOOL R_EDGE*),
 LDX  EN
#debug bool EN
 WRX  modbusRTU~EN
#debug_left bool modbusRTU~EN
 LD   usint 0
 WRX  modbusRTU~GrSel
#debug_left usint modbusRTU~GrSel
 LD   sint 1
 WRX  modbusRTU~CmdNo
#debug_left sint modbusRTU~CmdNo
#srcline 262 ;             MaxCmd := 1, chanCode := chanCode, Endian := Endian, MBtimeOut := MBtimeOut, Commands := localCmd);
 LD   sint 1
 WRX  modbusRTU~MaxCmd
#debug_left sint modbusRTU~MaxCmd
 LDX  chanCode
#debug uint chanCode
 WRX  modbusRTU~chanCode
#debug_left uint modbusRTU~chanCode
 LDX  Endian
#debug bool Endian
 WRX  modbusRTU~Endian
#debug_left bool modbusRTU~Endian
 LDX  MBtimeOut
#debug time MBtimeOut
 WRX  modbusRTU~MBtimeOut
#debug_left time modbusRTU~MBtimeOut
 LEAX localCmd
 WRX  modbusRTU~Commands
#debug_left pointer modbusRTU.Commands
 LEAX modbusRTU
 CAL  ModbusRTUmas_L0
#srcline 263 ;END_FUNCTION_BLOCK
 ULNK
RET
E     61

; Initialize - variables
P     61
ModbusTCPmas__InstanceInit__:
 LINK 0
 LD   time 2000
 WRX  MBtimeOut
 LD   0
 SRC  byte __Init___ModbusTCPmas_modbusRTU
 LEAX byte modbusRTU
 LD   614
 MOV  %X0
 ULNK
RET
E     61
; End initialize - variables
#endpou 



 

#srcfile ''
#srcfile 'C:\TECOLIBSRC\MODBUSRTU\MODBUSRTU\FBMODBUSRTUMAS2.ST'
#pou fbModbusRTUmas2
#srcline 1 ;FUNCTION_BLOCK fbModbusRTUmas2

#struct fbModbusRTUmas2__temp__
  pointer ptr,  ; {ENU} Structure for control of Modbus RTU master FB Struktura pro øízení funkèního bloku Modbus RTU master
  uint pomUINT,
  bool CmdFind,  ; GrSel find
  bool notRepeat,
  usint tempCmd,
  pointer sptr,  ; substitute of pointer
  uint i,
  uint k,  ; offset in DataBuffers for: 0..Eth., 6..Serial channels
  uint ByteCount,
  pointer pdata,
  uint NoPoints,
  pointer BOptr,
  pointer pBOptr,
  pointer BYptr,
  pointer pBYptr,
  usint P0__st__,
  usint P1__st__,
  udint P2__st__,
  uint P3__st__,
  uint P4__st__,
  uint P5__st__,
  udint P6__st__,
  uint P7__st__,
  uint P8__st__
P     61
fbModbusRTUmas2_L0:
 LINK __SizeOf(fbModbusRTUmas2__temp__)
; Initialize - dynamic variables
 LD   udint $FFFFFFFF    ; nil
 WRY  ptr
 LD   udint $FFFFFFFF    ; nil
 WRY  sptr
 LD   uint 6
 WRY  k
 LD   udint $FFFFFFFF    ; nil
 WRY  pdata
 LD   udint $FFFFFFFF    ; nil
 WRY  BOptr
 LD   udint $FFFFFFFF    ; nil
 WRY  pBOptr
 LD   udint $FFFFFFFF    ; nil
 WRY  BYptr
 LD   udint $FFFFFFFF    ; nil
 WRY  pBYptr
; End initialize - dynamic variables
; R_EDGE, F_EDGE 
 LDX  Start
 LETX __EDGE_R__Start
 WRX  Start
#srcline 92 ;  IF not EN THEN
 LDX  EN
#debug bool EN
 NEG
 JMC  fbModbusRTUmas2_L1
#srcline 93 ;    InitMB_Done := false;
 LD   bool 0       ; false
 WRX  InitMB_Done
#debug_left bool InitMB_Done
#srcline 94 ;    LastCmd := 0; autoCmd := 0; ErrCode := 0;           // clear error code
 LD   usint 0
 WRX  LastCmd
#debug_left usint LastCmd
 LD   usint 0
 WRX  autoCmd
#debug_left usint autoCmd
 LD   usint 0
 WRX  ErrCode
#debug_left usint ErrCode
#srcline 95 ;    wasStart := 0;
 LD   bool 0       ; false
 WRX  wasStart
#debug_left bool wasStart
#srcline 96 ;    Done := false;
 LD   bool 0       ; false
 WRX  Done
#debug_left bool Done
#srcline 97 ;    StateMB := StartMB;
 LD   udint 0  ; ModbusRTUlib_TStateMB#StartMB
 WRX  StateMB
#debug_left usint StateMB
#srcline 98 ;  ELSE
 JMP  fbModbusRTUmas2_L2
fbModbusRTUmas2_L1:
#srcline 99 ;    notRepeat := true;
 LD   bool -1       ; true
 WRY  notRepeat
#debug_left bool notRepeat
#srcline 100 ;    REPEAT
fbModbusRTUmas2_L3:
 DBG
#srcline 101 ;      //IF UINT_TO_WORD(chanCode) and 16#00F0 = 16#00E0 THEN k :=0; ELSE k :=6; END_IF;  // TCP
#srcline 102 ;      IF isTcp THEN k :=0; ELSE k :=6; END_IF;  // TCP
 LDX  isTcp
#debug bool isTcp
 JMC  fbModbusRTUmas2_L5
 LD   uint 0
 WRY  k
#debug_left uint k
 JMP  fbModbusRTUmas2_L6
fbModbusRTUmas2_L5:
 LD   uint 6
 WRY  k
#debug_left uint k
fbModbusRTUmas2_L6:
#srcline 103 ;      IF StateMB = StartMB THEN
 LDX  StateMB
#debug usint StateMB
 LD   udint 0  ; ModbusRTUlib_TStateMB#StartMB
 EQ
 JMC  fbModbusRTUmas2_L7
#srcline 104 ;        Done := false;
 LD   bool 0       ; false
 WRX  Done
#debug_left bool Done
#srcline 105 ;        ErrCode := 0; //!!!
 LD   usint 0
 WRX  ErrCode
#debug_left usint ErrCode
#srcline 106 ;        IF GrSel=0 THEN                               // manual
 LDX  GrSel
#debug usint GrSel
 LD   usint 0
 EQ
 JMC  fbModbusRTUmas2_L9
#srcline 107 ;          IF Start or wasStart THEN
 LDX  Start
#debug bool Start
 LDX  wasStart
#debug bool wasStart
 OR  
 JMC  fbModbusRTUmas2_L11
#srcline 108 ;            LastCmd := CmdNo;
 LDX  CmdNo
#debug usint CmdNo
 WRX  LastCmd
#debug_left usint LastCmd
#srcline 109 ;            IF CmdNo > 0 and CmdNo <= MaxCmd THEN StateMB := SndMB; END_IF;
 LDX  CmdNo
#debug usint CmdNo
 LD   usint 0
 GT
 LDX  CmdNo
#debug usint CmdNo
 LDX  MaxCmd
#debug usint MaxCmd
 GT
 NEG
 AND
 JMC  fbModbusRTUmas2_L13
 LD   udint 1  ; ModbusRTUlib_TStateMB#SndMB
 WRX  StateMB
#debug_left usint StateMB
fbModbusRTUmas2_L13:
#srcline 110 ;          END_IF;
fbModbusRTUmas2_L11:
#srcline 111 ;        ELSE                                          // auto
 JMP  fbModbusRTUmas2_L10
fbModbusRTUmas2_L9:
#srcline 112 ;          StateMB := SndMB;
 LD   udint 1  ; ModbusRTUlib_TStateMB#SndMB
 WRX  StateMB
#debug_left usint StateMB
#srcline 113 ;          CmdFind :=false;
 LD   bool 0       ; false
 WRY  CmdFind
#debug_left bool CmdFind
#srcline 114 ;          autoCmd := autoCmd + 1;
 LDX  autoCmd
#debug usint autoCmd
 LD   usint 1
 ADD
 AND  $FF
 WRX  autoCmd
#debug_left usint autoCmd
#srcline 115 ;          FOR tempCmd := autoCmd TO MaxCmd DO
 LDX  autoCmd
#debug usint autoCmd
 WRY  tempCmd
 LDX  MaxCmd
#debug usint MaxCmd
 WRY  P0__st__
fbModbusRTUmas2_L15:
 LDY  tempCmd
 LDY  P0__st__
 GT   
 JMD  fbModbusRTUmas2_L16
 DBG  
#srcline 116 ;            ptr := ADR(Commands) + USINT_TO_UDINT(tempCmd-1) * sizeof(TCmdStruct);
 LDX  Commands
#debug pointer Commands
 LDY  tempCmd
#debug usint tempCmd
 LD   usint 1
 SUB
 AND  $FF
 LD   11  ; SizeOf()
 MUL
 ADD
 LEAY ptr
 WRIL 
#debug_left pointer ptr
#srcline 117 ;            IF (((ptr^.Gr = GrSel) or (ptr^.Gr = 1)) and InitMB_Done) or
 LEAY ptr
 LDIL    ; dereference 
 LDI  
#debug usint ptr^.Gr
 LDX  GrSel
#debug usint GrSel
 EQ
 LEAY ptr
 LDIL    ; dereference 
 LDI  
#debug usint ptr^.Gr
 LD   usint 1
 EQ
 OR  
 LDX  InitMB_Done
#debug bool InitMB_Done
 AND
#srcline 118 ;                ((ptr^.Gr = 255)  and not InitMB_Done) THEN
 LEAY ptr
 LDIL    ; dereference 
 LDI  
#debug usint ptr^.Gr
 LD   usint 255
 EQ
 LDX  InitMB_Done
#debug bool InitMB_Done
 NEG
 AND
 OR  
 JMC  fbModbusRTUmas2_L17
#srcline 119 ;              autoCmd :=tempCmd;
 LDY  tempCmd
#debug usint tempCmd
 WRX  autoCmd
#debug_left usint autoCmd
#srcline 120 ;              notRepeat := true;
 LD   bool -1       ; true
 WRY  notRepeat
#debug_left bool notRepeat
#srcline 121 ;              CmdFind :=true;
 LD   bool -1       ; true
 WRY  CmdFind
#debug_left bool CmdFind
#srcline 122 ;              EXIT;
 JMP  fbModbusRTUmas2_L16
#srcline 123 ;            END_IF;
fbModbusRTUmas2_L17:
#srcline 124 ;  //!!!            IF (ptr^.Gr = 0) THEN EXIT; END_IF; // any record
#srcline 125 ;          END_FOR;
 LDY  tempCmd
 LD   1
 ADD  
 WRY  tempCmd
 JMP  fbModbusRTUmas2_L15
fbModbusRTUmas2_L16:
 NOP  -1
#srcline 126 ;          IF not CmdFind THEN
 LDY  CmdFind
#debug bool CmdFind
 NEG
 JMC  fbModbusRTUmas2_L19
#srcline 127 ;            IF not InitMB_Done THEN
 LDX  InitMB_Done
#debug bool InitMB_Done
 NEG
 JMC  fbModbusRTUmas2_L21
#srcline 128 ;              InitMB_Done := true;
 LD   bool -1       ; true
 WRX  InitMB_Done
#debug_left bool InitMB_Done
#srcline 129 ;            END_IF;
fbModbusRTUmas2_L21:
#srcline 130 ;            autoCmd :=0;
 LD   usint 0
 WRX  autoCmd
#debug_left usint autoCmd
#srcline 131 ;            StateMB := StartMB;
 LD   udint 0  ; ModbusRTUlib_TStateMB#StartMB
 WRX  StateMB
#debug_left usint StateMB
#srcline 132 ;            notRepeat := NOT notRepeat; //pokud se nenaslo zkusit jeste jednou
 LDY  notRepeat
#debug bool notRepeat
 NEG
 WRY  notRepeat
#debug_left bool notRepeat
#srcline 133 ;          END_IF;
fbModbusRTUmas2_L19:
#srcline 134 ;          lastCmd := autoCmd;
 LDX  autoCmd
#debug usint autoCmd
 WRX  lastCmd
#debug_left usint lastCmd
#srcline 135 ;        END_IF;
fbModbusRTUmas2_L10:
#srcline 136 ;        wasStart := false;
 LD   bool 0       ; false
 WRX  wasStart
#debug_left bool wasStart
#srcline 137 ;      END_IF;
fbModbusRTUmas2_L7:
#srcline 138 ;    UNTIL notRepeat
#srcline 139 ;    END_REPEAT;
 LDY  notRepeat
#debug bool notRepeat
 JMC  fbModbusRTUmas2_L3
fbModbusRTUmas2_L4:
 NOP  -1
#srcline 140 ;    
#srcline 141 ;    CASE StateMB OF
 LDX  StateMB
#debug usint StateMB
 WRY  P1__st__
 LD   1
 LDY  P1__st__
 EQ  
 JMC  fbModbusRTUmas2_L24
#srcline 142 ;      //------------------------------------------------------------------------
#srcline 143 ;      SndMB     : // Send Message
#srcline 144 ;        SendTo.rq := true;
 LD   bool -1       ; true
 WRX  SendTo~rq
#debug_left bool SendTo.rq
#srcline 145 ;        StateMB := SndMBt;
 LD   udint 2  ; ModbusRTUlib_TStateMB#SndMBt
 WRX  StateMB
#debug_left usint StateMB
#srcline 146 ;        ptr := ADR(Commands) + USINT_TO_UDINT(LastCmd-1) * sizeof(TCmdStruct);
 LDX  Commands
#debug pointer Commands
 LDX  LastCmd
#debug usint LastCmd
 LD   usint 1
 SUB
 AND  $FF
 LD   11  ; SizeOf()
 MUL
 ADD
 LEAY ptr
 WRIL 
#debug_left pointer ptr
#srcline 148 ;        IF ptr^.PtrData = 16#FFFF_FFFF THEN
 LEAY ptr
 LDIL    ; dereference 
 ADD  7  ; + offset 
 LDIL 
#debug udint ptr^.PtrData
 LD   udint $FFFFFFFF
 EQ
 JMC  fbModbusRTUmas2_L25
#srcline 149 ;          ErrCode := 23 + 128;               // Invalid pointer
 LD   usint 23
 LD   usint 128
 ADD
 AND  $FF
 WRX  ErrCode
#debug_left usint ErrCode
#srcline 150 ;          SendTo.rq := false;
 LD   bool 0       ; false
 WRX  SendTo~rq
#debug_left bool SendTo.rq
#srcline 151 ;          StateMB := ErrMB;
 LD   udint 5  ; ModbusRTUlib_TStateMB#ErrMB
 WRX  StateMB
#debug_left usint StateMB
#srcline 152 ;        ELSE
 JMP  fbModbusRTUmas2_L26
fbModbusRTUmas2_L25:
#srcline 153 ;          DataT[6] := ptr^.SNo;               // slave adress
 LEAY ptr
 LDIL    ; dereference 
 ADD  1  ; + offset 
 LDI  
#debug usint ptr^.SNo
 WRX  DataT[6]
#debug_left usint DataT[6]
#srcline 154 ;          DataT[7] := ptr^.FNC;                    // command code Modbus 01,02,03,04,05,06,15,16,17,22
 LEAY ptr
 LDIL    ; dereference 
 ADD  2  ; + offset 
 LDI  
#debug usint ptr^.FNC
 WRX  DataT[7]
#debug_left usint DataT[7]
#srcline 155 ;          CASE (ptr^.FNC) OF
 LEAY ptr
 LDIL    ; dereference 
 ADD  2  ; + offset 
 LDI  
#debug usint ptr^.FNC
 WRY  P2__st__
 LDY  P2__st__
 LD   2
 GT  
 JMD fbModbusRTUmas2_L28
 LDY  P2__st__
 LD   1
 LT  
 JMD fbModbusRTUmas2_L28
#srcline 156 ;            1..2 :   // 01 Read Coils
#srcline 157 ;                     // 02 Read Discrete Inputs
#srcline 158 ;              NoPoints:= LIMIT(MN :=1,IN := ptr^.NoPoint,MX :=2000);
 LEAY ptr
 LDIL    ; dereference 
 ADD  5  ; + offset 
 LDIW 
#debug uint ptr^.NoPoint
 LD   uint 1
 MAX
 LD   uint 2000
 MIN
 WRY  NoPoints
#debug_left uint NoPoints
#srcline 159 ;              DataT[8] := WORD_TO_USINT(SHR(UINT_TO_WORD(ptr^.StAdr),8));//Hi
 LEAY ptr
 LDIL    ; dereference 
 ADD  3  ; + offset 
 LDIW 
#debug uint ptr^.StAdr
 LD   uint 8
 SHR
 AND  $FFFF
 AND  $FF
 WRX  DataT[8]
#debug_left usint DataT[8]
#srcline 160 ;              DataT[9] := UINT_TO_USINT(ptr^.StAdr);// Lo adresa reg ve slave
 LEAY ptr
 LDIL    ; dereference 
 ADD  3  ; + offset 
 LDIW 
#debug uint ptr^.StAdr
 AND  $FF
 WRX  DataT[9]
#debug_left usint DataT[9]
#srcline 161 ;              DataT[10] := WORD_TO_USINT(SHR(UINT_TO_WORD(NoPoints),8));//Hi
 LDY  NoPoints
#debug uint NoPoints
 LD   uint 8
 SHR
 AND  $FFFF
 AND  $FF
 WRX  DataT[10]
#debug_left usint DataT[10]
#srcline 162 ;              DataT[11] := UINT_TO_USINT(NoPoints);// Lo len reg ve slave
 LDY  NoPoints
#debug uint NoPoints
 AND  $FF
 WRX  DataT[11]
#debug_left usint DataT[11]
#srcline 163 ;              i := 12;
 LD   uint 12
 WRY  i
#debug_left uint i
#srcline 164 ;            ;
 JMP  fbModbusRTUmas2_L27
fbModbusRTUmas2_L28:
 LDY  P2__st__
 LD   4
 GT  
 JMD fbModbusRTUmas2_L29
 LDY  P2__st__
 LD   3
 LT  
 JMD fbModbusRTUmas2_L29
#srcline 165 ;            3..4 : // 03 Read Holding Registers
#srcline 166 ;                   // 04 Read Input Registers
#srcline 167 ;              NoPoints:= LIMIT(MN :=1,IN := ptr^.NoPoint,MX :=125);
 LEAY ptr
 LDIL    ; dereference 
 ADD  5  ; + offset 
 LDIW 
#debug uint ptr^.NoPoint
 LD   uint 1
 MAX
 LD   uint 125
 MIN
 WRY  NoPoints
#debug_left uint NoPoints
#srcline 168 ;              DataT[8] := WORD_TO_USINT(SHR(UINT_TO_WORD(ptr^.StAdr),8));//Hi
 LEAY ptr
 LDIL    ; dereference 
 ADD  3  ; + offset 
 LDIW 
#debug uint ptr^.StAdr
 LD   uint 8
 SHR
 AND  $FFFF
 AND  $FF
 WRX  DataT[8]
#debug_left usint DataT[8]
#srcline 169 ;              DataT[9] := UINT_TO_USINT(ptr^.StAdr);// Lo adresa reg ve slave
 LEAY ptr
 LDIL    ; dereference 
 ADD  3  ; + offset 
 LDIW 
#debug uint ptr^.StAdr
 AND  $FF
 WRX  DataT[9]
#debug_left usint DataT[9]
#srcline 170 ;              DataT[10] := WORD_TO_USINT(SHR(UINT_TO_WORD(NoPoints),8));//Hi
 LDY  NoPoints
#debug uint NoPoints
 LD   uint 8
 SHR
 AND  $FFFF
 AND  $FF
 WRX  DataT[10]
#debug_left usint DataT[10]
#srcline 171 ;              DataT[11] := UINT_TO_USINT(NoPoints);// Lo len reg ve slave
 LDY  NoPoints
#debug uint NoPoints
 AND  $FF
 WRX  DataT[11]
#debug_left usint DataT[11]
#srcline 172 ;              i := 12;
 LD   uint 12
 WRY  i
#debug_left uint i
#srcline 173 ;            ;
 JMP  fbModbusRTUmas2_L27
fbModbusRTUmas2_L29:
 LD   5
 LDY  P2__st__
 EQ  
 JMC  fbModbusRTUmas2_L30
#srcline 174 ;            5 :    // 05 Write Single Coil
#srcline 175 ;              DataT[8] := WORD_TO_USINT(SHR(UINT_TO_WORD(ptr^.StAdr),8));// Hi
 LEAY ptr
 LDIL    ; dereference 
 ADD  3  ; + offset 
 LDIW 
#debug uint ptr^.StAdr
 LD   uint 8
 SHR
 AND  $FFFF
 AND  $FF
 WRX  DataT[8]
#debug_left usint DataT[8]
#srcline 176 ;              DataT[9] := UINT_TO_USINT(ptr^.StAdr);           // Lo adresa reg ve slave
 LEAY ptr
 LDIL    ; dereference 
 ADD  3  ; + offset 
 LDIW 
#debug uint ptr^.StAdr
 AND  $FF
 WRX  DataT[9]
#debug_left usint DataT[9]
#srcline 177 ;              //sptr:= UDINT_TO_PTR(ptr^.PtrData);          // substitute of pointer
#srcline 179 ;              //BOptr   := sptr;
#srcline 180 ;              BOptr   := UDINT_TO_PTR(ptr^.PtrData);
 LEAY ptr
 LDIL    ; dereference 
 ADD  7  ; + offset 
 LDIL 
#debug udint ptr^.PtrData
; UDINT -> PTR
 LEAY BOptr
 WRIL 
#debug_left pointer BOptr
#srcline 181 ;              IF BOptr^ THEN               // test of BOOL
 LEAY BOptr
 LDIL    ; dereference 
 LDIB 
#debug bool BOptr^
 JMC  fbModbusRTUmas2_L31
#srcline 182 ;                DataT[10] := 16#FF;          // true  Hi
 LD   usint $FF
 WRX  DataT[10]
#debug_left usint DataT[10]
#srcline 183 ;              ELSE
 JMP  fbModbusRTUmas2_L32
fbModbusRTUmas2_L31:
#srcline 184 ;                DataT[10] := 0;              // false Hi
 LD   usint 0
 WRX  DataT[10]
#debug_left usint DataT[10]
#srcline 185 ;              END_IF;
fbModbusRTUmas2_L32:
#srcline 186 ;              DataT[11] := 0;                // Lo
 LD   usint 0
 WRX  DataT[11]
#debug_left usint DataT[11]
#srcline 187 ;              i := 12;
 LD   uint 12
 WRY  i
#debug_left uint i
#srcline 188 ;            ;
 JMP  fbModbusRTUmas2_L27
fbModbusRTUmas2_L30:
 LD   6
 LDY  P2__st__
 EQ  
 JMC  fbModbusRTUmas2_L33
#srcline 189 ;            6 :    // 06 Write Single Register
#srcline 190 ;              DataT[8] := WORD_TO_USINT(SHR(UINT_TO_WORD(ptr^.StAdr),8)); //Hi
 LEAY ptr
 LDIL    ; dereference 
 ADD  3  ; + offset 
 LDIW 
#debug uint ptr^.StAdr
 LD   uint 8
 SHR
 AND  $FFFF
 AND  $FF
 WRX  DataT[8]
#debug_left usint DataT[8]
#srcline 191 ;              DataT[9] := UINT_TO_USINT(ptr^.StAdr);                      // Lo adresa reg ve slave
 LEAY ptr
 LDIL    ; dereference 
 ADD  3  ; + offset 
 LDIW 
#debug uint ptr^.StAdr
 AND  $FF
 WRX  DataT[9]
#debug_left usint DataT[9]
#srcline 192 ;              pdata := UDINT_TO_PTR(ptr^.PtrData);
 LEAY ptr
 LDIL    ; dereference 
 ADD  7  ; + offset 
 LDIL 
#debug udint ptr^.PtrData
; UDINT -> PTR
 LEAY pdata
 WRIL 
#debug_left pointer pdata
#srcline 193 ;              DataT[10] := WORD_TO_USINT(SHR(UINT_TO_WORD(pdata^),8));// Hi
 LEAY pdata
 LDIL    ; dereference 
 LDIW 
#debug uint pdata^
 LD   uint 8
 SHR
 AND  $FFFF
 AND  $FF
 WRX  DataT[10]
#debug_left usint DataT[10]
#srcline 194 ;              DataT[11] := UINT_TO_USINT(pdata^);                     // Lo data reg ve slave
 LEAY pdata
 LDIL    ; dereference 
 LDIW 
#debug uint pdata^
 AND  $FF
 WRX  DataT[11]
#debug_left usint DataT[11]
#srcline 195 ;              i := 12;
 LD   uint 12
 WRY  i
#debug_left uint i
#srcline 196 ;            ;
 JMP  fbModbusRTUmas2_L27
fbModbusRTUmas2_L33:
 LD   7
 LDY  P2__st__
 EQ  
 JMC  fbModbusRTUmas2_L34
#srcline 197 ;            7 :    // 07 Read Exception Status
#srcline 198 ;              i := 8;
 LD   uint 8
 WRY  i
#debug_left uint i
#srcline 199 ;            ;
 JMP  fbModbusRTUmas2_L27
fbModbusRTUmas2_L34:
 LD   8
 LDY  P2__st__
 EQ  
 JMC  fbModbusRTUmas2_L35
#srcline 200 ;            8 :    // 08 Diagnostic
#srcline 201 ;              DataT[8] := WORD_TO_USINT(SHR(UINT_TO_WORD(ptr^.StAdr),8)); //Hi
 LEAY ptr
 LDIL    ; dereference 
 ADD  3  ; + offset 
 LDIW 
#debug uint ptr^.StAdr
 LD   uint 8
 SHR
 AND  $FFFF
 AND  $FF
 WRX  DataT[8]
#debug_left usint DataT[8]
#srcline 202 ;              DataT[9] := UINT_TO_USINT(ptr^.StAdr);                      // Lo Sub-function code do slave
 LEAY ptr
 LDIL    ; dereference 
 ADD  3  ; + offset 
 LDIW 
#debug uint ptr^.StAdr
 AND  $FF
 WRX  DataT[9]
#debug_left usint DataT[9]
#srcline 203 ;              pdata := UDINT_TO_PTR(ptr^.PtrData);
 LEAY ptr
 LDIL    ; dereference 
 ADD  7  ; + offset 
 LDIL 
#debug udint ptr^.PtrData
; UDINT -> PTR
 LEAY pdata
 WRIL 
#debug_left pointer pdata
#srcline 204 ;              DataT[10] := WORD_TO_USINT(SHR(UINT_TO_WORD(pdata^),8));// Hi
 LEAY pdata
 LDIL    ; dereference 
 LDIW 
#debug uint pdata^
 LD   uint 8
 SHR
 AND  $FFFF
 AND  $FF
 WRX  DataT[10]
#debug_left usint DataT[10]
#srcline 205 ;              DataT[11] := UINT_TO_USINT(pdata^);                     // Lo data field do slave
 LEAY pdata
 LDIL    ; dereference 
 LDIW 
#debug uint pdata^
 AND  $FF
 WRX  DataT[11]
#debug_left usint DataT[11]
#srcline 206 ;              i := 12;
 LD   uint 12
 WRY  i
#debug_left uint i
#srcline 207 ;            ;
 JMP  fbModbusRTUmas2_L27
fbModbusRTUmas2_L35:
 LD   15
 LDY  P2__st__
 EQ  
 JMC  fbModbusRTUmas2_L36
#srcline 208 ;            15 :   // 15 Write Multiple Coils
#srcline 209 ;              NoPoints  := LIMIT(MN :=1,IN := ptr^.NoPoint,MX :=1968);
 LEAY ptr
 LDIL    ; dereference 
 ADD  5  ; + offset 
 LDIW 
#debug uint ptr^.NoPoint
 LD   uint 1
 MAX
 LD   uint 1968
 MIN
 WRY  NoPoints
#debug_left uint NoPoints
#srcline 210 ;              DataT[8]  := WORD_TO_USINT(SHR(UINT_TO_WORD(ptr^.StAdr),8));//Hi
 LEAY ptr
 LDIL    ; dereference 
 ADD  3  ; + offset 
 LDIW 
#debug uint ptr^.StAdr
 LD   uint 8
 SHR
 AND  $FFFF
 AND  $FF
 WRX  DataT[8]
#debug_left usint DataT[8]
#srcline 211 ;              DataT[9]  := UINT_TO_USINT(ptr^.StAdr);     // Lo adresa reg ve slave
 LEAY ptr
 LDIL    ; dereference 
 ADD  3  ; + offset 
 LDIW 
#debug uint ptr^.StAdr
 AND  $FF
 WRX  DataT[9]
#debug_left usint DataT[9]
#srcline 212 ;              DataT[10]  := WORD_TO_USINT(SHR(UINT_TO_WORD(NoPoints),8));//Hi
 LDY  NoPoints
#debug uint NoPoints
 LD   uint 8
 SHR
 AND  $FFFF
 AND  $FF
 WRX  DataT[10]
#debug_left usint DataT[10]
#srcline 213 ;              DataT[11]  := UINT_TO_USINT(NoPoints);   // Lo len reg ve slave
 LDY  NoPoints
#debug uint NoPoints
 AND  $FF
 WRX  DataT[11]
#debug_left usint DataT[11]
#srcline 214 ;              ByteCount:= NoPoints / 8 ;
 LDY  NoPoints
#debug uint NoPoints
 LD   uint 8
 DIVL
 AND  $FFFF
 WRY  ByteCount
#debug_left uint ByteCount
#srcline 215 ;              IF MOD(NoPoints,8) <> 0 then ByteCount := ByteCount + 1; END_IF;
 LDY  NoPoints
#debug uint NoPoints
 LD   uint 8
 MOD
 AND  $FFFF
 LD   uint 0
 EQ
 NEG
 JMC  fbModbusRTUmas2_L37
 LDY  ByteCount
#debug uint ByteCount
 LD   uint 1
 ADD
 AND  $FFFF
 WRY  ByteCount
#debug_left uint ByteCount
fbModbusRTUmas2_L37:
#srcline 216 ;              DataT[12]  := UINT_TO_USINT(ByteCount); // ByteCount
 LDY  ByteCount
#debug uint ByteCount
 AND  $FF
 WRX  DataT[12]
#debug_left usint DataT[12]
#srcline 217 ;              //sptr:= UDINT_TO_PTR(ptr^.PtrData);          // substitute of pointer
#srcline 218 ;              //BOptr    := sptr;                     // source
#srcline 219 ;              BOptr    := UDINT_TO_PTR(ptr^.PtrData); // source
 LEAY ptr
 LDIL    ; dereference 
 ADD  7  ; + offset 
 LDIL 
#debug udint ptr^.PtrData
; UDINT -> PTR
 LEAY BOptr
 WRIL 
#debug_left pointer BOptr
#srcline 220 ;              pBOptr   := ADR(DataT[13]) * 8;         // destination
 LEAX DataT
 ADD  13  ; + offset 
#debug pointer DataT[13]
 LD   udint 8
 MUL
 LEAY pBOptr
 WRIL 
#debug_left pointer pBOptr
#srcline 221 ;              FOR i := 0 TO NoPoints DO              // Bit stream
 LD   uint 0
 WRY  i
 LDY  NoPoints
#debug uint NoPoints
 WRY  P3__st__
fbModbusRTUmas2_L39:
 LDY  i
 LDY  P3__st__
 GT   
 JMD  fbModbusRTUmas2_L40
 DBG  
#srcline 222 ;                pBOptr^:= BOptr^; BOptr := BOptr+1; pBOptr := pBOptr+1;
 LEAY BOptr
 LDIL    ; dereference 
 LDIB 
#debug bool BOptr^
 LEAY pBOptr
 LDIL    ; dereference 
 WRIB 
#debug_left bool pBOptr^
 LEAY BOptr
 LDIL 
#debug pointer BOptr
 LD   udint 1
 ADD
 LEAY BOptr
 WRIL 
#debug_left pointer BOptr
 LEAY pBOptr
 LDIL 
#debug pointer pBOptr
 LD   udint 1
 ADD
 LEAY pBOptr
 WRIL 
#debug_left pointer pBOptr
#srcline 223 ;              END_FOR;
 LDY  i
 LD   1
 ADD  
 WRY  i
 JMP  fbModbusRTUmas2_L39
fbModbusRTUmas2_L40:
 NOP  -1
#srcline 224 ;              i        := 13 + ByteCount;  // +6
 LD   uint 13
 LDY  ByteCount
#debug uint ByteCount
 ADD
 AND  $FFFF
 WRY  i
#debug_left uint i
#srcline 225 ;            ;
 JMP  fbModbusRTUmas2_L27
fbModbusRTUmas2_L36:
 LD   16
 LDY  P2__st__
 EQ  
 JMC  fbModbusRTUmas2_L41
#srcline 226 ;            16 :   // 16 Write Multiple Registers
#srcline 227 ;              NoPoints  := LIMIT(MN :=1,IN := ptr^.NoPoint,MX :=123); //Byd rev.1.8
 LEAY ptr
 LDIL    ; dereference 
 ADD  5  ; + offset 
 LDIW 
#debug uint ptr^.NoPoint
 LD   uint 1
 MAX
 LD   uint 123
 MIN
 WRY  NoPoints
#debug_left uint NoPoints
#srcline 228 ;              DataT[8]  := WORD_TO_USINT(SHR(UINT_TO_WORD(ptr^.StAdr),8));//Hi
 LEAY ptr
 LDIL    ; dereference 
 ADD  3  ; + offset 
 LDIW 
#debug uint ptr^.StAdr
 LD   uint 8
 SHR
 AND  $FFFF
 AND  $FF
 WRX  DataT[8]
#debug_left usint DataT[8]
#srcline 229 ;              DataT[9]  := UINT_TO_USINT(ptr^.StAdr);     // Lo adresa reg ve slave
 LEAY ptr
 LDIL    ; dereference 
 ADD  3  ; + offset 
 LDIW 
#debug uint ptr^.StAdr
 AND  $FF
 WRX  DataT[9]
#debug_left usint DataT[9]
#srcline 230 ;              DataT[10]  := WORD_TO_USINT(SHR(UINT_TO_WORD(NoPoints),8));//Hi
 LDY  NoPoints
#debug uint NoPoints
 LD   uint 8
 SHR
 AND  $FFFF
 AND  $FF
 WRX  DataT[10]
#debug_left usint DataT[10]
#srcline 231 ;              DataT[11]  := UINT_TO_USINT(NoPoints);     // Lo len reg ve slave
 LDY  NoPoints
#debug uint NoPoints
 AND  $FF
 WRX  DataT[11]
#debug_left usint DataT[11]
#srcline 232 ;              ByteCount:= NoPoints * 2;
 LDY  NoPoints
#debug uint NoPoints
 LD   uint 2
 MUL
 AND  $FFFF
 WRY  ByteCount
#debug_left uint ByteCount
#srcline 233 ;              DataT[12]  := UINT_TO_USINT(ByteCount);    // ByteCount
 LDY  ByteCount
#debug uint ByteCount
 AND  $FF
 WRX  DataT[12]
#debug_left usint DataT[12]
#srcline 234 ;              BYptr:= UDINT_TO_PTR(ptr^.PtrData);         // source pointer
 LEAY ptr
 LDIL    ; dereference 
 ADD  7  ; + offset 
 LDIL 
#debug udint ptr^.PtrData
; UDINT -> PTR
 LEAY BYptr
 WRIL 
#debug_left pointer BYptr
#srcline 235 ;              pBYptr   := ADR(DataT[13]);                // destination pointer
 LEAX DataT
 ADD  13  ; + offset 
#debug pointer DataT[13]
 LEAY pBYptr
 WRIL 
#debug_left pointer pBYptr
#srcline 236 ;              FOR i := 0 TO NoPoints DO                 // Word stream big endian
 LD   uint 0
 WRY  i
 LDY  NoPoints
#debug uint NoPoints
 WRY  P4__st__
fbModbusRTUmas2_L42:
 LDY  i
 LDY  P4__st__
 GT   
 JMD  fbModbusRTUmas2_L43
 DBG  
#srcline 237 ;                IF Endian THEN                          // Little Endian
 LDX  Endian
#debug bool Endian
 JMC  fbModbusRTUmas2_L44
#srcline 238 ;                  pBYptr^:= BYptr^;                     // first byte to Lo
 LEAY BYptr
 LDIL    ; dereference 
 LDI  
#debug byte BYptr^
 LEAY pBYptr
 LDIL    ; dereference 
 WRI 
#debug_left byte pBYptr^
#srcline 239 ;                  pBYptr := pBYptr+1; BYptr := BYptr+1;
 LEAY pBYptr
 LDIL 
#debug pointer pBYptr
 LD   udint 1
 ADD
 LEAY pBYptr
 WRIL 
#debug_left pointer pBYptr
 LEAY BYptr
 LDIL 
#debug pointer BYptr
 LD   udint 1
 ADD
 LEAY BYptr
 WRIL 
#debug_left pointer BYptr
#srcline 240 ;                  pBYptr^:= BYptr^;                     // second byte to Hi
 LEAY BYptr
 LDIL    ; dereference 
 LDI  
#debug byte BYptr^
 LEAY pBYptr
 LDIL    ; dereference 
 WRI 
#debug_left byte pBYptr^
#srcline 241 ;                  pBYptr := pBYptr+1; BYptr := BYptr+1;
 LEAY pBYptr
 LDIL 
#debug pointer pBYptr
 LD   udint 1
 ADD
 LEAY pBYptr
 WRIL 
#debug_left pointer pBYptr
 LEAY BYptr
 LDIL 
#debug pointer BYptr
 LD   udint 1
 ADD
 LEAY BYptr
 WRIL 
#debug_left pointer BYptr
#srcline 242 ;                ELSE                                    // Big Endian
 JMP  fbModbusRTUmas2_L45
fbModbusRTUmas2_L44:
#srcline 243 ;                  pBYptr := pBYptr+1;
 LEAY pBYptr
 LDIL 
#debug pointer pBYptr
 LD   udint 1
 ADD
 LEAY pBYptr
 WRIL 
#debug_left pointer pBYptr
#srcline 244 ;                  pBYptr^:= BYptr^;                     // first byte to Hi
 LEAY BYptr
 LDIL    ; dereference 
 LDI  
#debug byte BYptr^
 LEAY pBYptr
 LDIL    ; dereference 
 WRI 
#debug_left byte pBYptr^
#srcline 245 ;                  pBYptr := pBYptr-1; BYptr := BYptr+1;
 LEAY pBYptr
 LDIL 
#debug pointer pBYptr
 LD   udint 1
 SUB
 LEAY pBYptr
 WRIL 
#debug_left pointer pBYptr
 LEAY BYptr
 LDIL 
#debug pointer BYptr
 LD   udint 1
 ADD
 LEAY BYptr
 WRIL 
#debug_left pointer BYptr
#srcline 246 ;                  pBYptr^:= BYptr^;                     // second byte to Lo
 LEAY BYptr
 LDIL    ; dereference 
 LDI  
#debug byte BYptr^
 LEAY pBYptr
 LDIL    ; dereference 
 WRI 
#debug_left byte pBYptr^
#srcline 247 ;                  pBYptr := pBYptr+2; BYptr := BYptr+1;
 LEAY pBYptr
 LDIL 
#debug pointer pBYptr
 LD   udint 2
 ADD
 LEAY pBYptr
 WRIL 
#debug_left pointer pBYptr
 LEAY BYptr
 LDIL 
#debug pointer BYptr
 LD   udint 1
 ADD
 LEAY BYptr
 WRIL 
#debug_left pointer BYptr
#srcline 248 ;                END_IF;
fbModbusRTUmas2_L45:
#srcline 249 ;              END_FOR;
 LDY  i
 LD   1
 ADD  
 WRY  i
 JMP  fbModbusRTUmas2_L42
fbModbusRTUmas2_L43:
 NOP  -1
#srcline 250 ;              i         := 13 + ByteCount;
 LD   uint 13
 LDY  ByteCount
#debug uint ByteCount
 ADD
 AND  $FFFF
 WRY  i
#debug_left uint i
#srcline 251 ;            ;
 JMP  fbModbusRTUmas2_L27
fbModbusRTUmas2_L41:
 LD   17
 LDY  P2__st__
 EQ  
 JMC  fbModbusRTUmas2_L46
#srcline 252 ;            17 :   // 17 Report Slave ID
#srcline 253 ;              i :=8;
 LD   uint 8
 WRY  i
#debug_left uint i
#srcline 254 ;            ;
 JMP  fbModbusRTUmas2_L27
fbModbusRTUmas2_L46:
 LD   22
 LDY  P2__st__
 EQ  
 JMC  fbModbusRTUmas2_L47
#srcline 255 ;            22 :
#srcline 256 ;              DataT[8]  := WORD_TO_USINT(SHR(UINT_TO_WORD(ptr^.StAdr),8));//Hi
 LEAY ptr
 LDIL    ; dereference 
 ADD  3  ; + offset 
 LDIW 
#debug uint ptr^.StAdr
 LD   uint 8
 SHR
 AND  $FFFF
 AND  $FF
 WRX  DataT[8]
#debug_left usint DataT[8]
#srcline 257 ;              DataT[9]  := UINT_TO_USINT(ptr^.StAdr);     // Lo adresa reg ve slave
 LEAY ptr
 LDIL    ; dereference 
 ADD  3  ; + offset 
 LDIW 
#debug uint ptr^.StAdr
 AND  $FF
 WRX  DataT[9]
#debug_left usint DataT[9]
#srcline 258 ;              BYptr:= UDINT_TO_PTR(ptr^.PtrData);         // source pointer
 LEAY ptr
 LDIL    ; dereference 
 ADD  7  ; + offset 
 LDIL 
#debug udint ptr^.PtrData
; UDINT -> PTR
 LEAY BYptr
 WRIL 
#debug_left pointer BYptr
#srcline 259 ;              pBYptr   := ADR(DataT[10]);                 // destination pointer
 LEAX DataT
 ADD  10  ; + offset 
#debug pointer DataT[10]
 LEAY pBYptr
 WRIL 
#debug_left pointer pBYptr
#srcline 260 ;              FOR i := 0 TO 1 DO                          // Word stream big endian
 LD   uint 0
 WRY  i
 LD   uint 1
 WRY  P5__st__
fbModbusRTUmas2_L48:
 LDY  i
 LDY  P5__st__
 GT   
 JMD  fbModbusRTUmas2_L49
 DBG  
#srcline 261 ;                IF Endian THEN                            // Little Endian
 LDX  Endian
#debug bool Endian
 JMC  fbModbusRTUmas2_L50
#srcline 262 ;                  pBYptr^:= BYptr^;                       // first byte to Lo
 LEAY BYptr
 LDIL    ; dereference 
 LDI  
#debug byte BYptr^
 LEAY pBYptr
 LDIL    ; dereference 
 WRI 
#debug_left byte pBYptr^
#srcline 263 ;                  pBYptr := pBYptr+1; BYptr := BYptr+1;
 LEAY pBYptr
 LDIL 
#debug pointer pBYptr
 LD   udint 1
 ADD
 LEAY pBYptr
 WRIL 
#debug_left pointer pBYptr
 LEAY BYptr
 LDIL 
#debug pointer BYptr
 LD   udint 1
 ADD
 LEAY BYptr
 WRIL 
#debug_left pointer BYptr
#srcline 264 ;                  pBYptr^:= BYptr^;                       // second byte to Hi
 LEAY BYptr
 LDIL    ; dereference 
 LDI  
#debug byte BYptr^
 LEAY pBYptr
 LDIL    ; dereference 
 WRI 
#debug_left byte pBYptr^
#srcline 265 ;                  pBYptr := pBYptr+1; BYptr := BYptr+1;
 LEAY pBYptr
 LDIL 
#debug pointer pBYptr
 LD   udint 1
 ADD
 LEAY pBYptr
 WRIL 
#debug_left pointer pBYptr
 LEAY BYptr
 LDIL 
#debug pointer BYptr
 LD   udint 1
 ADD
 LEAY BYptr
 WRIL 
#debug_left pointer BYptr
#srcline 266 ;                ELSE                                      // Big Endian
 JMP  fbModbusRTUmas2_L51
fbModbusRTUmas2_L50:
#srcline 267 ;                  pBYptr := pBYptr+1;
 LEAY pBYptr
 LDIL 
#debug pointer pBYptr
 LD   udint 1
 ADD
 LEAY pBYptr
 WRIL 
#debug_left pointer pBYptr
#srcline 268 ;                  pBYptr^:= BYptr^;                       // first byte to Hi
 LEAY BYptr
 LDIL    ; dereference 
 LDI  
#debug byte BYptr^
 LEAY pBYptr
 LDIL    ; dereference 
 WRI 
#debug_left byte pBYptr^
#srcline 269 ;                  pBYptr := pBYptr-1; BYptr := BYptr+1;
 LEAY pBYptr
 LDIL 
#debug pointer pBYptr
 LD   udint 1
 SUB
 LEAY pBYptr
 WRIL 
#debug_left pointer pBYptr
 LEAY BYptr
 LDIL 
#debug pointer BYptr
 LD   udint 1
 ADD
 LEAY BYptr
 WRIL 
#debug_left pointer BYptr
#srcline 270 ;                  pBYptr^:= BYptr^;                       // second byte to Lo
 LEAY BYptr
 LDIL    ; dereference 
 LDI  
#debug byte BYptr^
 LEAY pBYptr
 LDIL    ; dereference 
 WRI 
#debug_left byte pBYptr^
#srcline 271 ;                  pBYptr := pBYptr+2; BYptr := BYptr+1;
 LEAY pBYptr
 LDIL 
#debug pointer pBYptr
 LD   udint 2
 ADD
 LEAY pBYptr
 WRIL 
#debug_left pointer pBYptr
 LEAY BYptr
 LDIL 
#debug pointer BYptr
 LD   udint 1
 ADD
 LEAY BYptr
 WRIL 
#debug_left pointer BYptr
#srcline 272 ;                END_IF;
fbModbusRTUmas2_L51:
#srcline 273 ;              END_FOR;
 LDY  i
 LD   1
 ADD  
 WRY  i
 JMP  fbModbusRTUmas2_L48
fbModbusRTUmas2_L49:
 NOP  -1
#srcline 274 ;              i         := 14;
 LD   uint 14
 WRY  i
#debug_left uint i
 JMP  fbModbusRTUmas2_L27
fbModbusRTUmas2_L47:
#srcline 275 ;          ELSE
#srcline 276 ;            ErrCode := 4 + 128;               // Unknown FNC in transmit command
 LD   usint 4
 LD   usint 128
 ADD
 AND  $FF
 WRX  ErrCode
#debug_left usint ErrCode
#srcline 277 ;            SendTo.rq := false;
 LD   bool 0       ; false
 WRX  SendTo~rq
#debug_left bool SendTo.rq
#srcline 278 ;            StateMB := ErrMB;
 LD   udint 5  ; ModbusRTUlib_TStateMB#ErrMB
 WRX  StateMB
#debug_left usint StateMB
#srcline 280 ;          END_CASE;
fbModbusRTUmas2_L27:
#srcline 282 ;          IF k =6 THEN                        // no TCP
 LDY  k
#debug uint k
 LD   uint 6
 EQ
 JMC  fbModbusRTUmas2_L52
#srcline 283 ;            pomUINT   := CheckCRC_16(ptr := ADR(DataT[6]), length := i-6);
 NXT
 LEAX DataT
 ADD  6  ; + offset 
#debug pointer DataT[6]
 LEA  __Instance__CheckCRC_16~ptr
 WRIL 
#debug_left udint __Instance__CheckCRC_16~ptr
 LDY  i
#debug uint i
 LD   uint 6
 SUB
 AND  $FFFF
 WR   __Instance__CheckCRC_16~length
#debug_left uint __Instance__CheckCRC_16~length
 PRV
 LEA  __Instance__CheckCRC_16
 CAL  CheckCRC_16_L0
 WRY  pomUINT
#debug_left uint pomUINT
#srcline 284 ;            DataT[i]  := UINT_TO_USINT(pomUINT);                     //Lo
 LDY  pomUINT
#debug uint pomUINT
 AND  $FF
 LEAX DataT
 LDY  i
#debug uint i
 RCHK 261   ; Range Check
 ADD     ; + offset 
 WRI 
#debug_left usint DataT[i]
#srcline 285 ;            DataT[i+1]:= WORD_TO_USINT(SHR(UINT_TO_WORD(pomUINT),8));//Hi
 LDY  pomUINT
#debug uint pomUINT
 LD   uint 8
 SHR
 AND  $FFFF
 AND  $FF
 LEAX DataT
 LDY  i
#debug uint i
 LD   uint 1
 ADD
 AND  $FFFF
 RCHK 261   ; Range Check
 ADD     ; + offset 
 WRI 
#debug_left usint DataT[i+1]
#srcline 286 ;            DataT[5]  := UINT_TO_USINT(i-4);  // NUMT  no TCP
 LDY  i
#debug uint i
 LD   uint 4
 SUB
 AND  $FFFF
 AND  $FF
 WRX  DataT[5]
#debug_left usint DataT[5]
#srcline 287 ;          ELSE
 JMP  fbModbusRTUmas2_L53
fbModbusRTUmas2_L52:
#srcline 288 ;            traNum := traNum + 1;
 LDX  traNum
#debug uint traNum
 LD   uint 1
 ADD
 AND  $FFFF
 WRX  traNum
#debug_left uint traNum
#srcline 289 ;            DataT[0]  := WORD_TO_USINT(SHR(UINT_TO_WORD(pomUINT),8));  // transaction number Hi
 LDY  pomUINT
#debug uint pomUINT
 LD   uint 8
 SHR
 AND  $FFFF
 AND  $FF
 WRX  DataT[0]
#debug_left usint DataT[0]
#srcline 290 ;            DataT[1]  := UINT_TO_USINT(traNum);                        // transaction number Lo
 LDX  traNum
#debug uint traNum
 AND  $FF
 WRX  DataT[1]
#debug_left usint DataT[1]
#srcline 291 ;            DataT[5]  := UINT_TO_USINT(i-6);  // NUMT  TCP
 LDY  i
#debug uint i
 LD   uint 6
 SUB
 AND  $FFFF
 AND  $FF
 WRX  DataT[5]
#debug_left usint DataT[5]
#srcline 292 ;          END_IF;
fbModbusRTUmas2_L53:
#srcline 293 ;        END_IF;
fbModbusRTUmas2_L26:
 JMP  fbModbusRTUmas2_L23
fbModbusRTUmas2_L24:
 LD   2
 LDY  P1__st__
 EQ  
 JMC  fbModbusRTUmas2_L54
#srcline 294 ;      //------------------------------------------------------------------------
#srcline 295 ;      SndMBt    :                                 // Send Message test
#srcline 296 ;        IF SendTo.error <> COM_ERR5 THEN             // Byd rev.1.7
 LDX  SendTo~error
#debug usint SendTo.error
 LD   usint 5
 EQ
 NEG
 JMC  fbModbusRTUmas2_L55
#srcline 297 ;          SendTo.rq := false;
 LD   bool 0       ; false
 WRX  SendTo~rq
#debug_left bool SendTo.rq
#srcline 298 ;          IF SendTo.mesSent THEN
 LDX  SendTo~mesSent
#debug bool SendTo.mesSent
 JMC  fbModbusRTUmas2_L57
#srcline 299 ;            StateMB := WaitRespMB;
 LD   udint 3  ; ModbusRTUlib_TStateMB#WaitRespMB
 WRX  StateMB
#debug_left usint StateMB
#srcline 300 ;          END_IF;
fbModbusRTUmas2_L57:
#srcline 301 ;          IF SendTo.error <> 0 THEN
 LDX  SendTo~error
#debug usint SendTo.error
 LD   usint 0
 EQ
 NEG
 JMC  fbModbusRTUmas2_L59
#srcline 302 ;            ErrCode := SendTo.error ;               // transm chanel error
 LDX  SendTo~error
#debug usint SendTo.error
 WRX  ErrCode
#debug_left usint ErrCode
#srcline 303 ;            StateMB := ErrMB;                       // Hard Error
 LD   udint 5  ; ModbusRTUlib_TStateMB#ErrMB
 WRX  StateMB
#debug_left usint StateMB
#srcline 304 ;          END_IF;
fbModbusRTUmas2_L59:
#srcline 305 ;        END_IF;
fbModbusRTUmas2_L55:
 JMP  fbModbusRTUmas2_L23
fbModbusRTUmas2_L54:
 LD   5
 LDY  P1__st__
 EQ  
 JMC  fbModbusRTUmas2_L61
#srcline 306 ;      //------------------------------------------------------------------------
#srcline 307 ;      ErrMB     :
#srcline 308 ;        Done := true; //!!!
 LD   bool -1       ; true
 WRX  Done
#debug_left bool Done
#srcline 309 ;        //StateMB := StartMB;                       // Hard Error
#srcline 310 ;        StateMB := DelayMB;                         // Hard Error - wait! 3.0
 LD   udint 6  ; ModbusRTUlib_TStateMB#DelayMB
 WRX  StateMB
#debug_left usint StateMB
 JMP  fbModbusRTUmas2_L23
fbModbusRTUmas2_L61:
 LD   6
 LDY  P1__st__
 EQ  
 JMC  fbModbusRTUmas2_L62
#srcline 311 ;      DelayMB   :
#srcline 312 ;        wasStart := wasStart OR Start;
 LDX  wasStart
#debug bool wasStart
 LDX  Start
#debug bool Start
 OR  
 WRX  wasStart
#debug_left bool wasStart
#srcline 313 ;        Done := false;
 LD   bool 0       ; false
 WRX  Done
#debug_left bool Done
#srcline 314 ;        IF DelayTimeOut.Q THEN
 LDX  DelayTimeOut~Q
#debug bool DelayTimeOut.Q
 JMC  fbModbusRTUmas2_L63
#srcline 315 ;          StateMB := StartMB;
 LD   udint 0  ; ModbusRTUlib_TStateMB#StartMB
 WRX  StateMB
#debug_left usint StateMB
#srcline 316 ;        END_IF;
fbModbusRTUmas2_L63:
 JMP  fbModbusRTUmas2_L23
fbModbusRTUmas2_L62:
fbModbusRTUmas2_L23:
#srcline 319 ;    RecvFrom(rq := StateMB = WaitRespMB, lenRx := 255 +6 -k, chanCode := chanCode, data := void(DataR[k]));            // Byd rev.1.7
 LDX  StateMB
#debug usint StateMB
 LD   udint 3  ; ModbusRTUlib_TStateMB#WaitRespMB
 EQ
 WRX  RecvFrom~rq
#debug_left bool RecvFrom~rq
 LD   uint 255
 LD   uint 6
 ADD
 AND  $FFFF
 LDY  k
#debug uint k
 SUB
 AND  $FFFF
 WRX  RecvFrom~lenRx
#debug_left uint RecvFrom~lenRx
 LDX  chanCode
#debug uint chanCode
 WRX  RecvFrom~chanCode
#debug_left uint RecvFrom~chanCode
 LEAX DataR
 LDY  k
#debug uint k
 RCHK 261   ; Range Check
 ADD     ; + offset 
 WRX  RecvFrom~data
#debug_left pointer RecvFrom.data
 LEAX RecvFrom
 CAL  fbRecvFrom_L0
#srcline 321 ;    IF RecvFrom.rq THEN //prijem
 LDX  RecvFrom~rq
#debug bool RecvFrom.rq
 JMC  fbModbusRTUmas2_L65
#srcline 322 ;      IF k <> 0 THEN  // TCP nemá broadcast
 LDY  k
#debug uint k
 LD   uint 0
 EQ
 NEG
 JMC  fbModbusRTUmas2_L67
#srcline 323 ;        IF DataT[6] = 0 THEN                   // broadcast
 LDX  DataT[6]
#debug usint DataT[6]
 LD   usint 0
 EQ
 JMC  fbModbusRTUmas2_L69
#srcline 324 ;          IF Delay = T#0s THEN
 LDX  Delay
#debug time Delay
 LD   time 0
 EQ
 JMC  fbModbusRTUmas2_L71
#srcline 325 ;            StateMB := StartMB;
 LD   udint 0  ; ModbusRTUlib_TStateMB#StartMB
 WRX  StateMB
#debug_left usint StateMB
#srcline 326 ;            Done := true;
 LD   bool -1       ; true
 WRX  Done
#debug_left bool Done
#srcline 327 ;          ELSE
 JMP  fbModbusRTUmas2_L72
fbModbusRTUmas2_L71:
#srcline 328 ;            StateMB := DelayMB;
 LD   udint 6  ; ModbusRTUlib_TStateMB#DelayMB
 WRX  StateMB
#debug_left usint StateMB
#srcline 329 ;          END_IF;
fbModbusRTUmas2_L72:
#srcline 330 ;        END_IF;
fbModbusRTUmas2_L69:
#srcline 331 ;      END_IF;
fbModbusRTUmas2_L67:
#srcline 332 ;      IF RecvFrom.mesRec THEN                  // receive
 LDX  RecvFrom~mesRec
#debug bool RecvFrom.mesRec
 JMC  fbModbusRTUmas2_L73
#srcline 333 ;        NUMR := RecvFrom.lenData;
 LDX  RecvFrom~lenData
#debug uint RecvFrom.lenData
 WRX  NUMR
#debug_left uint NUMR
#srcline 334 ;        ERRr := RecvFrom.error;
 LDX  RecvFrom~error
#debug usint RecvFrom.error
 WRX  ERRr
#debug_left usint ERRr
#srcline 335 ;        StateMB := RecMB;
 LD   udint 4  ; ModbusRTUlib_TStateMB#RecMB
 WRX  StateMB
#debug_left usint StateMB
#srcline 336 ;      ELSE
 JMP  fbModbusRTUmas2_L74
fbModbusRTUmas2_L73:
#srcline 337 ;        IF RespTimeOut.Q THEN
 LDX  RespTimeOut~Q
#debug bool RespTimeOut.Q
 JMC  fbModbusRTUmas2_L75
#srcline 338 ;          ErrCode := 7 + 128;                   // Respond Timeout Error
 LD   usint 7
 LD   usint 128
 ADD
 AND  $FF
 WRX  ErrCode
#debug_left usint ErrCode
#srcline 339 ;          StateMB := ErrMB;                     // Hard Error
 LD   udint 5  ; ModbusRTUlib_TStateMB#ErrMB
 WRX  StateMB
#debug_left usint StateMB
#srcline 340 ;        END_IF;
fbModbusRTUmas2_L75:
#srcline 341 ;      END_IF;
fbModbusRTUmas2_L74:
#srcline 342 ;    END_IF;
fbModbusRTUmas2_L65:
#srcline 344 ;    IF StateMB = RecMB THEN                       // recive
 LDX  StateMB
#debug usint StateMB
 LD   udint 4  ; ModbusRTUlib_TStateMB#RecMB
 EQ
 JMC  fbModbusRTUmas2_L77
#srcline 345 ;      IF ERRr <> 0 THEN                         // no error
 LDX  ERRr
#debug usint ERRr
 LD   usint 0
 EQ
 NEG
 JMC  fbModbusRTUmas2_L79
#srcline 346 ;        ErrCode := ERRr;                        // Error recive chanel
 LDX  ERRr
#debug usint ERRr
 WRX  ErrCode
#debug_left usint ErrCode
#srcline 347 ;        StateMB := ErrMB;                       // Hard Error
 LD   udint 5  ; ModbusRTUlib_TStateMB#ErrMB
 WRX  StateMB
#debug_left usint StateMB
#srcline 348 ;      ELSE
 JMP  fbModbusRTUmas2_L80
fbModbusRTUmas2_L79:
#srcline 349 ;        ErrCode := 0;
 LD   usint 0
 WRX  ErrCode
#debug_left usint ErrCode
#srcline 350 ;        IF DataR[6] <> DataT[6] THEN
 LDX  DataR[6]
#debug usint DataR[6]
 LDX  DataT[6]
#debug usint DataT[6]
 EQ
 NEG
 JMC  fbModbusRTUmas2_L81
#srcline 351 ;          ErrCode := 1 + 128;                   // Respond with other station
 LD   usint 1
 LD   usint 128
 ADD
 AND  $FF
 WRX  ErrCode
#debug_left usint ErrCode
#srcline 352 ;                                                //     number of slave device
#srcline 353 ;          StateMB := ErrMB;                     // Hard Error
 LD   udint 5  ; ModbusRTUlib_TStateMB#ErrMB
 WRX  StateMB
#debug_left usint StateMB
#srcline 354 ;        ELSE
 JMP  fbModbusRTUmas2_L82
fbModbusRTUmas2_L81:
#srcline 355 ;          IF (DataR[7] <> DataT[7]) and         //FNC
 LDX  DataR[7]
#debug usint DataR[7]
 LDX  DataT[7]
#debug usint DataT[7]
 EQ
 NEG
#srcline 356 ;             (DataR[7] <> DataT[7] + 128) THEN  //FNC+Exception
 LDX  DataR[7]
#debug usint DataR[7]
 LDX  DataT[7]
#debug usint DataT[7]
 LD   usint 128
 ADD
 AND  $FF
 EQ
 NEG
 AND
 JMC  fbModbusRTUmas2_L83
#srcline 357 ;            ErrCode := 2 + 128;                 // Respond with other FNC ever ask
 LD   usint 2
 LD   usint 128
 ADD
 AND  $FF
 WRX  ErrCode
#debug_left usint ErrCode
#srcline 358 ;            StateMB := ErrMB;                   // Hard Error
 LD   udint 5  ; ModbusRTUlib_TStateMB#ErrMB
 WRX  StateMB
#debug_left usint StateMB
#srcline 359 ;          ELSE
 JMP  fbModbusRTUmas2_L84
fbModbusRTUmas2_L83:
#srcline 360 ;            IF k = 0 THEN  // TCP nemá CRC
 LDY  k
#debug uint k
 LD   uint 0
 EQ
 JMC  fbModbusRTUmas2_L85
#srcline 361 ;              pomUINT:=0;
 LD   uint 0
 WRY  pomUINT
#debug_left uint pomUINT
#srcline 362 ;            ELSE
 JMP  fbModbusRTUmas2_L86
fbModbusRTUmas2_L85:
#srcline 363 ;              pomUINT:=CheckCRC_16(ptr := ADR( DataR[6]),length:= NUMR);// CRC
 NXT
 LEAX DataR
 ADD  6  ; + offset 
#debug pointer DataR[6]
 LEA  __Instance__CheckCRC_16~ptr
 WRIL 
#debug_left udint __Instance__CheckCRC_16~ptr
 LDX  NUMR
#debug uint NUMR
 WR   __Instance__CheckCRC_16~length
#debug_left uint __Instance__CheckCRC_16~length
 PRV
 LEA  __Instance__CheckCRC_16
 CAL  CheckCRC_16_L0
 WRY  pomUINT
#debug_left uint pomUINT
#srcline 364 ;            END_IF;
fbModbusRTUmas2_L86:
#srcline 365 ;            IF (pomUINT <> 0) THEN
 LDY  pomUINT
#debug uint pomUINT
 LD   uint 0
 EQ
 NEG
 JMC  fbModbusRTUmas2_L87
#srcline 366 ;              ErrCode := 3 + 128;               // Checksum error in reception
 LD   usint 3
 LD   usint 128
 ADD
 AND  $FF
 WRX  ErrCode
#debug_left usint ErrCode
#srcline 367 ;              StateMB := ErrMB;                 // Hard Error
 LD   udint 5  ; ModbusRTUlib_TStateMB#ErrMB
 WRX  StateMB
#debug_left usint StateMB
#srcline 368 ;            ELSE
 JMP  fbModbusRTUmas2_L88
fbModbusRTUmas2_L87:
#srcline 369 ;              ptr := ADR(Commands) + USINT_TO_UDINT(LastCmd-1) * sizeof(TCmdStruct);
 LDX  Commands
#debug pointer Commands
 LDX  LastCmd
#debug usint LastCmd
 LD   usint 1
 SUB
 AND  $FF
 LD   11  ; SizeOf()
 MUL
 ADD
 LEAY ptr
 WRIL 
#debug_left pointer ptr
#srcline 370 ;              sptr:= UDINT_TO_PTR(ptr^.PtrData);// substitute of pointer
 LEAY ptr
 LDIL    ; dereference 
 ADD  7  ; + offset 
 LDIL 
#debug udint ptr^.PtrData
; UDINT -> PTR
 LEAY sptr
 WRIL 
#debug_left pointer sptr
#srcline 371 ;              Done := true;
 LD   bool -1       ; true
 WRX  Done
#debug_left bool Done
#srcline 372 ;              IF Delay = T#0s THEN
 LDX  Delay
#debug time Delay
 LD   time 0
 EQ
 JMC  fbModbusRTUmas2_L89
#srcline 373 ;                StateMB := StartMB;
 LD   udint 0  ; ModbusRTUlib_TStateMB#StartMB
 WRX  StateMB
#debug_left usint StateMB
#srcline 374 ;              ELSE
 JMP  fbModbusRTUmas2_L90
fbModbusRTUmas2_L89:
#srcline 375 ;                StateMB := DelayMB;
 LD   udint 6  ; ModbusRTUlib_TStateMB#DelayMB
 WRX  StateMB
#debug_left usint StateMB
#srcline 376 ;              END_IF;
fbModbusRTUmas2_L90:
#srcline 377 ;              IF DataR[7]>127 THEN
 LDX  DataR[7]
#debug usint DataR[7]
 LD   usint 127
 GT
 JMC  fbModbusRTUmas2_L91
#srcline 378 ;                ErrCode := DataR[8]+ 136;       // Exception from slave device 1,2,3,4,5,6,8,A,B
 LDX  DataR[8]
#debug usint DataR[8]
 LD   usint 136
 ADD
 AND  $FF
 WRX  ErrCode
#debug_left usint ErrCode
#srcline 379 ;              ELSE
 JMP  fbModbusRTUmas2_L92
fbModbusRTUmas2_L91:
#srcline 380 ;                CASE DataR[7]  OF               // Respondse FNC
 LDX  DataR[7]
#debug usint DataR[7]
 WRY  P6__st__
 LDY  P6__st__
 LD   2
 GT  
 JMD fbModbusRTUmas2_L94
 LDY  P6__st__
 LD   1
 LT  
 JMD fbModbusRTUmas2_L94
#srcline 381 ;                  1..2 :   // 01 Read Colls
#srcline 382 ;                           // 02 Read Discrete Inputs
#srcline 383 ;                     BOptr := sptr;
 LEAY sptr
 LDIL 
#debug pointer sptr
 LEAY BOptr
 WRIL 
#debug_left pointer BOptr
#srcline 384 ;                     pBOptr := ADR(DataR[9]) * 8;
 LEAX DataR
 ADD  9  ; + offset 
#debug pointer DataR[9]
 LD   udint 8
 MUL
 LEAY pBOptr
 WRIL 
#debug_left pointer pBOptr
#srcline 385 ;                     NoPoints:= LIMIT(MN :=1,IN := ptr^.NoPoint,MX :=2000);
 LEAY ptr
 LDIL    ; dereference 
 ADD  5  ; + offset 
 LDIW 
#debug uint ptr^.NoPoint
 LD   uint 1
 MAX
 LD   uint 2000
 MIN
 WRY  NoPoints
#debug_left uint NoPoints
#srcline 386 ;                     FOR i := 1 TO NoPoints DO    // Bit stream   // ByteCount
 LD   uint 1
 WRY  i
 LDY  NoPoints
#debug uint NoPoints
 WRY  P7__st__
fbModbusRTUmas2_L95:
 LDY  i
 LDY  P7__st__
 GT   
 JMD  fbModbusRTUmas2_L96
 DBG  
#srcline 387 ;                       BOptr^ := pBOptr^; BOptr := BOptr+1; pBOptr := pBOptr+1;
 LEAY pBOptr
 LDIL    ; dereference 
 LDIB 
#debug bool pBOptr^
 LEAY BOptr
 LDIL    ; dereference 
 WRIB 
#debug_left bool BOptr^
 LEAY BOptr
 LDIL 
#debug pointer BOptr
 LD   udint 1
 ADD
 LEAY BOptr
 WRIL 
#debug_left pointer BOptr
 LEAY pBOptr
 LDIL 
#debug pointer pBOptr
 LD   udint 1
 ADD
 LEAY pBOptr
 WRIL 
#debug_left pointer pBOptr
#srcline 388 ;                     END_FOR;
 LDY  i
 LD   1
 ADD  
 WRY  i
 JMP  fbModbusRTUmas2_L95
fbModbusRTUmas2_L96:
 NOP  -1
 JMP  fbModbusRTUmas2_L93
fbModbusRTUmas2_L94:
 LD   3
 LDY  P6__st__
 EQ   
 JMD  fbModbusRTUmas2_L97
 LD   4
 LDY  P6__st__
 EQ   
 JMD  fbModbusRTUmas2_L97
 LD   17
 LDY  P6__st__
 EQ   
 JMC  fbModbusRTUmas2_L98
fbModbusRTUmas2_L97:
#srcline 389 ;                  3,4,17 : // 03 Read Holding Registers
#srcline 390 ;                           // 04 Read Input Registers
#srcline 391 ;                           // 17 Report Slave ID
#srcline 392 ;                     BYptr  := ADR(DataR[9]);                  // source pointer
 LEAX DataR
 ADD  9  ; + offset 
#debug pointer DataR[9]
 LEAY BYptr
 WRIL 
#debug_left pointer BYptr
#srcline 393 ;                     pBYptr := sptr;                           // destination pointer
 LEAY sptr
 LDIL 
#debug pointer sptr
 LEAY pBYptr
 WRIL 
#debug_left pointer pBYptr
#srcline 395 ;                     NoPoints:= USINT_TO_UINT(DataR[8])/2;
 LDX  DataR[8]
#debug usint DataR[8]
 AND  $FFFF
 LD   uint 2
 DIVL
 AND  $FFFF
 WRY  NoPoints
#debug_left uint NoPoints
#srcline 396 ;                     IF DataR[7] <> 17 THEN
 LDX  DataR[7]
#debug usint DataR[7]
 LD   usint 17
 EQ
 NEG
 JMC  fbModbusRTUmas2_L99
#srcline 397 ;                       NoPoints:= LIMIT(MN := 1, IN := MIN(NoPoints, ptr^.NoPoint), MX := 125);
 LDY  NoPoints
#debug uint NoPoints
 LEAY ptr
 LDIL    ; dereference 
 ADD  5  ; + offset 
 LDIW 
#debug uint ptr^.NoPoint
 MIN
 LD   uint 1
 MAX
 LD   uint 125
 MIN
 WRY  NoPoints
#debug_left uint NoPoints
#srcline 398 ;                     END_IF;
fbModbusRTUmas2_L99:
#srcline 399 ;                     
#srcline 400 ;                     FOR i := 1 TO NoPoints DO
 LD   uint 1
 WRY  i
 LDY  NoPoints
#debug uint NoPoints
 WRY  P8__st__
fbModbusRTUmas2_L101:
 LDY  i
 LDY  P8__st__
 GT   
 JMD  fbModbusRTUmas2_L102
 DBG  
#srcline 401 ;                       IF Endian THEN                          // Little Endian
 LDX  Endian
#debug bool Endian
 JMC  fbModbusRTUmas2_L103
#srcline 402 ;                         pBYptr^:= BYptr^;                     // first byte to Lo
 LEAY BYptr
 LDIL    ; dereference 
 LDI  
#debug byte BYptr^
 LEAY pBYptr
 LDIL    ; dereference 
 WRI 
#debug_left byte pBYptr^
#srcline 403 ;                         pBYptr := pBYptr+1; BYptr := BYptr+1;
 LEAY pBYptr
 LDIL 
#debug pointer pBYptr
 LD   udint 1
 ADD
 LEAY pBYptr
 WRIL 
#debug_left pointer pBYptr
 LEAY BYptr
 LDIL 
#debug pointer BYptr
 LD   udint 1
 ADD
 LEAY BYptr
 WRIL 
#debug_left pointer BYptr
#srcline 404 ;                         pBYptr^:= BYptr^;                     // second byte to Hi
 LEAY BYptr
 LDIL    ; dereference 
 LDI  
#debug byte BYptr^
 LEAY pBYptr
 LDIL    ; dereference 
 WRI 
#debug_left byte pBYptr^
#srcline 405 ;                         pBYptr := pBYptr+1; BYptr := BYptr+1;
 LEAY pBYptr
 LDIL 
#debug pointer pBYptr
 LD   udint 1
 ADD
 LEAY pBYptr
 WRIL 
#debug_left pointer pBYptr
 LEAY BYptr
 LDIL 
#debug pointer BYptr
 LD   udint 1
 ADD
 LEAY BYptr
 WRIL 
#debug_left pointer BYptr
#srcline 406 ;                       ELSE                                    // Big Endian
 JMP  fbModbusRTUmas2_L104
fbModbusRTUmas2_L103:
#srcline 407 ;                         pBYptr := pBYptr+1;
 LEAY pBYptr
 LDIL 
#debug pointer pBYptr
 LD   udint 1
 ADD
 LEAY pBYptr
 WRIL 
#debug_left pointer pBYptr
#srcline 408 ;                         pBYptr^:= BYptr^;                     // first byte to Hi
 LEAY BYptr
 LDIL    ; dereference 
 LDI  
#debug byte BYptr^
 LEAY pBYptr
 LDIL    ; dereference 
 WRI 
#debug_left byte pBYptr^
#srcline 409 ;                         pBYptr := pBYptr-1; BYptr := BYptr+1;
 LEAY pBYptr
 LDIL 
#debug pointer pBYptr
 LD   udint 1
 SUB
 LEAY pBYptr
 WRIL 
#debug_left pointer pBYptr
 LEAY BYptr
 LDIL 
#debug pointer BYptr
 LD   udint 1
 ADD
 LEAY BYptr
 WRIL 
#debug_left pointer BYptr
#srcline 410 ;                         pBYptr^:= BYptr^;                     // second byte to Lo
 LEAY BYptr
 LDIL    ; dereference 
 LDI  
#debug byte BYptr^
 LEAY pBYptr
 LDIL    ; dereference 
 WRI 
#debug_left byte pBYptr^
#srcline 411 ;                         pBYptr := pBYptr+2; BYptr := BYptr+1;
 LEAY pBYptr
 LDIL 
#debug pointer pBYptr
 LD   udint 2
 ADD
 LEAY pBYptr
 WRIL 
#debug_left pointer pBYptr
 LEAY BYptr
 LDIL 
#debug pointer BYptr
 LD   udint 1
 ADD
 LEAY BYptr
 WRIL 
#debug_left pointer BYptr
#srcline 412 ;                       END_IF;
fbModbusRTUmas2_L104:
#srcline 413 ;                     END_FOR;
 LDY  i
 LD   1
 ADD  
 WRY  i
 JMP  fbModbusRTUmas2_L101
fbModbusRTUmas2_L102:
 NOP  -1
 JMP  fbModbusRTUmas2_L93
fbModbusRTUmas2_L98:
 LD   5
 LDY  P6__st__
 EQ  
 JMC  fbModbusRTUmas2_L105
#srcline 414 ;                  5 :       // 05 Write Single Coil
#srcline 415 ;                  ;
 JMP  fbModbusRTUmas2_L93
fbModbusRTUmas2_L105:
 LD   6
 LDY  P6__st__
 EQ  
 JMC  fbModbusRTUmas2_L106
#srcline 416 ;                  6 :       // 06 Write Single Register
#srcline 417 ;                  ;
 JMP  fbModbusRTUmas2_L93
fbModbusRTUmas2_L106:
 LD   7
 LDY  P6__st__
 EQ  
 JMC  fbModbusRTUmas2_L107
#srcline 418 ;                  7 :       // 07 Read Exception Status
#srcline 419 ;                       sptr^:= DataR[9];                     // first byte to Lo
 LDX  DataR[9]
#debug usint DataR[9]
 LEAY sptr
 LDIL    ; dereference 
 WRI 
#debug_left usint sptr^
#srcline 420 ;                  ;
 JMP  fbModbusRTUmas2_L93
fbModbusRTUmas2_L107:
 LD   8
 LDY  P6__st__
 EQ  
 JMC  fbModbusRTUmas2_L108
#srcline 421 ;                  8 :       // 08 Diagnostic
#srcline 422 ;                     IF Endian THEN                          // Little Endian
 LDX  Endian
#debug bool Endian
 JMC  fbModbusRTUmas2_L109
#srcline 423 ;                       sptr^:= DataR[10];                    // first byte to Lo
 LDX  DataR[10]
#debug usint DataR[10]
 LEAY sptr
 LDIL    ; dereference 
 WRI 
#debug_left usint sptr^
#srcline 424 ;                       sptr := sptr+1;
 LEAY sptr
 LDIL 
#debug pointer sptr
 LD   udint 1
 ADD
 LEAY sptr
 WRIL 
#debug_left pointer sptr
#srcline 425 ;                       sptr^:= DataR[11];                    // second byte to Hi
 LDX  DataR[11]
#debug usint DataR[11]
 LEAY sptr
 LDIL    ; dereference 
 WRI 
#debug_left usint sptr^
#srcline 426 ;                     ELSE                                    // Big Endian
 JMP  fbModbusRTUmas2_L110
fbModbusRTUmas2_L109:
#srcline 427 ;                       sptr^:= DataR[11];                    // first byte to Hi
 LDX  DataR[11]
#debug usint DataR[11]
 LEAY sptr
 LDIL    ; dereference 
 WRI 
#debug_left usint sptr^
#srcline 428 ;                       sptr := sptr+1;
 LEAY sptr
 LDIL 
#debug pointer sptr
 LD   udint 1
 ADD
 LEAY sptr
 WRIL 
#debug_left pointer sptr
#srcline 429 ;                       sptr^:= DataR[10];                    // second byte to Lo
 LDX  DataR[10]
#debug usint DataR[10]
 LEAY sptr
 LDIL    ; dereference 
 WRI 
#debug_left usint sptr^
#srcline 430 ;                     END_IF;
fbModbusRTUmas2_L110:
#srcline 431 ;                  ;
 JMP  fbModbusRTUmas2_L93
fbModbusRTUmas2_L108:
 LD   15
 LDY  P6__st__
 EQ  
 JMC  fbModbusRTUmas2_L111
#srcline 432 ;                  15:       // 15 Write Multiple Coils
#srcline 433 ;                  ;
 JMP  fbModbusRTUmas2_L93
fbModbusRTUmas2_L111:
 LD   16
 LDY  P6__st__
 EQ  
 JMC  fbModbusRTUmas2_L112
#srcline 434 ;                  16:       // 16 Write Multiple Registers
#srcline 435 ;                  ;
 JMP  fbModbusRTUmas2_L93
fbModbusRTUmas2_L112:
 LD   22
 LDY  P6__st__
 EQ  
 JMC  fbModbusRTUmas2_L113
#srcline 436 ;                  22:       // 22 Mask Write Registers
#srcline 437 ;                  ;
 JMP  fbModbusRTUmas2_L93
fbModbusRTUmas2_L113:
#srcline 438 ;                  ELSE
#srcline 439 ;                     ErrCode := 5 + 128;           // Respond with Unknown FNC
 LD   usint 5
 LD   usint 128
 ADD
 AND  $FF
 WRX  ErrCode
#debug_left usint ErrCode
#srcline 440 ;                     StateMB := ErrMB;             // Hard Error
 LD   udint 5  ; ModbusRTUlib_TStateMB#ErrMB
 WRX  StateMB
#debug_left usint StateMB
#srcline 441 ;                     //!!!
#srcline 442 ;                     Done := false;
 LD   bool 0       ; false
 WRX  Done
#debug_left bool Done
#srcline 443 ;                END_CASE;
fbModbusRTUmas2_L93:
#srcline 444 ;              END_IF;
fbModbusRTUmas2_L92:
#srcline 445 ;            END_IF;
fbModbusRTUmas2_L88:
#srcline 446 ;          END_IF;
fbModbusRTUmas2_L84:
#srcline 447 ;        END_IF;
fbModbusRTUmas2_L82:
#srcline 448 ;      END_IF;
fbModbusRTUmas2_L80:
#srcline 449 ;    END_IF;
fbModbusRTUmas2_L77:
#srcline 453 ;    SendTo( lenTx := USINT_TO_UINT(DataT[5]) +6 -k, chanCode := chanCode, data := void(DataT[k]) );                      //
 LDX  DataT[5]
#debug usint DataT[5]
 AND  $FFFF
 LD   uint 6
 ADD
 AND  $FFFF
 LDY  k
#debug uint k
 SUB
 AND  $FFFF
 WRX  SendTo~lenTx
#debug_left uint SendTo~lenTx
 LDX  chanCode
#debug uint chanCode
 WRX  SendTo~chanCode
#debug_left uint SendTo~chanCode
 LEAX DataT
 LDY  k
#debug uint k
 RCHK 261   ; Range Check
 ADD     ; + offset 
 WRX  SendTo~data
#debug_left pointer SendTo.data
 LEAX SendTo
 CAL  fbSendTo_L0
#srcline 454 ;  END_IF;
fbModbusRTUmas2_L2:
#srcline 456 ;  DelayTimeOut(IN := (StateMB = DelayMB), PT := Delay); //timeout between messages
 LDX  StateMB
#debug usint StateMB
 LD   udint 6  ; ModbusRTUlib_TStateMB#DelayMB
 EQ
 WRX  DelayTimeOut~IN
#debug_left bool DelayTimeOut~IN
 LDX  Delay
#debug time Delay
 WRX  DelayTimeOut~PT
#debug_left time DelayTimeOut~PT
 LEAX DelayTimeOut
 CAL  TON_L0
#srcline 457 ;  RespTimeOut(IN := (StateMB = WaitRespMB), PT := MBtimeOut); // respond timeout timer
 LDX  StateMB
#debug usint StateMB
 LD   udint 3  ; ModbusRTUlib_TStateMB#WaitRespMB
 EQ
 WRX  RespTimeOut~IN
#debug_left bool RespTimeOut~IN
 LDX  MBtimeOut
#debug time MBtimeOut
 WRX  RespTimeOut~PT
#debug_left time RespTimeOut~PT
 LEAX RespTimeOut
 CAL  TON_L0
#srcline 458 ;END_FUNCTION_BLOCK
 ULNK
RET
E     61

; Initialize - variables
P     61
fbModbusRTUmas2__InstanceInit__:
 LINK 0
 LD   time 2000
 WRX  MBtimeOut
 LEAX SendTo
 CAL  fbSendTo__InstanceInit__
 LEAX RecvFrom
 CAL  fbRecvFrom__InstanceInit__
 ULNK
RET
E     61
; End initialize - variables
#endpou 



 

#srcfile ''
#srcfile 'C:\TECOLIBSRC\MODBUSRTU\MODBUSRTU\FBMODBUSTCPMAS2.ST'
#pou fbModbusTCPmas2
#srcline 1 ;FUNCTION_BLOCK fbModbusTCPmas2
#table byte __Init___fbModbusTCPmas2_modbusRTU = 
      0,  0,  0,  0,  0,  0,  0,  0,208,  7,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  2;

#struct fbModbusTCPmas2__temp__
  bool CmdFind,  ; GrSel find
  bool cantChangeIP,
  usint tempCmd,
  int tempPos,
  string[81] tempStr,
  TRemoteEthAdr lastEthAdr,
  usint P0__st__,
  usint P1__st__,
  usint P2__st__,
  string[82] PS0__st__
#data byte _str_fbModbusTCPmas2_0 = 
  ':',0
P     61
fbModbusTCPmas2_L0:
 LINK __SizeOf(fbModbusTCPmas2__temp__)
; Initialize - dynamic variables
; End initialize - dynamic variables
; R_EDGE, F_EDGE 
 LDX  Start
 LETX __EDGE_R__Start
 WRX  Start
#srcline 79 ;  cantChangeIP := (UINT_TO_WORD(chanCode) and 16#00FF <> 16#00E1) AND ((System_S.S42 = 16#4B) OR (System_S.S42 = 16#4C));
 LDX  chanCode
#debug uint chanCode
 LD   word $00FF
 AND
 LD   word $00E1
 EQ
 NEG
 LD   System_S~S42
#debug byte System_S.S42
 LD   byte $4B
 EQ
 LD   System_S~S42
#debug byte System_S.S42
 LD   byte $4C
 EQ
 OR  
 AND
 WRY  cantChangeIP
#debug_left bool cantChangeIP
#srcline 80 ;  //  ErrCode := 20 + 128; RETURN;                     // kod kanalu musi byt ETH1_uni
#srcline 81 ;  //END_IF;  // TCP
#srcline 82 ;  
#srcline 83 ;  isEstab := IsEstabTCPconnection(chanCode := chanCode);
 NXT
 LDX  chanCode
#debug uint chanCode
 WR   __Instance__IsEstabTCPconnection~chanCode
#debug_left uint __Instance__IsEstabTCPconnection~chanCode
 PRV
 LEA  __Instance__IsEstabTCPconnection
 CAL  IsEstabTCPconnection_L0
 WRX  isEstab
#debug_left bool isEstab
#srcline 84 ;  
#srcline 85 ;  delayActive := delayActive AND isEstab; //shodit delay pokud neni spojeni
 LDX  delayActive
#debug bool delayActive
 LDX  isEstab
#debug bool isEstab
 AND
 WRX  delayActive
#debug_left bool delayActive
#srcline 87 ;  IF ProgramIsChanged() THEN
 LEA  __Instance__ProgramIsChanged
 CAL  ProgramIsChanged_L0
 JMC  fbModbusTCPmas2_L1
#srcline 88 ;    IF LastCmd > 0 AND LastCmd <= MaxCmd THEN
 LDX  LastCmd
#debug usint LastCmd
 LD   usint 0
 GT
 LDX  LastCmd
#debug usint LastCmd
 LDX  MaxCmd
#debug usint MaxCmd
 GT
 NEG
 AND
 JMC  fbModbusTCPmas2_L3
#srcline 89 ;      ptr := ADR(Commands) + USINT_TO_UDINT(LastCmd-1) * sizeof(TCmdStructTCP);
 LDX  Commands
#debug pointer Commands
 LDX  LastCmd
#debug usint LastCmd
 LD   usint 1
 SUB
 AND  $FF
 LD   34  ; SizeOf()
 MUL
 ADD
 LEAX ptr
 WRIL 
#debug_left pointer ptr
#srcline 90 ;      // prepare localCmd
#srcline 91 ;      localCmd.Gr  := ptr^.Gr;
 LEAX ptr
 LDIL    ; dereference 
 LDI  
#debug usint ptr^.Gr
 WRX  localCmd~Gr
#debug_left usint localCmd.Gr
#srcline 92 ;      localCmd.SNo := ptr^.UnitID;    // od verze 1.6, starsi verze mely natvrdo 0
 LEAX ptr
 LDIL    ; dereference 
 ADD  24  ; + offset 
 LDI  
#debug usint ptr^.UnitID
 WRX  localCmd~SNo
#debug_left usint localCmd.SNo
#srcline 93 ;      localCmd.FNC := ptr^.FNC;
 LEAX ptr
 LDIL    ; dereference 
 ADD  25  ; + offset 
 LDI  
#debug usint ptr^.FNC
 WRX  localCmd~FNC
#debug_left usint localCmd.FNC
#srcline 94 ;      localCmd.StAdr := ptr^.StAdr;
 LEAX ptr
 LDIL    ; dereference 
 ADD  26  ; + offset 
 LDIW 
#debug uint ptr^.StAdr
 WRX  localCmd~StAdr
#debug_left uint localCmd.StAdr
#srcline 95 ;      localCmd.NoPoint := ptr^.NoPoint;
 LEAX ptr
 LDIL    ; dereference 
 ADD  28  ; + offset 
 LDIW 
#debug uint ptr^.NoPoint
 WRX  localCmd~NoPoint
#debug_left uint localCmd.NoPoint
#srcline 96 ;      localCmd.PtrData := ptr^.PtrData;
 LEAX ptr
 LDIL    ; dereference 
 ADD  30  ; + offset 
 LDIL 
#debug udint ptr^.PtrData
 WRX  localCmd~PtrData
#debug_left udint localCmd.PtrData
#srcline 97 ;    END_IF;
fbModbusTCPmas2_L3:
#srcline 98 ;  END_IF;
fbModbusTCPmas2_L1:
#srcline 100 ;  IF not EN THEN
 LDX  EN
#debug bool EN
 NEG
 JMC  fbModbusTCPmas2_L5
#srcline 101 ;    InitDone := false; LastCmd := 0; autoCmd := 0;
 LD   bool 0       ; false
 WRX  InitDone
#debug_left bool InitDone
 LD   usint 0
 WRX  LastCmd
#debug_left usint LastCmd
 LD   usint 0
 WRX  autoCmd
#debug_left usint autoCmd
#srcline 102 ;    Done := FALSE; ErrCode := 0;                     // clear error code
 LD   bool 0       ; false
 WRX  Done
#debug_left bool Done
 LD   usint 0
 WRX  ErrCode
#debug_left usint ErrCode
#srcline 103 ;    CloseTCPconnection( chanCode);
 NXT
 LDX  chanCode
#debug uint chanCode
 WR   __Instance__CloseTCPconnection~chanCode
#debug_left uint __Instance__CloseTCPconnection~chanCode
 PRV
 LEA  __Instance__CloseTCPconnection
 CAL  CloseTCPconnection_L0
#srcline 104 ;    State := MdbTCP_init;
 LD   udint 0  ; ModbusRTUlib_TStatesMdbTCP#MdbTCP_init
 WRX  State
#debug_left usint State
#srcline 105 ;    chkTim( IN := FALSE);                            // switch timer OFF
 LD   bool 0       ; false
 WRX  chkTim~IN
#debug_left bool chkTim~IN
 LEAX chkTim
 CAL  TON_L0
#srcline 106 ;  ELSE
 JMP  fbModbusTCPmas2_L6
fbModbusTCPmas2_L5:
#srcline 107 ;    chkTim( IN := state = lastState AND (state = MdbTCP_setIPadr OR state = MdbTCP_sendData), PT := MBtimeOut);  // check timer
 LDX  state
#debug usint state
 LDX  lastState
#debug usint lastState
 EQ
 LDX  state
#debug usint state
 LD   udint 3  ; ModbusRTUlib_TStatesMdbTCP#MdbTCP_setIPadr
 EQ
 LDX  state
#debug usint state
 LD   udint 5  ; ModbusRTUlib_TStatesMdbTCP#MdbTCP_sendData
 EQ
 OR  
 AND
 WRX  chkTim~IN
#debug_left bool chkTim~IN
 LDX  MBtimeOut
#debug time MBtimeOut
 WRX  chkTim~PT
#debug_left time chkTim~PT
 LEAX chkTim
 CAL  TON_L0
#srcline 108 ;    IF chkTim.Q THEN
 LDX  chkTim~Q
#debug bool chkTim.Q
 JMC  fbModbusTCPmas2_L7
#srcline 109 ;      CASE state OF
 LDX  state
#debug usint state
 WRY  P0__st__
 LD   3
 LDY  P0__st__
 EQ  
 JMC  fbModbusTCPmas2_L10
#srcline 110 ;        MdbTCP_setIPadr : ErrCode := 23 + 128;       // nelze nastavit IP adresu
 LD   usint 23
 LD   usint 128
 ADD
 AND  $FF
 WRX  ErrCode
#debug_left usint ErrCode
 JMP  fbModbusTCPmas2_L9
fbModbusTCPmas2_L10:
 LD   5
 LDY  P0__st__
 EQ  
 JMC  fbModbusTCPmas2_L11
#srcline 111 ;        MdbTCP_sendData : ErrCode := 21 + 128;       // nelze navazat TCP spojeni
 LD   usint 21
 LD   usint 128
 ADD
 AND  $FF
 WRX  ErrCode
#debug_left usint ErrCode
 JMP  fbModbusTCPmas2_L9
fbModbusTCPmas2_L11:
fbModbusTCPmas2_L9:
#srcline 113 ;      State := MdbTCP_error;
 LD   udint 7  ; ModbusRTUlib_TStatesMdbTCP#MdbTCP_error
 WRX  State
#debug_left usint State
#srcline 114 ;    END_IF;
fbModbusTCPmas2_L7:
#srcline 115 ;    lastState := state;
 LDX  state
#debug usint state
 WRX  lastState
#debug_left usint lastState
#srcline 117 ;    CASE state OF
 LDX  state
#debug usint state
 WRY  P1__st__
 LD   0
 LDY  P1__st__
 EQ  
 JMC  fbModbusTCPmas2_L13
#srcline 118 ;      //---------------------------------------------
#srcline 119 ;      MdbTCP_init :
#srcline 120 ;         //nasledujici dva radky byly zbytecne a mohly zavlect do newEthAdr localport nenulovou hodnotu
#srcline 121 ;         //ta mohla zpusobit problemy nize pokud byla vyplnena vzdalena IP a port v ini tabulce
#srcline 122 ;         //GetRemoteIPaddress( chanCode, newEthAdr);
#srcline 123 ;         //SetRemoteIPaddress( TRUE, chanCode, newEthAdr); // to be sure, what is starting IP address
#srcline 124 ;         CloseTCPconnection();   //pokud je EN aktivni jiz v prvnim cyklu, predejdeme zbytecnemu navazovani
 NXT
 LD   0
 WR   __Instance__CloseTCPconnection~chanCode
 PRV
 LEA  __Instance__CloseTCPconnection
 CAL  CloseTCPconnection_L0
#srcline 125 ;         wasStart := Start;
 LDX  Start
#debug bool Start
 WRX  wasStart
#debug_left bool wasStart
#srcline 126 ;         State := MdbTCP_start;
 LD   udint 1  ; ModbusRTUlib_TStatesMdbTCP#MdbTCP_start
 WRX  State
#debug_left usint State
 JMP  fbModbusTCPmas2_L12
fbModbusTCPmas2_L13:
 LD   1
 LDY  P1__st__
 EQ  
 JMC  fbModbusTCPmas2_L14
#srcline 127 ;         
#srcline 128 ;      //---------------------------------------------
#srcline 129 ;      MdbTCP_start :
#srcline 130 ;        Done := FALSE; ErrCode := 0;
 LD   bool 0       ; false
 WRX  Done
#debug_left bool Done
 LD   usint 0
 WRX  ErrCode
#debug_left usint ErrCode
#srcline 131 ;        IF GrSel = 0 THEN                            // manual
 LDX  GrSel
#debug usint GrSel
 LD   usint 0
 EQ
 JMC  fbModbusTCPmas2_L15
#srcline 132 ;          IF Start OR wasStart THEN
 LDX  Start
#debug bool Start
 LDX  wasStart
#debug bool wasStart
 OR  
 JMC  fbModbusTCPmas2_L17
#srcline 133 ;            lastCmd := CmdNo;
 LDX  CmdNo
#debug usint CmdNo
 WRX  lastCmd
#debug_left usint lastCmd
#srcline 134 ;            IF CmdNo > 0 and CmdNo <= MaxCmd THEN state := MdbTCP_selCommand; END_IF;
 LDX  CmdNo
#debug usint CmdNo
 LD   usint 0
 GT
 LDX  CmdNo
#debug usint CmdNo
 LDX  MaxCmd
#debug usint MaxCmd
 GT
 NEG
 AND
 JMC  fbModbusTCPmas2_L19
 LD   udint 2  ; ModbusRTUlib_TStatesMdbTCP#MdbTCP_selCommand
 WRX  state
#debug_left usint state
fbModbusTCPmas2_L19:
#srcline 135 ;          END_IF;
fbModbusTCPmas2_L17:
#srcline 136 ;        ELSE                                          // auto
 JMP  fbModbusTCPmas2_L16
fbModbusTCPmas2_L15:
#srcline 137 ;          state := MdbTCP_selCommand;
 LD   udint 2  ; ModbusRTUlib_TStatesMdbTCP#MdbTCP_selCommand
 WRX  state
#debug_left usint state
#srcline 138 ;          CmdFind := false;
 LD   bool 0       ; false
 WRY  CmdFind
#debug_left bool CmdFind
#srcline 139 ;          autoCmd := autoCmd + 1;
 LDX  autoCmd
#debug usint autoCmd
 LD   usint 1
 ADD
 AND  $FF
 WRX  autoCmd
#debug_left usint autoCmd
#srcline 140 ;          FOR tempCmd := autoCmd TO MaxCmd DO
 LDX  autoCmd
#debug usint autoCmd
 WRY  tempCmd
 LDX  MaxCmd
#debug usint MaxCmd
 WRY  P2__st__
fbModbusTCPmas2_L21:
 LDY  tempCmd
 LDY  P2__st__
 GT   
 JMD  fbModbusTCPmas2_L22
 DBG  
#srcline 141 ;            ptr := ADR(Commands) + USINT_TO_UDINT(tempCmd-1) * sizeof(TCmdStructTCP);
 LDX  Commands
#debug pointer Commands
 LDY  tempCmd
#debug usint tempCmd
 LD   usint 1
 SUB
 AND  $FF
 LD   34  ; SizeOf()
 MUL
 ADD
 LEAX ptr
 WRIL 
#debug_left pointer ptr
#srcline 142 ;            IF (((ptr^.Gr = GrSel) or (ptr^.Gr = 1)) and initDone) or
 LEAX ptr
 LDIL    ; dereference 
 LDI  
#debug usint ptr^.Gr
 LDX  GrSel
#debug usint GrSel
 EQ
 LEAX ptr
 LDIL    ; dereference 
 LDI  
#debug usint ptr^.Gr
 LD   usint 1
 EQ
 OR  
 LDX  initDone
#debug bool initDone
 AND
#srcline 143 ;                ((ptr^.Gr = 255)  and not initDone) THEN
 LEAX ptr
 LDIL    ; dereference 
 LDI  
#debug usint ptr^.Gr
 LD   usint 255
 EQ
 LDX  initDone
#debug bool initDone
 NEG
 AND
 OR  
 JMC  fbModbusTCPmas2_L23
#srcline 144 ;              autoCmd := tempCmd;
 LDY  tempCmd
#debug usint tempCmd
 WRX  autoCmd
#debug_left usint autoCmd
#srcline 145 ;              CmdFind := true;
 LD   bool -1       ; true
 WRY  CmdFind
#debug_left bool CmdFind
#srcline 146 ;              EXIT;
 JMP  fbModbusTCPmas2_L22
#srcline 147 ;            END_IF;
fbModbusTCPmas2_L23:
#srcline 148 ;//!!!            IF (ptr^.Gr = 0) THEN EXIT; END_IF;       // no record
#srcline 149 ;          END_FOR;
 LDY  tempCmd
 LD   1
 ADD  
 WRY  tempCmd
 JMP  fbModbusTCPmas2_L21
fbModbusTCPmas2_L22:
 NOP  -1
#srcline 150 ;          IF not CmdFind THEN
 LDY  CmdFind
#debug bool CmdFind
 NEG
 JMC  fbModbusTCPmas2_L25
#srcline 151 ;            IF not initDone THEN
 LDX  initDone
#debug bool initDone
 NEG
 JMC  fbModbusTCPmas2_L27
#srcline 152 ;              initDone := true;
 LD   bool -1       ; true
 WRX  initDone
#debug_left bool initDone
#srcline 153 ;            END_IF;
fbModbusTCPmas2_L27:
#srcline 154 ;            autoCmd := 0;
 LD   usint 0
 WRX  autoCmd
#debug_left usint autoCmd
#srcline 155 ;            state := MdbTCP_start;
 LD   udint 1  ; ModbusRTUlib_TStatesMdbTCP#MdbTCP_start
 WRX  state
#debug_left usint state
#srcline 156 ;          END_IF;
fbModbusTCPmas2_L25:
#srcline 157 ;          LastCmd := autoCmd;
 LDX  autoCmd
#debug usint autoCmd
 WRX  LastCmd
#debug_left usint LastCmd
#srcline 158 ;        END_IF;
fbModbusTCPmas2_L16:
#srcline 159 ;        wasStart := 0;
 LD   bool 0       ; false
 WRX  wasStart
#debug_left bool wasStart
 JMP  fbModbusTCPmas2_L12
fbModbusTCPmas2_L14:
 LD   2
 LDY  P1__st__
 EQ  
 JMC  fbModbusTCPmas2_L29
#srcline 160 ;      //---------------------------------------------
#srcline 161 ;      MdbTCP_selCommand :
#srcline 162 ;        ptr := ADR(Commands) + USINT_TO_UDINT(LastCmd-1) * sizeof(TCmdStructTCP);
 LDX  Commands
#debug pointer Commands
 LDX  LastCmd
#debug usint LastCmd
 LD   usint 1
 SUB
 AND  $FF
 LD   34  ; SizeOf()
 MUL
 ADD
 LEAX ptr
 WRIL 
#debug_left pointer ptr
#srcline 163 ;        // prepare localCmd
#srcline 164 ;        localCmd.Gr  := ptr^.Gr;
 LEAX ptr
 LDIL    ; dereference 
 LDI  
#debug usint ptr^.Gr
 WRX  localCmd~Gr
#debug_left usint localCmd.Gr
#srcline 165 ;        localCmd.SNo := ptr^.UnitID;    // od verze 1.6, starsi verze mely natvrdo 0
 LEAX ptr
 LDIL    ; dereference 
 ADD  24  ; + offset 
 LDI  
#debug usint ptr^.UnitID
 WRX  localCmd~SNo
#debug_left usint localCmd.SNo
#srcline 166 ;        localCmd.FNC := ptr^.FNC;
 LEAX ptr
 LDIL    ; dereference 
 ADD  25  ; + offset 
 LDI  
#debug usint ptr^.FNC
 WRX  localCmd~FNC
#debug_left usint localCmd.FNC
#srcline 167 ;        localCmd.StAdr := ptr^.StAdr;
 LEAX ptr
 LDIL    ; dereference 
 ADD  26  ; + offset 
 LDIW 
#debug uint ptr^.StAdr
 WRX  localCmd~StAdr
#debug_left uint localCmd.StAdr
#srcline 168 ;        localCmd.NoPoint := ptr^.NoPoint;
 LEAX ptr
 LDIL    ; dereference 
 ADD  28  ; + offset 
 LDIW 
#debug uint ptr^.NoPoint
 WRX  localCmd~NoPoint
#debug_left uint localCmd.NoPoint
#srcline 169 ;        localCmd.PtrData := ptr^.PtrData;
 LEAX ptr
 LDIL    ; dereference 
 ADD  30  ; + offset 
 LDIL 
#debug udint ptr^.PtrData
 WRX  localCmd~PtrData
#debug_left udint localCmd.PtrData
#srcline 170 ;        IF cantChangeIP THEN
 LDY  cantChangeIP
#debug bool cantChangeIP
 JMC  fbModbusTCPmas2_L30
#srcline 171 ;          IF isEstab THEN
 LDX  isEstab
#debug bool isEstab
 JMC  fbModbusTCPmas2_L32
#srcline 172 ;            send := TRUE;
 LD   bool -1       ; true
 WRX  send
#debug_left bool send
#srcline 173 ;            state := MdbTCP_recData;
 LD   udint 6  ; ModbusRTUlib_TStatesMdbTCP#MdbTCP_recData
 WRX  state
#debug_left usint state
#srcline 174 ;          ELSE
 JMP  fbModbusTCPmas2_L33
fbModbusTCPmas2_L32:
#srcline 175 ;            EstabTCPconnection( chanCode);
 NXT
 LDX  chanCode
#debug uint chanCode
 WR   __Instance__EstabTCPconnection~chanCode
#debug_left uint __Instance__EstabTCPconnection~chanCode
 PRV
 LEA  __Instance__EstabTCPconnection
 CAL  EstabTCPconnection_L0
#srcline 176 ;            state := MdbTCP_sendData;
 LD   udint 5  ; ModbusRTUlib_TStatesMdbTCP#MdbTCP_sendData
 WRX  state
#debug_left usint state
#srcline 177 ;          END_IF;
fbModbusTCPmas2_L33:
#srcline 178 ;        ELSE
 JMP  fbModbusTCPmas2_L31
fbModbusTCPmas2_L30:
#srcline 179 ;          // prepare IP address
#srcline 180 ;          tempPos := FIND( ptr^.IP, ':');
 LEAX ptr
 LDIL    ; dereference 
 ADD  1  ; + offset 
#debug string ptr^.IP
 LEA  _str_fbModbusTCPmas2_0
 SFND 
 WRY  tempPos
#debug_left int tempPos
#srcline 181 ;          IF tempPos = 0 THEN
 LDY  tempPos
#debug int tempPos
 EXTW 
 LD   int 0
 EQ
 JMC  fbModbusTCPmas2_L34
#srcline 182 ;            newEthAdr.remoteIP := STRING_TO_IPADR( ptr^.IP); newEthAdr.remotePort := 502;
 NXT
 LD   0   ; null string
 LEA  __Instance__STRING_TO_IPADR~IPAdr
 WRI 
 LEA  __Instance__STRING_TO_IPADR~IPAdr
 LD   80
 DST    ; Level 1
 LEAX ptr
 LDIL    ; dereference 
 ADD  1  ; + offset 
#debug string ptr^.IP
 SCON 
#debug_left string __Instance__STRING_TO_IPADR~IPAdr
 PDST   ; Level 1
 PRV
 LEA  __Instance__STRING_TO_IPADR
 CAL  STRING_TO_IPADR_L0
 LEAX newEthAdr~remoteIP
#debug_left pointer newEthAdr.remoteIP
 LD   4   ;SizeOf() 
 MOV  %IB0
 LD   uint 502
 WRX  newEthAdr~remotePort
#debug_left uint newEthAdr.remotePort
#srcline 183 ;          ELSE
 JMP  fbModbusTCPmas2_L35
fbModbusTCPmas2_L34:
#srcline 184 ;            tempStr := LEFT( ptr^.IP, tempPos-1); newEthAdr.remoteIP := STRING_TO_IPADR( tempStr);
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   80
 DST    ; Level 1
 LEAX ptr
 LDIL    ; dereference 
 ADD  1  ; + offset 
#debug string ptr^.IP
 LDY  tempPos
#debug int tempPos
 EXTW 
 LD   int 1
 SUB
 EXTW
 SLFT 
 PDST   ; Level 1
 LD   0   ; null string
 LEAY tempStr
 WRI  
 LEAY tempStr
 LD   80
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string tempStr
 PDST   ; Level 1
 NXT
 LD   0   ; null string
 LEA  __Instance__STRING_TO_IPADR~IPAdr
 WRI 
 LEA  __Instance__STRING_TO_IPADR~IPAdr
 LD   80
 DST    ; Level 1
 LEAY tempStr
#debug string tempStr
 SCON 
#debug_left string __Instance__STRING_TO_IPADR~IPAdr
 PDST   ; Level 1
 PRV
 LEA  __Instance__STRING_TO_IPADR
 CAL  STRING_TO_IPADR_L0
 LEAX newEthAdr~remoteIP
#debug_left pointer newEthAdr.remoteIP
 LD   4   ;SizeOf() 
 MOV  %IB0
#srcline 185 ;            tempStr := MID( ptr^.IP, 5, tempPos+1); newEthAdr.remotePort := STRING_TO_UINT(tempStr);
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   80
 DST    ; Level 1
 LEAX ptr
 LDIL    ; dereference 
 ADD  1  ; + offset 
#debug string ptr^.IP
 LD   5
 LDY  tempPos
#debug int tempPos
 EXTW 
 LD   int 1
 ADD
 EXTW
 SUB  1
 SMID 
 PDST   ; Level 1
 LD   0   ; null string
 LEAY tempStr
 WRI  
 LEAY tempStr
 LD   80
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string tempStr
 PDST   ; Level 1
 LEAY tempStr
#debug string tempStr
 SCNV $300A;  IEC_STRING _TO_ IEC_UINT
 WRX  newEthAdr~remotePort
#debug_left uint newEthAdr.remotePort
#srcline 186 ;          END_IF;
fbModbusTCPmas2_L35:
#srcline 187 ;          // check new IP address
#srcline 188 ;          IF newEthAdr.remoteIP[0] = 0 AND newEthAdr.remoteIP[1] = 0 AND newEthAdr.remoteIP[2] = 0 AND newEthAdr.remoteIP[3] = 0 THEN
 LDX  newEthAdr~remoteIP[0]
#debug usint newEthAdr.remoteIP[0]
 LD   usint 0
 EQ
 LDX  newEthAdr~remoteIP[1]
#debug usint newEthAdr.remoteIP[1]
 LD   usint 0
 EQ
 AND
 LDX  newEthAdr~remoteIP[2]
#debug usint newEthAdr.remoteIP[2]
 LD   usint 0
 EQ
 AND
 LDX  newEthAdr~remoteIP[3]
#debug usint newEthAdr.remoteIP[3]
 LD   usint 0
 EQ
 AND
 JMC  fbModbusTCPmas2_L36
#srcline 189 ;            ErrCode := 22 + 128;                           // chybna IP adresa
 LD   usint 22
 LD   usint 128
 ADD
 AND  $FF
 WRX  ErrCode
#debug_left usint ErrCode
#srcline 190 ;            state := MdbTCP_error;
 LD   udint 7  ; ModbusRTUlib_TStatesMdbTCP#MdbTCP_error
 WRX  state
#debug_left usint state
#srcline 191 ;          ELSE
 JMP  fbModbusTCPmas2_L37
fbModbusTCPmas2_L36:
#srcline 192 ;            // set IP address
#srcline 193 ;            GetRemoteIPaddress( chanCode, lastEthAdr);
 NXT
 LDX  chanCode
#debug uint chanCode
 WR   __Instance__GetRemoteIPaddress~chanCode
#debug_left uint __Instance__GetRemoteIPaddress~chanCode
 LEAY lastEthAdr
 WR   __Instance__GetRemoteIPaddress~ethAdr
#debug_left pointer __Instance__GetRemoteIPaddress.ethAdr
 PRV
 LEA  __Instance__GetRemoteIPaddress
 CAL  GetRemoteIPaddress_L0
#srcline 194 ;            IF lastEthAdr.remoteIP <> newEthAdr.remoteIP OR lastEthAdr.remotePort <> newEthAdr.remotePort THEN
 LEAY lastEthAdr~remoteIP
 LEAX newEthAdr~remoteIP
 LD   4   ; SizeOf()
 BCMP 
 EQ   0
 NEG
 LDY  lastEthAdr~remotePort
#debug uint lastEthAdr.remotePort
 LDX  newEthAdr~remotePort
#debug uint newEthAdr.remotePort
 EQ
 NEG
 OR  
 JMC  fbModbusTCPmas2_L38
#srcline 195 ;              newEthAdr.localPort := 0;                    // local port is done by TCP driver
 LD   uint 0
 WRX  newEthAdr~localPort
#debug_left uint newEthAdr.localPort
#srcline 196 ;              CloseTCPconnection( chanCode);               // then we must close it
 NXT
 LDX  chanCode
#debug uint chanCode
 WR   __Instance__CloseTCPconnection~chanCode
#debug_left uint __Instance__CloseTCPconnection~chanCode
 PRV
 LEA  __Instance__CloseTCPconnection
 CAL  CloseTCPconnection_L0
#srcline 197 ;              state := MdbTCP_setIPadr;
 LD   udint 3  ; ModbusRTUlib_TStatesMdbTCP#MdbTCP_setIPadr
 WRX  state
#debug_left usint state
#srcline 198 ;            ELSE
 JMP  fbModbusTCPmas2_L39
fbModbusTCPmas2_L38:
#srcline 199 ;              IF isEstab THEN
 LDX  isEstab
#debug bool isEstab
 JMC  fbModbusTCPmas2_L40
#srcline 200 ;                send := TRUE;
 LD   bool -1       ; true
 WRX  send
#debug_left bool send
#srcline 201 ;                state := MdbTCP_recData;
 LD   udint 6  ; ModbusRTUlib_TStatesMdbTCP#MdbTCP_recData
 WRX  state
#debug_left usint state
#srcline 202 ;              ELSE
 JMP  fbModbusTCPmas2_L41
fbModbusTCPmas2_L40:
#srcline 203 ;                EstabTCPconnection( chanCode);
 NXT
 LDX  chanCode
#debug uint chanCode
 WR   __Instance__EstabTCPconnection~chanCode
#debug_left uint __Instance__EstabTCPconnection~chanCode
 PRV
 LEA  __Instance__EstabTCPconnection
 CAL  EstabTCPconnection_L0
#srcline 204 ;                state := MdbTCP_sendData;
 LD   udint 5  ; ModbusRTUlib_TStatesMdbTCP#MdbTCP_sendData
 WRX  state
#debug_left usint state
#srcline 205 ;              END_IF;
fbModbusTCPmas2_L41:
#srcline 206 ;            END_IF;
fbModbusTCPmas2_L39:
#srcline 207 ;          END_IF;
fbModbusTCPmas2_L37:
#srcline 208 ;        END_IF;
fbModbusTCPmas2_L31:
 JMP  fbModbusTCPmas2_L12
fbModbusTCPmas2_L29:
 LD   3
 LDY  P1__st__
 EQ  
 JMC  fbModbusTCPmas2_L42
#srcline 210 ;      //---------------------------------------------
#srcline 211 ;      MdbTCP_setIPadr :
#srcline 212 ;        IF NOT isEstab THEN        // if connection closed
 LDX  isEstab
#debug bool isEstab
 NEG
 JMC  fbModbusTCPmas2_L43
#srcline 213 ;          SetRemoteIPaddress( TRUE, chanCode, newEthAdr);  // set new IP address
 NXT
 LD   bool -1       ; true
 WR   __Instance__SetRemoteIPaddress~rq
#debug_left bool __Instance__SetRemoteIPaddress~rq
 LDX  chanCode
#debug uint chanCode
 WR   __Instance__SetRemoteIPaddress~chanCode
#debug_left uint __Instance__SetRemoteIPaddress~chanCode
 LEAX newEthAdr
 WR   __Instance__SetRemoteIPaddress~ethAdr
#debug_left pointer __Instance__SetRemoteIPaddress.ethAdr
 PRV
 LEA  __Instance__SetRemoteIPaddress
 CAL  SetRemoteIPaddress_L0
#srcline 214 ;          state := MdbTCP_estabCon;
 LD   udint 4  ; ModbusRTUlib_TStatesMdbTCP#MdbTCP_estabCon
 WRX  state
#debug_left usint state
#srcline 215 ;        END_IF;
fbModbusTCPmas2_L43:
 JMP  fbModbusTCPmas2_L12
fbModbusTCPmas2_L42:
 LD   4
 LDY  P1__st__
 EQ  
 JMC  fbModbusTCPmas2_L45
#srcline 217 ;      //---------------------------------------------
#srcline 218 ;      MdbTCP_estabCon :
#srcline 219 ;        EstabTCPconnection( chanCode);                   // establish connection
 NXT
 LDX  chanCode
#debug uint chanCode
 WR   __Instance__EstabTCPconnection~chanCode
#debug_left uint __Instance__EstabTCPconnection~chanCode
 PRV
 LEA  __Instance__EstabTCPconnection
 CAL  EstabTCPconnection_L0
#srcline 220 ;        state := MdbTCP_sendData;
 LD   udint 5  ; ModbusRTUlib_TStatesMdbTCP#MdbTCP_sendData
 WRX  state
#debug_left usint state
 JMP  fbModbusTCPmas2_L12
fbModbusTCPmas2_L45:
 LD   5
 LDY  P1__st__
 EQ  
 JMC  fbModbusTCPmas2_L46
#srcline 222 ;      //---------------------------------------------
#srcline 223 ;      MdbTCP_sendData :
#srcline 224 ;        IF isEstab THEN            // if connection established
 LDX  isEstab
#debug bool isEstab
 JMC  fbModbusTCPmas2_L47
#srcline 225 ;          send := TRUE;                         // send message
 LD   bool -1       ; true
 WRX  send
#debug_left bool send
#srcline 226 ;          state := MdbTCP_recData;
 LD   udint 6  ; ModbusRTUlib_TStatesMdbTCP#MdbTCP_recData
 WRX  state
#debug_left usint state
#srcline 227 ;        END_IF;
fbModbusTCPmas2_L47:
 JMP  fbModbusTCPmas2_L12
fbModbusTCPmas2_L46:
 LD   6
 LDY  P1__st__
 EQ  
 JMC  fbModbusTCPmas2_L49
#srcline 229 ;      //---------------------------------------------
#srcline 230 ;      MdbTCP_recData :
#srcline 231 ;        //modbusRTU.Start := FALSE;
#srcline 232 ;        IF modbusRTU.Done THEN                             // wait for answer
 LDX  modbusRTU~Done
#debug bool modbusRTU.Done
 JMC  fbModbusTCPmas2_L50
#srcline 233 ;          ErrCode := modbusRTU.ErrCode;
 LDX  modbusRTU~ErrCode
#debug usint modbusRTU.ErrCode
 WRX  ErrCode
#debug_left usint ErrCode
#srcline 234 ;          IF ErrCode = 0 OR (ErrCode > 136 & ErrCode < 143) THEN
 LDX  ErrCode
#debug usint ErrCode
 LD   usint 0
 EQ
 LDX  ErrCode
#debug usint ErrCode
 LD   usint 136
 GT
 LDX  ErrCode
#debug usint ErrCode
 LD   usint 143
 LT
 AND
 OR  
 JMC  fbModbusTCPmas2_L52
#srcline 235 ;            state := MdbTCP_start; Done := TRUE;
 LD   udint 1  ; ModbusRTUlib_TStatesMdbTCP#MdbTCP_start
 WRX  state
#debug_left usint state
 LD   bool -1       ; true
 WRX  Done
#debug_left bool Done
#srcline 236 ;          ELSE
 JMP  fbModbusTCPmas2_L53
fbModbusTCPmas2_L52:
#srcline 237 ;            state := MdbTCP_error;
 LD   udint 7  ; ModbusRTUlib_TStatesMdbTCP#MdbTCP_error
 WRX  state
#debug_left usint state
#srcline 238 ;          END_IF;
fbModbusTCPmas2_L53:
#srcline 239 ;        END_IF;
fbModbusTCPmas2_L50:
 JMP  fbModbusTCPmas2_L12
fbModbusTCPmas2_L49:
 LD   7
 LDY  P1__st__
 EQ  
 JMC  fbModbusTCPmas2_L54
#srcline 240 ;      //---------------------------------------------
#srcline 241 ;      MdbTCP_error :
#srcline 242 ;        CloseTCPconnection( chanCode);                     // then we must close it
 NXT
 LDX  chanCode
#debug uint chanCode
 WR   __Instance__CloseTCPconnection~chanCode
#debug_left uint __Instance__CloseTCPconnection~chanCode
 PRV
 LEA  __Instance__CloseTCPconnection
 CAL  CloseTCPconnection_L0
#srcline 243 ;        IF NOT isEstab THEN        // if connection closed
 LDX  isEstab
#debug bool isEstab
 NEG
 JMC  fbModbusTCPmas2_L55
#srcline 244 ;Done := TRUE;  //!!!
 LD   bool -1       ; true
 WRX  Done
#debug_left bool Done
#srcline 245 ;          State := MdbTCP_start;                           // another slave device
 LD   udint 1  ; ModbusRTUlib_TStatesMdbTCP#MdbTCP_start
 WRX  State
#debug_left usint State
#srcline 246 ;        END_IF;
fbModbusTCPmas2_L55:
 JMP  fbModbusTCPmas2_L12
fbModbusTCPmas2_L54:
#srcline 248 ;    ELSE
#srcline 249 ;      state := MdbTCP_start;
 LD   udint 1  ; ModbusRTUlib_TStatesMdbTCP#MdbTCP_start
 WRX  state
#debug_left usint state
#srcline 250 ;    END_CASE;
fbModbusTCPmas2_L12:
#srcline 251 ;  END_IF;
fbModbusTCPmas2_L6:
#srcline 253 ;  IF send THEN
 LDX  send
#debug bool send
 JMC  fbModbusTCPmas2_L57
#srcline 254 ;    IF NOT delayActive OR DelayTimeOut.Q THEN
 LDX  delayActive
#debug bool delayActive
 NEG
 LDX  DelayTimeOut~Q
#debug bool DelayTimeOut.Q
 OR  
 JMC  fbModbusTCPmas2_L59
#srcline 255 ;      modbusRTU.Start := true;
 LD   bool -1       ; true
 WRX  modbusRTU~Start
#debug_left bool modbusRTU.Start
#srcline 256 ;      send := false;
 LD   bool 0       ; false
 WRX  send
#debug_left bool send
#srcline 257 ;    END_IF;
fbModbusTCPmas2_L59:
#srcline 258 ;  END_IF;
fbModbusTCPmas2_L57:
#srcline 259 ;//  GetRemoteIPaddress( chanCode, curEthAdr);
#srcline 260 ;  modbusRTU( EN := EN,  GrSel := 0(*manualne*), CmdNo := 1(*index v localCmd*), //Start := (*BOOL R_EDGE*),
 LDX  EN
#debug bool EN
 WRX  modbusRTU~EN
#debug_left bool modbusRTU~EN
 LD   usint 0
 WRX  modbusRTU~GrSel
#debug_left usint modbusRTU~GrSel
 LD   usint 1
 WRX  modbusRTU~CmdNo
#debug_left usint modbusRTU~CmdNo
#srcline 261 ;             MaxCmd := 1, chanCode := chanCode, Endian := Endian, MBtimeOut := MBtimeOut, Commands := localCmd);
 LD   usint 1
 WRX  modbusRTU~MaxCmd
#debug_left usint modbusRTU~MaxCmd
 LDX  chanCode
#debug uint chanCode
 WRX  modbusRTU~chanCode
#debug_left uint modbusRTU~chanCode
 LDX  Endian
#debug bool Endian
 WRX  modbusRTU~Endian
#debug_left bool modbusRTU~Endian
 LDX  MBtimeOut
#debug time MBtimeOut
 WRX  modbusRTU~MBtimeOut
#debug_left time modbusRTU~MBtimeOut
 LEAX localCmd
 WRX  modbusRTU~Commands
#debug_left pointer modbusRTU.Commands
 LEAX modbusRTU
 CAL  fbModbusRTUmas2_L0
#srcline 262 ;  modbusRTU.Start := false;
 LD   bool 0       ; false
 WRX  modbusRTU~Start
#debug_left bool modbusRTU.Start
#srcline 264 ;  IF modbusRTU.Done THEN
 LDX  modbusRTU~Done
#debug bool modbusRTU.Done
 JMC  fbModbusTCPmas2_L61
#srcline 265 ;    delayActive := modbusRTU.ErrCode = 0 OR (ErrCode > 136 & ErrCode < 143) ; //aktivuje delay pokud jsme dostali odpoved, deaktivuje pokud nebyla
 LDX  modbusRTU~ErrCode
#debug usint modbusRTU.ErrCode
 LD   usint 0
 EQ
 LDX  ErrCode
#debug usint ErrCode
 LD   usint 136
 GT
 LDX  ErrCode
#debug usint ErrCode
 LD   usint 143
 LT
 AND
 OR  
 WRX  delayActive
#debug_left bool delayActive
#srcline 266 ;  END_IF;
fbModbusTCPmas2_L61:
#srcline 267 ;             
#srcline 268 ;  DelayTimeOut(IN := delayActive AND NOT modbusRTU.Done, PT := Delay); //timeout between messages
 LDX  delayActive
#debug bool delayActive
 LDX  modbusRTU~Done
#debug bool modbusRTU.Done
 NEG
 AND
 WRX  DelayTimeOut~IN
#debug_left bool DelayTimeOut~IN
 LDX  Delay
#debug time Delay
 WRX  DelayTimeOut~PT
#debug_left time DelayTimeOut~PT
 LEAX DelayTimeOut
 CAL  TON_L0
#srcline 269 ;END_FUNCTION_BLOCK
 ULNK
RET
E     61

; Initialize - variables
P     61
fbModbusTCPmas2__InstanceInit__:
 LINK 0
 LD   time 2000
 WRX  MBtimeOut
 LD   udint $FFFFFFFF    ; nil
 WRX  ptr
 LD   0
 SRC  byte __Init___fbModbusTCPmas2_modbusRTU
 LEAX byte modbusRTU
 LD   633
 MOV  %X0
 ULNK
RET
E     61
; End initialize - variables
#endpou 



 

#srcfile ''
#srcfile 'C:\TECOLIBSRC\MODBUSRTU\MODBUSRTU\FBRECVFROM.ST'
#pou fbRecvFromModbus
#srcline 1 ;FUNCTION_BLOCK fbRecvFromModbus
P     61
fbRecvFromModbus_L0:
 LINK 0
#srcline 37 ;  IF reset OR NOT IsEstabTCPconnection(chanCode := chanCode) THEN
 LDX  reset
#debug bool reset
 NXT
 LDX  chanCode
#debug uint chanCode
 WR   __Instance__IsEstabTCPconnection~chanCode
#debug_left uint __Instance__IsEstabTCPconnection~chanCode
 PRV
 LEA  __Instance__IsEstabTCPconnection
 CAL  IsEstabTCPconnection_L0
 NEG
 OR  
 JMC  fbRecvFromModbus_L1
#srcline 38 ;    lenBuf := 0;
 LD   uint 0
 WRX  lenBuf
#debug_left uint lenBuf
#srcline 39 ;  END_IF;
fbRecvFromModbus_L1:
#srcline 40 ;  //posunout adresu bufferu
#srcline 41 ;  {ASM}
#srcline 42
  LDX buffer
#srcline 43
  LDX lenBuf
#srcline 44
  ADD
#srcline 45
  WRX buffer
#srcline 46 ;  {END_ASM}
#srcline 47 ;  
#srcline 48 ;  mesRec := false;
 LD   bool 0       ; false
 WRX  mesRec
#debug_left bool mesRec
#srcline 49 ;  recvFrom(rq := rq, chanCode := chanCode, lenRx := MIN(lenRx, sizeBuf - lenBuf), data := void(buffer), error => error);
 LDX  rq
#debug bool rq
 WRX  recvFrom~rq
#debug_left bool recvFrom~rq
 LDX  chanCode
#debug uint chanCode
 WRX  recvFrom~chanCode
#debug_left uint recvFrom~chanCode
 LDX  lenRx
#debug uint lenRx
 LDX  sizeBuf
#debug uint sizeBuf
 LDX  lenBuf
#debug uint lenBuf
 SUB
 AND  $FFFF
 MIN
 WRX  recvFrom~lenRx
#debug_left uint recvFrom~lenRx
 LDX  buffer
 WRX  recvFrom~data
#debug_left pointer recvFrom.data
 LEAX recvFrom
 CAL  fbRecvFrom_L0
; output assigment 
 LDX  recvFrom~error
#debug usint recvFrom~error
 WRX  error
#debug_left usint error
#srcline 50 ;  bufFul := error = COM_ERR3;
 LDX  error
#debug usint error
 LD   usint 3
 EQ
 WRX  bufFul
#debug_left bool bufFul
#srcline 52 ;  //srovna zpet
#srcline 53 ;  {ASM}
#srcline 54
  LDX buffer
#srcline 55
  LDX lenBuf
#srcline 56
  SUB
#srcline 57
  WRX  buffer
#srcline 58 ;  {END_ASM}
#srcline 60 ;  IF recvFrom.mesRec THEN
 LDX  recvFrom~mesRec
#debug bool recvFrom.mesRec
 JMC  fbRecvFromModbus_L3
#srcline 61 ;    lenBuf := lenBuf + recvFrom.lenData;
 LDX  lenBuf
#debug uint lenBuf
 LDX  recvFrom~lenData
#debug uint recvFrom.lenData
 ADD
 AND  $FFFF
 WRX  lenBuf
#debug_left uint lenBuf
#srcline 62 ;  END_IF;
fbRecvFromModbus_L3:
#srcline 64 ;  //check packet
#srcline 65 ;  IF lenBuf >= 6 THEN //header received
 LDX  lenBuf
#debug uint lenBuf
 LD   uint 6
 LT
 NEG
 JMC  fbRecvFromModbus_L5
#srcline 66 ;    ptrToUint := ADR(buffer) + 4; //pointer na delku
 LDX  buffer
#debug pointer buffer
 LD   udint 4
 ADD
 LEAX ptrToUint
 WRIL 
#debug_left pointer ptrToUint
#srcline 67 ;    {ASM}
#srcline 68
    ;swap lenBuf
#srcline 69
    LDX  ptrToUint
#srcline 70
    LDIW
#srcline 71
    SWP
#srcline 72
    ADD  6
#srcline 73
    WRX  lenBufNet
#srcline 74 ;    {END_ASM}
#srcline 75 ;    
#srcline 76 ;    IF lenBufNet <= lenBuf THEN //we have all data
 LDX  lenBufNet
#debug uint lenBufNet
 LDX  lenBuf
#debug uint lenBuf
 GT
 NEG
 JMC  fbRecvFromModbus_L7
#srcline 77 ;      lenData := lenBufNet;
 LDX  lenBufNet
#debug uint lenBufNet
 WRX  lenData
#debug_left uint lenData
#srcline 78 ;      Memcpy(length := lenData, source := buffer, dest := data[0]);
 NXT
 LDX  lenData
#debug uint lenData
 WR   __Instance__Memcpy~length
#debug_left uint __Instance__Memcpy~length
 LDX  buffer
 WR   __Instance__Memcpy~source
#debug_left pointer __Instance__Memcpy.source
 LDX  data
 WR   __Instance__Memcpy~dest
#debug_left pointer __Instance__Memcpy.dest
 PRV
 LEA  __Instance__Memcpy
 CAL  Memcpy_L0
#srcline 79 ;      lenBuf := lenBuf - lenData;
 LDX  lenBuf
#debug uint lenBuf
 LDX  lenData
#debug uint lenData
 SUB
 AND  $FFFF
 WRX  lenBuf
#debug_left uint lenBuf
#srcline 80 ;      MemcpyEx(length := UINT_TO_UDINT(lenBuf), offSource := UINT_TO_UDINT(lenData), source := buffer, dest := buffer);
 NXT
 LDX  lenBuf
#debug uint lenBuf
 WR   __Instance__MemcpyEx~length
#debug_left udint __Instance__MemcpyEx~length
 LDX  lenData
#debug uint lenData
 WR   __Instance__MemcpyEx~offSource
#debug_left udint __Instance__MemcpyEx~offSource
 LDX  buffer
 WR   __Instance__MemcpyEx~source
#debug_left pointer __Instance__MemcpyEx.source
 LDX  buffer
 WR   __Instance__MemcpyEx~dest
#debug_left pointer __Instance__MemcpyEx.dest
 LD   0
 WR   __Instance__MemcpyEx~offDest
 PRV
 LEA  __Instance__MemcpyEx
 CAL  MemcpyEx_L0
#srcline 81 ;      mesRec := true;
 LD   bool -1       ; true
 WRX  mesRec
#debug_left bool mesRec
#srcline 82 ;    END_IF;
fbRecvFromModbus_L7:
#srcline 83 ;  END_IF;
fbRecvFromModbus_L5:
#srcline 85 ;  
#srcline 86 ;  
#srcline 87 ;  
#srcline 88 ;END_FUNCTION_BLOCK
 ULNK
RET
E     61

; Initialize - variables
P     61
fbRecvFromModbus__InstanceInit__:
 LINK 0
 LEAX recvFrom
 CAL  fbRecvFrom__InstanceInit__
 LD   udint $FFFFFFFF    ; nil
 WRX  ptrToUint
 ULNK
RET
E     61
; End initialize - variables
#endpou 



 

#srcfile ''
#srcfile 'C:\TECOLIBSRC\MODBUSRTU\MODBUSRTU\MODBUSTCPDELAYSENDMAS.ST'
#pou ModbusTcpDelaySendmas
#srcline 1 ;FUNCTION_BLOCK ModbusTcpDelaySendmas {HIDDEN}
#table byte __Init___ModbusTcpDelaySendmas_modbusRTU = 
      0,  0,  0,  0,  0,  0,  0,  0,208,  7,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  2;

#struct ModbusTcpDelaySendmas__temp__
  pointer ptr,  ; {ENU} Structure for control of Modbus TCP master FB {CSY} Struktura pro øízení funkèního bloku Modbus TCP master
  bool CmdFind,  ; GrSel find
  bool cantChangeIP,
  usint tempCmd,
  int tempPos,
  string[81] tempStr,
  TRemoteEthAdr lastEthAdr,
  usint P0__st__,
  usint P1__st__,
  usint P2__st__,
  string[82] PS0__st__
#data byte _str_ModbusTcpDelaySendmas_0 = 
  ':',0
P     61
ModbusTcpDelaySendmas_L0:
 LINK __SizeOf(ModbusTcpDelaySendmas__temp__)
; Initialize - dynamic variables
 LD   udint $FFFFFFFF    ; nil
 WRY  ptr
; End initialize - dynamic variables
; R_EDGE, F_EDGE 
 LDX  Start
 LETX __EDGE_R__Start
 WRX  Start
#srcline 77 ;  cantChangeIP := (UINT_TO_WORD(chanCode) and 16#00FF <> 16#00E1) AND ((System_S.S42 = 16#4B) OR (System_S.S42 = 16#4C));
 LDX  chanCode
#debug uint chanCode
 LD   word $00FF
 AND
 LD   word $00E1
 EQ
 NEG
 LD   System_S~S42
#debug byte System_S.S42
 LD   byte $4B
 EQ
 LD   System_S~S42
#debug byte System_S.S42
 LD   byte $4C
 EQ
 OR  
 AND
 WRY  cantChangeIP
#debug_left bool cantChangeIP
#srcline 78 ;  //  ErrCode := 20 + 128; RETURN;                     // kod kanalu musi byt ETH1_uni
#srcline 79 ;  //END_IF;  // TCP
#srcline 81 ;  isEstab := IsEstabTCPconnection(chanCode := chanCode);
 NXT
 LDX  chanCode
#debug uint chanCode
 WR   __Instance__IsEstabTCPconnection~chanCode
#debug_left uint __Instance__IsEstabTCPconnection~chanCode
 PRV
 LEA  __Instance__IsEstabTCPconnection
 CAL  IsEstabTCPconnection_L0
 WRX  isEstab
#debug_left bool isEstab
#srcline 83 ;  IF ProgramIsChanged() THEN
 LEA  __Instance__ProgramIsChanged
 CAL  ProgramIsChanged_L0
 JMC  ModbusTcpDelaySendmas_L1
#srcline 84 ;    IF LastCmd > 0 AND LastCmd <= MaxCmd THEN
 LDX  LastCmd
#debug usint LastCmd
 LD   usint 0
 GT
 LDX  LastCmd
#debug usint LastCmd
 LDX  MaxCmd
#debug usint MaxCmd
 GT
 NEG
 AND
 JMC  ModbusTcpDelaySendmas_L3
#srcline 85 ;      ptr := ADR(Commands) + USINT_TO_UDINT(LastCmd-1) * sizeof(TCmdStructTCP);
 LDX  Commands
#debug pointer Commands
 LDX  LastCmd
#debug usint LastCmd
 LD   usint 1
 SUB
 AND  $FF
 LD   34  ; SizeOf()
 MUL
 ADD
 LEAY ptr
 WRIL 
#debug_left pointer ptr
#srcline 86 ;      // prepare localCmd
#srcline 87 ;      localCmd.Gr  := ptr^.Gr;
 LEAY ptr
 LDIL    ; dereference 
 LDI  
#debug usint ptr^.Gr
 WRX  localCmd~Gr
#debug_left usint localCmd.Gr
#srcline 88 ;      localCmd.SNo := ptr^.UnitID;    // od verze 1.6, starsi verze mely natvrdo 0
 LEAY ptr
 LDIL    ; dereference 
 ADD  24  ; + offset 
 LDI  
#debug usint ptr^.UnitID
 WRX  localCmd~SNo
#debug_left usint localCmd.SNo
#srcline 89 ;      localCmd.FNC := ptr^.FNC;
 LEAY ptr
 LDIL    ; dereference 
 ADD  25  ; + offset 
 LDI  
#debug usint ptr^.FNC
 WRX  localCmd~FNC
#debug_left usint localCmd.FNC
#srcline 90 ;      localCmd.StAdr := ptr^.StAdr;
 LEAY ptr
 LDIL    ; dereference 
 ADD  26  ; + offset 
 LDIW 
#debug uint ptr^.StAdr
 WRX  localCmd~StAdr
#debug_left uint localCmd.StAdr
#srcline 91 ;      localCmd.NoPoint := ptr^.NoPoint;
 LEAY ptr
 LDIL    ; dereference 
 ADD  28  ; + offset 
 LDIW 
#debug uint ptr^.NoPoint
 WRX  localCmd~NoPoint
#debug_left uint localCmd.NoPoint
#srcline 92 ;      localCmd.PtrData := ptr^.PtrData;
 LEAY ptr
 LDIL    ; dereference 
 ADD  30  ; + offset 
 LDIL 
#debug udint ptr^.PtrData
 WRX  localCmd~PtrData
#debug_left udint localCmd.PtrData
#srcline 93 ;    END_IF;
ModbusTcpDelaySendmas_L3:
#srcline 94 ;  END_IF;
ModbusTcpDelaySendmas_L1:
#srcline 96 ;  delaySend(IN := State = MdbTCP_sendData AND isEstab, PT := MBdelay);
 LDX  State
#debug usint State
 LD   udint 5  ; ModbusRTUlib_TStatesMdbTCP#MdbTCP_sendData
 EQ
 LDX  isEstab
#debug bool isEstab
 AND
 WRX  delaySend~IN
#debug_left bool delaySend~IN
 LDX  MBdelay
#debug time MBdelay
 WRX  delaySend~PT
#debug_left time delaySend~PT
 LEAX delaySend
 CAL  TON_L0
#srcline 98 ;  IF not EN THEN
 LDX  EN
#debug bool EN
 NEG
 JMC  ModbusTcpDelaySendmas_L5
#srcline 99 ;    InitDone := false; LastCmd := 0; autoCmd := 0;
 LD   bool 0       ; false
 WRX  InitDone
#debug_left bool InitDone
 LD   usint 0
 WRX  LastCmd
#debug_left usint LastCmd
 LD   usint 0
 WRX  autoCmd
#debug_left usint autoCmd
#srcline 100 ;    Done := FALSE; ErrCode := 0;                     // clear error code
 LD   bool 0       ; false
 WRX  Done
#debug_left bool Done
 LD   usint 0
 WRX  ErrCode
#debug_left usint ErrCode
#srcline 101 ;    CloseTCPconnection( chanCode);
 NXT
 LDX  chanCode
#debug uint chanCode
 WR   __Instance__CloseTCPconnection~chanCode
#debug_left uint __Instance__CloseTCPconnection~chanCode
 PRV
 LEA  __Instance__CloseTCPconnection
 CAL  CloseTCPconnection_L0
#srcline 102 ;    State := MdbTCP_init;
 LD   udint 0  ; ModbusRTUlib_TStatesMdbTCP#MdbTCP_init
 WRX  State
#debug_left usint State
#srcline 103 ;    chkTim( IN := FALSE);                            // switch timer OFF
 LD   bool 0       ; false
 WRX  chkTim~IN
#debug_left bool chkTim~IN
 LEAX chkTim
 CAL  TON_L0
#srcline 104 ;  ELSE
 JMP  ModbusTcpDelaySendmas_L6
ModbusTcpDelaySendmas_L5:
#srcline 105 ;    chkTim( IN := state = lastState AND (state = MdbTCP_setIPadr OR state = MdbTCP_sendData), PT := MBtimeOut);  // check timer
 LDX  state
#debug usint state
 LDX  lastState
#debug usint lastState
 EQ
 LDX  state
#debug usint state
 LD   udint 3  ; ModbusRTUlib_TStatesMdbTCP#MdbTCP_setIPadr
 EQ
 LDX  state
#debug usint state
 LD   udint 5  ; ModbusRTUlib_TStatesMdbTCP#MdbTCP_sendData
 EQ
 OR  
 AND
 WRX  chkTim~IN
#debug_left bool chkTim~IN
 LDX  MBtimeOut
#debug time MBtimeOut
 WRX  chkTim~PT
#debug_left time chkTim~PT
 LEAX chkTim
 CAL  TON_L0
#srcline 106 ;    IF chkTim.Q THEN
 LDX  chkTim~Q
#debug bool chkTim.Q
 JMC  ModbusTcpDelaySendmas_L7
#srcline 107 ;      CASE state OF
 LDX  state
#debug usint state
 WRY  P0__st__
 LD   3
 LDY  P0__st__
 EQ  
 JMC  ModbusTcpDelaySendmas_L10
#srcline 108 ;        MdbTCP_setIPadr : ErrCode := 23 + 128;       // nelze nastavit IP adresu
 LD   usint 23
 LD   usint 128
 ADD
 AND  $FF
 WRX  ErrCode
#debug_left usint ErrCode
 JMP  ModbusTcpDelaySendmas_L9
ModbusTcpDelaySendmas_L10:
 LD   5
 LDY  P0__st__
 EQ  
 JMC  ModbusTcpDelaySendmas_L11
#srcline 109 ;        MdbTCP_sendData : ErrCode := 21 + 128;       // nelze navazat TCP spojeni
 LD   usint 21
 LD   usint 128
 ADD
 AND  $FF
 WRX  ErrCode
#debug_left usint ErrCode
 JMP  ModbusTcpDelaySendmas_L9
ModbusTcpDelaySendmas_L11:
ModbusTcpDelaySendmas_L9:
#srcline 111 ;      State := MdbTCP_error;
 LD   udint 7  ; ModbusRTUlib_TStatesMdbTCP#MdbTCP_error
 WRX  State
#debug_left usint State
#srcline 112 ;    END_IF;
ModbusTcpDelaySendmas_L7:
#srcline 113 ;    lastState := state;
 LDX  state
#debug usint state
 WRX  lastState
#debug_left usint lastState
#srcline 115 ;    CASE state OF
 LDX  state
#debug usint state
 WRY  P1__st__
 LD   0
 LDY  P1__st__
 EQ  
 JMC  ModbusTcpDelaySendmas_L13
#srcline 116 ;      //---------------------------------------------
#srcline 117 ;      MdbTCP_init :
#srcline 118 ;         //nasledujici dva radky byly zbytecne a mohly zavlect do newEthAdr localport nenulovou hodnotu
#srcline 119 ;         //ta mohla zpusobit problemy nize pokud byla vyplnena vzdalena IP a port v ini tabulce
#srcline 120 ;         //GetRemoteIPaddress( chanCode, newEthAdr);
#srcline 121 ;         //SetRemoteIPaddress( TRUE, chanCode, newEthAdr); // to be sure, what is starting IP address
#srcline 122 ;         CloseTCPconnection();   //pokud je EN aktivni jiz v prvnim cyklu, predejdeme zbytecnemu navazovani
 NXT
 LD   0
 WR   __Instance__CloseTCPconnection~chanCode
 PRV
 LEA  __Instance__CloseTCPconnection
 CAL  CloseTCPconnection_L0
#srcline 123 ;         wasStart := Start;
 LDX  Start
#debug bool Start
 WRX  wasStart
#debug_left bool wasStart
#srcline 124 ;         State := MdbTCP_start;
 LD   udint 1  ; ModbusRTUlib_TStatesMdbTCP#MdbTCP_start
 WRX  State
#debug_left usint State
 JMP  ModbusTcpDelaySendmas_L12
ModbusTcpDelaySendmas_L13:
 LD   1
 LDY  P1__st__
 EQ  
 JMC  ModbusTcpDelaySendmas_L14
#srcline 125 ;         
#srcline 126 ;      //---------------------------------------------
#srcline 127 ;      MdbTCP_start :
#srcline 128 ;        Done := FALSE; ErrCode := 0;
 LD   bool 0       ; false
 WRX  Done
#debug_left bool Done
 LD   usint 0
 WRX  ErrCode
#debug_left usint ErrCode
#srcline 129 ;        IF GrSel = 0 THEN                            // manual
 LDX  GrSel
#debug usint GrSel
 LD   usint 0
 EQ
 JMC  ModbusTcpDelaySendmas_L15
#srcline 130 ;          IF Start OR wasStart THEN
 LDX  Start
#debug bool Start
 LDX  wasStart
#debug bool wasStart
 OR  
 JMC  ModbusTcpDelaySendmas_L17
#srcline 131 ;            lastCmd := CmdNo;
 LDX  CmdNo
#debug usint CmdNo
 WRX  lastCmd
#debug_left usint lastCmd
#srcline 132 ;            IF CmdNo > 0 and CmdNo <= MaxCmd THEN state := MdbTCP_selCommand; END_IF;
 LDX  CmdNo
#debug usint CmdNo
 LD   usint 0
 GT
 LDX  CmdNo
#debug usint CmdNo
 LDX  MaxCmd
#debug usint MaxCmd
 GT
 NEG
 AND
 JMC  ModbusTcpDelaySendmas_L19
 LD   udint 2  ; ModbusRTUlib_TStatesMdbTCP#MdbTCP_selCommand
 WRX  state
#debug_left usint state
ModbusTcpDelaySendmas_L19:
#srcline 133 ;          END_IF;
ModbusTcpDelaySendmas_L17:
#srcline 134 ;        ELSE                                          // auto
 JMP  ModbusTcpDelaySendmas_L16
ModbusTcpDelaySendmas_L15:
#srcline 135 ;          state := MdbTCP_selCommand;
 LD   udint 2  ; ModbusRTUlib_TStatesMdbTCP#MdbTCP_selCommand
 WRX  state
#debug_left usint state
#srcline 136 ;          CmdFind := false;
 LD   bool 0       ; false
 WRY  CmdFind
#debug_left bool CmdFind
#srcline 137 ;          autoCmd := autoCmd + 1;
 LDX  autoCmd
#debug usint autoCmd
 LD   usint 1
 ADD
 AND  $FF
 WRX  autoCmd
#debug_left usint autoCmd
#srcline 138 ;          FOR tempCmd := autoCmd TO MaxCmd DO
 LDX  autoCmd
#debug usint autoCmd
 WRY  tempCmd
 LDX  MaxCmd
#debug usint MaxCmd
 WRY  P2__st__
ModbusTcpDelaySendmas_L21:
 LDY  tempCmd
 LDY  P2__st__
 GT   
 JMD  ModbusTcpDelaySendmas_L22
 DBG  
#srcline 139 ;            ptr := ADR(Commands) + USINT_TO_UDINT(tempCmd-1) * sizeof(TCmdStructTCP);
 LDX  Commands
#debug pointer Commands
 LDY  tempCmd
#debug usint tempCmd
 LD   usint 1
 SUB
 AND  $FF
 LD   34  ; SizeOf()
 MUL
 ADD
 LEAY ptr
 WRIL 
#debug_left pointer ptr
#srcline 140 ;            IF (((ptr^.Gr = GrSel) or (ptr^.Gr = 1)) and initDone) or
 LEAY ptr
 LDIL    ; dereference 
 LDI  
#debug usint ptr^.Gr
 LDX  GrSel
#debug usint GrSel
 EQ
 LEAY ptr
 LDIL    ; dereference 
 LDI  
#debug usint ptr^.Gr
 LD   usint 1
 EQ
 OR  
 LDX  initDone
#debug bool initDone
 AND
#srcline 141 ;                ((ptr^.Gr = 255)  and not initDone) THEN
 LEAY ptr
 LDIL    ; dereference 
 LDI  
#debug usint ptr^.Gr
 LD   usint 255
 EQ
 LDX  initDone
#debug bool initDone
 NEG
 AND
 OR  
 JMC  ModbusTcpDelaySendmas_L23
#srcline 142 ;              autoCmd := tempCmd;
 LDY  tempCmd
#debug usint tempCmd
 WRX  autoCmd
#debug_left usint autoCmd
#srcline 143 ;              CmdFind := true;
 LD   bool -1       ; true
 WRY  CmdFind
#debug_left bool CmdFind
#srcline 144 ;              EXIT;
 JMP  ModbusTcpDelaySendmas_L22
#srcline 145 ;            END_IF;
ModbusTcpDelaySendmas_L23:
#srcline 146 ;//!!!            IF (ptr^.Gr = 0) THEN EXIT; END_IF;       // no record
#srcline 147 ;          END_FOR;
 LDY  tempCmd
 LD   1
 ADD  
 WRY  tempCmd
 JMP  ModbusTcpDelaySendmas_L21
ModbusTcpDelaySendmas_L22:
 NOP  -1
#srcline 148 ;          IF not CmdFind THEN
 LDY  CmdFind
#debug bool CmdFind
 NEG
 JMC  ModbusTcpDelaySendmas_L25
#srcline 149 ;            IF not initDone THEN
 LDX  initDone
#debug bool initDone
 NEG
 JMC  ModbusTcpDelaySendmas_L27
#srcline 150 ;              initDone := true;
 LD   bool -1       ; true
 WRX  initDone
#debug_left bool initDone
#srcline 151 ;            END_IF;
ModbusTcpDelaySendmas_L27:
#srcline 152 ;            autoCmd := 0;
 LD   usint 0
 WRX  autoCmd
#debug_left usint autoCmd
#srcline 153 ;            state := MdbTCP_start;
 LD   udint 1  ; ModbusRTUlib_TStatesMdbTCP#MdbTCP_start
 WRX  state
#debug_left usint state
#srcline 154 ;          END_IF;
ModbusTcpDelaySendmas_L25:
#srcline 155 ;          LastCmd := autoCmd;
 LDX  autoCmd
#debug usint autoCmd
 WRX  LastCmd
#debug_left usint LastCmd
#srcline 156 ;        END_IF;
ModbusTcpDelaySendmas_L16:
#srcline 157 ;        wasStart := 0;
 LD   bool 0       ; false
 WRX  wasStart
#debug_left bool wasStart
 JMP  ModbusTcpDelaySendmas_L12
ModbusTcpDelaySendmas_L14:
 LD   2
 LDY  P1__st__
 EQ  
 JMC  ModbusTcpDelaySendmas_L29
#srcline 158 ;      //---------------------------------------------
#srcline 159 ;      MdbTCP_selCommand :
#srcline 160 ;        ptr := ADR(Commands) + USINT_TO_UDINT(LastCmd-1) * sizeof(TCmdStructTCP);
 LDX  Commands
#debug pointer Commands
 LDX  LastCmd
#debug usint LastCmd
 LD   usint 1
 SUB
 AND  $FF
 LD   34  ; SizeOf()
 MUL
 ADD
 LEAY ptr
 WRIL 
#debug_left pointer ptr
#srcline 161 ;        // prepare localCmd
#srcline 162 ;        localCmd.Gr  := ptr^.Gr;
 LEAY ptr
 LDIL    ; dereference 
 LDI  
#debug usint ptr^.Gr
 WRX  localCmd~Gr
#debug_left usint localCmd.Gr
#srcline 163 ;        localCmd.SNo := ptr^.UnitID;    // od verze 1.6, starsi verze mely natvrdo 0
 LEAY ptr
 LDIL    ; dereference 
 ADD  24  ; + offset 
 LDI  
#debug usint ptr^.UnitID
 WRX  localCmd~SNo
#debug_left usint localCmd.SNo
#srcline 164 ;        localCmd.FNC := ptr^.FNC;
 LEAY ptr
 LDIL    ; dereference 
 ADD  25  ; + offset 
 LDI  
#debug usint ptr^.FNC
 WRX  localCmd~FNC
#debug_left usint localCmd.FNC
#srcline 165 ;        localCmd.StAdr := ptr^.StAdr;
 LEAY ptr
 LDIL    ; dereference 
 ADD  26  ; + offset 
 LDIW 
#debug uint ptr^.StAdr
 WRX  localCmd~StAdr
#debug_left uint localCmd.StAdr
#srcline 166 ;        localCmd.NoPoint := ptr^.NoPoint;
 LEAY ptr
 LDIL    ; dereference 
 ADD  28  ; + offset 
 LDIW 
#debug uint ptr^.NoPoint
 WRX  localCmd~NoPoint
#debug_left uint localCmd.NoPoint
#srcline 167 ;        localCmd.PtrData := ptr^.PtrData;
 LEAY ptr
 LDIL    ; dereference 
 ADD  30  ; + offset 
 LDIL 
#debug udint ptr^.PtrData
 WRX  localCmd~PtrData
#debug_left udint localCmd.PtrData
#srcline 168 ;        // prepare IP address
#srcline 169 ;        IF cantChangeIP THEN
 LDY  cantChangeIP
#debug bool cantChangeIP
 JMC  ModbusTcpDelaySendmas_L30
#srcline 170 ;          IF isEstab THEN
 LDX  isEstab
#debug bool isEstab
 JMC  ModbusTcpDelaySendmas_L32
#srcline 171 ;            modbusRTU.Start := TRUE;
 LD   bool -1       ; true
 WRX  modbusRTU~Start
#debug_left bool modbusRTU.Start
#srcline 172 ;            state := MdbTCP_recData;
 LD   udint 6  ; ModbusRTUlib_TStatesMdbTCP#MdbTCP_recData
 WRX  state
#debug_left usint state
#srcline 173 ;          ELSE
 JMP  ModbusTcpDelaySendmas_L33
ModbusTcpDelaySendmas_L32:
#srcline 174 ;            EstabTCPconnection( chanCode);
 NXT
 LDX  chanCode
#debug uint chanCode
 WR   __Instance__EstabTCPconnection~chanCode
#debug_left uint __Instance__EstabTCPconnection~chanCode
 PRV
 LEA  __Instance__EstabTCPconnection
 CAL  EstabTCPconnection_L0
#srcline 175 ;            state := MdbTCP_sendData;
 LD   udint 5  ; ModbusRTUlib_TStatesMdbTCP#MdbTCP_sendData
 WRX  state
#debug_left usint state
#srcline 176 ;          END_IF;
ModbusTcpDelaySendmas_L33:
#srcline 177 ;        ELSE
 JMP  ModbusTcpDelaySendmas_L31
ModbusTcpDelaySendmas_L30:
#srcline 178 ;          tempPos := FIND( ptr^.IP, ':');
 LEAY ptr
 LDIL    ; dereference 
 ADD  1  ; + offset 
#debug string ptr^.IP
 LEA  _str_ModbusTcpDelaySendmas_0
 SFND 
 WRY  tempPos
#debug_left int tempPos
#srcline 179 ;          IF tempPos = 0 THEN
 LDY  tempPos
#debug int tempPos
 EXTW 
 LD   int 0
 EQ
 JMC  ModbusTcpDelaySendmas_L34
#srcline 180 ;            newEthAdr.remoteIP := STRING_TO_IPADR( ptr^.IP); newEthAdr.remotePort := 502;
 NXT
 LD   0   ; null string
 LEA  __Instance__STRING_TO_IPADR~IPAdr
 WRI 
 LEA  __Instance__STRING_TO_IPADR~IPAdr
 LD   80
 DST    ; Level 1
 LEAY ptr
 LDIL    ; dereference 
 ADD  1  ; + offset 
#debug string ptr^.IP
 SCON 
#debug_left string __Instance__STRING_TO_IPADR~IPAdr
 PDST   ; Level 1
 PRV
 LEA  __Instance__STRING_TO_IPADR
 CAL  STRING_TO_IPADR_L0
 LEAX newEthAdr~remoteIP
#debug_left pointer newEthAdr.remoteIP
 LD   4   ;SizeOf() 
 MOV  %IB0
 LD   uint 502
 WRX  newEthAdr~remotePort
#debug_left uint newEthAdr.remotePort
#srcline 181 ;          ELSE
 JMP  ModbusTcpDelaySendmas_L35
ModbusTcpDelaySendmas_L34:
#srcline 182 ;            tempStr := LEFT( ptr^.IP, tempPos-1); newEthAdr.remoteIP := STRING_TO_IPADR( tempStr);
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   80
 DST    ; Level 1
 LEAY ptr
 LDIL    ; dereference 
 ADD  1  ; + offset 
#debug string ptr^.IP
 LDY  tempPos
#debug int tempPos
 EXTW 
 LD   int 1
 SUB
 EXTW
 SLFT 
 PDST   ; Level 1
 LD   0   ; null string
 LEAY tempStr
 WRI  
 LEAY tempStr
 LD   80
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string tempStr
 PDST   ; Level 1
 NXT
 LD   0   ; null string
 LEA  __Instance__STRING_TO_IPADR~IPAdr
 WRI 
 LEA  __Instance__STRING_TO_IPADR~IPAdr
 LD   80
 DST    ; Level 1
 LEAY tempStr
#debug string tempStr
 SCON 
#debug_left string __Instance__STRING_TO_IPADR~IPAdr
 PDST   ; Level 1
 PRV
 LEA  __Instance__STRING_TO_IPADR
 CAL  STRING_TO_IPADR_L0
 LEAX newEthAdr~remoteIP
#debug_left pointer newEthAdr.remoteIP
 LD   4   ;SizeOf() 
 MOV  %IB0
#srcline 183 ;            tempStr := MID( ptr^.IP, 5, tempPos+1); newEthAdr.remotePort := STRING_TO_UINT(tempStr);
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   80
 DST    ; Level 1
 LEAY ptr
 LDIL    ; dereference 
 ADD  1  ; + offset 
#debug string ptr^.IP
 LD   5
 LDY  tempPos
#debug int tempPos
 EXTW 
 LD   int 1
 ADD
 EXTW
 SUB  1
 SMID 
 PDST   ; Level 1
 LD   0   ; null string
 LEAY tempStr
 WRI  
 LEAY tempStr
 LD   80
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string tempStr
 PDST   ; Level 1
 LEAY tempStr
#debug string tempStr
 SCNV $300A;  IEC_STRING _TO_ IEC_UINT
 WRX  newEthAdr~remotePort
#debug_left uint newEthAdr.remotePort
#srcline 184 ;          END_IF;
ModbusTcpDelaySendmas_L35:
#srcline 185 ;          // check new IP address
#srcline 186 ;          IF newEthAdr.remoteIP[0] = 0 AND newEthAdr.remoteIP[1] = 0 AND newEthAdr.remoteIP[2] = 0 AND newEthAdr.remoteIP[3] = 0 THEN
 LDX  newEthAdr~remoteIP[0]
#debug usint newEthAdr.remoteIP[0]
 LD   usint 0
 EQ
 LDX  newEthAdr~remoteIP[1]
#debug usint newEthAdr.remoteIP[1]
 LD   usint 0
 EQ
 AND
 LDX  newEthAdr~remoteIP[2]
#debug usint newEthAdr.remoteIP[2]
 LD   usint 0
 EQ
 AND
 LDX  newEthAdr~remoteIP[3]
#debug usint newEthAdr.remoteIP[3]
 LD   usint 0
 EQ
 AND
 JMC  ModbusTcpDelaySendmas_L36
#srcline 187 ;            ErrCode := 22 + 128;                           // chybna IP adresa
 LD   usint 22
 LD   usint 128
 ADD
 AND  $FF
 WRX  ErrCode
#debug_left usint ErrCode
#srcline 188 ;            state := MdbTCP_error;
 LD   udint 7  ; ModbusRTUlib_TStatesMdbTCP#MdbTCP_error
 WRX  state
#debug_left usint state
#srcline 189 ;          ELSE
 JMP  ModbusTcpDelaySendmas_L37
ModbusTcpDelaySendmas_L36:
#srcline 190 ;            // set IP address
#srcline 191 ;            GetRemoteIPaddress( chanCode, lastEthAdr);
 NXT
 LDX  chanCode
#debug uint chanCode
 WR   __Instance__GetRemoteIPaddress~chanCode
#debug_left uint __Instance__GetRemoteIPaddress~chanCode
 LEAY lastEthAdr
 WR   __Instance__GetRemoteIPaddress~ethAdr
#debug_left pointer __Instance__GetRemoteIPaddress.ethAdr
 PRV
 LEA  __Instance__GetRemoteIPaddress
 CAL  GetRemoteIPaddress_L0
#srcline 192 ;            IF lastEthAdr.remoteIP <> newEthAdr.remoteIP OR lastEthAdr.remotePort <> newEthAdr.remotePort THEN
 LEAY lastEthAdr~remoteIP
 LEAX newEthAdr~remoteIP
 LD   4   ; SizeOf()
 BCMP 
 EQ   0
 NEG
 LDY  lastEthAdr~remotePort
#debug uint lastEthAdr.remotePort
 LDX  newEthAdr~remotePort
#debug uint newEthAdr.remotePort
 EQ
 NEG
 OR  
 JMC  ModbusTcpDelaySendmas_L38
#srcline 193 ;              newEthAdr.localPort := 0;                    // local port is done by TCP driver
 LD   uint 0
 WRX  newEthAdr~localPort
#debug_left uint newEthAdr.localPort
#srcline 194 ;              CloseTCPconnection( chanCode);               // then we must close it
 NXT
 LDX  chanCode
#debug uint chanCode
 WR   __Instance__CloseTCPconnection~chanCode
#debug_left uint __Instance__CloseTCPconnection~chanCode
 PRV
 LEA  __Instance__CloseTCPconnection
 CAL  CloseTCPconnection_L0
#srcline 195 ;              state := MdbTCP_setIPadr;
 LD   udint 3  ; ModbusRTUlib_TStatesMdbTCP#MdbTCP_setIPadr
 WRX  state
#debug_left usint state
#srcline 196 ;            ELSE
 JMP  ModbusTcpDelaySendmas_L39
ModbusTcpDelaySendmas_L38:
#srcline 197 ;              IF isEstab THEN
 LDX  isEstab
#debug bool isEstab
 JMC  ModbusTcpDelaySendmas_L40
#srcline 198 ;                modbusRTU.Start := TRUE;
 LD   bool -1       ; true
 WRX  modbusRTU~Start
#debug_left bool modbusRTU.Start
#srcline 199 ;                state := MdbTCP_recData;
 LD   udint 6  ; ModbusRTUlib_TStatesMdbTCP#MdbTCP_recData
 WRX  state
#debug_left usint state
#srcline 200 ;              ELSE
 JMP  ModbusTcpDelaySendmas_L41
ModbusTcpDelaySendmas_L40:
#srcline 201 ;                EstabTCPconnection( chanCode);
 NXT
 LDX  chanCode
#debug uint chanCode
 WR   __Instance__EstabTCPconnection~chanCode
#debug_left uint __Instance__EstabTCPconnection~chanCode
 PRV
 LEA  __Instance__EstabTCPconnection
 CAL  EstabTCPconnection_L0
#srcline 202 ;                state := MdbTCP_sendData;
 LD   udint 5  ; ModbusRTUlib_TStatesMdbTCP#MdbTCP_sendData
 WRX  state
#debug_left usint state
#srcline 203 ;              END_IF;
ModbusTcpDelaySendmas_L41:
#srcline 204 ;            END_IF;
ModbusTcpDelaySendmas_L39:
#srcline 205 ;          END_IF;
ModbusTcpDelaySendmas_L37:
#srcline 206 ;        END_IF;
ModbusTcpDelaySendmas_L31:
 JMP  ModbusTcpDelaySendmas_L12
ModbusTcpDelaySendmas_L29:
 LD   3
 LDY  P1__st__
 EQ  
 JMC  ModbusTcpDelaySendmas_L42
#srcline 208 ;      //---------------------------------------------
#srcline 209 ;      MdbTCP_setIPadr :
#srcline 210 ;        IF NOT isEstab THEN        // if connection closed
 LDX  isEstab
#debug bool isEstab
 NEG
 JMC  ModbusTcpDelaySendmas_L43
#srcline 211 ;          SetRemoteIPaddress( TRUE, chanCode, newEthAdr);  // set new IP address
 NXT
 LD   bool -1       ; true
 WR   __Instance__SetRemoteIPaddress~rq
#debug_left bool __Instance__SetRemoteIPaddress~rq
 LDX  chanCode
#debug uint chanCode
 WR   __Instance__SetRemoteIPaddress~chanCode
#debug_left uint __Instance__SetRemoteIPaddress~chanCode
 LEAX newEthAdr
 WR   __Instance__SetRemoteIPaddress~ethAdr
#debug_left pointer __Instance__SetRemoteIPaddress.ethAdr
 PRV
 LEA  __Instance__SetRemoteIPaddress
 CAL  SetRemoteIPaddress_L0
#srcline 212 ;          state := MdbTCP_estabCon;
 LD   udint 4  ; ModbusRTUlib_TStatesMdbTCP#MdbTCP_estabCon
 WRX  state
#debug_left usint state
#srcline 213 ;        END_IF;
ModbusTcpDelaySendmas_L43:
 JMP  ModbusTcpDelaySendmas_L12
ModbusTcpDelaySendmas_L42:
 LD   4
 LDY  P1__st__
 EQ  
 JMC  ModbusTcpDelaySendmas_L45
#srcline 215 ;      //---------------------------------------------
#srcline 216 ;      MdbTCP_estabCon :
#srcline 217 ;        EstabTCPconnection( chanCode);                   // establish connection
 NXT
 LDX  chanCode
#debug uint chanCode
 WR   __Instance__EstabTCPconnection~chanCode
#debug_left uint __Instance__EstabTCPconnection~chanCode
 PRV
 LEA  __Instance__EstabTCPconnection
 CAL  EstabTCPconnection_L0
#srcline 218 ;        state := MdbTCP_sendData;
 LD   udint 5  ; ModbusRTUlib_TStatesMdbTCP#MdbTCP_sendData
 WRX  state
#debug_left usint state
 JMP  ModbusTcpDelaySendmas_L12
ModbusTcpDelaySendmas_L45:
 LD   5
 LDY  P1__st__
 EQ  
 JMC  ModbusTcpDelaySendmas_L46
#srcline 220 ;      //---------------------------------------------
#srcline 221 ;      MdbTCP_sendData :
#srcline 222 ;        IF delaySend.Q THEN            // if connection established
 LDX  delaySend~Q
#debug bool delaySend.Q
 JMC  ModbusTcpDelaySendmas_L47
#srcline 223 ;          modbusRTU.Start := TRUE;                         // send message
 LD   bool -1       ; true
 WRX  modbusRTU~Start
#debug_left bool modbusRTU.Start
#srcline 224 ;          state := MdbTCP_recData;
 LD   udint 6  ; ModbusRTUlib_TStatesMdbTCP#MdbTCP_recData
 WRX  state
#debug_left usint state
#srcline 225 ;        END_IF;
ModbusTcpDelaySendmas_L47:
 JMP  ModbusTcpDelaySendmas_L12
ModbusTcpDelaySendmas_L46:
 LD   6
 LDY  P1__st__
 EQ  
 JMC  ModbusTcpDelaySendmas_L49
#srcline 227 ;      //---------------------------------------------
#srcline 228 ;      MdbTCP_recData :
#srcline 229 ;        modbusRTU.Start := FALSE;
 LD   bool 0       ; false
 WRX  modbusRTU~Start
#debug_left bool modbusRTU.Start
#srcline 230 ;        IF modbusRTU.Done THEN                             // wait for answer
 LDX  modbusRTU~Done
#debug bool modbusRTU.Done
 JMC  ModbusTcpDelaySendmas_L50
#srcline 231 ;          ErrCode := modbusRTU.ErrCode;
 LDX  modbusRTU~ErrCode
#debug usint modbusRTU.ErrCode
 WRX  ErrCode
#debug_left usint ErrCode
#srcline 232 ;          IF ErrCode = 0 OR (ErrCode > 136 & ErrCode < 143) THEN
 LDX  ErrCode
#debug usint ErrCode
 LD   usint 0
 EQ
 LDX  ErrCode
#debug usint ErrCode
 LD   usint 136
 GT
 LDX  ErrCode
#debug usint ErrCode
 LD   usint 143
 LT
 AND
 OR  
 JMC  ModbusTcpDelaySendmas_L52
#srcline 233 ;            state := MdbTCP_start; Done := TRUE;
 LD   udint 1  ; ModbusRTUlib_TStatesMdbTCP#MdbTCP_start
 WRX  state
#debug_left usint state
 LD   bool -1       ; true
 WRX  Done
#debug_left bool Done
#srcline 234 ;          ELSE
 JMP  ModbusTcpDelaySendmas_L53
ModbusTcpDelaySendmas_L52:
#srcline 235 ;            state := MdbTCP_error;
 LD   udint 7  ; ModbusRTUlib_TStatesMdbTCP#MdbTCP_error
 WRX  state
#debug_left usint state
#srcline 236 ;          END_IF;
ModbusTcpDelaySendmas_L53:
#srcline 237 ;        END_IF;
ModbusTcpDelaySendmas_L50:
 JMP  ModbusTcpDelaySendmas_L12
ModbusTcpDelaySendmas_L49:
 LD   7
 LDY  P1__st__
 EQ  
 JMC  ModbusTcpDelaySendmas_L54
#srcline 239 ;      //---------------------------------------------
#srcline 240 ;      MdbTCP_error :
#srcline 241 ;        CloseTCPconnection( chanCode);                     // then we must close it
 NXT
 LDX  chanCode
#debug uint chanCode
 WR   __Instance__CloseTCPconnection~chanCode
#debug_left uint __Instance__CloseTCPconnection~chanCode
 PRV
 LEA  __Instance__CloseTCPconnection
 CAL  CloseTCPconnection_L0
#srcline 242 ;        IF NOT isEstab THEN        // if connection closed
 LDX  isEstab
#debug bool isEstab
 NEG
 JMC  ModbusTcpDelaySendmas_L55
#srcline 243 ;Done := TRUE;  //!!!
 LD   bool -1       ; true
 WRX  Done
#debug_left bool Done
#srcline 244 ;          State := MdbTCP_start;                           // another slave device
 LD   udint 1  ; ModbusRTUlib_TStatesMdbTCP#MdbTCP_start
 WRX  State
#debug_left usint State
#srcline 245 ;        END_IF;
ModbusTcpDelaySendmas_L55:
 JMP  ModbusTcpDelaySendmas_L12
ModbusTcpDelaySendmas_L54:
#srcline 247 ;    ELSE
#srcline 248 ;      state := MdbTCP_start;
 LD   udint 1  ; ModbusRTUlib_TStatesMdbTCP#MdbTCP_start
 WRX  state
#debug_left usint state
#srcline 249 ;    END_CASE;
ModbusTcpDelaySendmas_L12:
#srcline 250 ;  END_IF;
ModbusTcpDelaySendmas_L6:
#srcline 252 ;//  GetRemoteIPaddress( chanCode, curEthAdr);
#srcline 253 ;  modbusRTU( EN := EN,  GrSel := 0(*manualne*), CmdNo := 1(*index v localCmd*), //Start := (*BOOL R_EDGE*),
 LDX  EN
#debug bool EN
 WRX  modbusRTU~EN
#debug_left bool modbusRTU~EN
 LD   usint 0
 WRX  modbusRTU~GrSel
#debug_left usint modbusRTU~GrSel
 LD   sint 1
 WRX  modbusRTU~CmdNo
#debug_left sint modbusRTU~CmdNo
#srcline 254 ;             MaxCmd := 1, chanCode := chanCode, Endian := Endian, MBtimeOut := MBtimeOut, Commands := localCmd);
 LD   sint 1
 WRX  modbusRTU~MaxCmd
#debug_left sint modbusRTU~MaxCmd
 LDX  chanCode
#debug uint chanCode
 WRX  modbusRTU~chanCode
#debug_left uint modbusRTU~chanCode
 LDX  Endian
#debug bool Endian
 WRX  modbusRTU~Endian
#debug_left bool modbusRTU~Endian
 LDX  MBtimeOut
#debug time MBtimeOut
 WRX  modbusRTU~MBtimeOut
#debug_left time modbusRTU~MBtimeOut
 LEAX localCmd
 WRX  modbusRTU~Commands
#debug_left pointer modbusRTU.Commands
 LEAX modbusRTU
 CAL  ModbusRTUmas_L0
#srcline 255 ;END_FUNCTION_BLOCK
 ULNK
RET
E     61

; Initialize - variables
P     61
ModbusTcpDelaySendmas__InstanceInit__:
 LINK 0
 LD   time 2000
 WRX  MBtimeOut
 LD   time 1000
 WRX  MBdelay
 LD   0
 SRC  byte __Init___ModbusTcpDelaySendmas_modbusRTU
 LEAX byte modbusRTU
 LD   614
 MOV  %X0
 ULNK
RET
E     61
; End initialize - variables
#endpou 



 

#srcfile ''
#srcfile 'C:\TECOLIBSRC\MODBUSRTU\MODBUSRTU\FBMODBUSUDPMAS.ST'
#pou fbModbusUDPmas
#srcline 1 ;FUNCTION_BLOCK fbModbusUDPmas
#table byte __Init___fbModbusUDPmas_modbusRTU = 
      0,  0,  0,  0,  0,  0,  0,  0,208,  7,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  2;

#struct fbModbusUDPmas__temp__
  bool CmdFind,  ; GrSel find
  usint tempCmd,
  int tempPos,
  string[81] tempStr,
  TRemoteEthAdr lastEthAdr,
  usint P0__st__,
  usint P1__st__,
  string[82] PS0__st__
#data byte _str_fbModbusUDPmas_0 = 
  ':',0
P     61
fbModbusUDPmas_L0:
 LINK __SizeOf(fbModbusUDPmas__temp__)
; Initialize - dynamic variables
; End initialize - dynamic variables
; R_EDGE, F_EDGE 
 LDX  Start
 LETX __EDGE_R__Start
 WRX  Start
#srcline 70 ;  IF UINT_TO_WORD(chanCode) and 16#00F1 <> 16#00E1 THEN
 LDX  chanCode
#debug uint chanCode
 LD   word $00F1
 AND
 LD   word $00E1
 EQ
 NEG
 JMC  fbModbusUDPmas_L1
#srcline 71 ;    ErrCode := 20 + 128; RETURN;                     // kod kanalu musi byt ETH1_uni
 LD   usint 20
 LD   usint 128
 ADD
 AND  $FF
 WRX  ErrCode
#debug_left usint ErrCode
 JMP  fbModbusUDPmas_RET
#srcline 72 ;  END_IF;  // TCP
fbModbusUDPmas_L1:
#srcline 74 ;  IF not EN THEN
 LDX  EN
#debug bool EN
 NEG
 JMC  fbModbusUDPmas_L3
#srcline 75 ;    InitDone := false; LastCmd := 0; autoCmd := 0;
 LD   bool 0       ; false
 WRX  InitDone
#debug_left bool InitDone
 LD   usint 0
 WRX  LastCmd
#debug_left usint LastCmd
 LD   usint 0
 WRX  autoCmd
#debug_left usint autoCmd
#srcline 76 ;    Done := FALSE; ErrCode := 0;                     // clear error code
 LD   bool 0       ; false
 WRX  Done
#debug_left bool Done
 LD   usint 0
 WRX  ErrCode
#debug_left usint ErrCode
#srcline 77 ;    State := MdbTCP_start;
 LD   udint 1  ; ModbusRTUlib_TStatesMdbTCP#MdbTCP_start
 WRX  State
#debug_left usint State
#srcline 78 ;  ELSE
 JMP  fbModbusUDPmas_L4
fbModbusUDPmas_L3:
#srcline 79 ;    IF State = MdbTCP_start THEN     //not inside case so we can do two states at once
 LDX  State
#debug usint State
 LD   udint 1  ; ModbusRTUlib_TStatesMdbTCP#MdbTCP_start
 EQ
 JMC  fbModbusUDPmas_L5
#srcline 80 ;      Done := FALSE; ErrCode := 0;
 LD   bool 0       ; false
 WRX  Done
#debug_left bool Done
 LD   usint 0
 WRX  ErrCode
#debug_left usint ErrCode
#srcline 81 ;      IF GrSel = 0 THEN                            // manual
 LDX  GrSel
#debug usint GrSel
 LD   usint 0
 EQ
 JMC  fbModbusUDPmas_L7
#srcline 82 ;        IF Start THEN
 LDX  Start
#debug bool Start
 JMC  fbModbusUDPmas_L9
#srcline 83 ;          lastCmd := CmdNo;
 LDX  CmdNo
#debug usint CmdNo
 WRX  lastCmd
#debug_left usint lastCmd
#srcline 84 ;          IF CmdNo > 0 and CmdNo <= MaxCmd THEN state := MdbTCP_selCommand; END_IF;
 LDX  CmdNo
#debug usint CmdNo
 LD   usint 0
 GT
 LDX  CmdNo
#debug usint CmdNo
 LDX  MaxCmd
#debug usint MaxCmd
 GT
 NEG
 AND
 JMC  fbModbusUDPmas_L11
 LD   udint 2  ; ModbusRTUlib_TStatesMdbTCP#MdbTCP_selCommand
 WRX  state
#debug_left usint state
fbModbusUDPmas_L11:
#srcline 85 ;        END_IF;
fbModbusUDPmas_L9:
#srcline 86 ;      ELSE                                          // auto
 JMP  fbModbusUDPmas_L8
fbModbusUDPmas_L7:
#srcline 87 ;        state := MdbTCP_selCommand;
 LD   udint 2  ; ModbusRTUlib_TStatesMdbTCP#MdbTCP_selCommand
 WRX  state
#debug_left usint state
#srcline 88 ;        CmdFind := false;
 LD   bool 0       ; false
 WRY  CmdFind
#debug_left bool CmdFind
#srcline 89 ;        autoCmd := autoCmd + 1;
 LDX  autoCmd
#debug usint autoCmd
 LD   usint 1
 ADD
 AND  $FF
 WRX  autoCmd
#debug_left usint autoCmd
#srcline 90 ;        FOR tempCmd := autoCmd TO MaxCmd DO
 LDX  autoCmd
#debug usint autoCmd
 WRY  tempCmd
 LDX  MaxCmd
#debug usint MaxCmd
 WRY  P0__st__
fbModbusUDPmas_L13:
 LDY  tempCmd
 LDY  P0__st__
 GT   
 JMD  fbModbusUDPmas_L14
 DBG  
#srcline 91 ;          ptr := ADR(Commands) + USINT_TO_UDINT(tempCmd-1) * sizeof(TCmdStructTCP);
 LDX  Commands
#debug pointer Commands
 LDY  tempCmd
#debug usint tempCmd
 LD   usint 1
 SUB
 AND  $FF
 LD   34  ; SizeOf()
 MUL
 ADD
 LEAX ptr
 WRIL 
#debug_left pointer ptr
#srcline 92 ;          IF (((ptr^.Gr = GrSel) or (ptr^.Gr = 1)) and initDone) or
 LEAX ptr
 LDIL    ; dereference 
 LDI  
#debug usint ptr^.Gr
 LDX  GrSel
#debug usint GrSel
 EQ
 LEAX ptr
 LDIL    ; dereference 
 LDI  
#debug usint ptr^.Gr
 LD   usint 1
 EQ
 OR  
 LDX  initDone
#debug bool initDone
 AND
#srcline 93 ;              ((ptr^.Gr = 255)  and not initDone) THEN
 LEAX ptr
 LDIL    ; dereference 
 LDI  
#debug usint ptr^.Gr
 LD   usint 255
 EQ
 LDX  initDone
#debug bool initDone
 NEG
 AND
 OR  
 JMC  fbModbusUDPmas_L15
#srcline 94 ;            autoCmd := tempCmd;
 LDY  tempCmd
#debug usint tempCmd
 WRX  autoCmd
#debug_left usint autoCmd
#srcline 95 ;            CmdFind := true;
 LD   bool -1       ; true
 WRY  CmdFind
#debug_left bool CmdFind
#srcline 96 ;            EXIT;
 JMP  fbModbusUDPmas_L14
#srcline 97 ;          END_IF;
fbModbusUDPmas_L15:
#srcline 98 ;        END_FOR;
 LDY  tempCmd
 LD   1
 ADD  
 WRY  tempCmd
 JMP  fbModbusUDPmas_L13
fbModbusUDPmas_L14:
 NOP  -1
#srcline 99 ;        IF not CmdFind THEN
 LDY  CmdFind
#debug bool CmdFind
 NEG
 JMC  fbModbusUDPmas_L17
#srcline 100 ;          IF not initDone THEN
 LDX  initDone
#debug bool initDone
 NEG
 JMC  fbModbusUDPmas_L19
#srcline 101 ;            initDone := true;
 LD   bool -1       ; true
 WRX  initDone
#debug_left bool initDone
#srcline 102 ;          END_IF;
fbModbusUDPmas_L19:
#srcline 103 ;          autoCmd := 0;
 LD   usint 0
 WRX  autoCmd
#debug_left usint autoCmd
#srcline 104 ;          state := MdbTCP_start;
 LD   udint 1  ; ModbusRTUlib_TStatesMdbTCP#MdbTCP_start
 WRX  state
#debug_left usint state
#srcline 105 ;        END_IF;
fbModbusUDPmas_L17:
#srcline 106 ;        LastCmd := autoCmd;
 LDX  autoCmd
#debug usint autoCmd
 WRX  LastCmd
#debug_left usint LastCmd
#srcline 107 ;      END_IF;
fbModbusUDPmas_L8:
#srcline 108 ;    END_IF;
fbModbusUDPmas_L5:
#srcline 109 ;    CASE state OF
 LDX  state
#debug usint state
 WRY  P1__st__
 LD   2
 LDY  P1__st__
 EQ  
 JMC  fbModbusUDPmas_L22
#srcline 110 ;      //---------------------------------------------
#srcline 111 ;      MdbTCP_selCommand :
#srcline 112 ;        ptr := ADR(Commands) + USINT_TO_UDINT(LastCmd-1) * sizeof(TCmdStructTCP);
 LDX  Commands
#debug pointer Commands
 LDX  LastCmd
#debug usint LastCmd
 LD   usint 1
 SUB
 AND  $FF
 LD   34  ; SizeOf()
 MUL
 ADD
 LEAX ptr
 WRIL 
#debug_left pointer ptr
#srcline 113 ;        // prepare localCmd
#srcline 114 ;        localCmd.Gr  := ptr^.Gr;
 LEAX ptr
 LDIL    ; dereference 
 LDI  
#debug usint ptr^.Gr
 WRX  localCmd~Gr
#debug_left usint localCmd.Gr
#srcline 115 ;        localCmd.SNo := ptr^.UnitID;    // od verze 1.6, starsi verze mely natvrdo 0
 LEAX ptr
 LDIL    ; dereference 
 ADD  24  ; + offset 
 LDI  
#debug usint ptr^.UnitID
 WRX  localCmd~SNo
#debug_left usint localCmd.SNo
#srcline 116 ;        localCmd.FNC := ptr^.FNC;
 LEAX ptr
 LDIL    ; dereference 
 ADD  25  ; + offset 
 LDI  
#debug usint ptr^.FNC
 WRX  localCmd~FNC
#debug_left usint localCmd.FNC
#srcline 117 ;        localCmd.StAdr := ptr^.StAdr;
 LEAX ptr
 LDIL    ; dereference 
 ADD  26  ; + offset 
 LDIW 
#debug uint ptr^.StAdr
 WRX  localCmd~StAdr
#debug_left uint localCmd.StAdr
#srcline 118 ;        localCmd.NoPoint := ptr^.NoPoint;
 LEAX ptr
 LDIL    ; dereference 
 ADD  28  ; + offset 
 LDIW 
#debug uint ptr^.NoPoint
 WRX  localCmd~NoPoint
#debug_left uint localCmd.NoPoint
#srcline 119 ;        localCmd.PtrData := ptr^.PtrData;
 LEAX ptr
 LDIL    ; dereference 
 ADD  30  ; + offset 
 LDIL 
#debug udint ptr^.PtrData
 WRX  localCmd~PtrData
#debug_left udint localCmd.PtrData
#srcline 120 ;        // prepare IP address
#srcline 121 ;        tempPos := FIND( ptr^.IP, ':');
 LEAX ptr
 LDIL    ; dereference 
 ADD  1  ; + offset 
#debug string ptr^.IP
 LEA  _str_fbModbusUDPmas_0
 SFND 
 WRY  tempPos
#debug_left int tempPos
#srcline 122 ;        IF tempPos = 0 THEN
 LDY  tempPos
#debug int tempPos
 EXTW 
 LD   int 0
 EQ
 JMC  fbModbusUDPmas_L23
#srcline 123 ;          newEthAdr.remoteIP := STRING_TO_IPADR( ptr^.IP); newEthAdr.remotePort := 502;
 NXT
 LD   0   ; null string
 LEA  __Instance__STRING_TO_IPADR~IPAdr
 WRI 
 LEA  __Instance__STRING_TO_IPADR~IPAdr
 LD   80
 DST    ; Level 1
 LEAX ptr
 LDIL    ; dereference 
 ADD  1  ; + offset 
#debug string ptr^.IP
 SCON 
#debug_left string __Instance__STRING_TO_IPADR~IPAdr
 PDST   ; Level 1
 PRV
 LEA  __Instance__STRING_TO_IPADR
 CAL  STRING_TO_IPADR_L0
 LEAX newEthAdr~remoteIP
#debug_left pointer newEthAdr.remoteIP
 LD   4   ;SizeOf() 
 MOV  %IB0
 LD   uint 502
 WRX  newEthAdr~remotePort
#debug_left uint newEthAdr.remotePort
#srcline 124 ;        ELSE
 JMP  fbModbusUDPmas_L24
fbModbusUDPmas_L23:
#srcline 125 ;          tempStr := LEFT( ptr^.IP, tempPos-1); newEthAdr.remoteIP := STRING_TO_IPADR( tempStr);
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   80
 DST    ; Level 1
 LEAX ptr
 LDIL    ; dereference 
 ADD  1  ; + offset 
#debug string ptr^.IP
 LDY  tempPos
#debug int tempPos
 EXTW 
 LD   int 1
 SUB
 EXTW
 SLFT 
 PDST   ; Level 1
 LD   0   ; null string
 LEAY tempStr
 WRI  
 LEAY tempStr
 LD   80
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string tempStr
 PDST   ; Level 1
 NXT
 LD   0   ; null string
 LEA  __Instance__STRING_TO_IPADR~IPAdr
 WRI 
 LEA  __Instance__STRING_TO_IPADR~IPAdr
 LD   80
 DST    ; Level 1
 LEAY tempStr
#debug string tempStr
 SCON 
#debug_left string __Instance__STRING_TO_IPADR~IPAdr
 PDST   ; Level 1
 PRV
 LEA  __Instance__STRING_TO_IPADR
 CAL  STRING_TO_IPADR_L0
 LEAX newEthAdr~remoteIP
#debug_left pointer newEthAdr.remoteIP
 LD   4   ;SizeOf() 
 MOV  %IB0
#srcline 126 ;          tempStr := MID( ptr^.IP, 5, tempPos+1); newEthAdr.remotePort := STRING_TO_UINT(tempStr);
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   80
 DST    ; Level 1
 LEAX ptr
 LDIL    ; dereference 
 ADD  1  ; + offset 
#debug string ptr^.IP
 LD   5
 LDY  tempPos
#debug int tempPos
 EXTW 
 LD   int 1
 ADD
 EXTW
 SUB  1
 SMID 
 PDST   ; Level 1
 LD   0   ; null string
 LEAY tempStr
 WRI  
 LEAY tempStr
 LD   80
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string tempStr
 PDST   ; Level 1
 LEAY tempStr
#debug string tempStr
 SCNV $300A;  IEC_STRING _TO_ IEC_UINT
 WRX  newEthAdr~remotePort
#debug_left uint newEthAdr.remotePort
#srcline 127 ;        END_IF;
fbModbusUDPmas_L24:
#srcline 128 ;        // check new IP address
#srcline 129 ;        IF newEthAdr.remoteIP[0] = 0 AND newEthAdr.remoteIP[1] = 0 AND newEthAdr.remoteIP[2] = 0 AND newEthAdr.remoteIP[3] = 0 THEN
 LDX  newEthAdr~remoteIP[0]
#debug usint newEthAdr.remoteIP[0]
 LD   usint 0
 EQ
 LDX  newEthAdr~remoteIP[1]
#debug usint newEthAdr.remoteIP[1]
 LD   usint 0
 EQ
 AND
 LDX  newEthAdr~remoteIP[2]
#debug usint newEthAdr.remoteIP[2]
 LD   usint 0
 EQ
 AND
 LDX  newEthAdr~remoteIP[3]
#debug usint newEthAdr.remoteIP[3]
 LD   usint 0
 EQ
 AND
 JMC  fbModbusUDPmas_L25
#srcline 130 ;          ErrCode := 22 + 128;                           // chybna IP adresa
 LD   usint 22
 LD   usint 128
 ADD
 AND  $FF
 WRX  ErrCode
#debug_left usint ErrCode
#srcline 131 ;          state := MdbTCP_error;
 LD   udint 7  ; ModbusRTUlib_TStatesMdbTCP#MdbTCP_error
 WRX  state
#debug_left usint state
#srcline 132 ;        ELSE
 JMP  fbModbusUDPmas_L26
fbModbusUDPmas_L25:
#srcline 133 ;          // set IP address
#srcline 134 ;          GetRemoteIPaddress( chanCode, lastEthAdr);
 NXT
 LDX  chanCode
#debug uint chanCode
 WR   __Instance__GetRemoteIPaddress~chanCode
#debug_left uint __Instance__GetRemoteIPaddress~chanCode
 LEAY lastEthAdr
 WR   __Instance__GetRemoteIPaddress~ethAdr
#debug_left pointer __Instance__GetRemoteIPaddress.ethAdr
 PRV
 LEA  __Instance__GetRemoteIPaddress
 CAL  GetRemoteIPaddress_L0
#srcline 135 ;          IF lastEthAdr.remoteIP <> newEthAdr.remoteIP OR lastEthAdr.remotePort <> newEthAdr.remotePort THEN
 LEAY lastEthAdr~remoteIP
 LEAX newEthAdr~remoteIP
 LD   4   ; SizeOf()
 BCMP 
 EQ   0
 NEG
 LDY  lastEthAdr~remotePort
#debug uint lastEthAdr.remotePort
 LDX  newEthAdr~remotePort
#debug uint newEthAdr.remotePort
 EQ
 NEG
 OR  
 JMC  fbModbusUDPmas_L27
#srcline 136 ;            newEthAdr.localPort := localPort;                // local port
 LDX  localPort
#debug uint localPort
 WRX  newEthAdr~localPort
#debug_left uint newEthAdr.localPort
#srcline 137 ;            SetRemoteIPaddress( TRUE, chanCode, newEthAdr);  // set new IP address
 NXT
 LD   bool -1       ; true
 WR   __Instance__SetRemoteIPaddress~rq
#debug_left bool __Instance__SetRemoteIPaddress~rq
 LDX  chanCode
#debug uint chanCode
 WR   __Instance__SetRemoteIPaddress~chanCode
#debug_left uint __Instance__SetRemoteIPaddress~chanCode
 LEAX newEthAdr
 WR   __Instance__SetRemoteIPaddress~ethAdr
#debug_left pointer __Instance__SetRemoteIPaddress.ethAdr
 PRV
 LEA  __Instance__SetRemoteIPaddress
 CAL  SetRemoteIPaddress_L0
#srcline 138 ;          END_IF;
fbModbusUDPmas_L27:
#srcline 139 ;          modbusRTU.Start := TRUE; //odvysilat zpravu
 LD   bool -1       ; true
 WRX  modbusRTU~Start
#debug_left bool modbusRTU.Start
#srcline 140 ;          state := MdbTCP_recData;
 LD   udint 6  ; ModbusRTUlib_TStatesMdbTCP#MdbTCP_recData
 WRX  state
#debug_left usint state
#srcline 141 ;        END_IF;
fbModbusUDPmas_L26:
 JMP  fbModbusUDPmas_L21
fbModbusUDPmas_L22:
 LD   6
 LDY  P1__st__
 EQ  
 JMC  fbModbusUDPmas_L29
#srcline 143 ;      //---------------------------------------------
#srcline 144 ;      MdbTCP_recData :
#srcline 145 ;        modbusRTU.Start := FALSE;
 LD   bool 0       ; false
 WRX  modbusRTU~Start
#debug_left bool modbusRTU.Start
#srcline 146 ;        IF modbusRTU.Done THEN                             // wait for answer
 LDX  modbusRTU~Done
#debug bool modbusRTU.Done
 JMC  fbModbusUDPmas_L30
#srcline 147 ;          IF modbusRTU.ErrCode <> 0 THEN
 LDX  modbusRTU~ErrCode
#debug usint modbusRTU.ErrCode
 LD   usint 0
 EQ
 NEG
 JMC  fbModbusUDPmas_L32
#srcline 148 ;            ErrCode := modbusRTU.ErrCode;
 LDX  modbusRTU~ErrCode
#debug usint modbusRTU.ErrCode
 WRX  ErrCode
#debug_left usint ErrCode
#srcline 149 ;            state := MdbTCP_error;
 LD   udint 7  ; ModbusRTUlib_TStatesMdbTCP#MdbTCP_error
 WRX  state
#debug_left usint state
#srcline 150 ;          ELSE
 JMP  fbModbusUDPmas_L33
fbModbusUDPmas_L32:
#srcline 151 ;            state := MdbTCP_start; Done := TRUE;
 LD   udint 1  ; ModbusRTUlib_TStatesMdbTCP#MdbTCP_start
 WRX  state
#debug_left usint state
 LD   bool -1       ; true
 WRX  Done
#debug_left bool Done
#srcline 152 ;          END_IF;
fbModbusUDPmas_L33:
#srcline 153 ;        END_IF;
fbModbusUDPmas_L30:
 JMP  fbModbusUDPmas_L21
fbModbusUDPmas_L29:
 LD   7
 LDY  P1__st__
 EQ  
 JMC  fbModbusUDPmas_L34
#srcline 155 ;      //---------------------------------------------
#srcline 156 ;      MdbTCP_error :
#srcline 157 ;        Done := TRUE;  //!!!
 LD   bool -1       ; true
 WRX  Done
#debug_left bool Done
#srcline 158 ;        State := MdbTCP_start;                           // another slave device
 LD   udint 1  ; ModbusRTUlib_TStatesMdbTCP#MdbTCP_start
 WRX  State
#debug_left usint State
 JMP  fbModbusUDPmas_L21
fbModbusUDPmas_L34:
#srcline 159 ;    ELSE
#srcline 160 ;      state := MdbTCP_start;
 LD   udint 1  ; ModbusRTUlib_TStatesMdbTCP#MdbTCP_start
 WRX  state
#debug_left usint state
#srcline 161 ;    END_CASE;
fbModbusUDPmas_L21:
#srcline 162 ;  END_IF;
fbModbusUDPmas_L4:
#srcline 164 ;  modbusRTU( EN := EN,  GrSel := 0(*manualne*), CmdNo := 1(*index v localCmd*),
 LDX  EN
#debug bool EN
 WRX  modbusRTU~EN
#debug_left bool modbusRTU~EN
 LD   usint 0
 WRX  modbusRTU~GrSel
#debug_left usint modbusRTU~GrSel
 LD   usint 1
 WRX  modbusRTU~CmdNo
#debug_left usint modbusRTU~CmdNo
#srcline 165 ;             MaxCmd := 1, chanCode := chanCode, Endian := Endian, MBtimeOut := MBtimeOut, Delay := Delay, Commands := localCmd);
 LD   usint 1
 WRX  modbusRTU~MaxCmd
#debug_left usint modbusRTU~MaxCmd
 LDX  chanCode
#debug uint chanCode
 WRX  modbusRTU~chanCode
#debug_left uint modbusRTU~chanCode
 LDX  Endian
#debug bool Endian
 WRX  modbusRTU~Endian
#debug_left bool modbusRTU~Endian
 LDX  MBtimeOut
#debug time MBtimeOut
 WRX  modbusRTU~MBtimeOut
#debug_left time modbusRTU~MBtimeOut
 LDX  Delay
#debug time Delay
 WRX  modbusRTU~Delay
#debug_left time modbusRTU~Delay
 LEAX localCmd
 WRX  modbusRTU~Commands
#debug_left pointer modbusRTU.Commands
 LEAX modbusRTU
 CAL  fbModbusRTUmas2_L0
#srcline 166 ;END_FUNCTION_BLOCK
fbModbusUDPmas_RET:
 ULNK
RET
E     61

; Initialize - variables
P     61
fbModbusUDPmas__InstanceInit__:
 LINK 0
 LD   time 2000
 WRX  MBtimeOut
 LD   uint 61502
 WRX  localPort
 LD   udint $FFFFFFFF    ; nil
 WRX  ptr
 LD   0
 SRC  byte __Init___fbModbusUDPmas_modbusRTU
 LEAX byte modbusRTU
 LD   633
 MOV  %X0
 ULNK
RET
E     61
; End initialize - variables
#endpou 



 

#srcfile ''
#srcfile 'C:\TECOLIBSRC\MODBUSRTU\MODBUSRTU\FCMODBUSTCPOFF.ST'
#pou fcModbusUdpOff
#srcline 1 ;FUNCTION fcModbusUdpOff : BOOL
P     61
fcModbusUdpOff_L0:
 LINK 0
 NXT
; Initialize - variables
 LD   0
 WRX  __fc__fcModbusUdpOff
; End initialize - variables
#srcline 8 ;  begin
#srcline 9 ;  {asm}
#srcline 10
    #useoption __konst 27 = $02 ; vypnou default driver pro Modbus UDP
#srcline 11 ;  {end_asm}
#srcline 12 ;END_FUNCTION
 PRV  
 LDX  __fc__fcModbusUdpOff
 ULNK
RET
E     61
#endpou 

#pou fcModbusTcpOff
#srcline 14 ;FUNCTION fcModbusTcpOff : BOOL
P     61
fcModbusTcpOff_L0:
 LINK 0
 NXT
; Initialize - variables
 LD   0
 WRX  __fc__fcModbusTcpOff
; End initialize - variables
#srcline 23 ;  begin
#srcline 24 ;  {asm}
#srcline 25
    #useoption __konst 27 = $01 ; vypnou default driver pro Modbus TCP
#srcline 26 ;  {end_asm}
#srcline 27 ;END_FUNCTION
 PRV  
 LDX  __fc__fcModbusTcpOff
 ULNK
RET
E     61
#endpou 

#pou fcModbusTcpUdpOff
#srcline 29 ;FUNCTION fcModbusTcpUdpOff : BOOL
P     61
fcModbusTcpUdpOff_L0:
 LINK 0
 NXT
; Initialize - variables
 LD   0
 WRX  __fc__fcModbusTcpUdpOff
; End initialize - variables
#srcline 36 ;  begin
#srcline 37 ;  {asm}
#srcline 38
    #useoption __konst 27 = $03 ; vypnou default driver pro Modbus TCP/UDP
#srcline 39 ;  {end_asm}
#srcline 40 ;END_FUNCTION
 PRV  
 LDX  __fc__fcModbusTcpUdpOff
 ULNK
RET
E     61
#endpou 



 

#srcfile ''
#srcfile 'C:\TECOLIBSRC\MODBUSRTU\MODBUSRTU\FBMODBUSSLAVE.ST'
#pou fbModbusSlave
#srcline 1 ;FUNCTION_BLOCK fbModbusSlave {HIDDEN}

#struct fbModbusSlave__temp__
  uint QuantityB,
  uint i,
  pointer ptrB,
  pointer ptrB2,
  pointer ptrW,
  pointer ptrBit,
  pointer ptrBit2,
  udint End,
  udint P0__st__,
  uint P1__st__,
  uint P2__st__
P     61
fbModbusSlave_L0:
 LINK __SizeOf(fbModbusSlave__temp__)
; Initialize - dynamic variables
 LD   udint $FFFFFFFF    ; nil
 WRY  ptrB
 LD   udint $FFFFFFFF    ; nil
 WRY  ptrB2
 LD   udint $FFFFFFFF    ; nil
 WRY  ptrW
 LD   udint $FFFFFFFF    ; nil
 WRY  ptrBit
 LD   udint $FFFFFFFF    ; nil
 WRY  ptrBit2
; End initialize - dynamic variables
#srcline 38 ;  Read      := 0;
 LD   bool 0       ; false
 WRX  Read
#debug_left bool Read
#srcline 39 ;  Write     := 0;
 LD   bool 0       ; false
 WRX  Write
#debug_left bool Write
#srcline 40 ;  Addr := WORD_TO_UINT(SHL(USINT_TO_WORD(Buf[2]),8)) + USINT_TO_UINT(Buf[3]);
 LDX  Buf[2]
#debug usint Buf[2]
 LD   uint 8
 SHL
 AND  $FFFF
 LDX  Buf[3]
#debug usint Buf[3]
 AND  $FFFF
 ADD
 AND  $FFFF
 WRX  Addr
#debug_left uint Addr
#srcline 41 ;  Quantity := WORD_TO_UINT(SHL(USINT_TO_WORD(Buf[4]),8)) + USINT_TO_UINT(Buf[5]);
 LDX  Buf[4]
#debug usint Buf[4]
 LD   uint 8
 SHL
 AND  $FFFF
 LDX  Buf[5]
#debug usint Buf[5]
 AND  $FFFF
 ADD
 AND  $FFFF
 WRX  Quantity
#debug_left uint Quantity
#srcline 42 ;  CASE Buf[1] OF //typ zpravy
 LDX  Buf[1]
#debug usint Buf[1]
 WRY  P0__st__
 LD   1
 LDY  P0__st__
 EQ   
 JMD  fbModbusSlave_L2
 LD   2
 LDY  P0__st__
 EQ   
 JMC  fbModbusSlave_L3
fbModbusSlave_L2:
#srcline 43 ;    1,2 : //read coil or input status
#srcline 44 ;      IF Quantity > 0 AND Quantity <= 2000 THEN
 LDX  Quantity
#debug uint Quantity
 LD   uint 0
 GT
 LDX  Quantity
#debug uint Quantity
 LD   uint 2000
 GT
 NEG
 AND
 JMC  fbModbusSlave_L4
#srcline 45 ;        IF UINT_TO_UDINT(Addr)+UINT_TO_UDINT(Quantity) <= UINT_TO_UDINT(coilsCnt) AND Buf[1] = 1 OR
 LDX  Addr
#debug uint Addr
 LDX  Quantity
#debug uint Quantity
 ADD
 LDX  coilsCnt
#debug uint coilsCnt
 GT
 NEG
 LDX  Buf[1]
#debug usint Buf[1]
 LD   usint 1
 EQ
 AND
#srcline 46 ;           UINT_TO_UDINT(Addr)+UINT_TO_UDINT(Quantity) <= UINT_TO_UDINT(inputsCnt) AND Buf[1] = 2 THEN //je to v rozsahu nasich registru
 LDX  Addr
#debug uint Addr
 LDX  Quantity
#debug uint Quantity
 ADD
 LDX  inputsCnt
#debug uint inputsCnt
 GT
 NEG
 LDX  Buf[1]
#debug usint Buf[1]
 LD   usint 2
 EQ
 AND
 OR  
 JMC  fbModbusSlave_L6
#srcline 47 ;          SendTo_rq := NOT Broadcast;
 LDX  Broadcast
#debug bool Broadcast
 NEG
 WRX  SendTo_rq
#debug_left bool SendTo_rq
#srcline 48 ;          QuantityB := (Quantity+7)/8; //number of bytes;
 LDX  Quantity
#debug uint Quantity
 LD   uint 7
 ADD
 AND  $FFFF
 LD   uint 8
 DIVL
 AND  $FFFF
 WRY  QuantityB
#debug_left uint QuantityB
#srcline 49 ;          Buf[2] := UINT_TO_USINT(QuantityB);
 LDY  QuantityB
#debug uint QuantityB
 AND  $FF
 WRX  Buf[2]
#debug_left usint Buf[2]
#srcline 50 ;          Memset(val := 0, length := QuantityB, dest := Buf[3]); //20131003 - aby ve zprave nebyly zbytky od predchozich
 NXT
 LD   udint 0
 WR   __Instance__Memset~val
#debug_left udint __Instance__Memset~val
 LDY  QuantityB
#debug uint QuantityB
 WR   __Instance__Memset~length
#debug_left uint __Instance__Memset~length
 LEAX Buf
 ADD  3  ; + offset 
 WR   __Instance__Memset~dest
#debug_left pointer __Instance__Memset.dest
 PRV
 LEA  __Instance__Memset
 CAL  Memset_L0
#srcline 51 ;          IF Buf[1] = 1 THEN
 LDX  Buf[1]
#debug usint Buf[1]
 LD   usint 1
 EQ
 JMC  fbModbusSlave_L8
#srcline 52 ;            ptrBit := ADR(coils) + UINT_TO_UDINT(Addr);
 LDX  coils
#debug pointer coils
 LDX  Addr
#debug uint Addr
 ADD
 LEAY ptrBit
 WRIL 
#debug_left pointer ptrBit
#srcline 53 ;          ELSE
 JMP  fbModbusSlave_L9
fbModbusSlave_L8:
#srcline 54 ;            ptrBit := ADR(inputs) + UINT_TO_UDINT(Addr);
 LDX  inputs
#debug pointer inputs
 LDX  Addr
#debug uint Addr
 ADD
 LEAY ptrBit
 WRIL 
#debug_left pointer ptrBit
#srcline 55 ;          END_IF;
fbModbusSlave_L9:
#srcline 56 ;          End := PTR_TO_UDINT(ptrBit) + UINT_TO_UDINT(Quantity);
 LEAY ptrBit
 LDIL 
#debug pointer ptrBit
 LDX  Quantity
#debug uint Quantity
 ADD
 WRY  End
#debug_left udint End
#srcline 57 ;          ptrBit2 := ADR(Buf[3])*8;
 LEAX Buf
 ADD  3  ; + offset 
#debug pointer Buf[3]
 LD   udint 8
 MUL
 LEAY ptrBit2
 WRIL 
#debug_left pointer ptrBit2
#srcline 58 ;          WHILE PTR_TO_UDINT(ptrBit) < End DO
fbModbusSlave_L10:
 LEAY ptrBit
 LDIL 
#debug pointer ptrBit
 LDY  End
#debug udint End
 LT
 JMC  fbModbusSlave_L11
 DBG 
#srcline 59 ;            ptrBit2^ := ptrBit^;
 LEAY ptrBit
 LDIL    ; dereference 
 LDIB 
#debug bool ptrBit^
 LEAY ptrBit2
 LDIL    ; dereference 
 WRIB 
#debug_left bool ptrBit2^
#srcline 60 ;            ptrBit := ptrBit + 1;
 LEAY ptrBit
 LDIL 
#debug pointer ptrBit
 LD   udint 1
 ADD
 LEAY ptrBit
 WRIL 
#debug_left pointer ptrBit
#srcline 61 ;            ptrBit2 := ptrBit2 + 1;
 LEAY ptrBit2
 LDIL 
#debug pointer ptrBit2
 LD   udint 1
 ADD
 LEAY ptrBit2
 WRIL 
#debug_left pointer ptrBit2
#srcline 62 ;          END_WHILE;
 JMP  fbModbusSlave_L10
fbModbusSlave_L11:
 NOP  -1
#srcline 63 ;          SendTo_lenTx := USINT_TO_UINT(Buf[2]) + 5; //delka
 LDX  Buf[2]
#debug usint Buf[2]
 AND  $FFFF
 LD   uint 5
 ADD
 AND  $FFFF
 WRX  SendTo_lenTx
#debug_left uint SendTo_lenTx
#srcline 64 ;          read := true;
 LD   bool -1       ; true
 WRX  read
#debug_left bool read
#srcline 65 ;        ELSE
 JMP  fbModbusSlave_L7
fbModbusSlave_L6:
#srcline 66 ;          Exception := 2;
 LD   usint 2
 WRX  Exception
#debug_left usint Exception
#srcline 67 ;        END_IF;
fbModbusSlave_L7:
#srcline 68 ;      ELSE
 JMP  fbModbusSlave_L5
fbModbusSlave_L4:
#srcline 69 ;        Exception := 3;
 LD   usint 3
 WRX  Exception
#debug_left usint Exception
#srcline 70 ;      END_IF;
fbModbusSlave_L5:
 JMP  fbModbusSlave_L1
fbModbusSlave_L3:
 LD   3
 LDY  P0__st__
 EQ   
 JMD  fbModbusSlave_L12
 LD   4
 LDY  P0__st__
 EQ   
 JMC  fbModbusSlave_L13
fbModbusSlave_L12:
#srcline 71 ;    3,4 : //read holding or input register
#srcline 72 ;      IF Quantity > 0 AND Quantity <= 125 THEN
 LDX  Quantity
#debug uint Quantity
 LD   uint 0
 GT
 LDX  Quantity
#debug uint Quantity
 LD   uint 125
 GT
 NEG
 AND
 JMC  fbModbusSlave_L14
#srcline 73 ;        QuantityB := Quantity*2; //number of bytes;
 LDX  Quantity
#debug uint Quantity
 LD   uint 2
 MUL
 AND  $FFFF
 WRY  QuantityB
#debug_left uint QuantityB
#srcline 74 ;        Buf[2] := UINT_TO_USINT(QuantityB);
 LDY  QuantityB
#debug uint QuantityB
 AND  $FF
 WRX  Buf[2]
#debug_left usint Buf[2]
#srcline 75 ;        IF UINT_TO_UDINT(Addr)+UINT_TO_UDINT(Quantity) <= UINT_TO_UDINT(holdingRegCnt) AND Buf[1] = 3 OR
 LDX  Addr
#debug uint Addr
 LDX  Quantity
#debug uint Quantity
 ADD
 LDX  holdingRegCnt
#debug uint holdingRegCnt
 GT
 NEG
 LDX  Buf[1]
#debug usint Buf[1]
 LD   usint 3
 EQ
 AND
#srcline 76 ;           UINT_TO_UDINT(Addr)+UINT_TO_UDINT(Quantity) <= UINT_TO_UDINT(inputRegCnt) AND Buf[1] = 4 THEN
 LDX  Addr
#debug uint Addr
 LDX  Quantity
#debug uint Quantity
 ADD
 LDX  inputRegCnt
#debug uint inputRegCnt
 GT
 NEG
 LDX  Buf[1]
#debug usint Buf[1]
 LD   usint 4
 EQ
 AND
 OR  
 JMC  fbModbusSlave_L16
#srcline 77 ;          SendTo_rq := NOT Broadcast;
 LDX  Broadcast
#debug bool Broadcast
 NEG
 WRX  SendTo_rq
#debug_left bool SendTo_rq
#srcline 78 ;          IF Buf[1] = 3 THEN
 LDX  Buf[1]
#debug usint Buf[1]
 LD   usint 3
 EQ
 JMC  fbModbusSlave_L18
#srcline 79 ;            MemcpyEx(length := UINT_TO_UDINT(QuantityB), offSource := UINT_TO_UDINT(Addr)*2, offDest := 0, source := void(holdingRegs), dest := Buf[4]);
 NXT
 LDY  QuantityB
#debug uint QuantityB
 WR   __Instance__MemcpyEx~length
#debug_left udint __Instance__MemcpyEx~length
 LDX  Addr
#debug uint Addr
 LD   udint 2
 MUL
 WR   __Instance__MemcpyEx~offSource
#debug_left udint __Instance__MemcpyEx~offSource
 LD   udint 0
 WR   __Instance__MemcpyEx~offDest
#debug_left udint __Instance__MemcpyEx~offDest
 LDX  holdingRegs
 WR   __Instance__MemcpyEx~source
#debug_left pointer __Instance__MemcpyEx.source
 LEAX Buf
 ADD  4  ; + offset 
 WR   __Instance__MemcpyEx~dest
#debug_left pointer __Instance__MemcpyEx.dest
 PRV
 LEA  __Instance__MemcpyEx
 CAL  MemcpyEx_L0
#srcline 80 ;            ptrB  := ADR(holdingRegs) + UINT_TO_UDINT(Addr)*2 + 1;
 LDX  holdingRegs
#debug pointer holdingRegs
 LDX  Addr
#debug uint Addr
 LD   udint 2
 MUL
 ADD
 LD   udint 1
 ADD
 LEAY ptrB
 WRIL 
#debug_left pointer ptrB
#srcline 81 ;          ELSE
 JMP  fbModbusSlave_L19
fbModbusSlave_L18:
#srcline 82 ;            MemcpyEx(length := UINT_TO_UDINT(QuantityB), offSource := UINT_TO_UDINT(Addr)*2, offDest := 0, source := void(inputRegs), dest := Buf[4]);
 NXT
 LDY  QuantityB
#debug uint QuantityB
 WR   __Instance__MemcpyEx~length
#debug_left udint __Instance__MemcpyEx~length
 LDX  Addr
#debug uint Addr
 LD   udint 2
 MUL
 WR   __Instance__MemcpyEx~offSource
#debug_left udint __Instance__MemcpyEx~offSource
 LD   udint 0
 WR   __Instance__MemcpyEx~offDest
#debug_left udint __Instance__MemcpyEx~offDest
 LDX  inputRegs
 WR   __Instance__MemcpyEx~source
#debug_left pointer __Instance__MemcpyEx.source
 LEAX Buf
 ADD  4  ; + offset 
 WR   __Instance__MemcpyEx~dest
#debug_left pointer __Instance__MemcpyEx.dest
 PRV
 LEA  __Instance__MemcpyEx
 CAL  MemcpyEx_L0
#srcline 83 ;            ptrB  := ADR(inputRegs) + UINT_TO_UDINT(Addr)*2 + 1;
 LDX  inputRegs
#debug pointer inputRegs
 LDX  Addr
#debug uint Addr
 LD   udint 2
 MUL
 ADD
 LD   udint 1
 ADD
 LEAY ptrB
 WRIL 
#debug_left pointer ptrB
#srcline 84 ;          END_IF;
fbModbusSlave_L19:
#srcline 86 ;          ptrB2 := ADR(Buf[3]);
 LEAX Buf
 ADD  3  ; + offset 
#debug pointer Buf[3]
 LEAY ptrB2
 WRIL 
#debug_left pointer ptrB2
#srcline 87 ;          FOR i := 1 TO Quantity DO
 LD   uint 1
 WRY  i
 LDX  Quantity
#debug uint Quantity
 WRY  P1__st__
fbModbusSlave_L20:
 LDY  i
 LDY  P1__st__
 GT   
 JMD  fbModbusSlave_L21
 DBG  
#srcline 88 ;            ptrB2^ := ptrB^;
 LEAY ptrB
 LDIL    ; dereference 
 LDI  
#debug byte ptrB^
 LEAY ptrB2
 LDIL    ; dereference 
 WRI 
#debug_left byte ptrB2^
#srcline 89 ;            ptrB := ptrB + 2;
 LEAY ptrB
 LDIL 
#debug pointer ptrB
 LD   udint 2
 ADD
 LEAY ptrB
 WRIL 
#debug_left pointer ptrB
#srcline 90 ;            ptrB2 := ptrB2 + 2;
 LEAY ptrB2
 LDIL 
#debug pointer ptrB2
 LD   udint 2
 ADD
 LEAY ptrB2
 WRIL 
#debug_left pointer ptrB2
#srcline 91 ;          END_FOR;
 LDY  i
 LD   1
 ADD  
 WRY  i
 JMP  fbModbusSlave_L20
fbModbusSlave_L21:
 NOP  -1
#srcline 92 ;          SendTo_lenTx := USINT_TO_UINT(Buf[2]) + 5; //delka
 LDX  Buf[2]
#debug usint Buf[2]
 AND  $FFFF
 LD   uint 5
 ADD
 AND  $FFFF
 WRX  SendTo_lenTx
#debug_left uint SendTo_lenTx
#srcline 93 ;          read := true;
 LD   bool -1       ; true
 WRX  read
#debug_left bool read
#srcline 94 ;        ELSE
 JMP  fbModbusSlave_L17
fbModbusSlave_L16:
#srcline 95 ;          Exception := 2;
 LD   usint 2
 WRX  Exception
#debug_left usint Exception
#srcline 96 ;        END_IF;
fbModbusSlave_L17:
#srcline 97 ;      ELSE
 JMP  fbModbusSlave_L15
fbModbusSlave_L14:
#srcline 98 ;        Exception := 3;
 LD   usint 3
 WRX  Exception
#debug_left usint Exception
#srcline 99 ;      END_IF;
fbModbusSlave_L15:
 JMP  fbModbusSlave_L1
fbModbusSlave_L13:
 LD   5
 LDY  P0__st__
 EQ  
 JMC  fbModbusSlave_L22
#srcline 100 ;    5 : //force single coil
#srcline 101 ;      IF Quantity = 16#FF00 OR Quantity = 0 THEN
 LDX  Quantity
#debug uint Quantity
 LD   uint $FF00
 EQ
 LDX  Quantity
#debug uint Quantity
 LD   uint 0
 EQ
 OR  
 JMC  fbModbusSlave_L23
#srcline 102 ;        IF Addr < coilsCnt THEN
 LDX  Addr
#debug uint Addr
 LDX  coilsCnt
#debug uint coilsCnt
 LT
 JMC  fbModbusSlave_L25
#srcline 103 ;          SendTo_rq := NOT Broadcast;
 LDX  Broadcast
#debug bool Broadcast
 NEG
 WRX  SendTo_rq
#debug_left bool SendTo_rq
#srcline 104 ;          ptrBit  := ADR(coils) + UINT_TO_UDINT(Addr);
 LDX  coils
#debug pointer coils
 LDX  Addr
#debug uint Addr
 ADD
 LEAY ptrBit
 WRIL 
#debug_left pointer ptrBit
#srcline 105 ;          ptrBit^ := Quantity = 16#FF00;
 LDX  Quantity
#debug uint Quantity
 LD   uint $FF00
 EQ
 LEAY ptrBit
 LDIL    ; dereference 
 WRIB 
#debug_left bool ptrBit^
#srcline 106 ;          Quantity := 1;
 LD   uint 1
 WRX  Quantity
#debug_left uint Quantity
#srcline 107 ;          SendTo_lenTx := 8; //delka - byla o jedna kratsi
 LD   uint 8
 WRX  SendTo_lenTx
#debug_left uint SendTo_lenTx
#srcline 108 ;          write := true;
 LD   bool -1       ; true
 WRX  write
#debug_left bool write
#srcline 109 ;        ELSE
 JMP  fbModbusSlave_L26
fbModbusSlave_L25:
#srcline 110 ;          Exception := 2;
 LD   usint 2
 WRX  Exception
#debug_left usint Exception
#srcline 111 ;        END_IF;
fbModbusSlave_L26:
#srcline 112 ;      ELSE
 JMP  fbModbusSlave_L24
fbModbusSlave_L23:
#srcline 113 ;        Exception := 3;
 LD   usint 3
 WRX  Exception
#debug_left usint Exception
#srcline 114 ;      END_IF;
fbModbusSlave_L24:
 JMP  fbModbusSlave_L1
fbModbusSlave_L22:
 LD   6
 LDY  P0__st__
 EQ  
 JMC  fbModbusSlave_L27
#srcline 115 ;    6 : //preset single register
#srcline 116 ;      IF Addr < holdingRegCnt THEN
 LDX  Addr
#debug uint Addr
 LDX  holdingRegCnt
#debug uint holdingRegCnt
 LT
 JMC  fbModbusSlave_L28
#srcline 117 ;        SendTo_rq := NOT Broadcast;
 LDX  Broadcast
#debug bool Broadcast
 NEG
 WRX  SendTo_rq
#debug_left bool SendTo_rq
#srcline 118 ;        ptrW := ADR(holdingRegs) + UINT_TO_UDINT(Addr)*2;
 LDX  holdingRegs
#debug pointer holdingRegs
 LDX  Addr
#debug uint Addr
 LD   udint 2
 MUL
 ADD
 LEAY ptrW
 WRIL 
#debug_left pointer ptrW
#srcline 119 ;        ptrW^ := UINT_TO_WORD(Quantity);
 LDX  Quantity
#debug uint Quantity
 LEAY ptrW
 LDIL    ; dereference 
 WRIW 
#debug_left word ptrW^
#srcline 120 ;        SendTo_lenTx := 8; //delka
 LD   uint 8
 WRX  SendTo_lenTx
#debug_left uint SendTo_lenTx
#srcline 121 ;        Quantity := 1;
 LD   uint 1
 WRX  Quantity
#debug_left uint Quantity
#srcline 122 ;        write := true;
 LD   bool -1       ; true
 WRX  write
#debug_left bool write
#srcline 123 ;      ELSE
 JMP  fbModbusSlave_L29
fbModbusSlave_L28:
#srcline 124 ;        Exception := 2;
 LD   usint 2
 WRX  Exception
#debug_left usint Exception
#srcline 125 ;      END_IF;
fbModbusSlave_L29:
 JMP  fbModbusSlave_L1
fbModbusSlave_L27:
 LD   15
 LDY  P0__st__
 EQ  
 JMC  fbModbusSlave_L30
#srcline 126 ;    15 : //force multiple coils
#srcline 127 ;      IF Quantity > 0 AND Quantity <= 1968 THEN
 LDX  Quantity
#debug uint Quantity
 LD   uint 0
 GT
 LDX  Quantity
#debug uint Quantity
 LD   uint 1968
 GT
 NEG
 AND
 JMC  fbModbusSlave_L31
#srcline 128 ;        IF UINT_TO_UDINT(Addr)+UINT_TO_UDINT(Quantity) <= UINT_TO_UDINT(coilsCnt) THEN //je to v rozsahu nasich registru
 LDX  Addr
#debug uint Addr
 LDX  Quantity
#debug uint Quantity
 ADD
 LDX  coilsCnt
#debug uint coilsCnt
 GT
 NEG
 JMC  fbModbusSlave_L33
#srcline 129 ;          SendTo_rq := NOT Broadcast;
 LDX  Broadcast
#debug bool Broadcast
 NEG
 WRX  SendTo_rq
#debug_left bool SendTo_rq
#srcline 130 ;          QuantityB := (Quantity+7)/8; //number of bytes;
 LDX  Quantity
#debug uint Quantity
 LD   uint 7
 ADD
 AND  $FFFF
 LD   uint 8
 DIVL
 AND  $FFFF
 WRY  QuantityB
#debug_left uint QuantityB
#srcline 131 ;          Buf[2] := UINT_TO_USINT(QuantityB);
 LDY  QuantityB
#debug uint QuantityB
 AND  $FF
 WRX  Buf[2]
#debug_left usint Buf[2]
#srcline 132 ;          //shift
#srcline 133 ;          ptrBit := ADR(coils) + UINT_TO_UDINT(Addr);
 LDX  coils
#debug pointer coils
 LDX  Addr
#debug uint Addr
 ADD
 LEAY ptrBit
 WRIL 
#debug_left pointer ptrBit
#srcline 134 ;          End := PTR_TO_UDINT(ptrBit) + UINT_TO_UDINT(Quantity);
 LEAY ptrBit
 LDIL 
#debug pointer ptrBit
 LDX  Quantity
#debug uint Quantity
 ADD
 WRY  End
#debug_left udint End
#srcline 135 ;          ptrBit2 := ADR(Buf[7])*8;
 LEAX Buf
 ADD  7  ; + offset 
#debug pointer Buf[7]
 LD   udint 8
 MUL
 LEAY ptrBit2
 WRIL 
#debug_left pointer ptrBit2
#srcline 136 ;          WHILE PTR_TO_UDINT(ptrBit) < End DO
fbModbusSlave_L35:
 LEAY ptrBit
 LDIL 
#debug pointer ptrBit
 LDY  End
#debug udint End
 LT
 JMC  fbModbusSlave_L36
 DBG 
#srcline 137 ;            ptrBit^ := ptrBit2^;
 LEAY ptrBit2
 LDIL    ; dereference 
 LDIB 
#debug bool ptrBit2^
 LEAY ptrBit
 LDIL    ; dereference 
 WRIB 
#debug_left bool ptrBit^
#srcline 138 ;            ptrBit := ptrBit + 1;
 LEAY ptrBit
 LDIL 
#debug pointer ptrBit
 LD   udint 1
 ADD
 LEAY ptrBit
 WRIL 
#debug_left pointer ptrBit
#srcline 139 ;            ptrBit2 := ptrBit2 + 1;
 LEAY ptrBit2
 LDIL 
#debug pointer ptrBit2
 LD   udint 1
 ADD
 LEAY ptrBit2
 WRIL 
#debug_left pointer ptrBit2
#srcline 140 ;          END_WHILE;
 JMP  fbModbusSlave_L35
fbModbusSlave_L36:
 NOP  -1
#srcline 141 ;          SendTo_lenTx := 8; //delka
 LD   uint 8
 WRX  SendTo_lenTx
#debug_left uint SendTo_lenTx
#srcline 142 ;          write := true;
 LD   bool -1       ; true
 WRX  write
#debug_left bool write
#srcline 143 ;        ELSE
 JMP  fbModbusSlave_L34
fbModbusSlave_L33:
#srcline 144 ;          Exception := 2;
 LD   usint 2
 WRX  Exception
#debug_left usint Exception
#srcline 145 ;        END_IF;
fbModbusSlave_L34:
#srcline 146 ;      ELSE
 JMP  fbModbusSlave_L32
fbModbusSlave_L31:
#srcline 147 ;        Exception := 3;
 LD   usint 3
 WRX  Exception
#debug_left usint Exception
#srcline 148 ;      END_IF;
fbModbusSlave_L32:
 JMP  fbModbusSlave_L1
fbModbusSlave_L30:
 LD   16
 LDY  P0__st__
 EQ  
 JMC  fbModbusSlave_L37
#srcline 149 ;    16 : //preset multiple registers
#srcline 150 ;      IF Quantity > 0 AND Quantity <= 123 THEN
 LDX  Quantity
#debug uint Quantity
 LD   uint 0
 GT
 LDX  Quantity
#debug uint Quantity
 LD   uint 123
 GT
 NEG
 AND
 JMC  fbModbusSlave_L38
#srcline 151 ;        QuantityB := Quantity*2; //number of bytes;
 LDX  Quantity
#debug uint Quantity
 LD   uint 2
 MUL
 AND  $FFFF
 WRY  QuantityB
#debug_left uint QuantityB
#srcline 152 ;        Buf[2] := UINT_TO_USINT(QuantityB);
 LDY  QuantityB
#debug uint QuantityB
 AND  $FF
 WRX  Buf[2]
#debug_left usint Buf[2]
#srcline 153 ;        IF UINT_TO_UDINT(Addr)+UINT_TO_UDINT(Quantity) <= UINT_TO_UDINT(holdingRegCnt) THEN
 LDX  Addr
#debug uint Addr
 LDX  Quantity
#debug uint Quantity
 ADD
 LDX  holdingRegCnt
#debug uint holdingRegCnt
 GT
 NEG
 JMC  fbModbusSlave_L40
#srcline 154 ;          SendTo_rq := NOT Broadcast;
 LDX  Broadcast
#debug bool Broadcast
 NEG
 WRX  SendTo_rq
#debug_left bool SendTo_rq
#srcline 155 ;          ptrW := ADR(Buf[7]);
 LEAX Buf
 ADD  7  ; + offset 
#debug pointer Buf[7]
 LEAY ptrW
 WRIL 
#debug_left pointer ptrW
#srcline 156 ;          FOR i := 1 TO Quantity DO
 LD   uint 1
 WRY  i
 LDX  Quantity
#debug uint Quantity
 WRY  P2__st__
fbModbusSlave_L42:
 LDY  i
 LDY  P2__st__
 GT   
 JMD  fbModbusSlave_L43
 DBG  
#srcline 157 ;            ptrW^ := SHL(ptrW^,8) OR SHR(ptrW^,8);
 LEAY ptrW
 LDIL    ; dereference 
 LDIW 
#debug word ptrW^
 LD   uint 8
 SHL
 AND  $FFFF
 LEAY ptrW
 LDIL    ; dereference 
 LDIW 
#debug word ptrW^
 LD   uint 8
 SHR
 AND  $FFFF
 OR  
 LEAY ptrW
 LDIL    ; dereference 
 WRIW 
#debug_left word ptrW^
#srcline 158 ;            ptrW  := ptrW + 2;
 LEAY ptrW
 LDIL 
#debug pointer ptrW
 LD   udint 2
 ADD
 LEAY ptrW
 WRIL 
#debug_left pointer ptrW
#srcline 159 ;          END_FOR;
 LDY  i
 LD   1
 ADD  
 WRY  i
 JMP  fbModbusSlave_L42
fbModbusSlave_L43:
 NOP  -1
#srcline 160 ;          MemcpyEx(length := UINT_TO_UDINT(QuantityB), offSource := 0, offDest := UINT_TO_UDINT(Addr)*2, source := Buf[7], dest := void(holdingRegs));
 NXT
 LDY  QuantityB
#debug uint QuantityB
 WR   __Instance__MemcpyEx~length
#debug_left udint __Instance__MemcpyEx~length
 LD   udint 0
 WR   __Instance__MemcpyEx~offSource
#debug_left udint __Instance__MemcpyEx~offSource
 LDX  Addr
#debug uint Addr
 LD   udint 2
 MUL
 WR   __Instance__MemcpyEx~offDest
#debug_left udint __Instance__MemcpyEx~offDest
 LEAX Buf
 ADD  7  ; + offset 
 WR   __Instance__MemcpyEx~source
#debug_left pointer __Instance__MemcpyEx.source
 LDX  holdingRegs
 WR   __Instance__MemcpyEx~dest
#debug_left pointer __Instance__MemcpyEx.dest
 PRV
 LEA  __Instance__MemcpyEx
 CAL  MemcpyEx_L0
#srcline 161 ;          SendTo_lenTx := 8; //delka
 LD   uint 8
 WRX  SendTo_lenTx
#debug_left uint SendTo_lenTx
#srcline 162 ;          write := true;
 LD   bool -1       ; true
 WRX  write
#debug_left bool write
#srcline 163 ;        ELSE
 JMP  fbModbusSlave_L41
fbModbusSlave_L40:
#srcline 164 ;          Exception := 2;
 LD   usint 2
 WRX  Exception
#debug_left usint Exception
#srcline 165 ;        END_IF;
fbModbusSlave_L41:
#srcline 166 ;      ELSE
 JMP  fbModbusSlave_L39
fbModbusSlave_L38:
#srcline 167 ;        Exception := 3;
 LD   usint 3
 WRX  Exception
#debug_left usint Exception
#srcline 168 ;      END_IF;
fbModbusSlave_L39:
 JMP  fbModbusSlave_L1
fbModbusSlave_L37:
 LD   22
 LDY  P0__st__
 EQ  
 JMC  fbModbusSlave_L44
#srcline 169 ;    (*
#srcline 170 ;    17 : //report Server ID
#srcline 171 ;      SendTo_rq := NOT Broadcast;
#srcline 172 ;      Buf[2] := 7;
#srcline 173 ;      GetMACaddress(ethChan := ETH1, MacAdr := void(Buf[3]));
#srcline 174 ;      Buf[9] := 16#FF;
#srcline 175 ;      SendTo_lenTx := 10; //delka
#srcline 176 ;      read := true;
#srcline 177 ;    *)
#srcline 178 ;    22 : //Mask Write Register
#srcline 179 ;      IF Addr < holdingRegCnt THEN
 LDX  Addr
#debug uint Addr
 LDX  holdingRegCnt
#debug uint holdingRegCnt
 LT
 JMC  fbModbusSlave_L45
#srcline 180 ;        SendTo_rq := NOT Broadcast;
 LDX  Broadcast
#debug bool Broadcast
 NEG
 WRX  SendTo_rq
#debug_left bool SendTo_rq
#srcline 181 ;        ptrW := ADR(holdingRegs) + UINT_TO_UDINT(Addr)*2; //nastavit pointer na modifikovany word
 LDX  holdingRegs
#debug pointer holdingRegs
 LDX  Addr
#debug uint Addr
 LD   udint 2
 MUL
 ADD
 LEAY ptrW
 WRIL 
#debug_left pointer ptrW
#srcline 182 ;        //v Quantity lezi "AND mask" a do QuantityB si ulozime "OR mask"
#srcline 183 ;        QuantityB := WORD_TO_UINT(SHL(USINT_TO_WORD(Buf[6]),8)) + USINT_TO_UINT(Buf[7]);
 LDX  Buf[6]
#debug usint Buf[6]
 LD   uint 8
 SHL
 AND  $FFFF
 LDX  Buf[7]
#debug usint Buf[7]
 AND  $FFFF
 ADD
 AND  $FFFF
 WRY  QuantityB
#debug_left uint QuantityB
#srcline 184 ;        //Result = (Current Contents AND And_Mask) OR (Or_Mask AND (NOT And_Mask))
#srcline 185 ;        ptrW^ := (ptrW^ AND UINT_TO_WORD(Quantity)) OR (UINT_TO_WORD(QuantityB) AND NOT UINT_TO_WORD(Quantity));
 LEAY ptrW
 LDIL    ; dereference 
 LDIW 
#debug word ptrW^
 LDX  Quantity
#debug uint Quantity
 AND
 LDY  QuantityB
#debug uint QuantityB
 LDX  Quantity
#debug uint Quantity
 NEG
 AND  $FFFF
 AND
 OR  
 LEAY ptrW
 LDIL    ; dereference 
 WRIW 
#debug_left word ptrW^
#srcline 186 ;        SendTo_lenTx := 10; //delka
 LD   uint 10
 WRX  SendTo_lenTx
#debug_left uint SendTo_lenTx
#srcline 187 ;        Quantity := 1;
 LD   uint 1
 WRX  Quantity
#debug_left uint Quantity
#srcline 188 ;        write := true;
 LD   bool -1       ; true
 WRX  write
#debug_left bool write
#srcline 189 ;      ELSE
 JMP  fbModbusSlave_L46
fbModbusSlave_L45:
#srcline 190 ;        Exception := 2;
 LD   usint 2
 WRX  Exception
#debug_left usint Exception
#srcline 191 ;      END_IF;
fbModbusSlave_L46:
 JMP  fbModbusSlave_L1
fbModbusSlave_L44:
#srcline 192 ;  ELSE //neznamy kod
#srcline 193 ;    Exception := 1;
 LD   usint 1
 WRX  Exception
#debug_left usint Exception
#srcline 194 ;  END_CASE;
fbModbusSlave_L1:
#srcline 195 ;  IF Exception <> 0 THEN
 LDX  Exception
#debug usint Exception
 LD   usint 0
 EQ
 NEG
 JMC  fbModbusSlave_L47
#srcline 196 ;    SendTo_rq := NOT Broadcast;
 LDX  Broadcast
#debug bool Broadcast
 NEG
 WRX  SendTo_rq
#debug_left bool SendTo_rq
#srcline 197 ;    Buf[1] := Buf[1] + 16#80;
 LDX  Buf[1]
#debug usint Buf[1]
 LD   usint $80
 ADD
 AND  $FF
 WRX  Buf[1]
#debug_left usint Buf[1]
#srcline 198 ;    Buf[2] := Exception;
 LDX  Exception
#debug usint Exception
 WRX  Buf[2]
#debug_left usint Buf[2]
#srcline 199 ;    SendTo_lenTx := 5; //delka
 LD   uint 5
 WRX  SendTo_lenTx
#debug_left uint SendTo_lenTx
#srcline 200 ;    Quantity := 0; //nulovat pocet pokud nastala vyjimka
 LD   uint 0
 WRX  Quantity
#debug_left uint Quantity
#srcline 201 ;  END_IF;
fbModbusSlave_L47:
#srcline 203 ;END_FUNCTION_BLOCK
 ULNK
RET
E     61

; Initialize - variables
P     61
fbModbusSlave__InstanceInit__:
 LINK 0
 ULNK
RET
E     61
; End initialize - variables
#endpou 



 

#srcfile ''
#srcfile 'C:\TECOLIBSRC\MODBUSRTU\MODBUSRTU\FBMODBUSRTUSLAVE.ST'
#pou fbModbusRTUslave
#srcline 1 ;FUNCTION_BLOCK fbModbusRTUslave

#struct fbModbusRTUslave__temp__
  word Crc,
  TUniDesc uniDesc
P     61
fbModbusRTUslave_L0:
 LINK __SizeOf(fbModbusRTUslave__temp__)
; Initialize - dynamic variables
; End initialize - dynamic variables
#srcline 71 ;  Read  := 0;
 LD   bool 0       ; false
 WRX  Read
#debug_left bool Read
#srcline 72 ;  Write := 0;
 LD   bool 0       ; false
 WRX  Write
#debug_left bool Write
#srcline 73 ;  Err   := 0;
 LD   bool 0       ; false
 WRX  Err
#debug_left bool Err
#srcline 74 ;  Mdb.Exception := 0;
 LD   usint 0
 WRX  Mdb~Exception
#debug_left usint Mdb.Exception
#srcline 76 ;  RecvFrom(rq := 1, chanCode := chanCode, lenRx := 256, data := void(Mdb.Buf));
 LD   1
 WRX  RecvFrom~rq
#debug_left bool RecvFrom~rq
 LDX  chanCode
#debug uint chanCode
 WRX  RecvFrom~chanCode
#debug_left uint RecvFrom~chanCode
 LD   uint 256
 WRX  RecvFrom~lenRx
#debug_left uint RecvFrom~lenRx
 LEAX Mdb
 WRX  RecvFrom~data
#debug_left pointer RecvFrom.data
 LEAX RecvFrom
 CAL  fbRecvFrom_L0
#srcline 78 ;  uniDesc := GetChanDesc( chanCode);
 NXT
 LDX  chanCode
#debug uint chanCode
 WR   __Instance__GetChanDesc~chanCode
#debug_left uint __Instance__GetChanDesc~chanCode
 PRV
 LEA  __Instance__GetChanDesc
 CAL  GetChanDesc_L0
 LEAY uniDesc
#debug_left pointer uniDesc
 LD   26   ;SizeOf() 
 MOV  %IB0
#srcline 79 ;  IF uniDesc.lenUniIn < 260 OR uniDesc.lenUniOut < 259 THEN
 LDY  uniDesc~lenUniIn
#debug uint uniDesc.lenUniIn
 LD   uint 260
 LT
 LDY  uniDesc~lenUniOut
#debug uint uniDesc.lenUniOut
 LD   uint 259
 LT
 OR  
 JMC  fbModbusRTUslave_L1
#srcline 80 ;    RecvFrom.error := COM_ERRc6;
 LD   usint 198
 WRX  RecvFrom~error
#debug_left usint RecvFrom.error
#srcline 81 ;  END_IF;
fbModbusRTUslave_L1:
#srcline 82 ;  
#srcline 83 ;  IF RecvFrom.error > 0 THEN
 LDX  RecvFrom~error
#debug usint RecvFrom.error
 LD   usint 0
 GT
 JMC  fbModbusRTUslave_L3
#srcline 84 ;    err := 1;
 LD   bool -1      ; true
 WRX  err
#debug_left bool err
#srcline 85 ;    errCode := RecvFrom.error;
 LDX  RecvFrom~error
#debug usint RecvFrom.error
 WRX  errCode
#debug_left usint errCode
#srcline 86 ;    IF errCode <> 1 AND errCode <> 4 THEN errCnt := errCnt + 1; END_IF;
 LDX  errCode
#debug usint errCode
 LD   usint 1
 EQ
 NEG
 LDX  errCode
#debug usint errCode
 LD   usint 4
 EQ
 NEG
 AND
 JMC  fbModbusRTUslave_L5
 LDX  errCnt
#debug udint errCnt
 LD   udint 1
 ADD
 WRX  errCnt
#debug_left udint errCnt
fbModbusRTUslave_L5:
#srcline 87 ;    return;
 JMP  fbModbusRTUslave_RET
#srcline 88 ;  END_IF;
fbModbusRTUslave_L3:
#srcline 90 ;  IF RecvFrom.mesRec THEN
 LDX  RecvFrom~mesRec
#debug bool RecvFrom.mesRec
 JMC  fbModbusRTUslave_L7
#srcline 91 ;    Mdb.Broadcast := Mdb.Buf[0] = 0;
 LDX  Mdb~Buf[0]
#debug usint Mdb.Buf[0]
 LD   usint 0
 EQ
 WRX  Mdb~Broadcast
#debug_left bool Mdb.Broadcast
#srcline 92 ;    IF Mdb.Buf[0] = sAdr OR Mdb.Broadcast THEN //zprava je pro nas
 LDX  Mdb~Buf[0]
#debug usint Mdb.Buf[0]
 LDX  sAdr
#debug usint sAdr
 EQ
 LDX  Mdb~Broadcast
#debug bool Mdb.Broadcast
 OR  
 JMC  fbModbusRTUslave_L9
#srcline 93 ;      Crc := UINT_TO_WORD(CheckCRC_16(ptr := ADR(Mdb.Buf), length := RecvFrom.lenData));
 NXT
 LEAX Mdb
#debug pointer Mdb.Buf
 LEA  __Instance__CheckCRC_16~ptr
 WRIL 
#debug_left udint __Instance__CheckCRC_16~ptr
 LDX  RecvFrom~lenData
#debug uint RecvFrom.lenData
 WR   __Instance__CheckCRC_16~length
#debug_left uint __Instance__CheckCRC_16~length
 PRV
 LEA  __Instance__CheckCRC_16
 CAL  CheckCRC_16_L0
 WRY  Crc
#debug_left word Crc
#srcline 94 ;      IF Crc = 0 THEN
 LDY  Crc
#debug word Crc
 LD   word 0
 EQ
 JMC  fbModbusRTUslave_L11
#srcline 95 ;        lastCmd := Mdb.Buf[1];
 LDX  Mdb~Buf[1]
#debug usint Mdb.Buf[1]
 WRX  lastCmd
#debug_left usint lastCmd
#srcline 96 ;        Mdb(inputsCnt := inputsCnt,
 LDX  inputsCnt
#debug uint inputsCnt
 WRX  Mdb~inputsCnt
#debug_left uint Mdb~inputsCnt
#srcline 97 ;            coilsCnt := coilsCnt,
 LDX  coilsCnt
#debug uint coilsCnt
 WRX  Mdb~coilsCnt
#debug_left uint Mdb~coilsCnt
#srcline 98 ;            inputRegCnt := inputRegCnt,
 LDX  inputRegCnt
#debug uint inputRegCnt
 WRX  Mdb~inputRegCnt
#debug_left uint Mdb~inputRegCnt
#srcline 99 ;            holdingRegCnt := holdingRegCnt,
 LDX  holdingRegCnt
#debug uint holdingRegCnt
 WRX  Mdb~holdingRegCnt
#debug_left uint Mdb~holdingRegCnt
#srcline 100 ;            inputs := inputs,
 LDX  inputs
 WRX  Mdb~inputs
#debug_left pointer Mdb.inputs
#srcline 101 ;            coils := coils,
 LDX  coils
 WRX  Mdb~coils
#debug_left pointer Mdb.coils
#srcline 102 ;            inputRegs := inputRegs,
 LDX  inputRegs
 WRX  Mdb~inputRegs
#debug_left pointer Mdb.inputRegs
#srcline 103 ;            holdingRegs := holdingRegs);
 LDX  holdingRegs
 WRX  Mdb~holdingRegs
#debug_left pointer Mdb.holdingRegs
 LEAX Mdb
 CAL  fbModbusSlave_L0
#srcline 104 ;        lastAddr     := Mdb.Addr;
 LDX  Mdb~Addr
#debug uint Mdb.Addr
 WRX  lastAddr
#debug_left uint lastAddr
#srcline 105 ;        lastQuantity := Mdb.Quantity;
 LDX  Mdb~Quantity
#debug uint Mdb.Quantity
 WRX  lastQuantity
#debug_left uint lastQuantity
#srcline 106 ;        read := Mdb.read;
 LDX  Mdb~read
#debug bool Mdb.read
 WRX  read
#debug_left bool read
#srcline 107 ;        write := Mdb.write;
 LDX  Mdb~write
#debug bool Mdb.write
 WRX  write
#debug_left bool write
#srcline 108 ;        SendTo.rq    := Mdb.SendTo_rq;
 LDX  Mdb~SendTo_rq
#debug bool Mdb.SendTo_rq
 WRX  SendTo~rq
#debug_left bool SendTo.rq
#srcline 109 ;        SendTo.lenTx := Mdb.SendTo_lenTx;
 LDX  Mdb~SendTo_lenTx
#debug uint Mdb.SendTo_lenTx
 WRX  SendTo~lenTx
#debug_left uint SendTo.lenTx
#srcline 110 ;      ELSE
 JMP  fbModbusRTUslave_L12
fbModbusRTUslave_L11:
#srcline 111 ;        errCnt := errCnt + 1;
 LDX  errCnt
#debug udint errCnt
 LD   udint 1
 ADD
 WRX  errCnt
#debug_left udint errCnt
#srcline 112 ;        err   := 1;
 LD   bool -1      ; true
 WRX  err
#debug_left bool err
#srcline 113 ;        errCode := 131;
 LD   usint 131
 WRX  errCode
#debug_left usint errCode
#srcline 114 ;      END_IF;
fbModbusRTUslave_L12:
#srcline 115 ;    END_IF;
fbModbusRTUslave_L9:
#srcline 116 ;  END_IF;
fbModbusRTUslave_L7:
#srcline 117 ;  
#srcline 118 ;  IF Mdb.Exception <> 0 THEN
 LDX  Mdb~Exception
#debug usint Mdb.Exception
 LD   usint 0
 EQ
 NEG
 JMC  fbModbusRTUslave_L13
#srcline 119 ;    excCnt := excCnt + 1;
 LDX  excCnt
#debug udint excCnt
 LD   udint 1
 ADD
 WRX  excCnt
#debug_left udint excCnt
#srcline 120 ;    err   := 1;
 LD   bool -1      ; true
 WRX  err
#debug_left bool err
#srcline 121 ;    errCode := 136 + Mdb.Exception;
 LD   usint 136
 LDX  Mdb~Exception
#debug usint Mdb.Exception
 ADD
 AND  $FF
 WRX  errCode
#debug_left usint errCode
#srcline 122 ;  END_IF;
fbModbusRTUslave_L13:
#srcline 123 ;  
#srcline 125 ;  IF SendTo.rq THEN
 LDX  SendTo~rq
#debug bool SendTo.rq
 JMC  fbModbusRTUslave_L15
#srcline 126 ;    Crc := UINT_TO_WORD(CheckCRC_16(ptr := ADR(Mdb.Buf), length := SendTo.lenTx-2));
 NXT
 LEAX Mdb
#debug pointer Mdb.Buf
 LEA  __Instance__CheckCRC_16~ptr
 WRIL 
#debug_left udint __Instance__CheckCRC_16~ptr
 LDX  SendTo~lenTx
#debug uint SendTo.lenTx
 LD   uint 2
 SUB
 AND  $FFFF
 WR   __Instance__CheckCRC_16~length
#debug_left uint __Instance__CheckCRC_16~length
 PRV
 LEA  __Instance__CheckCRC_16
 CAL  CheckCRC_16_L0
 WRY  Crc
#debug_left word Crc
#srcline 127 ;    Mdb.Buf[SendTo.lenTx-1] := WORD_TO_USINT(SHR(Crc,8));
 LDY  Crc
#debug word Crc
 LD   uint 8
 SHR
 AND  $FFFF
 AND  $FF
 LEAX Mdb
 LDX  SendTo~lenTx
#debug uint SendTo.lenTx
 LD   uint 1
 SUB
 AND  $FFFF
 RCHK 256   ; Range Check
 ADD     ; + offset 
 WRI 
#debug_left usint Mdb.Buf[SendTo.lenTx-1]
#srcline 128 ;    Mdb.Buf[SendTo.lenTx-2] := WORD_TO_USINT(Crc);
 LDY  Crc
#debug word Crc
 AND  $FF
 LEAX Mdb
 LDX  SendTo~lenTx
#debug uint SendTo.lenTx
 LD   uint 2
 SUB
 AND  $FFFF
 RCHK 256   ; Range Check
 ADD     ; + offset 
 WRI 
#debug_left usint Mdb.Buf[SendTo.lenTx-2]
#srcline 129 ;  END_IF;
fbModbusRTUslave_L15:
#srcline 131 ;  IF read OR write THEN
 LDX  read
#debug bool read
 LDX  write
#debug bool write
 OR  
 JMC  fbModbusRTUslave_L17
#srcline 132 ;    msgCnt := msgCnt + 1;
 LDX  msgCnt
#debug udint msgCnt
 LD   udint 1
 ADD
 WRX  msgCnt
#debug_left udint msgCnt
#srcline 133 ;  END_IF;
fbModbusRTUslave_L17:
#srcline 134 ;  SendTo(chanCode := chanCode, data := void(Mdb.Buf));
 LDX  chanCode
#debug uint chanCode
 WRX  SendTo~chanCode
#debug_left uint SendTo~chanCode
 LEAX Mdb
 WRX  SendTo~data
#debug_left pointer SendTo.data
 LEAX SendTo
 CAL  fbSendTo_L0
#srcline 135 ;  SendTo.rq := 0;
 LD   bool 0       ; false
 WRX  SendTo~rq
#debug_left bool SendTo.rq
#srcline 137 ;  IF SendTo.error > 0 THEN
 LDX  SendTo~error
#debug usint SendTo.error
 LD   usint 0
 GT
 JMC  fbModbusRTUslave_L19
#srcline 138 ;    err := true;
 LD   bool -1       ; true
 WRX  err
#debug_left bool err
#srcline 139 ;    errCode := SendTo.error;
 LDX  SendTo~error
#debug usint SendTo.error
 WRX  errCode
#debug_left usint errCode
#srcline 140 ;  END_IF;
fbModbusRTUslave_L19:
#srcline 142 ;  brdcst := Mdb.Broadcast;
 LDX  Mdb~Broadcast
#debug bool Mdb.Broadcast
 WRX  brdcst
#debug_left bool brdcst
#srcline 144 ;END_FUNCTION_BLOCK
fbModbusRTUslave_RET:
 ULNK
RET
E     61

; Initialize - variables
P     61
fbModbusRTUslave__InstanceInit__:
 LINK 0
 LEAX RecvFrom
 CAL  fbRecvFrom__InstanceInit__
 LEAX SendTo
 CAL  fbSendTo__InstanceInit__
 LEAX Mdb
 CAL  fbModbusSlave__InstanceInit__
 ULNK
RET
E     61
; End initialize - variables
#endpou 



 

#srcfile ''
#srcfile 'C:\TECOLIBSRC\MODBUSRTU\MODBUSRTU\FBMODBUSTCPSLAVE.ST'
#pou fbModbusTCPslave
#srcline 2 ;FUNCTION_BLOCK fbModbusTCPslave

#struct fbModbusTCPslave__temp__
  TRemoteEthAdr ethAdrGet,
  TRemoteEthAdr ethAdrSet,
  TUniDesc uniDesc
P     61
fbModbusTCPslave_L0:
 LINK __SizeOf(fbModbusTCPslave__temp__)
; Initialize - dynamic variables
; End initialize - dynamic variables
#srcline 80 ;  fcModbusTCPoff();
 LEA  __Instance__fcModbusTcpOff
 CAL  fcModbusTcpOff_L0
#srcline 81 ;  
#srcline 82 ;  EstabTCPconnection(chanCode := chanCode); //allow connection
 NXT
 LDX  chanCode
#debug uint chanCode
 WR   __Instance__EstabTCPconnection~chanCode
#debug_left uint __Instance__EstabTCPconnection~chanCode
 PRV
 LEA  __Instance__EstabTCPconnection
 CAL  EstabTCPconnection_L0
#srcline 84 ;  Read  := 0;
 LD   bool 0       ; false
 WRX  Read
#debug_left bool Read
#srcline 85 ;  Write := 0;
 LD   bool 0       ; false
 WRX  Write
#debug_left bool Write
#srcline 86 ;  Err   := 0;
 LD   bool 0       ; false
 WRX  Err
#debug_left bool Err
#srcline 87 ;  Mdb.Exception := 0;
 LD   usint 0
 WRX  Mdb~Exception
#debug_left usint Mdb.Exception
#srcline 89 ;  established := IsEstabTCPconnection(chanCode := chanCode);
 NXT
 LDX  chanCode
#debug uint chanCode
 WR   __Instance__IsEstabTCPconnection~chanCode
#debug_left uint __Instance__IsEstabTCPconnection~chanCode
 PRV
 LEA  __Instance__IsEstabTCPconnection
 CAL  IsEstabTCPconnection_L0
 WRX  established
#debug_left bool established
#srcline 90 ;  
#srcline 91 ;  IF GetChanIndex( chanCode) <> -1 THEN
 NXT
 LDX  chanCode
#debug uint chanCode
 WR   __Instance__GetChanIndex~chanCode
#debug_left uint __Instance__GetChanIndex~chanCode
 PRV
 LEA  __Instance__GetChanIndex
 CAL  GetChanIndex_L0
 LD   int -1
 EQ
 NEG
 JMC  fbModbusTCPslave_L1
#srcline 92 ;  // kanal zalozen pomoci #module => kontrola nutna
#srcline 93 ;    uniDesc := GetChanDesc( chanCode);
 NXT
 LDX  chanCode
#debug uint chanCode
 WR   __Instance__GetChanDesc~chanCode
#debug_left uint __Instance__GetChanDesc~chanCode
 PRV
 LEA  __Instance__GetChanDesc
 CAL  GetChanDesc_L0
 LEAY uniDesc
#debug_left pointer uniDesc
 LD   26   ;SizeOf() 
 MOV  %IB0
#srcline 94 ;    IF uniDesc.lenUniIn < 263 OR uniDesc.lenUniOut < 263 THEN
 LDY  uniDesc~lenUniIn
#debug uint uniDesc.lenUniIn
 LD   uint 263
 LT
 LDY  uniDesc~lenUniOut
#debug uint uniDesc.lenUniOut
 LD   uint 263
 LT
 OR  
 JMC  fbModbusTCPslave_L3
#srcline 95 ;      RecvFrom.error := COM_ERRc6;
 LD   usint 198
 WRX  RecvFrom~error
#debug_left usint RecvFrom.error
#srcline 96 ;    END_IF;
fbModbusTCPslave_L3:
#srcline 97 ;  END_IF;
fbModbusTCPslave_L1:
#srcline 99 ;  RecvFrom(rq := 1, chanCode := chanCode, lenRx := 259, sizeBuf := 1036, buffer := buffer[0], data := void(TrascactionIndent));
 LD   1
 WRX  RecvFrom~rq
#debug_left bool RecvFrom~rq
 LDX  chanCode
#debug uint chanCode
 WRX  RecvFrom~chanCode
#debug_left uint RecvFrom~chanCode
 LD   uint 259
 WRX  RecvFrom~lenRx
#debug_left uint RecvFrom~lenRx
 LD   uint 1036
 WRX  RecvFrom~sizeBuf
#debug_left uint RecvFrom~sizeBuf
 LEAX buffer
 WRX  RecvFrom~buffer
#debug_left pointer RecvFrom.buffer
 LEAX TrascactionIndent
 WRX  RecvFrom~data
#debug_left pointer RecvFrom.data
 LEAX RecvFrom
 CAL  fbRecvFromModbus_L0
#srcline 100 ;  RecvFrom.reset := 0;
 LD   bool 0       ; false
 WRX  RecvFrom~reset
#debug_left bool RecvFrom.reset
#srcline 102 ;  IF RecvFrom.error > 0 THEN
 LDX  RecvFrom~error
#debug usint RecvFrom.error
 LD   usint 0
 GT
 JMC  fbModbusTCPslave_L5
#srcline 103 ;    err := 1;
 LD   bool -1      ; true
 WRX  err
#debug_left bool err
#srcline 104 ;    errCode := RecvFrom.error;
 LDX  RecvFrom~error
#debug usint RecvFrom.error
 WRX  errCode
#debug_left usint errCode
#srcline 105 ;    RecvFrom.reset := 1;
 LD   bool -1      ; true
 WRX  RecvFrom~reset
#debug_left bool RecvFrom.reset
#srcline 106 ;    IF errCode <> 1 AND errCode <> 4 THEN
 LDX  errCode
#debug usint errCode
 LD   usint 1
 EQ
 NEG
 LDX  errCode
#debug usint errCode
 LD   usint 4
 EQ
 NEG
 AND
 JMC  fbModbusTCPslave_L7
#srcline 107 ;      errCnt := errCnt + 1;
 LDX  errCnt
#debug udint errCnt
 LD   udint 1
 ADD
 WRX  errCnt
#debug_left udint errCnt
#srcline 108 ;    END_IF;
fbModbusTCPslave_L7:
#srcline 109 ;    CloseTCPconnection(chanCode := chanCode); //zavrit kanal
 NXT
 LDX  chanCode
#debug uint chanCode
 WR   __Instance__CloseTCPconnection~chanCode
#debug_left uint __Instance__CloseTCPconnection~chanCode
 PRV
 LEA  __Instance__CloseTCPconnection
 CAL  CloseTCPconnection_L0
#srcline 110 ;    return;
 JMP  fbModbusTCPslave_RET
#srcline 111 ;  END_IF;
fbModbusTCPslave_L5:
#srcline 112 ;  
#srcline 113 ;  IF RecvFrom.bufFul THEN //prepinili se kanal je potreba to zavrit
 LDX  RecvFrom~bufFul
#debug bool RecvFrom.bufFul
 JMC  fbModbusTCPslave_L9
#srcline 114 ;    err := 1;
 LD   bool -1      ; true
 WRX  err
#debug_left bool err
#srcline 115 ;    errCode := 3;
 LD   usint 3
 WRX  errCode
#debug_left usint errCode
#srcline 116 ;    RecvFrom.reset := 1;
 LD   bool -1      ; true
 WRX  RecvFrom~reset
#debug_left bool RecvFrom.reset
#srcline 117 ;    CloseTCPconnection(chanCode := chanCode); //zavrit kanal
 NXT
 LDX  chanCode
#debug uint chanCode
 WR   __Instance__CloseTCPconnection~chanCode
#debug_left uint __Instance__CloseTCPconnection~chanCode
 PRV
 LEA  __Instance__CloseTCPconnection
 CAL  CloseTCPconnection_L0
#srcline 118 ;    return;
 JMP  fbModbusTCPslave_RET
#srcline 119 ;  END_IF;
fbModbusTCPslave_L9:
#srcline 121 ;  IF (UINT_TO_WORD(chanCode) and 16#00FF <> 16#00E1) AND ((System_S.S42 = 16#4B) OR (System_S.S42 = 16#4C)) THEN  //CPM K nebo L a Eth <> ETH1
 LDX  chanCode
#debug uint chanCode
 LD   word $00FF
 AND
 LD   word $00E1
 EQ
 NEG
 LD   System_S~S42
#debug byte System_S.S42
 LD   byte $4B
 EQ
 LD   System_S~S42
#debug byte System_S.S42
 LD   byte $4C
 EQ
 OR  
 AND
 JMC  fbModbusTCPslave_L11
#srcline 122 ;    IF NOT established THEN
 LDX  established
#debug bool established
 NEG
 JMC  fbModbusTCPslave_L13
#srcline 123 ;      GetRemoteIPaddress(chanCode := chanCode, ethAdr := ethAdrGet);
 NXT
 LDX  chanCode
#debug uint chanCode
 WR   __Instance__GetRemoteIPaddress~chanCode
#debug_left uint __Instance__GetRemoteIPaddress~chanCode
 LEAY ethAdrGet
 WR   __Instance__GetRemoteIPaddress~ethAdr
#debug_left pointer __Instance__GetRemoteIPaddress.ethAdr
 PRV
 LEA  __Instance__GetRemoteIPaddress
 CAL  GetRemoteIPaddress_L0
#srcline 124 ;      IF ethAdrGet.localPort <> port THEN
 LDY  ethAdrGet~localPort
#debug uint ethAdrGet.localPort
 LDX  port
#debug uint port
 EQ
 NEG
 JMC  fbModbusTCPslave_L15
#srcline 125 ;        ethAdrSet.localPort := port;
 LDX  port
#debug uint port
 WRY  ethAdrSet~localPort
#debug_left uint ethAdrSet.localPort
#srcline 126 ;        SetRemoteIPaddress(rq := NOT established, chanCode := chanCode, ethAdr := ethAdrSet);
 NXT
 LDX  established
#debug bool established
 NEG
 WR   __Instance__SetRemoteIPaddress~rq
#debug_left bool __Instance__SetRemoteIPaddress~rq
 LDX  chanCode
#debug uint chanCode
 WR   __Instance__SetRemoteIPaddress~chanCode
#debug_left uint __Instance__SetRemoteIPaddress~chanCode
 LEAY ethAdrSet
 WR   __Instance__SetRemoteIPaddress~ethAdr
#debug_left pointer __Instance__SetRemoteIPaddress.ethAdr
 PRV
 LEA  __Instance__SetRemoteIPaddress
 CAL  SetRemoteIPaddress_L0
#srcline 127 ;      END_IF;
fbModbusTCPslave_L15:
#srcline 128 ;    END_IF;
fbModbusTCPslave_L13:
#srcline 129 ;  ELSE
 JMP  fbModbusTCPslave_L12
fbModbusTCPslave_L11:
#srcline 130 ;    GetRemoteIPaddress(chanCode := chanCode, ethAdr := ethAdrGet);
 NXT
 LDX  chanCode
#debug uint chanCode
 WR   __Instance__GetRemoteIPaddress~chanCode
#debug_left uint __Instance__GetRemoteIPaddress~chanCode
 LEAY ethAdrGet
 WR   __Instance__GetRemoteIPaddress~ethAdr
#debug_left pointer __Instance__GetRemoteIPaddress.ethAdr
 PRV
 LEA  __Instance__GetRemoteIPaddress
 CAL  GetRemoteIPaddress_L0
#srcline 131 ;    IF ethAdrGet.localPort <> port THEN
 LDY  ethAdrGet~localPort
#debug uint ethAdrGet.localPort
 LDX  port
#debug uint port
 EQ
 NEG
 JMC  fbModbusTCPslave_L17
#srcline 132 ;      CloseTCPconnection(chanCode := chanCode);
 NXT
 LDX  chanCode
#debug uint chanCode
 WR   __Instance__CloseTCPconnection~chanCode
#debug_left uint __Instance__CloseTCPconnection~chanCode
 PRV
 LEA  __Instance__CloseTCPconnection
 CAL  CloseTCPconnection_L0
#srcline 133 ;      IF NOT established THEN
 LDX  established
#debug bool established
 NEG
 JMC  fbModbusTCPslave_L19
#srcline 134 ;        ethAdrSet.localPort := port;
 LDX  port
#debug uint port
 WRY  ethAdrSet~localPort
#debug_left uint ethAdrSet.localPort
#srcline 135 ;        SetRemoteIPaddress(rq := NOT established, chanCode := chanCode, ethAdr := ethAdrSet);
 NXT
 LDX  established
#debug bool established
 NEG
 WR   __Instance__SetRemoteIPaddress~rq
#debug_left bool __Instance__SetRemoteIPaddress~rq
 LDX  chanCode
#debug uint chanCode
 WR   __Instance__SetRemoteIPaddress~chanCode
#debug_left uint __Instance__SetRemoteIPaddress~chanCode
 LEAY ethAdrSet
 WR   __Instance__SetRemoteIPaddress~ethAdr
#debug_left pointer __Instance__SetRemoteIPaddress.ethAdr
 PRV
 LEA  __Instance__SetRemoteIPaddress
 CAL  SetRemoteIPaddress_L0
#srcline 136 ;      END_IF;
fbModbusTCPslave_L19:
#srcline 137 ;    END_IF;
fbModbusTCPslave_L17:
#srcline 138 ;  END_IF;
fbModbusTCPslave_L12:
#srcline 140 ;  IF RecvFrom.mesRec THEN
 LDX  RecvFrom~mesRec
#debug bool RecvFrom.mesRec
 JMC  fbModbusTCPslave_L21
#srcline 141 ;    IF UnitID = 0 OR Mdb.Buf[0] = UnitID THEN //zprava je pro nas
 LDX  UnitID
#debug usint UnitID
 LD   usint 0
 EQ
 LDX  Mdb~Buf[0]
#debug usint Mdb.Buf[0]
 LDX  UnitID
#debug usint UnitID
 EQ
 OR  
 JMC  fbModbusTCPslave_L23
#srcline 142 ;      lastCmd := Mdb.Buf[1];
 LDX  Mdb~Buf[1]
#debug usint Mdb.Buf[1]
 WRX  lastCmd
#debug_left usint lastCmd
#srcline 143 ;      Mdb(inputsCnt := inputsCnt,
 LDX  inputsCnt
#debug uint inputsCnt
 WRX  Mdb~inputsCnt
#debug_left uint Mdb~inputsCnt
#srcline 144 ;          coilsCnt := coilsCnt,
 LDX  coilsCnt
#debug uint coilsCnt
 WRX  Mdb~coilsCnt
#debug_left uint Mdb~coilsCnt
#srcline 145 ;          inputRegCnt := inputRegCnt,
 LDX  inputRegCnt
#debug uint inputRegCnt
 WRX  Mdb~inputRegCnt
#debug_left uint Mdb~inputRegCnt
#srcline 146 ;          holdingRegCnt := holdingRegCnt,
 LDX  holdingRegCnt
#debug uint holdingRegCnt
 WRX  Mdb~holdingRegCnt
#debug_left uint Mdb~holdingRegCnt
#srcline 147 ;          inputs := inputs,
 LDX  inputs
 WRX  Mdb~inputs
#debug_left pointer Mdb.inputs
#srcline 148 ;          coils := coils,
 LDX  coils
 WRX  Mdb~coils
#debug_left pointer Mdb.coils
#srcline 149 ;          inputRegs := inputRegs,
 LDX  inputRegs
 WRX  Mdb~inputRegs
#debug_left pointer Mdb.inputRegs
#srcline 150 ;          holdingRegs := holdingRegs);
 LDX  holdingRegs
 WRX  Mdb~holdingRegs
#debug_left pointer Mdb.holdingRegs
 LEAX Mdb
 CAL  fbModbusSlave_L0
#srcline 151 ;      lastAddr := Mdb.Addr;
 LDX  Mdb~Addr
#debug uint Mdb.Addr
 WRX  lastAddr
#debug_left uint lastAddr
#srcline 152 ;      lastQuantity := Mdb.Quantity;
 LDX  Mdb~Quantity
#debug uint Mdb.Quantity
 WRX  lastQuantity
#debug_left uint lastQuantity
#srcline 153 ;      read  := Mdb.read;
 LDX  Mdb~read
#debug bool Mdb.read
 WRX  read
#debug_left bool read
#srcline 154 ;      write := Mdb.write;
 LDX  Mdb~write
#debug bool Mdb.write
 WRX  write
#debug_left bool write
#srcline 155 ;      SendTo.rq    := Mdb.SendTo_rq;
 LDX  Mdb~SendTo_rq
#debug bool Mdb.SendTo_rq
 WRX  SendTo~rq
#debug_left bool SendTo.rq
#srcline 156 ;      SendTo.lenTx := Mdb.SendTo_lenTx;
 LDX  Mdb~SendTo_lenTx
#debug uint Mdb.SendTo_lenTx
 WRX  SendTo~lenTx
#debug_left uint SendTo.lenTx
#srcline 157 ;    END_IF;
fbModbusTCPslave_L23:
#srcline 158 ;  END_IF;
fbModbusTCPslave_L21:
#srcline 160 ;  IF Mdb.Exception <> 0 THEN
 LDX  Mdb~Exception
#debug usint Mdb.Exception
 LD   usint 0
 EQ
 NEG
 JMC  fbModbusTCPslave_L25
#srcline 161 ;    excCnt := excCnt + 1;
 LDX  excCnt
#debug udint excCnt
 LD   udint 1
 ADD
 WRX  excCnt
#debug_left udint excCnt
#srcline 162 ;    err   := 1;
 LD   bool -1      ; true
 WRX  err
#debug_left bool err
#srcline 163 ;    errCode := 136 + Mdb.Exception;
 LD   usint 136
 LDX  Mdb~Exception
#debug usint Mdb.Exception
 ADD
 AND  $FF
 WRX  errCode
#debug_left usint errCode
#srcline 164 ;  END_IF;
fbModbusTCPslave_L25:
#srcline 166 ;  IF read OR write THEN
 LDX  read
#debug bool read
 LDX  write
#debug bool write
 OR  
 JMC  fbModbusTCPslave_L27
#srcline 167 ;    msgCnt := msgCnt + 1;
 LDX  msgCnt
#debug udint msgCnt
 LD   udint 1
 ADD
 WRX  msgCnt
#debug_left udint msgCnt
#srcline 168 ;  END_IF;
fbModbusTCPslave_L27:
#srcline 170 ;  IF SendTo.rq THEN
 LDX  SendTo~rq
#debug bool SendTo.rq
 JMC  fbModbusTCPslave_L29
#srcline 171 ;    Length := WORD_TO_UINT(ROL(UINT_TO_WORD(SendTo.lenTx - 2),8)); //prohodit byte 20131008
 LDX  SendTo~lenTx
#debug uint SendTo.lenTx
 LD   uint 2
 SUB
 AND  $FFFF
 MUL  $00010001
 LD   uint 8
 ROL
 AND  $FFFF
 WRX  Length
#debug_left uint Length
#srcline 172 ;    SendTo.lenTx := SendTo.lenTx + 4;
 LDX  SendTo~lenTx
#debug uint SendTo.lenTx
 LD   uint 4
 ADD
 AND  $FFFF
 WRX  SendTo~lenTx
#debug_left uint SendTo.lenTx
#srcline 173 ;  END_IF;
fbModbusTCPslave_L29:
#srcline 175 ;  SendTo(chanCode := chanCode, data := void(TrascactionIndent));
 LDX  chanCode
#debug uint chanCode
 WRX  SendTo~chanCode
#debug_left uint SendTo~chanCode
 LEAX TrascactionIndent
 WRX  SendTo~data
#debug_left pointer SendTo.data
 LEAX SendTo
 CAL  fbSendTo_L0
#srcline 176 ;  SendTo.rq := 0;
 LD   bool 0       ; false
 WRX  SendTo~rq
#debug_left bool SendTo.rq
#srcline 178 ;  IF SendTo.error > 0 THEN
 LDX  SendTo~error
#debug usint SendTo.error
 LD   usint 0
 GT
 JMC  fbModbusTCPslave_L31
#srcline 179 ;    err := true;
 LD   bool -1       ; true
 WRX  err
#debug_left bool err
#srcline 180 ;    errCode := SendTo.error;
 LDX  SendTo~error
#debug usint SendTo.error
 WRX  errCode
#debug_left usint errCode
#srcline 181 ;  END_IF;
fbModbusTCPslave_L31:
#srcline 183 ;END_FUNCTION_BLOCK
fbModbusTCPslave_RET:
 ULNK
RET
E     61

; Initialize - variables
P     61
fbModbusTCPslave__InstanceInit__:
 LINK 0
 LD   uint 502
 WRX  port
 LEAX RecvFrom
 CAL  fbRecvFromModbus__InstanceInit__
 LEAX SendTo
 CAL  fbSendTo__InstanceInit__
 LEAX Mdb
 CAL  fbModbusSlave__InstanceInit__
 ULNK
RET
E     61
; End initialize - variables
#endpou 



 

#srcfile ''
#srcfile 'C:\TECOLIBSRC\MODBUSRTU\MODBUSRTU\FBMODBUSTCPSLAVE2.ST'
#pou fbModbusTCPslave2
#srcline 1 ;FUNCTION_BLOCK fbModbusTCPslave2 {HIDDEN}

#struct fbModbusTCPslave2__temp__
  TRemoteEthAdr ethAdrGet,
  TRemoteEthAdr ethAdrSet,
  TUniDesc uniDesc
P     61
fbModbusTCPslave2_L0:
 LINK __SizeOf(fbModbusTCPslave2__temp__)
; Initialize - dynamic variables
; End initialize - dynamic variables
#srcline 89 ;  fcModbusTCPoff();
 LEA  __Instance__fcModbusTcpOff
 CAL  fcModbusTcpOff_L0
#srcline 91 ;  Read  := 0;
 LD   bool 0       ; false
 WRX  Read
#debug_left bool Read
#srcline 92 ;  Write := 0;
 LD   bool 0       ; false
 WRX  Write
#debug_left bool Write
#srcline 93 ;  Err   := 0;
 LD   bool 0       ; false
 WRX  Err
#debug_left bool Err
#srcline 94 ;  Mdb.Exception := 0;
 LD   usint 0
 WRX  Mdb~Exception
#debug_left usint Mdb.Exception
#srcline 96 ;  RecvFrom(rq := 1, chanCode := chanCode, lenRx := 259, data := void(TrascactionIndent));
 LD   1
 WRX  RecvFrom~rq
#debug_left bool RecvFrom~rq
 LDX  chanCode
#debug uint chanCode
 WRX  RecvFrom~chanCode
#debug_left uint RecvFrom~chanCode
 LD   uint 259
 WRX  RecvFrom~lenRx
#debug_left uint RecvFrom~lenRx
 LEAX TrascactionIndent
 WRX  RecvFrom~data
#debug_left pointer RecvFrom.data
 LEAX RecvFrom
 CAL  fbRecvFrom_L0
#srcline 98 ;  established := IsEstabTCPconnection(chanCode := chanCode);
 NXT
 LDX  chanCode
#debug uint chanCode
 WR   __Instance__IsEstabTCPconnection~chanCode
#debug_left uint __Instance__IsEstabTCPconnection~chanCode
 PRV
 LEA  __Instance__IsEstabTCPconnection
 CAL  IsEstabTCPconnection_L0
 WRX  established
#debug_left bool established
#srcline 99 ;  
#srcline 100 ;  uniDesc := GetChanDesc( chanCode);
 NXT
 LDX  chanCode
#debug uint chanCode
 WR   __Instance__GetChanDesc~chanCode
#debug_left uint __Instance__GetChanDesc~chanCode
 PRV
 LEA  __Instance__GetChanDesc
 CAL  GetChanDesc_L0
 LEAY uniDesc
#debug_left pointer uniDesc
 LD   26   ;SizeOf() 
 MOV  %IB0
#srcline 101 ;  IF uniDesc.lenUniIn < 263 OR uniDesc.lenUniOut < 263 THEN
 LDY  uniDesc~lenUniIn
#debug uint uniDesc.lenUniIn
 LD   uint 263
 LT
 LDY  uniDesc~lenUniOut
#debug uint uniDesc.lenUniOut
 LD   uint 263
 LT
 OR  
 JMC  fbModbusTCPslave2_L1
#srcline 102 ;    RecvFrom.error := COM_ERRc6;
 LD   usint 198
 WRX  RecvFrom~error
#debug_left usint RecvFrom.error
#srcline 103 ;  END_IF;
fbModbusTCPslave2_L1:
#srcline 105 ;  IF RecvFrom.error > 0 THEN
 LDX  RecvFrom~error
#debug usint RecvFrom.error
 LD   usint 0
 GT
 JMC  fbModbusTCPslave2_L3
#srcline 106 ;    err := 1;
 LD   bool -1      ; true
 WRX  err
#debug_left bool err
#srcline 107 ;    errCode := RecvFrom.error;
 LDX  RecvFrom~error
#debug usint RecvFrom.error
 WRX  errCode
#debug_left usint errCode
#srcline 108 ;    IF errCode <> 1 AND errCode <> 4 THEN errCnt := errCnt + 1; END_IF;
 LDX  errCode
#debug usint errCode
 LD   usint 1
 EQ
 NEG
 LDX  errCode
#debug usint errCode
 LD   usint 4
 EQ
 NEG
 AND
 JMC  fbModbusTCPslave2_L5
 LDX  errCnt
#debug udint errCnt
 LD   udint 1
 ADD
 WRX  errCnt
#debug_left udint errCnt
fbModbusTCPslave2_L5:
#srcline 109 ;    return;
 JMP  fbModbusTCPslave2_RET
#srcline 110 ;  END_IF;
fbModbusTCPslave2_L3:
#srcline 112 ;{$ifdef FORCED_SWITCH}
#srcline 114 ;  GetRemoteIPaddress(chanCode := chanCode, ethAdr := ethAdrGet);
#srcline 115 ;  IF ethAdrGet.localPort <> port THEN
#srcline 116 ;    CloseTCPconnection(chanCode := chanCode);
#srcline 117 ;    IF NOT established THEN
#srcline 118 ;      ethAdrSet.localPort := port;
#srcline 119 ;      SetRemoteIPaddress(rq := NOT established, chanCode := chanCode, ethAdr := ethAdrSet);
#srcline 120 ;      EstabTCPconnection(chanCode := chanCode);
#srcline 121 ;    END_IF;
#srcline 122 ;  END_IF;
#srcline 123 ;{$else}
#srcline 124 ;  IF NOT established THEN
 LDX  established
#debug bool established
 NEG
 JMC  fbModbusTCPslave2_L7
#srcline 125 ;    GetRemoteIPaddress(chanCode := chanCode, ethAdr := ethAdrGet);
 NXT
 LDX  chanCode
#debug uint chanCode
 WR   __Instance__GetRemoteIPaddress~chanCode
#debug_left uint __Instance__GetRemoteIPaddress~chanCode
 LEAY ethAdrGet
 WR   __Instance__GetRemoteIPaddress~ethAdr
#debug_left pointer __Instance__GetRemoteIPaddress.ethAdr
 PRV
 LEA  __Instance__GetRemoteIPaddress
 CAL  GetRemoteIPaddress_L0
#srcline 126 ;    IF ethAdrGet.localPort <> port THEN
 LDY  ethAdrGet~localPort
#debug uint ethAdrGet.localPort
 LDX  port
#debug uint port
 EQ
 NEG
 JMC  fbModbusTCPslave2_L9
#srcline 127 ;      ethAdrSet.localPort := port;
 LDX  port
#debug uint port
 WRY  ethAdrSet~localPort
#debug_left uint ethAdrSet.localPort
#srcline 128 ;      SetRemoteIPaddress(rq := NOT established, chanCode := chanCode, ethAdr := ethAdrSet);
 NXT
 LDX  established
#debug bool established
 NEG
 WR   __Instance__SetRemoteIPaddress~rq
#debug_left bool __Instance__SetRemoteIPaddress~rq
 LDX  chanCode
#debug uint chanCode
 WR   __Instance__SetRemoteIPaddress~chanCode
#debug_left uint __Instance__SetRemoteIPaddress~chanCode
 LEAY ethAdrSet
 WR   __Instance__SetRemoteIPaddress~ethAdr
#debug_left pointer __Instance__SetRemoteIPaddress.ethAdr
 PRV
 LEA  __Instance__SetRemoteIPaddress
 CAL  SetRemoteIPaddress_L0
#srcline 129 ;    END_IF;
fbModbusTCPslave2_L9:
#srcline 130 ;  END_IF;
fbModbusTCPslave2_L7:
#srcline 131 ;{$end_if}
#srcline 133 ;  IF RecvFrom.mesRec THEN
 LDX  RecvFrom~mesRec
#debug bool RecvFrom.mesRec
 JMC  fbModbusTCPslave2_L11
#srcline 134 ;    lastUnitID := Mdb.Buf[0];
 LDX  Mdb~Buf[0]
#debug usint Mdb.Buf[0]
 WRX  lastUnitID
#debug_left usint lastUnitID
#srcline 135 ;    IF Mdb.Buf[0] = UnitID1 OR Mdb.Buf[0] = UnitID2 THEN //zprava je pro nas
 LDX  Mdb~Buf[0]
#debug usint Mdb.Buf[0]
 LDX  UnitID1
#debug usint UnitID1
 EQ
 LDX  Mdb~Buf[0]
#debug usint Mdb.Buf[0]
 LDX  UnitID2
#debug usint UnitID2
 EQ
 OR  
 JMC  fbModbusTCPslave2_L13
#srcline 136 ;      lastCmd := Mdb.Buf[1];
 LDX  Mdb~Buf[1]
#debug usint Mdb.Buf[1]
 WRX  lastCmd
#debug_left usint lastCmd
#srcline 137 ;      IF Mdb.Buf[0] = UnitID1 THEN
 LDX  Mdb~Buf[0]
#debug usint Mdb.Buf[0]
 LDX  UnitID1
#debug usint UnitID1
 EQ
 JMC  fbModbusTCPslave2_L15
#srcline 138 ;        Mdb(inputsCnt := inputsCnt1,
 LDX  inputsCnt1
#debug uint inputsCnt1
 WRX  Mdb~inputsCnt
#debug_left uint Mdb~inputsCnt
#srcline 139 ;            coilsCnt := coilsCnt1,
 LDX  coilsCnt1
#debug uint coilsCnt1
 WRX  Mdb~coilsCnt
#debug_left uint Mdb~coilsCnt
#srcline 140 ;            inputRegCnt := inputRegCnt1,
 LDX  inputRegCnt1
#debug uint inputRegCnt1
 WRX  Mdb~inputRegCnt
#debug_left uint Mdb~inputRegCnt
#srcline 141 ;            holdingRegCnt := holdingRegCnt1,
 LDX  holdingRegCnt1
#debug uint holdingRegCnt1
 WRX  Mdb~holdingRegCnt
#debug_left uint Mdb~holdingRegCnt
#srcline 142 ;            inputs := inputs1,
 LDX  inputs1
 WRX  Mdb~inputs
#debug_left pointer Mdb.inputs
#srcline 143 ;            coils := coils1,
 LDX  coils1
 WRX  Mdb~coils
#debug_left pointer Mdb.coils
#srcline 144 ;            inputRegs := inputRegs1,
 LDX  inputRegs1
 WRX  Mdb~inputRegs
#debug_left pointer Mdb.inputRegs
#srcline 145 ;            holdingRegs := holdingRegs1);
 LDX  holdingRegs1
 WRX  Mdb~holdingRegs
#debug_left pointer Mdb.holdingRegs
 LEAX Mdb
 CAL  fbModbusSlave_L0
#srcline 146 ;      ELSE
 JMP  fbModbusTCPslave2_L16
fbModbusTCPslave2_L15:
#srcline 147 ;        Mdb(inputsCnt := inputsCnt2,
 LDX  inputsCnt2
#debug uint inputsCnt2
 WRX  Mdb~inputsCnt
#debug_left uint Mdb~inputsCnt
#srcline 148 ;            coilsCnt := coilsCnt2,
 LDX  coilsCnt2
#debug uint coilsCnt2
 WRX  Mdb~coilsCnt
#debug_left uint Mdb~coilsCnt
#srcline 149 ;            inputRegCnt := inputRegCnt2,
 LDX  inputRegCnt2
#debug uint inputRegCnt2
 WRX  Mdb~inputRegCnt
#debug_left uint Mdb~inputRegCnt
#srcline 150 ;            holdingRegCnt := holdingRegCnt2,
 LDX  holdingRegCnt2
#debug uint holdingRegCnt2
 WRX  Mdb~holdingRegCnt
#debug_left uint Mdb~holdingRegCnt
#srcline 151 ;            inputs := inputs2,
 LDX  inputs2
 WRX  Mdb~inputs
#debug_left pointer Mdb.inputs
#srcline 152 ;            coils := coils2,
 LDX  coils2
 WRX  Mdb~coils
#debug_left pointer Mdb.coils
#srcline 153 ;            inputRegs := inputRegs2,
 LDX  inputRegs2
 WRX  Mdb~inputRegs
#debug_left pointer Mdb.inputRegs
#srcline 154 ;            holdingRegs := holdingRegs2);
 LDX  holdingRegs2
 WRX  Mdb~holdingRegs
#debug_left pointer Mdb.holdingRegs
 LEAX Mdb
 CAL  fbModbusSlave_L0
#srcline 155 ;      END_IF;
fbModbusTCPslave2_L16:
#srcline 156 ;      lastAddr := Mdb.Addr;
 LDX  Mdb~Addr
#debug uint Mdb.Addr
 WRX  lastAddr
#debug_left uint lastAddr
#srcline 157 ;      lastQuantity := Mdb.Quantity;
 LDX  Mdb~Quantity
#debug uint Mdb.Quantity
 WRX  lastQuantity
#debug_left uint lastQuantity
#srcline 158 ;      read  := Mdb.read;
 LDX  Mdb~read
#debug bool Mdb.read
 WRX  read
#debug_left bool read
#srcline 159 ;      write := Mdb.write;
 LDX  Mdb~write
#debug bool Mdb.write
 WRX  write
#debug_left bool write
#srcline 160 ;      SendTo.rq    := Mdb.SendTo_rq;
 LDX  Mdb~SendTo_rq
#debug bool Mdb.SendTo_rq
 WRX  SendTo~rq
#debug_left bool SendTo.rq
#srcline 161 ;      SendTo.lenTx := Mdb.SendTo_lenTx;
 LDX  Mdb~SendTo_lenTx
#debug uint Mdb.SendTo_lenTx
 WRX  SendTo~lenTx
#debug_left uint SendTo.lenTx
#srcline 162 ;    END_IF;
fbModbusTCPslave2_L13:
#srcline 163 ;  END_IF;
fbModbusTCPslave2_L11:
#srcline 165 ;  IF Mdb.Exception <> 0 THEN
 LDX  Mdb~Exception
#debug usint Mdb.Exception
 LD   usint 0
 EQ
 NEG
 JMC  fbModbusTCPslave2_L17
#srcline 166 ;    excCnt := excCnt + 1;
 LDX  excCnt
#debug udint excCnt
 LD   udint 1
 ADD
 WRX  excCnt
#debug_left udint excCnt
#srcline 167 ;    err   := 1;
 LD   bool -1      ; true
 WRX  err
#debug_left bool err
#srcline 168 ;    errCode := 136 + Mdb.Exception;
 LD   usint 136
 LDX  Mdb~Exception
#debug usint Mdb.Exception
 ADD
 AND  $FF
 WRX  errCode
#debug_left usint errCode
#srcline 169 ;  END_IF;
fbModbusTCPslave2_L17:
#srcline 171 ;  IF read OR write THEN
 LDX  read
#debug bool read
 LDX  write
#debug bool write
 OR  
 JMC  fbModbusTCPslave2_L19
#srcline 172 ;    msgCnt := msgCnt + 1;
 LDX  msgCnt
#debug udint msgCnt
 LD   udint 1
 ADD
 WRX  msgCnt
#debug_left udint msgCnt
#srcline 173 ;  END_IF;
fbModbusTCPslave2_L19:
#srcline 175 ;  IF SendTo.rq THEN
 LDX  SendTo~rq
#debug bool SendTo.rq
 JMC  fbModbusTCPslave2_L21
#srcline 176 ;    Length := WORD_TO_UINT(ROL(UINT_TO_WORD(SendTo.lenTx - 2),8)); //prohodit byte 20131008
 LDX  SendTo~lenTx
#debug uint SendTo.lenTx
 LD   uint 2
 SUB
 AND  $FFFF
 MUL  $00010001
 LD   uint 8
 ROL
 AND  $FFFF
 WRX  Length
#debug_left uint Length
#srcline 177 ;    SendTo.lenTx := SendTo.lenTx + 4;
 LDX  SendTo~lenTx
#debug uint SendTo.lenTx
 LD   uint 4
 ADD
 AND  $FFFF
 WRX  SendTo~lenTx
#debug_left uint SendTo.lenTx
#srcline 178 ;  END_IF;
fbModbusTCPslave2_L21:
#srcline 180 ;  SendTo(chanCode := chanCode, data := void(TrascactionIndent));
 LDX  chanCode
#debug uint chanCode
 WRX  SendTo~chanCode
#debug_left uint SendTo~chanCode
 LEAX TrascactionIndent
 WRX  SendTo~data
#debug_left pointer SendTo.data
 LEAX SendTo
 CAL  fbSendTo_L0
#srcline 181 ;  SendTo.rq := 0;
 LD   bool 0       ; false
 WRX  SendTo~rq
#debug_left bool SendTo.rq
#srcline 183 ;  IF SendTo.error > 0 THEN
 LDX  SendTo~error
#debug usint SendTo.error
 LD   usint 0
 GT
 JMC  fbModbusTCPslave2_L23
#srcline 184 ;    err := true;
 LD   bool -1       ; true
 WRX  err
#debug_left bool err
#srcline 185 ;    errCode := SendTo.error;
 LDX  SendTo~error
#debug usint SendTo.error
 WRX  errCode
#debug_left usint errCode
#srcline 186 ;  END_IF;
fbModbusTCPslave2_L23:
#srcline 188 ;END_FUNCTION_BLOCK
fbModbusTCPslave2_RET:
 ULNK
RET
E     61

; Initialize - variables
P     61
fbModbusTCPslave2__InstanceInit__:
 LINK 0
 LD   uint 502
 WRX  port
 LEAX RecvFrom
 CAL  fbRecvFrom__InstanceInit__
 LEAX SendTo
 CAL  fbSendTo__InstanceInit__
 LEAX Mdb
 CAL  fbModbusSlave__InstanceInit__
 ULNK
RET
E     61
; End initialize - variables
#endpou 



 

#srcfile ''
Ãñ  ë  ®