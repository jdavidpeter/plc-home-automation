(*` {CSY}Knihovna v˝vojovÈho systÈmu Mosaic{ENU}Mosaic IDE library *)
(*` {CSY}JmÈno souboru{ENU}File name{} : D:\TecoUserLibs\InternetLib_V56_20200402.mlb *)
(*` {CSY}Knihovna : InternetLib{ENU}Library : InternetLib{} 5.6 *)
(*` {CSY}Autor{ENU}Author{} : Teco a.s. *)
(*` {CSY}Autorsk· pr·va{ENU}Copyright{} : (c) 2010 - 2020 *)
(*` {CSY}Verze IEC p¯ekladaËe{ENU}IEC compiler version{} : 4.2.9.0 *)
(*` {CSY}Verze assembleru{ENU}Assembler version{} : 4.3.00 *)

//{Knihovna : InternetLib 5.6  }
(*` {CSY}Historie{ENU}History{}: *)
(*`
{CSY} 
v5.6 22.04.2020 Byd
  ZmÏnÏna poloûka "Accept" v HTTP hlaviËce, tak aby nebyl preferov·n û·dn˝ konkrÈtnÌ form·t
v5.5 02.04.2020 Byd
  Oprava zpracov·nÌ fragmentovan˝ch HTTP hlaviËek 
v5.4 20.03.2020 Nem
 ⁄prava poloûky host, kterou vracÌ blok fbSplitUrlAddress (doplnÏno ËÌslo portu)
 ⁄prava p¯Ìjmu paket˘ ping a pong v bloku fbWebSocketClient
 Oprava zpracov·nÌ TCP streamu pri prijmu dat v bloku fbWebSocketClient
 Oprava vysÌl·nÌ paket˘ ping a pong (doplnÏno maskov·nÌ)
v5.3 27.01.2020 Nem
 Do bloku fbWebSocketClient p¯idan· voliteln· poloûka wsOptHeader, doplnÏn ˙vodnÌ GET
v5.2 16.12.2019 Nem
 P¯id·na detekce wss:// do fbSplitUrlAddress
 P¯id·n blok fbWebSocketClient (pouze pro Foxtrot 2)
v5.1 26.11.2019 Byd
  Oprava zpracov·nÌ HTTP hlaviËky (zaneseno ve verzi 4.7)
v5.0 12.11.2019 Byd
  P¯id·n blok fbHttpRequestL3, kter˝ rozöi¯uje moûnosti fbHttpRequestL2 p¯id·nÌm metody PUT
  V bloku fbSntp vylepöena kontrola û·dosti o letnÌ Ëas
v4.9 08.10.2019 Byd
  ⁄prava bloku fbHttpRequestL2, aby pouûil ContentType i v p¯ÌpadÏ, ûe se nejedn· o metodu POST s nenulovou BodyLen
  Oprava timeoutu pro blok fbRetriveFromFtp p¯i p¯Ìjmu dlouh˝ch soubor˘
v4.8 02.09.2019 Nem
  fbPingIP upraven i pro centr·lnÌ jednotky CP-2xxx (Foxtrot 2 family)
v4.7 11.06.2019 Byd
  fbSmtp opraven stav, kdy nastavenÌ Send v n·sledujÌcÌm cyklu po nastavenÌ Done na TRUE nebylo zaznamen·no
  fbHttpRequest oprava p¯Ìjmu HTTP hlaviËky pro p¯Ìpad, kdy dojde k jejÌ fragmentaci TCP protokolem
v4.6 30.10.2018 Nem
  ⁄prava fbSplitUrlAddress() pro URL zaËÌnajÌcÌ https://
  Byd 
  P¯id·n fbSmtpDbx - stejn˝ jako fbSmtp, ale p¯Ìlohu bere z databoxu mÌsto ze souboru
  ⁄prava zpracov·nÌ vÌce¯·dkov˝ch odpovÏdÌ pro fbRetriveFromFtp
v4.5 16.04.2018 Byd 
  Oprava zpracov·nÌ zlomk˘ sekund ve funkËnÌm bloku fbSntp
v4.4 08.03.2018 Byd
  fbStoreToFtp: doplnÏn vstup append, umoûÚujÌcÌ p¯epnout p¯enos soubor˘ z reûimu, kter˝ p¯episuje cÌlovÈ soubory, na ¯eûim, kter˝ p¯ipojuje data na konec existujÌcÌch soubor˘ nebo vytv·¯Ì novÈ pokud û·dnÈ neexistujÌ
v4.3 22.01.2018 Byd 
  fbNsLookEx: p¯id·na detekce, kdy je p¯ed·na p¯Ìmo IP adresa namÌsto domÈnovÈho jmÈna
v4.2 01.11.2017 Nem
  fbSplitUrlAddress : ZvÏtöena velikost promÏnnÈ Action na STRING[255]
v4.1 02.05.2017 Byd
  fbSmtp : P¯id·na moûnost urËit typ p¯Ìlohy a generovat Message-ID pro blok 
  fbSmtp : Opravena definice hranice, kter· byla delöÌ neû doporuËen˝ch 80 znak˘ v fbSmtp
  fbSmtp : ÿ·dky p¯Ìlohy kÛdovanÈ Base64 zkr·ceny na 76 znak˘, aby vyhovovaly bÏûn˝m zvyklostem
v4.0 16.02.2017 Byd
  Upraven blok fbSmtp pro z·pornÈ posunutÌ ËasovÈho p·sma
v3.9 09.12.2016 Byd
  P¯id·n blok pro zÌsk·nÌ souboru z FTP serveru fbRetriveFromFtp  
v3.8 19.10.2016 Nem
  P¯id·ny bloky fbPingIP a fbPing - nutn˝ Foxtrot FW v9.9 nebo vyööÌ
v3.7 23.09.2016 Byd
  KÛdov·nÌ do Base64 vyuûÌv· EncryptLib - nutn˝ firmware firmware v8.8
  P¯id·n blok fbRetriveFromFtp pro zÌsk·nÌ souboru z FTP serveru
  Upraven blok fbSplitUrlAddress, aby dok·zal pracovat s adresou vËetnÏ jmÈna a hesla pro z·kladnÌ autentifikaci
  P¯id·na moûnost aktivnÏ uzav¯Ìt spojenÌ pro bloky fbHttpRequest, fbHttpRequestL a fbHttpRequestL2
  U bloku fbSmtp je moûnÈ zadat znakovou sadu, kter· se uplatnÌ pro p¯edmÏt a tÏlo zpr·vy
v3.6 16.05.2016 Byd
  Blok fbSmtp rozöÌ¯en o moûnost skrytÈ kopie (adresa p¯ed kterou je uvedena teËka nenÌ p¯Ìjemci zobrazen
v3.5 20.11.2015 Byd
  Bloky HttpRequest nastavujÌ v˝stup Busy ve stejnÈm cyklu, kdy opouötÌ stav Idle
v3.4 26.10.2015 Byd
  P¯Ìd·n blok fbSplitUrlAddress
v3.3 18. 9.2015 Byd
  ⁄prava bloku fbSMTP - pouûitÌ EHLO mÌsto HELO
v3.2  4. 9.2015 Byd
  Vynech·n KeyID a Message Authentication Code ze SNTP
v3.1 22. 4.2014 Byd
  Blok fbStoreToFtp kontroluje p¯eplnÏnÌ odesÌlacÌho TCP bufferu (vyûaduje ComLib 
1.4)
v3.0  2. 4.2014 Byd
  V˝stup Done bloku fbSmtp byl nastaven i v p¯ÌpadÏ, kdy se nepovedlo zpr·vu ˙spÏönÏ 
odeslat.
  RychlejöÌ kÛdovanÌ Base64
  OdstranÏn˝ hazard p¯i odesÌl·nÌ dlouh˝ch p¯Ìloh z verze 2.8
v2.9 22.10.2013 Byd
  P¯id·n funkËnÌ blok fbHttpRequestL2 s moûnostÌ zadat typ obsahu (Content-Type)
v2.8  6.6.2013 Byd
  Blok fbStoreToFtp udrûuje ¯ÌdÌcÌ spojenÌ bÏhem vysÌl·nÌ dat (vyûaduje firmware 
7.7)
  Blok fbSmtp podporuje vÌce¯·dkovÈ odpovÏdi serveru
v2.7 29.5.2013 Byd
  Blok fbStoreToFtp akceptuje p¯i p¯Ìstupu na neexistujÌcÌ soubor vöechny negativnÌ 
odpovÏdi s kÛdem 5xx
  Blokov·nÌ timeoutu u fbStoreToFtp p¯i p¯enosu velk˝ch soubor˘
v2.6 27.2.2013 Byd
  ⁄prava bloku fbSntp pro z·pornÈ ofsety Ëasu od UTC
  ProdlouûenÌ timeoutu pro HTTP protokol
v2.5 16.1.2013 Byd
  Oprava chyby bloku fbHttpRequestL zanesen· ve verzi 2.4 (blok odesÌlal jen 
hlaviËku)
V2.4 5.10.2012 Byd
  P¯id·na podpora z·kladnÌ autentifikace p¯edan· v URI jmeno:heslo@domain
V2.3 21.8.2012 Byd
  Vytvo¯enÌ cesty na FTP serveru
  Moûnost nahr·vat celÈ adres·¯e na FTP
V2.2 6.3.2012 Byd
  VypuötÏn pr·zdn˝ p¯Ìkaz v komunikaci se SMTP serverem (nÏkterÈ servry vracely 
negativnÌ odpovÏÔ)
V2.1 13.2.2012 Byd
  DoplÚen blok NsLookUpEx pro p¯eklad domÈnov˝ch jmen s podporou firmware
  (vyûaduje firmware 7.1 nebo vyööÌ)
  Opraveno chov·nÌ v˝stup˘ Done a Err v fbStoreToFtp 
V2.0  1.12.2011 Byd
  Funkce GetDateAndTime_RFC2822 p¯esunuta do knihovny TimeLib  
V1.9  8.4.2011 Byd
  DoplnÏno hlÌd·nÌ dÈlky p¯i odesÌl·nÌ dat p¯es HTTP
  DoplnÏn blok fbHttpRequestL pro odesÌl·nÌ dlouh˝ch dat metodou POST
  DoplnÏn blok fbStringStream pro naplnÏnÌ pracovnÌho buferu z promÏnn˝ch typu 
STRING
V1.8 17.3.2010 Byd
  DoplnÏna Ëasov· znaËka p¯i odesÌl·nÌ p¯es SMTP
V1.7 8.12.2010 Byd
V1.6 1.12.2010 Byd
  DoplnÏn kÛd odpovÏdi 125 pokud je spojenÌ s FTP serverem jiû nav·z·no.
V1.5 2.9.2010 Byd
  DoplnÏny z·vislosti na knihovn·ch.
V1.4 Byd 
  fbStoreToFtp - p¯id·no chybÏjÌcÌ zav¯enÌ souboru v p¯ÌpadÏ chyby p¯enosu. Mohlo 
zp˘sobit aû blokov·nÌ file systÈmu.
V1.3 Byd
  fbStoreToFtp - blok pro p¯enos souboru na FTP server 
V1.2 Byd
  NsLookUp - rozöÌ¯enÈ p¯Ìznaky chyb 2 aû 16 odpovÌdajÌ ResponseCode dle RFC1035 + 1
V1.1 Byd
  Smtp blok kontroluje p¯eplnÏnÌ odesÌlacÌho TCP bufferu (vyûaduje ComLib 1.4)

{ENG}
v5.6 22.04.2020 Byd
  Changed item "Accept" in the HTTP header in order to not prefer any specific format
v5.5 02.04.2020 Byd
  Fixed processing of fragmented HTTP headers
v5.4 17.02.2020 Nem
  Fixed the host item that fbSplitUrlAddress returns (port number added)
  Receiving ping and pong packets in block fbWebSocketClient corrected
  Processing of TCP stream in block fbWebSocketClient corrected
  Sending packets ping and pong corrected (masking added)
v5.3 27.01.2020 Nem
  Into block fbWebSocketClient added optional parameter wsOptHeader
v5.2 16.12.2019 Nem
  Added detection of wss:// into block fbSplitUrlAddress
  Added block fbWebSocketClient (Foxtrot 2 only)
v5.1 26.11.2019 Byd
  Fixed processing of HTTP header (error from version 4.7)
v5.0 12.11.2019 Byd
  Added block fbHttpRequestL3, which extends the capabilities of fbHttpRequestL2 by sdding the PUT method
  Improved check of daylight saving time request in function block fbSntp 
v4.9 08.10.2019 Byd
  Modification of fbHttpRequestL2 block to use ContentType event if it's not POST method with non-zero Bodylen
  Fixed fbRetriveFromFtp block timeout for receiving long files
v4.8 02.09.2019 Nem
  Block fbPing corrected for using on central unit CP-2xxx (Foxtrot 2 family)
v4.7 11.06.2019 Byd
  fbSmtp - fixed behaviour of Send output
  fbHttpRequest - corrected receiving of HTTP header (when it is fragmented)
v4.6 30.10.2018 Nem
  Modification of fbSplitUrlAddress for URL starting with https://
  Byd 
  Added fbSmtpDbx - same as fbSmtp but attachement is from the databox instead of a file
  Changed processing of multiline replies for fbRetriveFromFtp
v4.5 2018-04-16 Byd
  Fixed handling of fractions of seconds in function block fbSntp
v4.4 2018-03-08 Byd
  fbStoreToFtp: input append added. It allows to switch file transfer from mode that overwrites target files to mode that appends new data to the end of existing files or create new if there is no such file
v4.3 2018-01-22 Byd 
  fbNsLookEx: added detection, when an IP address is passed instead of a domain name
v4.2 2017-11-01 Nem
  fbSplitUrlAddress : Size of variable Action was changed to STRING[255]
v4.1 2017-05-02 Byd
  fbSmtp: Added option to assign attachement type and generate Message-ID
  fbSmtp: Fixed boundary definition that was longer than recommended 80 characters
  fbSmtp: Base64-encoded attachment lines are truncated to 76 characters to comply with common standard
v4.0 2017-02-16 Byd
  Modified block fbSmtp for negative UTC offsets
v3.9 2016-12-09 Byd
  Added block for retrieving file from FTP server fbRetriveFromFtp
v3.8 2016-10-19 Nem
  Added blocks fbPingIP and fbPing (requires Foxtrot FW v9.9 or more)
v3.7 2016-09-23 Byd
  Encoding to Base64 is using EncryptLib - firmware v8.8 is mandatory
  Added block fbRetriveFromFtp for obtaining file from FTP server
  Modified block fbSplitUrlAddress to be able to work with address including name and password for basic authentication
  Added possibility to actively close connection for blocks fbHttpRequest, fbHttpRequestL and fbHttpRequestL2
  For block fbSmtp it's now possible to specify charset, which is used for subject and body of mail
v3.6 2016-05-16 Byd
  Block fbSmtp expanded to allow blind copy (address, in front of which is put a full 
stop, won't be displayed to recipient)
v3.5 2015-11-20 Byd
  Blocks HttpRequest set output Busy in the same cycle, when they are leaving Idle 
state
v3.4 2015-10-2 Byd
  Added block fbSplitUrlAddress
v3.3 2015-09-18
  Modification of fbSMTP block - use of EHLO instead of HELO
v3.2 2015-09-04 Byd
  Ommited KeyID and Message Authentication Code from SNTP
v3.1 2014-04-22 Byd
  fbStoreToFtp blok checks overflow of TCP sending buffer (requires ComLib 1.4)
v3.0 2014-04-02 Byd
  Output Done of block fbSmtp was set even if message was not sucessfully sent.
  Faster coding to Base64
  Fixed hazard when sending long attachments from version 2.8
v2.9 2013-10-22 Byd
  Added function blok fbHttpRequestL2 with option to add content type (Content-Type)
v2.8 2013-06-06 Byd
  Block fbStoreToFtp maintains control connections during data transmission 
(requires firmware 7.7)
  Block fbSmtp supports multi-line server responses
v2.7 2013-05-29 Byd
  During access to non-existent file block fbStoreToFtp accepts all negative reply 
codes 5xx
  Blocking timeout for transfer of large files 
v2.6 2013-02-27 Byd
  Modifacation of fbSntp for negative offset from UTC
  Longer timeout for HTTP protocol
v2.5 2013-01-16 Byd
  Fixed error in fbHttpRequestL from version 2.4 (block sent only header)
V2.4 2012-10-05 Byd
  Added support for basic authentication passed in URI name:password@domain 
V2.3 2012-08-21 Byd
  Creating path at FTP server
  Posibility to upload whole directories to FTP
V2.2 2012-03-06 Byd
  Empty command leaved out of communication with SMTP server (some servers returned 
negative reply)
V2.1 2012-02-13 Byd
  Block NsLookUpEx added for translation of domain names with firmware support
  (require firmware 7.1 or higher)
  Corrected behaviour of outputs Done and Err in fbStoreToFtp  
V2.0 2011-12-01 Byd
  Function GetDateAndTime_RFC2822 moved to library TimeLib  
V1.9 2011-04-08 Byd
  Lenght checking added for sending via HTTP
  Block fbHttpRequestL for sending long data via method POST added.
  Block fbStringStream for filling work buffer from STRING variables added.
V1.8 2010-03-17 Byd
  Time stamp added for sending via SMTP 
V1.7 2010-12-8 Byd
V1.6 2010-12-1 Byd
  Added reply code 125 if connection to FTP server is already established. 
V1.5 2010-09-02 Byd
  Dependency on the libraries added.
V1.4 Byd
  fbStoreToFtp - missing closing of file in case of transmission error added. It 
could lead to blocked file system.
V1.3 Byd
  fbStoreToFtp - block for transfering file to FTP server 
V1.2 Byd
  NsLookUp - expanded error numbers from 2 to 16 equal ResponseCode RFC1035 + 1
V1.1 Byd
  Smtp blok checks overflow of TCP sending buffer (requires ComLib 1.4)
*)

(*----------------------------------------------------------------------------*)
{LIBRARY="LOCALLIB\STDLIB_V22_20180619.MLB"}
{LIBRARY="LOCALLIB\SYSLIB_V41_20190710.MLB"}
{LIBRARY="LOCALLIB\TOSTRINGLIB_V13_20110203.MLB"}
{LIBRARY="LOCALLIB\TIMELIB_V15_20170216.MLB"}
{LIBRARY="LOCALLIB\DATABOXLIB_V17_20170717.MLB"}
{LIBRARY="LOCALLIB\COMLIB_V31_20190507.MLB"}
{LIBRARY="LOCALLIB\FILELIB_V25_20190605.MLB"}
{LIBRARY="LOCALLIB\ENCRYPTLIB_V12_20160923.MLB"}
{LIBRARY="LOCALLIB\CONVERTLIB_V21_20170222.MLB"}

VAR_GLOBAL CONSTANT
 INTERNETLIB_END_OF_LINE_ {HIDDEN} : string [2] :=  '$r$l';
 INTERNETLIB_EMPTY_STRING_ {HIDDEN} : string [1] :=  '';

END_VAR

__DECL FUNCTION _FindNextPathSeparator {HIDDEN} : bool
  VAR_IN_OUT
    In               : string [80];  (*`string with path*)
    Pos              : udint;  (*`start with zero*)
  END_VAR
END_FUNCTION

TYPE TDnsReplyHeader :
  STRUCT
    TransactionID    : uint;
    Recursion_des    : bool;
    Truncated        : bool;
    Authoritative    : bool;
    OpCode_0         : bool;
    OpCode_1         : bool;
    OpCode_2         : bool;
    OpCode_3         : bool;
    Response         : bool;
    ReplyCode_0      : bool;
    ReplyCode_1      : bool;
    ReplyCode_2      : bool;
    ReplyCode_3      : bool;
    Empty            : bool;
    Autheticated     : bool;
    Reseved          : bool;
    Recursion_ava    : bool;
    Question         : uint;
    AnswerRRs        : uint;
    AuthorityRRs     : uint;
    AdditionalRRs    : uint;
  END_STRUCT;
END_TYPE

TYPE TDnsReply :
  STRUCT
    Header           : TDnsReplyHeader;
    Data             : ARRAY [0..511] OF usint;
  END_STRUCT;
END_TYPE

TYPE TDnsQueryHeader :
  STRUCT
    TransactionID    : uint;
    Recursion_des    : bool;
    Truncated        : bool;
    Empty_6          : bool;
    OpCode_0         : bool;
    OpCode_1         : bool;
    OpCode_2         : bool;
    OpCode_3         : bool;
    Query            : bool;
    Empty_0          : bool;
    Empty_1          : bool;
    Empty_2          : bool;
    Empty_3          : bool;
    NonAutheticated  : bool;
    Empty_4          : bool;
    Reseved          : bool;
    Empty_5          : bool;
    Question         : uint;
    AnswerRRs        : uint;
    AuthorityRRs     : uint;
    AdditionalRRs    : uint;
  END_STRUCT;
END_TYPE

TYPE TDnsQuery :
  STRUCT
    Header           : TDnsQueryHeader;
    QueryString      : string [80];
  END_STRUCT;
END_TYPE

__DECL FUNCTION _internetlib_DnsLenOfDomainName {HIDDEN} : udint
  VAR_INPUT
    IN               : PTR_TO usint;
  END_VAR
END_FUNCTION

__DECL FUNCTION _internetlib_DnsCodeDomainName {HIDDEN} : string
(*`{CSY}KÛduje jmÈno domÈny
  {ENU}Code name of domain*)
  VAR_INPUT
    IN               : string [80];
  END_VAR
  VAR
    I                : int;
  END_VAR
END_FUNCTION

__DECL FUNCTION _internetlib_DnsDecodeDomainName {HIDDEN} : string
(*`{CSY}DekÛduje jmÈno domÈny
  {ENU}Decode name of domain*)
  VAR_INPUT
    IN               : PTR_TO usint;
    BG               : PTR_TO usint;
  END_VAR
END_FUNCTION

__DECL FUNCTION_BLOCK fbNsLookUp
(*`{CSY} ZÌsk· IP adresu zadanÈho domÈnovÈho jmÈna
  {ENU} Gets IP address of the provided domain name*)
  VAR_INPUT
    getIP            : bool R_EDGE;  (*`{ENG}Get IP address by Name {CSY}ZÌskat IP adresu dle jmÈna*)
    chanCode         : uint;  (*`{ENG}UNI channel {CSY}p¯enosov˝ kan·l {} UDP, lport: 0, rport: 53, in: 524, out: 93*)
    DnsIP            : TIPadr;  (*`{ENG}DNS server IP address {CSY}IP adresa DNS serveru*)
  END_VAR
  VAR_IN_OUT
    Name             : string [80];  (*`{ENG}Domain name {CSY}DomÈnove jmÈno*)
    IP               : TIPadr;  (*`{ENG}Obtained IP address {CSY}ZÌskan· IP adresa*)
  END_VAR
  VAR_OUTPUT
    Done             : bool;  (*`{ENG}IP address successfully obtained {CSY}IP adresa obdrûena ˙spÏsnÏ*)
    Busy             : bool;  (*`{ENG}Operation pending {CSY}Operace probÌh·*)
    Err              : bool;  (*`{ENG}Error occured {CSY}Nastala chyba*)
    ErrId            : usint;  (*`{ENG}Error number {CSY}»Ìslo chyby*)
  END_VAR
  VAR
    RecvFrom         : fbRecvFrom;
    SendTo           : fbSendTo;
    timeout          : TON;
    timeout2         : TON;
    netDnsQuery      : TDnsQuery;
    netDnsReply      : TDnsReply;
    TransID          : uint;
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION_BLOCK fbNsLookUpEx
(*`{CSY} ZÌsk· IP adresu zadanÈho domÈnovÈho jmÈna
  {ENU} Gets IP address of the provided domain name*)
  VAR_INPUT
    getIP            : bool R_EDGE;  (*`{ENG}Get IP address by Name {CSY}ZÌskat IP adresu dle jmÈna*)
    dnsIP            : TIPadr;  (*`{ENG}DNS server IP address {CSY}IP adresa DNS serveru*)
    Name             : string [80];  (*`{ENG}Domain name {CSY}DomÈnove jmÈno*)
  END_VAR
  VAR_IN_OUT
    IP               : TIPadr;  (*`{ENG}Obtained IP address {CSY}ZÌskan· IP adresa*)
  END_VAR
  VAR_OUTPUT
    Done             : bool;  (*`{ENG}IP address successfully obtained {CSY}IP adresa obdrûena ˙spÏsnÏ*)
    Busy             : bool;  (*`{ENG}Operation pending {CSY}Operace probÌh·*)
    Err              : bool;  (*`{ENG}Error occured {CSY}Nastala chyba*)
    ErrId            : usint;  (*`{ENG}Error number {CSY}»Ìslo chyby*)
  END_VAR
  VAR
    CurrName         : string [80];  (*`current domain name*)
  END_VAR
  VAR CONSTANT
    HTTP_IP_NULL     : TIPadr :=  [0,0,0,0];
  END_VAR
END_FUNCTION_BLOCK

TYPE  THttpBuffer : ARRAY [0..511] OF usint;
END_TYPE

TYPE THttpState : 
  (hs_HttpIdle,
   hs_HttpSetIP,
   hs_HttpConnect,
   hs_HttpSend,
   hs_HttpReceivingData,
   hs_HttpSendPost 
  );
END_TYPE

__DECL FUNCTION_BLOCK fbHttpRequest
(*`{ENU}Sends POST and GET metods via HTTP
{CSY}VysÌl· metody GET a POST p¯es HTTP protokol*)
  VAR_INPUT
    Post             : bool R_EDGE;  (*`{ENG}Send data via method POST {CSY}vyslat data metodou POST*)
    Get              : bool R_EDGE;  (*`{ENG}Get data via method GET {CSY}zÌskat data metodu GET*)
    Cancel           : bool R_EDGE;  (*`{ENG}Cancel pending operation {CSY}zruöit probÌhajÌcÌ operaci*)
    chanCode         : uint;  (*`{ENG}UNI channel {CSY}p¯enosov˝ kan·l {}TCP master in: 512, out: 512*)
    IPadr            : TIPadr;  (*`{ENG}IP address of remote server {CSY}IP adresa vzd·lenÈho serveru*)
    port             : uint :=  80;  (*`{ENG}Port of remote server {CSY}»Ìslo portu vzd·lenÈho serveru*)
    Close            : bool;  (*`{ENG}If set, block don't wait for server to close connection and close it actively after receiving all data{CSY}Pokud je nastaveno, blok neËek· na server aû zav¯e spojenÌ a zav¯e jej aktivnÏ jakmile zÌsk· vöechny data*)
  END_VAR
  VAR_IN_OUT
    Action           : string [255];  (*`{ENG}Path to a data on the server (always starts with character '/') {CSY}Cesta k dat˘m na serveru (vûdy zaËÌn· znakem '/')*)
    Host             : string [80];  (*`{ENG}Host name {CSY}JmÈno hostitele*)
    Data             : string [80];  (*`{ENG}POST data {CSY}Data pro metodu POST*)
    RecvData         : THttpBuffer;  (*`{ENG}Data buffer 512 bytes {CSY}Bufer dat 512 byt˘*)
  END_VAR
  VAR_OUTPUT
    Done             : bool;  (*`{ENG}Operation done {CSY}Operace ukonËena*)
    Busy             : bool;  (*`{ENG}Operation pending {CSY}Operace probÌh·*)
    Err              : bool;  (*`{ENG}Communication error {CSY}Chyba komunikace*)
    ErrId            : usint;  (*`{ENG}Error number {CSY}»Ìslo chyby*)
    DataReady        : bool;  (*`{ENG}New data received {CSY}P¯ijata nov· data*)
    DataLen          : uint;  (*`{ENG}Data length {CSY}DÈlka dat*)
    State            : THttpState;  (*`{ENG}State of communication {CSY}Stav komunikace*)
    Result           : int;  (*`{ENG}HTTP Code {CSY}HTTP kod*)
    Progress         : sint;  (*`{ENG}Progress of data downloading {CSY}Pr˘bÏh stahov·nÌ dat*)
  END_VAR
  VAR
    ResRecv          : bool;
    LenRecv          : bool;
    HeaderRecv       : bool;
    TimeOutTon       : TON;
    helpstring       : string [255];
    RecvFrom         : fbRecvFrom;
    SendTo           : fbSendTo;
    ContLen          : dint;
    WholeLen         : dint;
    lHost            : string [80];
    sOff             : uint;
    rLen             : uint;
  END_VAR
END_FUNCTION_BLOCK

TYPE TSmtpState : 
  (ss_SmtpInit,
   ss_SmtpIdle,
   ss_SmtpSetIP,
   ss_SmtpTxConnect,
   ss_SmtpRxConnect,
   ss_SmtpTxHelo,
   ss_SmtpRxHelo,
   ss_SmtpTxAuthlogin,
   ss_SmtpRxAuthlogin,
   ss_SmtpTxUserName,
   ss_SmtpRxUserName,
   ss_SmtpTxPassword,
   ss_SmtpRxPassword,
   ss_SmtpTxMailFrom,
   ss_SmtpRxMailFrom,
   ss_SmtpTxRcptTo,
   ss_SmtpRxRcptTo,
   ss_SmtpTxData,
   ss_SmtpRxData,
   ss_SmtpTxDataFrom,
   ss_SmtpTxDataTo,
   ss_SmtpTxDataSubject,
   ss_SmtpTxMultipart,
   ss_SmtpTxDataText,
   ss_SmtpTxAttachement,
   ss_SmtpTxAttachementBody,
   ss_SmtpTxEndOfMail,
   ss_SmtpRxAck,
   ss_SmtpTxQuit,
   ss_SmtpRxClose,
   ss_SmtpRxTimeout,
   ss_SmtpRxError,
   ss_SmtpTxDate,
   ss_SmtpTxContentType,
   ss_SmtpTxMessageId 
  );
END_TYPE

VAR_GLOBAL CONSTANT
 SMTP_END_OF_LINE_2_ {HIDDEN} : string [3] :=  '>$r$l';

END_VAR

__DECL FUNCTION_BLOCK fbSmtp
(*`{ENU}Sends email messages via SMTP
  {CSY}OdesÌl· emailovÈ zpr·vy p¯es SMTP*)
  VAR_INPUT
    Send             : bool R_EDGE;  (*`{ENG} starts sending of email {CSY}spustÌ odesl·nÌ zpr·vy*)
    Auth             : bool;  (*`{ENG} authetification requiered? {CSY}vyûaduje server authetifikaci?*)
    Cancel           : bool R_EDGE;  (*`{ENG} cancel action {CSY}stornovat odesÌl·nÌ*)
    chanCode         : uint;  (*`{ENG} channel code {CSY}p¯enosov˝ kan·l {} TCP Master, in: 255, out: 255*)
    IPadr            : TIPadr;  (*`{ENG} IP address of SMTP server {CSY}IP adresa SMTP serveru*)
    port             : uint :=  25;  (*`{ENG} Port of SMTP server {CSY}Port SMTP serveru*)
    Lines            : usint;  (*`{ENG} number of lines {CSY}poËet ¯·dk˘ tÏla zpr·vy*)
    UtcOff           : int;  (*`{ENG} offset from UTC in minutes{CSY}posun ËasovÈho p·sma v minut·ch*)
    charset          : string [16];  (*`{ENG} charset of Email body {CSY}znakov· sada tÏla zpr·vy {}('windows-1250', 'UTF-8',...)*)
    attachementType  : string [32];  (*`{ENG} user defined MINE type of attachement. If not specified, 'application/octet-stream' is used (other possible values are {CSY}uûivatelsky definovan˝ MINE typ p¯Ìlohy. NenÌ-li specifikov·n, je pouûit 'application/octet-stream' (dalöÌ moûnÈ hodnoty jsou {}'image/jpeg', 'image/png', 'text/plain; charset=windows-1250',...)*)
    genMessageID     : bool;  (*`{ENG} generate unique Message-ID{CSY}vygeneruje unik·tnÌ Message-ID*)
  END_VAR
  VAR_IN_OUT
    Sender           : string [80];  (*`{ENG} sender address {CSY}adresa odesÌlatele*)
    SendName         : string [80];  (*`{ENG} sender name {CSY}jmÈno odesÌlatele*)
    Rcpt             : string [80];  (*`{ENG} recipient address {CSY}adresa p¯Ìjemce*)
    Subject          : string [80];  (*`{ENG} subject {CSY}p¯edmÏt zpr·vy*)
    Text             : string [80];  (*`{ENG} first line of email body {CSY}prvnÌ ¯·dek tÏla zpr·vy*)
    Attach           : string [80];  (*`{ENG} file name of attachement {CSY}jmÈno souboru s p¯ilohou*)
    Username         : string [80];  (*`{ENG} user name for SMTP server {CSY}uûivatelskÈ jmÈno pro SMTP server*)
    Password         : string [80];  (*`{ENG} password  for SMTP server {CSY}heslo pro SMTP server*)
  END_VAR
  VAR_OUTPUT
    Done             : bool;  (*`true{ENG} after email was sent successfully {CSY}pokud se poda¯ilo zpr·vu odeslat*)
    Busy             : bool;  (*`true{ENG} when sending is in progress {CSY}pokud se pr·vÏ odesÌl· zpr·va*)
    Err              : bool;  (*`true{ENG} when sending failed {CSY}pokud nastala p¯i odesÌl·nÌ chyba*)
    ErrId            : usint;  (*`{ENG} number of error {CSY}ËÌslo chyby*)
    ReplyCode        : uint;  (*`{ENG} server reply code {CSY}kÛd odpovÏdi serveru*)
    State            : TSmtpState;  (*`{ENG} communication state {CSY}stav komunikace*)
  END_VAR
  VAR CONSTANT
    SMTP_BASE64_LEN_ : udint :=  57;  (*`60*)
    SMTP_BASE64_LEN2_ : udint :=  SMTP_BASE64_LEN_*2;  (*`120*)
    SMTP_MAXIMUM_FILE_LINE_LENGTH_ : udint :=  SMTP_BASE64_LEN_*3;  (*`180;*)
  END_VAR
  VAR
    timeout_cntr     : TON;  (*`detekce timeoutu pri komunikaci*)
    cmd              : string [255];
    buff             : ARRAY [0..511] OF usint;
    copy_rcpt        : string [255];
    temp_rcpt        : string [180];
    body_rcpt        : string [80];
    ptrText          : PTR_TO string [80];
    body_lines       : sint;
    Recv_from        : fbRecvTxt;  (*`FB pro prijem*)
    Send_to          : fbSendTo;  (*`FB pro vysilani*)
    h                : HANDLE;
    TRO              : bool;  (*`buffer overflow*)
    lAuth            : bool;  (*`byla pozadovana autorizace*)
    mesRec           : bool;
    lSend            : bool;
  END_VAR
END_FUNCTION_BLOCK

TYPE TNtpMessage {HIDDEN} :
  STRUCT
    Flags            : byte :=  2#00_011_011;  (*`|  LI1 | LI0 | VN2 | VN1 | VN0 |Mode2|Mode1|Mode0|*)
    Stratum          : usint :=  15;
    Polling          : sint :=  8;
    Precision        : sint :=  -8;
    RootDelay        : udint;
    RootDispersion   : udint;
    RefIdentifier    : udint;
    ReferenceTS      : udint;
    ReferenceTSFrac  : udint;
    OriginateTS      : udint;
    OriginateTSFrac  : udint;
    ReceiveTS        : udint;
    ReceiveTSFrac    : udint;
    TransmitTS       : udint;
    TransmitTSFrac   : udint;
  END_STRUCT;
END_TYPE

__DECL FUNCTION_BLOCK fbSntp
(*`{ENU}Gets time offset from remote time server
Names of time servers groups
  {CSY}ZÌsk·v· Ëasov˝ ofset se vzd·lenÈho ËasovÈho serveru
JmÈna skupin Ëasov˝ch server˘:
  {}
  pool.ntp.org
  europe.pool.ntp.org
  cz.pool.ntp.org*)
  VAR_INPUT
    Get              : bool R_EDGE;  (*`{ENG}Get new time offset from time server {CSY}ZÌskat nov˝ Ëasov˝ ofset ze serveru*)
    Accept           : bool R_EDGE;  (*`{ENG}Accept new time from server {CSY}P¯ijmout Ëasov˝ ofset ze serveru*)
    chanCode         : uint;  (*`{ENG}UNI UDP chanel (60 bytes IN/OUT){CSY}UNI UDP kan·l (60 bytes IN/OUT)*)
    IPadr            : TIPadr;  (*`{ENG}IP address of NTP server {CSY}IP adresa NTP serveru*)
    port             : uint :=  123;  (*`{ENG}Port of NTP server {CSY}Port NTP serveru*)
    UtcOff           : int;  (*`{ENG}Offset from UTC in minutes{CSY}Posun ËasovÈho p·sma v minut·ch*)
  END_VAR
  VAR_OUTPUT
    Done             : bool;  (*`{ENG}Time offset successfully acquired {CSY}»asov˝ ofset ˙spÏönÏ zÌsk·n*)
    Busy             : bool;  (*`{ENG}Communication in progress {CSY}ProbÌh· komunikace*)
    TimeSet          : bool;  (*`{ENG}New time set to RTC {CSY}Nov˝ Ëas nastaven do RTC*)
    Err              : bool;  (*`{ENG}Error during communication {CSY}Chyba bÏhem komunikace*)
    ErrId            : usint;  (*`{ENG}Number of error {CSY}»Ìslo chyby*)
    Offset           : lreal;  (*`{ENG}Acquried offset [s]{CSY}ZÌskan˝ ofset [s]*)
    Error            : lreal;  (*`{ENG}Maximum error of acquired offset [s]{CSY}MaximalnÌ chyba zÌskanÈho ofsetu [s]*)
  END_VAR
  VAR
    Recv             : bool;
    SettingTime      : bool;
    Now              : dt;
    NowLocal         : dt;
    NowTeco          : ARRAY [0..6] OF usint;
    NowMili          : uint;
    NtpPacket        : TNtpMessage;
    SendTo           : fbSendTo;
    RecvFrom         : fbRecvFrom;
    Attemps          : udint;
    Success          : udint;
    Delay            : TON;
    ShortTimeout     : TON;
    Timeout          : TON;
    maxSW22          : uint;
  END_VAR
  VAR CONSTANT
    _fbSntp_EMPTY_NTP_MESSAGE_ : TNtpMessage :=  (RootDispersion:= 0);
  END_VAR
END_FUNCTION_BLOCK

TYPE TNsLookUpItem :
  STRUCT
    Request          : bool;
    Set              : bool;
    Done             : bool;
    Err              : bool;
    IP               : TIPadr;
    Name             : string [80];
  END_STRUCT;
END_TYPE

TYPE  TNsLookUpTable : ARRAY [0..15] OF TNsLookUpItem;
END_TYPE

__DECL FUNCTION_BLOCK fbNsLookUpByTable
(*`{CSY} ZÌsk· IP adresu domÈnov˝ch jmÈn v tabulce
  {ENU} Gets IP address of the domain names in the table*)
  VAR_INPUT
    chanCode         : uint;  (*`{ENG}UNI channel {CSY}p¯enosov˝ kan·l {}UDP, lport: 0, rport: 53, in: 524, out: 93*)
    DnsIP            : TIPadr;  (*`{ENG}DNS server IP address {CSY}Adresa DNS serveru*)
  END_VAR
  VAR_IN_OUT
    NsLookUpTable    : TNsLookUpTable;  (*`{ENG}Table of domain names {CSY}Tabulka domenov˝ch jmen*)
  END_VAR
  VAR_OUTPUT
    Busy             : bool;  (*`{ENG}Communication in progress {CSY}ProbÌh· komunikace*)
    Err              : bool;  (*`{ENG}Communication error {CSY}Chyba komunikace*)
    ErrId            : usint;  (*`{ENG}Error number {CSY}»Ìslo chyby*)
  END_VAR
  VAR
    i                : uint;
    j                : uint;
    NsLookUp         : fbNsLookUp;
    NsLookUpItem     : TNsLookUpItem;
  END_VAR
END_FUNCTION_BLOCK

TYPE TFtpStoreState : 
  (fss_Init,
   fss_Idle,
   fss_OpenFile,
   fss_IpCom,
   fss_Connect,
   fss_Rx220,
   fss_TxUser,
   fss_RxUser,
   fss_TxPass,
   fss_RxPass,
   fss_TxType,
   fss_RxType,
   fss_TxPasv,
   fss_RxPasv,
   fss_TxStor,
   fss_IpDat,
   fss_WaitForOpen,
   fss_TxData,
   fss_RxComplete,
   fss_TxQuit,
   fss_RxQuit,
   fss_Close,
   fss_Error,
   fss_UnexpectedReply,
   fss_TxCreateDir,
   fss_RxCreateDir,
   fss_ReadDir,
   fss_TxRetr,
   fss_RxData,
   fss_TxSize,
   fss_RxSize 
  );
END_TYPE

VAR_GLOBAL CONSTANT
 FTP_DIR_STACK_ {HIDDEN} : usint :=  4;

END_VAR

TYPE TFtpDirStack {HIDDEN} :
  STRUCT
    hDir             : HANDLE;
    sDir             : string [12];
  END_STRUCT;
END_TYPE

__DECL FUNCTION_BLOCK fbStoreToFtp
(*`{ENU}Stores files from memory card to FTP server
  {CSY}Uklad· soubory z pamÏùovÈ karty na FTP server*)
  VAR_INPUT
    Send             : bool R_EDGE;  (*`{ENG}Sends file/directory to FTP{CSY}Odeöle soubor/adres·¯ na FTP*)
    IPadr            : TIPadr;  (*`{ENG}IP address of FTP server {CSY}IP adresa FTP serveru*)
    port             : uint :=  21;  (*`{ENG}Port of FTP server {CSY}Port FTP serveru*)
    chanCodeCom      : uint;  (*`{ENG}Channel code {CSY}P¯enosov˝ kan·l TCP Master, in: 255, out: 255*)
    chanCodeDat      : uint;  (*`{ENG}Channel code {CSY}P¯enosov˝ kan·l TCP Master, in: 1, out: 255*)
    append           : bool;  (*`{ENG}If file on server exists data will be appended to that file{CSY}Pokud soubor na stranÏ serveru existuje budou data p¯id·na na jeho konec*)
  END_VAR
  VAR_IN_OUT
    User             : string [80];  (*`{ENG}User name {CSY}UûivatelskÈ jmÈno*)
    Pass             : string [80];  (*`{ENG}Password {CSY}Heslo*)
    LocalName        : string [80];  (*`{ENG}Name of file or directory at the memory card {CSY}JmÈno souboru nebo sloûky na pamÏùovÈ kartÏ*)
    RemotName        : string [80];  (*`{ENG}Name of file or directory at FTP server {CSY}JmÈno souboru nebo sloûky na FTP serveru*)
  END_VAR
  VAR_OUTPUT
    Done             : bool;  (*`{ENG}File was stored to FTP server {CSY}Soubor byl uloûen na FTP server*)
    Busy             : bool;  (*`{ENG}File is storing to FTP server {CSY}Soubor se ukl·d· na FTP server*)
    Err              : bool;  (*`{ENG}Error occured {CSY}Nastala chyba*)
    ErrId            : usint;  (*`{ENG}Error number {CSY}»Ìslo chyby*)
    ReplyCode        : uint;  (*`{ENG}Reply code {CSY}KÛd odpovÏdi serveru*)
    State            : TFtpStoreState;  (*`{ENG}State of communication {CSY}Stav komunikace*)
    CurrFile         : string [80];  (*`{ENG}Name of currently uploaded file{CSY}JmÈno aktu·lnÏ nahr·vanÈho souboru*)
    Progress         : usint;  (*`{ENG}Progress of file uploading in percent {CSY}Pr˘bÏh nahr·v·nÌ souboru v procentech*)
  END_VAR
  VAR
    Send_To_Com      : fbSendTo;
    Recv_From_Com    : fbRecvFrom;
    KeepAliveTCP     : fbKeepAliveTCP;
    rea              : TRemoteEthAdr;
    cmdCom           : string [255];
    lRemotName       : string [80];
    lLocalFileInfo   : TFileInfo;
    idPos            : udint;
    lSize            : udint;
    lTrans           : udint;
    dirStack         : ARRAY [0..4] OF TFtpDirStack;
    dirStackLev      : usint;
    i                : usint;
    eErrId           : usint;
    Send_To_Dat      : fbSendTo;
    cmdDat           : ARRAY [0..254] OF usint;
    timeoutCom       : TON;
    data             : udint;
    h                : HANDLE :=  INVALID_HANDLE_VALUE;
    pasvDat          : ARRAY [0..5] OF usint;
    TRO              : bool;
    mesRec           : bool;
    iniDir           : bool;
    endDir           : bool;
    TRO_com          : bool;
    TRO_dat          : bool;
  END_VAR
END_FUNCTION_BLOCK

TYPE  THttpPostData : ARRAY [0..1535] OF usint;
END_TYPE

__DECL FUNCTION_BLOCK fbHttpRequestL
(*`{ENU}Sends POST and GET metods via HTTP
{CSY}VysÌl· metody GET a POST p¯es HTTP protokol*)
  VAR_INPUT
    Post             : bool R_EDGE;  (*`{ENG}Send data via method POST {CSY}vyslat data metodou POST*)
    Get              : bool R_EDGE;  (*`{ENG}Get data via method GET {CSY}zÌskat data metodu GET*)
    Cancel           : bool R_EDGE;  (*`{ENG}Cancel pending operation {CSY}zruöit probÌhajÌcÌ operaci*)
    chanCode         : uint;  (*`{ENG}UNI channel {CSY}p¯enosov˝ kan·l {}TCP master in: 512, out: 512*)
    IPadr            : TIPadr;  (*`{ENG}IP address of remote server {CSY}IP adresa vzd·lenÈho serveru*)
    port             : uint :=  80;  (*`{ENG}Port of remote server {CSY}»Ìslo portu vzd·lenÈho serveru*)
    postLen          : uint;  (*`{ENG}Lenght of data to POST{CSY}DÈlka dat pro metodu POST*)
    Close            : bool;  (*`{ENG}If set, block don't wait for server to close connection and close it actively after receiving all data{CSY}Pokud je nastaveno, blok neËek· na server aû zav¯e spojenÌ a zav¯e jej aktivnÏ jakmile zÌsk· vöechny data*)
  END_VAR
  VAR_IN_OUT
    Action           : string [255];  (*`{ENG}Path to the data on the server (always starts with character '/') {CSY}Cesta k dat˘m na serveru (vûdy zaËÌn· znakem '/')*)
    Host             : string [80];  (*`{ENG}Host name {CSY}JmÈno hostitele*)
    Data             : THttpPostData;  (*`{ENG}First byte of data to POST {CSY}PrvnÌ byte dat pro metodu POST*)
    RecvData         : THttpBuffer;  (*`{ENG}Data buffer 512 bytes {CSY}Bufer dat 512 byt˘*)
  END_VAR
  VAR_OUTPUT
    Done             : bool;  (*`{ENG}Operation done {CSY}Operace ukonËena*)
    Busy             : bool;  (*`{ENG}Operation pending {CSY}Operace probÌh·*)
    Err              : bool;  (*`{ENG}Communication error {CSY}Chyba komunikace*)
    ErrId            : usint;  (*`{ENG}Error number {CSY}»Ìslo chyby*)
    DataReady        : bool;  (*`{ENG}New data received {CSY}P¯ijata nov· data*)
    DataLen          : uint;  (*`{ENG}Data length {CSY}DÈlka dat*)
    State            : THttpState;  (*`{ENG}State of communication {CSY}Stav komunikace*)
    Result           : int;  (*`{ENG}HTTP Code {CSY}HTTP kod*)
    Progress         : sint;  (*`{ENG}Progress of data downloading {CSY}Pr˘bÏh stahov·nÌ dat*)
  END_VAR
  VAR
    ResRecv          : bool;
    LenRecv          : bool;
    HeaderRecv       : bool;
    WasEOL           : bool;
    TimeOutTon       : TON;
    helpstring       : string [255];
    RecvFrom         : fbRecvFrom;
    SendTo           : fbSendTo;
    ContLen          : dint;
    WholeLen         : dint;
    lPostLen         : uint;
    lHost            : string [80];
    BodyLen          : uint;
    sOff             : uint;
    rLen             : uint;
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION_BLOCK fbHttpRequestL2
(*`{ENU}Sends POST and GET metods via HTTP with option to set content type (Content-Type)
{CSY}VysÌl· metody GET a POST p¯es HTTP protokol s moûnostÌ definice typu obsahu (Content-Type)*)
  VAR_INPUT
    Post             : bool R_EDGE;  (*`{ENG}Send data via method POST {CSY}vyslat data metodou POST*)
    Get              : bool R_EDGE;  (*`{ENG}Get data via method GET {CSY}zÌskat data metodu GET*)
    Cancel           : bool R_EDGE;  (*`{ENG}Cancel pending operation {CSY}zruöit probÌhajÌcÌ operaci*)
    chanCode         : uint;  (*`{ENG}UNI channel {CSY}p¯enosov˝ kan·l {}TCP master in: 512, out: 512*)
    IPadr            : TIPadr;  (*`{ENG}IP address of remote server {CSY}IP adresa vzd·lenÈho serveru*)
    port             : uint :=  80;  (*`{ENG}Port of remote server {CSY}»Ìslo portu vzd·lenÈho serveru*)
    postLen          : uint;  (*`{ENG}Lenght of data to POST{CSY}DÈlka dat pro metodu POST*)
    Close            : bool;  (*`{ENG}If set, block don't wait for server to close connection and close it actively after receiving all data{CSY}Pokud je nastaveno, blok neËek· na server aû zav¯e spojenÌ a zav¯e jej aktivnÏ jakmile zÌsk· vöechny data*)
  END_VAR
  VAR_IN_OUT
    Action           : string [255];  (*`{ENG}Path to the data on the server (always starts with character '/') {CSY}Cesta k dat˘m na serveru (vûdy zaËÌn· znakem '/')*)
    Host             : string [80];  (*`{ENG}Host name {CSY}JmÈno hostitele*)
    Data             : THttpPostData;  (*`{ENG}First byte of data to POST {CSY}PrvnÌ byte dat pro metodu POST*)
    ContentType      : string [80];  (*`{ENG}Content-Type {CSY}Typ obsahu (Content-Type)*)
    RecvData         : THttpBuffer;  (*`{ENG}Data buffer 512 bytes {CSY}Bufer dat 512 byt˘*)
  END_VAR
  VAR_OUTPUT
    Done             : bool;  (*`{ENG}Operation done {CSY}Operace ukonËena*)
    Busy             : bool;  (*`{ENG}Operation pending {CSY}Operace probÌh·*)
    Err              : bool;  (*`{ENG}Communication error {CSY}Chyba komunikace*)
    ErrId            : usint;  (*`{ENG}Error number {CSY}»Ìslo chyby*)
    DataReady        : bool;  (*`{ENG}New data received {CSY}P¯ijata nov· data*)
    DataLen          : uint;  (*`{ENG}Data length {CSY}DÈlka dat*)
    State            : THttpState;  (*`{ENG}State of communication {CSY}Stav komunikace*)
    Result           : int;  (*`{ENG}HTTP Code {CSY}HTTP kod*)
    Progress         : sint;  (*`{ENG}Progress of data downloading {CSY}Pr˘bÏh stahov·nÌ dat*)
  END_VAR
  VAR
    ResRecv          : bool;
    LenRecv          : bool;
    HeaderRecv       : bool;
    WasEOL           : bool;
    TimeOutTon       : TON;
    helpstring       : string [255];
    RecvFrom         : fbRecvFrom;
    SendTo           : fbSendTo;
    ContLen          : dint;
    WholeLen         : dint;
    lPostLen         : uint;
    lHost            : string [80];
    BodyLen          : uint;
    sOff             : uint;
    rLen             : uint;
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION_BLOCK fbSplitUrlAddress
(*`{CSY}FunkËnÌ blok fbSplitUrlAddress rozebÌr· zadanou URL adresu na jednotlivÈ poloûky vyûadovanÈ bloky fbHttpRequest, fbHttpRequestL a fbHttpRequestL2.
  Vstupem bloku je promÏnn· p¯edan· p¯es urlAddress, kter· nese URL adresu tak jak je uvedena ve webovÈm prohlÌûeËi.
  {ENG}
  Function block fbSplitUrlAddress splits specified URL address to items required by blocks fbHttpRequest, fbHttpRequestL and fbHttpRequestL2.
  Input of the block is a variable, that carries a URL as it appears in the web browser, passed through urlAddress.*)
  VAR_INPUT
    split            : bool R_EDGE;  (*`{ENU}Split URL address{CSY} RozdÏlenÌ URL adresy*)
  END_VAR
  VAR_OUTPUT
    done             : bool;  (*`{ENG}URL address splitted and IP address successfully obtained {CSY}URL adresa rozdÏlena a IP adresa ˙spÏönÏ zÌsk·na*)
    busy             : bool;  (*`{ENG}Operation pending {CSY}Operace probÌh·*)
    err              : bool;  (*`{ENG}Error occured {CSY}Nastala chyba*)
    errId            : usint;  (*`{ENG}Error number {CSY}»Ìslo chyby*)
  END_VAR
  VAR_IN_OUT
    urlAddress       : string [255];  (*`{ENG}URL as it appears in a web browser{CSY}URL adresa tak jak je uvedena ve webovÈm prohlÌûeËi*)
    host             : string [80];  (*`{ENG}Host name {CSY}JmÈno hostitele*)
    action           : string [255];  (*`{ENG}Path to the data on the server (always starts with character '/') {CSY}Cesta k dat˘m na serveru (vûdy zaËÌn· znakem '/')*)
    ipAdr            : TIPadr;  (*`{ENG}IP address of remote server {CSY}IP adresa vzd·lenÈho serveru*)
    port             : uint;  (*`{ENG}Port of remote server {CSY}»Ìslo portu vzd·lenÈho serveru*)
  END_VAR
  VAR
    NsLookUp         : fbNsLookUpEx;
  END_VAR
  VAR CONSTANT
    HTTP_IP_NULL     : TIPadr :=  [0,0,0,0];
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION_BLOCK fbRetriveFromFtp
(*`{ENU}Retrive file from FTP server and saves it to memory card
  {CSY}ZÌsk·v· soubor z FTP serveru a ukl·d· na pamÏùovou kartu*)
  VAR_INPUT
    Retrieve         : bool R_EDGE;  (*`{ENG}Retrieves file from FTP{CSY}P¯Ìjmout soubor z FTP*)
    IPadr            : TIPadr;  (*`{ENG}IP address of FTP server {CSY}IP adresa FTP serveru*)
    port             : uint :=  21;  (*`{ENG}Port of FTP server {CSY}Port FTP serveru*)
    chanCodeCom      : uint;  (*`{ENG}Channel code {CSY}P¯enosov˝ kan·l TCP Master, in: 255, out: 255*)
    chanCodeDat      : uint;  (*`{ENG}Channel code {CSY}P¯enosov˝ kan·l TCP Master, in: 255, out: 1*)
  END_VAR
  VAR_IN_OUT
    User             : string [80];  (*`{ENG}User name {CSY}UûivatelskÈ jmÈno*)
    Pass             : string [80];  (*`{ENG}Password {CSY}Heslo*)
    LocalName        : string [80];  (*`{ENG}Name of file at the memory card {CSY}JmÈno souboru na pamÏùovÈ kartÏ*)
    RemotName        : string [80];  (*`{ENG}Name of file at FTP server {CSY}JmÈno souboru na FTP serveru*)
  END_VAR
  VAR_OUTPUT
    Done             : bool;  (*`{ENG}File was stored to memory card {CSY}Soubor byl uloûen na pamÏùovou kartu*)
    Busy             : bool;  (*`{ENG}File is being stored to memory card {CSY}Soubor se ukl·d· na pamÏùovou kartu*)
    Err              : bool;  (*`{ENG}Error occured {CSY}Nastala chyba*)
    ErrId            : usint;  (*`{ENG}Error number {CSY}»Ìslo chyby*)
    ReplyCode        : uint;  (*`{ENG}Reply code {CSY}KÛd odpovÏdi serveru*)
    State            : TFtpStoreState;  (*`{ENG}State of communication {CSY}Stav komunikace*)
    Progress         : usint;  (*`{ENG}Progress of file uploading in percent {CSY}Pr˘bÏh nahr·v·nÌ souboru v procentech*)
  END_VAR
  VAR
    Send_To_Com      : fbSendTo;
    Recv_From_Com    : fbRecvTxt;  (*`fbRecvFrom;*)
    KeepAliveTCP     : fbKeepAliveTCP;
    rea              : TRemoteEthAdr;
    cmdCom           : string [255];
    lRemotName       : string [80];
    lLocalFileInfo   : TFileInfo;
    idPos            : udint;
    lSize            : udint;
    lTrans           : udint;
    i                : usint;
    eErrId           : usint;
    Recv_From_Dat    : fbRecvFrom;
    WTFS             : WriteToFileSeq;
    cmdBuffer        : ARRAY [0..254] OF usint;
    cmdDat           : ARRAY [0..254] OF usint;
    timeoutCom       : TON;
    data             : udint;
    h                : HANDLE :=  INVALID_HANDLE_VALUE;
    pasvDat          : ARRAY [0..5] OF usint;
    TRO              : bool;
    mesRec           : bool;
    TRO_com          : bool;
    TRO_dat          : bool;
  END_VAR
END_FUNCTION_BLOCK

TYPE T_PING_INFO :
  STRUCT
    result           : dint;  (*`{ENG}result 0=busy, 1=done without errors, -1=error {CSY}0=probÌh·, 1=dokonËeno bez chyb, -1=chyba*)
    hostIP           : TIPadr;  (*`{ENG}host IP                     {CSY}IP adresa hostitele*)
    responseTime     : time;  (*`{ENG}response time               {CSY}Ëas odezvy*)
    pingNumber       : udint;  (*`{ENG}ping number                 {CSY}ËÌslo pingu*)
    dataLen          : udint;  (*`{ENG}length of data              {CSY}dÈlka dat*)
    ttl              : usint;  (*`{ENG}response TTL                {CSY}TTL odpovÏdi*)
    errMsg           : string [80];  (*`{ENG}error message               {CSY}chybov· zpr·va*)
  END_STRUCT;
END_TYPE

__DECL FUNCTION_BLOCK fbPingIP
(*`{CSY} OvÏ¯Ì spojenÌ mezi PLC a sÌùov˝m rozhranÌm s danou IP adresou
  {ENU} Check the connection between the PLC and the network interface with given IP address*)
  VAR_INPUT
    rqPing           : bool R_EDGE;  (*`{ENG} Ping request         {CSY} é·dost o odesl·nÌ Ping*)
    hostIP           : TIPadr;  (*`{ENG} Host IP              {CSY} IP adresa hostitele*)
    ttl              : usint;  (*`{ENG} Time to live TTL     {CSY} éivotnost paketu TTL*)
    timeLimit        : time;  (*`{ENG} Time limit for reply {CSY} »asov˝ limit pro odpovÏÔ*)
    dataLen          : uint;  (*`{ENG} Length of data       {CSY} DÈlka dat*)
  END_VAR
  VAR_IN_OUT
    pingInfo         : T_PING_INFO;  (*`{ENG} Ping information       {CSY} Informace o Pingu*)
  END_VAR
  VAR_OUTPUT
    done             : bool;  (*`{ENG} Operation successfully completed {CSY} Operace byla ˙spÏönÏ dokonËena*)
    busy             : bool;  (*`{ENG} Operation pending      {CSY} Operace probÌh·*)
    err              : bool;  (*`{ENG} Error occured          {CSY} Nastala chyba*)
  END_VAR
  VAR
    timeout          : TON;
    waitArp          : bool;
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION_BLOCK fbPing
(*`{CSY} OvÏ¯Ì spojenÌ mezi PLC a hostitelem danÈho jmÈna
  {ENU} Check the connection between the PLC and the host of given name*)
  VAR_INPUT
    rqPing           : bool R_EDGE;  (*`{ENG} Ping request  {CSY} é·dost o odesl·nÌ Ping*)
    hostName         : string [80];  (*`{ENG} Host name     {CSY} JmÈno hostitele*)
  END_VAR
  VAR_OUTPUT
    done             : bool;  (*`{ENG} Operation successfully completed {CSY} Operace byla ˙spÏönÏ dokonËena*)
    busy             : bool;  (*`{ENG} Operation pending                {CSY} Operace probÌh·*)
    err              : bool;  (*`{ENG} Error occured                    {CSY} Nastala chyba*)
    pingInfo         : T_PING_INFO;  (*`{ENG} Ping information                 {CSY} Informace o Pingu*)
  END_VAR
  VAR
    rqSplit          : bool;
    SplitUrlAdr      : fbSplitUrlAddress;
    PingIP           : fbPingIP;
    host             : string [80];  (*`JmÈno hostitele*)
    action           : string [80];  (*`Poûadovan· str·nka nap¯Ìklad "/index.xml"*)
    ipAdr            : TIPadr;  (*`IP adresa vzd·lenÈho serveru*)
    port             : uint;  (*`»Ìslo portu vzd·lenÈho serveru*)
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION_BLOCK fbSmtpDbx
(*`{ENU}Sends email messages via SMTP
  {CSY}OdesÌl· emailovÈ zpr·vy p¯es SMTP*)
  VAR_INPUT
    Send             : bool R_EDGE;  (*`{ENG} starts sending of email {CSY}spustÌ odesl·nÌ zpr·vy*)
    Auth             : bool;  (*`{ENG} authetification requiered? {CSY}vyûaduje server authetifikaci?*)
    Cancel           : bool R_EDGE;  (*`{ENG} cancel action {CSY}stornovat odesÌl·nÌ*)
    chanCode         : uint;  (*`{ENG} channel code {CSY}p¯enosov˝ kan·l {} TCP Master, in: 255, out: 255*)
    IPadr            : TIPadr;  (*`{ENG} IP address of SMTP server {CSY}IP adresa SMTP serveru*)
    port             : uint :=  25;  (*`{ENG} Port of SMTP server {CSY}Port SMTP serveru*)
    Lines            : usint;  (*`{ENG} number of lines {CSY}poËet ¯·dk˘ tÏla zpr·vy*)
    UtcOff           : int;  (*`{ENG} offset from UTC in minutes{CSY}posun ËasovÈho p·sma v minut·ch*)
    charset          : string [16];  (*`{ENG} charset of Email body {CSY}znakov· sada tÏla zpr·vy {}('windows-1250', 'UTF-8',...)*)
    attachementType  : string [32];  (*`{ENG} user defined MINE type of attachement. If not specified, 'application/octet-stream' is used (other possible values are {CSY}uûivatelsky definovan˝ MINE typ p¯Ìlohy. NenÌ-li specifikov·n, je pouûit 'application/octet-stream' (dalöÌ moûnÈ hodnoty jsou {}'image/jpeg', 'image/png', 'text/plain; charset=windows-1250',...)*)
    genMessageID     : bool;  (*`{ENG} generate unique Message-ID{CSY}vygeneruje unik·tnÌ Message-ID*)
    Attachement      : bool;  (*`{ENG} send with attachemnt{CSY}poslat s p¯Ìlohou*)
    AttachAdr        : udint;  (*`{ENG} address of attachemnt in databox{CSY}adresa p¯Ìlohy v databoxu*)
    AttachLen        : udint;  (*`{ENG} length of attachement in databox{CSY}dÈlka p¯Ìlohy v databoxu*)
  END_VAR
  VAR_IN_OUT
    Sender           : string [80];  (*`{ENG} sender address {CSY}adresa odesÌlatele*)
    SendName         : string [80];  (*`{ENG} sender name {CSY}jmÈno odesÌlatele*)
    Rcpt             : string [80];  (*`{ENG} recipient address {CSY}adresa p¯Ìjemce*)
    Subject          : string [80];  (*`{ENG} subject {CSY}p¯edmÏt zpr·vy*)
    Text             : string [80];  (*`{ENG} first line of email body {CSY}prvnÌ ¯·dek tÏla zpr·vy*)
    Attach           : string [80];  (*`{ENG} file name of attachement {CSY}jmÈno souboru s p¯ilohou*)
    Username         : string [80];  (*`{ENG} user name for SMTP server {CSY}uûivatelskÈ jmÈno pro SMTP server*)
    Password         : string [80];  (*`{ENG} password  for SMTP server {CSY}heslo pro SMTP server*)
  END_VAR
  VAR_OUTPUT
    Done             : bool;  (*`true{ENG} after email was sent successfully {CSY}pokud se poda¯ilo zpr·vu odeslat*)
    Busy             : bool;  (*`true{ENG} when sending is in progress {CSY}pokud se pr·vÏ odesÌl· zpr·va*)
    Err              : bool;  (*`true{ENG} when sending failed {CSY}pokud nastala p¯i odesÌl·nÌ chyba*)
    ErrId            : usint;  (*`{ENG} number of error {CSY}ËÌslo chyby*)
    ReplyCode        : uint;  (*`{ENG} server reply code {CSY}kÛd odpovÏdi serveru*)
    State            : TSmtpState;  (*`{ENG} communication state {CSY}stav komunikace*)
  END_VAR
  VAR CONSTANT
    SMTP_BASE64_LEN_ : udint :=  57;  (*`60*)
    SMTP_BASE64_LEN2_ : udint :=  SMTP_BASE64_LEN_*2;  (*`120*)
    SMTP_MAXIMUM_FILE_LINE_LENGTH_ : udint :=  SMTP_BASE64_LEN_*3;  (*`180;*)
  END_VAR
  VAR
    timeout_cntr     : TON;  (*`detekce timeoutu pri komunikaci*)
    cmd              : string [255];
    buff             : ARRAY [0..511] OF usint;
    copy_rcpt        : string [255];
    temp_rcpt        : string [180];
    body_rcpt        : string [80];
    ptrText          : PTR_TO string [80];
    body_lines       : sint;
    Recv_from        : fbRecvTxt;  (*`FB pro prijem*)
    Send_to          : fbSendTo;  (*`FB pro vysilani*)
    lAttachLen       : udint;
    oAttachLen       : udint;
    TRO              : bool;  (*`buffer overflow*)
    lAuth            : bool;  (*`byla pozadovana autorizace*)
    mesRec           : bool;
    lSend            : bool;
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION_BLOCK fbHttpRequestL3
(*`{ENU}Sends POST, PUT and GET metods via HTTP with option to set content type (Content-Type)
{CSY}VysÌl· metody GET, POST a PUT p¯es HTTP protokol s moûnostÌ definice typu obsahu (Content-Type)*)
  VAR_INPUT
    Post             : bool R_EDGE;  (*`{ENG}Send data via method POST {CSY}vyslat data metodou POST*)
    Put              : bool R_EDGE;  (*`{ENG}Send data via method PUT {CSY}vyslat data metodou PUT*)
    Get              : bool R_EDGE;  (*`{ENG}Get data via method GET {CSY}zÌskat data metodu GET*)
    Cancel           : bool R_EDGE;  (*`{ENG}Cancel pending operation {CSY}zruöit probÌhajÌcÌ operaci*)
    chanCode         : uint;  (*`{ENG}UNI channel {CSY}p¯enosov˝ kan·l {}TCP master in: 512, out: 512*)
    IPadr            : TIPadr;  (*`{ENG}IP address of remote server {CSY}IP adresa vzd·leneho serveru*)
    port             : uint :=  80;  (*`{ENG}Port of remote server {CSY}»Ìslo portu vzd·lenÈho serveru*)
    postLen          : uint;  (*`{ENG}Lenght of data to POST{CSY}DÈlka dat pro metodu POST*)
    Close            : bool;  (*`{ENG}If set, block don't wait for server to close connection and close it actively after receiving all data{CSY}Pokud je nastaveno, blok neËek· na server aû zav¯e spojenÌ a zav¯e jej aktivnÏ jakmile zÌsk· vöechny data*)
  END_VAR
  VAR_IN_OUT
    Action           : string [255];  (*`{ENG}Path to the data on the server (always starts with character '/') {CSY}Cesta k dat˘m na serveru (vûdy zaËÌn· znakem '/')*)
    Host             : string [80];  (*`{ENG}Host name {CSY}JmÈno hostitele*)
    Data             : THttpPostData;  (*`{ENG}First byte of data to POST {CSY}PrvnÌ byte dat pro metodu POST*)
    ContentType      : string [80];  (*`{ENG}Content-Type {CSY}Typ obsahu (Content-Type)*)
    RecvData         : THttpBuffer;  (*`{ENG}Data buffer 512 bytes {CSY}Bufer dat 512 byt˘*)
  END_VAR
  VAR_OUTPUT
    Done             : bool;  (*`{ENG}Operation done {CSY}Operace ukonËena*)
    Busy             : bool;  (*`{ENG}Operation pending {CSY}Operace probÌh·*)
    Err              : bool;  (*`{ENG}Communication error {CSY}Chyba komunikace*)
    ErrId            : usint;  (*`{ENG}Error number {CSY}»Ìslo chyby*)
    DataReady        : bool;  (*`{ENG}New data received {CSY}P¯ijata nov· data*)
    DataLen          : uint;  (*`{ENG}Data length {CSY}DÈlka dat*)
    State            : THttpState;  (*`{ENG}State of communication {CSY}Stav komunikace*)
    Result           : int;  (*`{ENG}HTTP Code {CSY}HTTP kod*)
    Progress         : sint;  (*`{ENG}Progress of data downloading {CSY}Pr˘bÏh stahov·nÌ dat*)
  END_VAR
  VAR
    ResRecv          : bool;
    LenRecv          : bool;
    HeaderRecv       : bool;
    WasEOL           : bool;
    TimeOutTon       : TON;
    helpstring       : string [255];
    RecvFrom         : fbRecvFrom;
    SendTo           : fbSendTo;
    ContLen          : dint;
    WholeLen         : dint;
    lPostLen         : uint;
    lHost            : string [80];
    BodyLen          : uint;
    sOff             : uint;
    rLen             : uint;
  END_VAR
END_FUNCTION_BLOCK

VAR_GLOBAL CONSTANT
 MAX_LEN_WS_BUFFER : uint :=  1440;

END_VAR

TYPE  TWebSocketData : ARRAY [0..1440] OF byte;
END_TYPE

TYPE TSendWsBuffer {HIDDEN} :
  STRUCT
    opcode           : byte;  (*`opcode.7 = FIN,   .3...0 = interpretation of the "Payload data"*)
    payloadLen       : usint;  (*`lenData.7 = mask, .6...0 = payload len up to 125 bytes*)
    extPayLen        : uint;  (*`if payloadLen = 126 then extPayLen is valid*)
    maskingKey       : ARRAY [0..3] OF byte;  (*`masking key*)
    data             : TWebSocketData;
  END_STRUCT;
END_TYPE

TYPE TRecvWsBuffer {HIDDEN} :
  STRUCT
    opcode           : byte;  (*`opcode.7 = FIN,   .3...0 = interpretation of the "Payload data"*)
    payloadLen       : usint;  (*`lenData.7 = mask, .6...0 = payload len up to 125 bytes*)
    extPayLen        : uint;  (*`if payloadLen = 126 then extPayLen is valid*)
    data             : TWebSocketData;
  END_STRUCT;
END_TYPE

__DECL FUNCTION _internetlib_SwpUint {HIDDEN} : uint
(*`{ENU} UINT conversion Litle Endian <==> Big Endian
  {CSY} UINT konverze Litle Endian <==> Big Endian*)
  VAR_INPUT
    in               : uint;
  END_VAR
END_FUNCTION

__DECL FUNCTION_BLOCK _internetlib_fbRandUdint {HIDDEN}
(*`Function block returns a pseudorandom number.
  This routine implements the recursion
    seed = 16807 * seed mod ( 2**31 - 1 )
  The integer arithmetic never requires more than 32 bits,
  including a sign bit.*)
  VAR_IN_OUT
    out              : udint;  (*`random number*)
  END_VAR
  VAR
    k                : dint;
    seed             : dint;
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION_BLOCK fbWebSocketClient
(*`{ENU} Function blok for communication by WebSocket protocol, PLC is as a client (for Foxtrot CP-2xxx only)
  {CSY} FunkËnÌ blok pro komunikaci WebSocket protokolem, PLC je v roli klienta (pouze pro Foxtrot CP-2xxx)*)
  VAR_INPUT
    rqConnect        : bool;  (*`{ENU} request for connection to a WebSocket server {CSY} û·dost o spojenÌ s WebSocket serverem*)
    serverUrl        : string [80];  (*`{ENU} server URI (eg 'wss: //echo.websocket.org') {CSY} URI serveru (nap¯. 'wss://echo.websocket.org')*)
    wsOptHeader      : string [80];  (*`{ENU} optional part of web socket header (for example 'Sec-WebSocket-Protocol: ocpp1.6$0D$0A'){CSY} voliteln· poloûka hlaviËky web socketu (nap¯. 'Sec-WebSocket-Protocol: ocpp1.6$0D$0A')*)
    textMode         : bool;  (*`{ENU} 0 = binary data exchange, 1 = text data exchange {CSY} 0 = bin·rnÌ v˝mÏna dat, 1 = textov· v˝mÏna dat*)
    pingTime         : time;  (*`{ENU} preset for sending of ping packet {CSY} p¯edvolba pro odesÌl·nÌ ping paketu (p¯i T#0s je spont·nnÌ vysÌl·nÌ ping vypnuto)*)
    rqSend           : bool;  (*`{ENU} request to send a message to the server {CSY} û·dost o odesl·nÌ zpr·vy na server*)
    lenSend          : uint;  (*`{ENU} length of sending message {CSY} dÈlka odesÌlanÈ zpr·vy*)
    logSizeKB        : uint;  (*`{ENU} max. log file size [KB] (0 = no logging) {CSY} max. velikost log souboru [KB] (0 = bez logov·nÌ)*)
    logMode          : uint;  (*`{ENU} log mode (one-time = ONE_TIME_LOG, cyclic = CYCLIC_LOG) {CSY} reûim logu ( jednor·zov˝ = ONE_TIME_LOG, cyklick˝ = CYCLIC_LOG)*)
    logFileName      : string [32];  (*`{ENU} log file name (it will be stored in WWW/LOGS/) {CSY} jmÈno log souboru (bude uloûen ve WWW/LOGS/)*)
  END_VAR
  VAR_IN_OUT
    sendBuf          : TWebSocketData;  (*`{ENU} buffer for transmitted data {CSY} buffer pro vysÌlan· data*)
    recvBuf          : TWebSocketData;  (*`{ENU} buffer for received data {CSY} buffer pro p¯ijÌman· data*)
  END_VAR
  VAR_OUTPUT
    isConnected      : bool;  (*`{ENU} connection with WebSocket server established {CSY} spojenÌ s WebSocket serverem nav·z·no*)
    isRecv           : bool;  (*`{ENU} received message fro server {CSY} p¯iöla zpr·va od serveru*)
    lenRecv          : uint;  (*`{ENU} length of received message {CSY} dÈlka p¯ijatÈ zpr·vy*)
    sumaSend         : udint;  (*`{ENU} total number of sent bytes {CSY} celkem odesl·no*)
    sumaRecv         : udint;  (*`{ENU} total number of received bytes {CSY} celkem p¯ijato*)
    isError          : bool;  (*`{ENU} an error has occurred {CSY} doölo k chybÏ*)
    lastErrDesc      : string [80];  (*`{ENU} error description {CSY} popis chyby*)
  END_VAR
  VAR CONSTANT
    wsHeader0        : string [24] :=  'GET ';
    wsHeader1        : string [24] :=  ' HTTP/1.1$0D$0AHost: ';
    wsHeader2        : string [80] :=  '$0D$0AUpgrade: websocket$0D$0AConnection: Upgrade$0D$0ASec-WebSocket-Key: ';
    wsHeader3        : string [32] :=  '$0D$0ASec-WebSocket-Version: 13$0D$0A';
    wsHeader4        : string [3] :=  '$0D$0A';
    handshakeErr     : string [20] :=  'Handshake failed! ';
  END_VAR
  VAR
    hSocket          : uint;  (*`handle socketu*)
    ConnectTrg       : R_TRIG;
    Split            : fbSplitUrlAddress;
    HttpName         : string [80];
    Action           : string [80];
    protocol         : usint;
    serverAdr        : TRemoteEthAdr;
    SendTo           : fbSendTo;
    RecvFrom         : fbRecvFrom;
    RandomNum {HIDDEN} : _internetlib_fbRandUdint;
    recvData         : TRecvWsBuffer;
    sendData         : TSendWsBuffer;
    wsKey64          : string [32];
    rqWebSocket      : bool;
    setAdr           : bool;
    rqSendHeader     : bool;
    newPacket        : bool;
    rqPing           : bool;
    rqPong           : bool;
    lenPong          : uint;
    dataPong         : ARRAY [0..127] OF byte;
    TimerWs          : TON;
    reqRecv          : uint;
    indRecv          : uint;
    cntPing          : usint;
  END_VAR
END_FUNCTION_BLOCK



{USES=fbNsLookUp:GetChanIndex,GetChanDesc,SetRemoteIPaddress,_internetlib_DnsCodeDomainName,_internetlib_DnsLenOfDomainName}
{USES=fbNsLookUpEx:STRING_TO_IPADR}
{USES=fbHttpRequest:GetChanIndex,GetChanDesc,CloseTCPconnection,MemcpyPtr,Base64_encode_string,SetUniChanHostName,SetRemoteIPaddress,EstabTCPconnection,IsEstabTCPconnection,MemcpyEx,Memcpy}
{USES=fbSmtp:GetChanIndex,GetChanDesc,FileClose,CloseTCPconnection,SetRemoteIPaddress,EstabTCPconnection,Base64_encode_string,GetDateAndTime_RFC2822,GetMACaddress,GetRTC,DT_TO_STRINGF,FileOpen,FileRead,Base64_encode_ptr_string,IsEstabTCPconnection}
{USES=fbSntp:GetChanIndex,GetChanDesc,SetRemoteIPaddress}
{USES=fbStoreToFtp:GetChanIndex,GetChanDesc,CloseTCPconnection,FileClose,DirClose,_FindNextPathSeparator,SetRemoteIPaddress,EstabTCPconnection,IsEstabTCPconnection,FileOpen,FileSize,DirOpen,DirRead,FileRead}
{USES=fbHttpRequestL:GetChanIndex,GetChanDesc,CloseTCPconnection,MemcpyPtr,Base64_encode_string,SetUniChanHostName,SetRemoteIPaddress,EstabTCPconnection,IsEstabTCPconnection,MemcpyEx,Memcpy}
{USES=fbHttpRequestL2:GetChanIndex,GetChanDesc,CloseTCPconnection,MemcpyPtr,Base64_encode_string,SetUniChanHostName,SetRemoteIPaddress,EstabTCPconnection,IsEstabTCPconnection,MemcpyEx,Memcpy}
{USES=fbSplitUrlAddress:GetDNS_IP}
{USES=fbRetriveFromFtp:GetChanIndex,GetChanDesc,CloseTCPconnection,FileClose,_FindNextPathSeparator,SetRemoteIPaddress,EstabTCPconnection,IsEstabTCPconnection}
{USES=fbPingIP:CheckGatewayIP,Memset}
{USES=fbPing:Memset,CheckGatewayIP}
{USES=fbSmtpDbx:GetChanIndex,GetChanDesc,CloseTCPconnection,SetRemoteIPaddress,EstabTCPconnection,Base64_encode_string,GetDateAndTime_RFC2822,GetMACaddress,GetRTC,DT_TO_STRINGF,ReadBlockFromDBx,Base64_encode_ptr_string,IsEstabTCPconnection}
{USES=fbHttpRequestL3:GetChanIndex,GetChanDesc,CloseTCPconnection,MemcpyPtr,Base64_encode_string,SetUniChanHostName,SetRemoteIPaddress,EstabTCPconnection,IsEstabTCPconnection,MemcpyEx,Memcpy}
{USES=fbWebSocketClient:Memset,OpenUniSocket,SetUniLog,SetRemoteIPaddress,EstabTCPconnection,IsEstabTCPconnection,Base64_encode,GetLastComErrTxt,STRING_TO_LOWER,Memcpy,_internetlib_SwpUint,UINT_TO_STRINGF,CloseUniSocket}
#srcfile 'C:\TECOLIBSRC\INTERNETLIB\INTERNETLIBVCONTROL\GLOBAL.ST'


 

#srcfile ''
#srcfile 'C:\TECOLIBSRC\INTERNETLIB\INTERNETLIBVCONTROL\_FINDNEXTPATHSEPARATOR.ST'
#pou _FindNextPathSeparator
#srcline 1 ;FUNCTION _FindNextPathSeparator {$IFNDEF _DEBUG} {HIDDEN} {$END_IF} : BOOL

#struct _FindNextPathSeparator__temp__
  pointer p
P     61
_FindNextPathSeparator_L0:
 LINK __SizeOf(_FindNextPathSeparator__temp__)
 NXT
; Initialize - variables
 LD   0
 WRX  __fc___FindNextPathSeparator
; End initialize - variables
; Initialize - dynamic variables
 LD   udint $FFFFFFFF    ; nil
 WRY  p
; End initialize - dynamic variables
#srcline 14 ;  Pos := Pos + 1;
 LDX  Pos
 LDIL 
#debug udint Pos
 LD   udint 1
 ADD
 LDX  Pos
 WRIL 
#debug_left udint Pos
#srcline 16 ;  p := ADR(In) + Pos - 1;
 LDX  In
#debug pointer In
 LDX  Pos
 LDIL 
#debug udint Pos
 ADD
 LD   udint 1
 SUB
 LEAY p
 WRIL 
#debug_left pointer p
#srcline 17 ;  
#srcline 18 ;  WHILE p^ <> 47 AND p^ <> 0 DO
_FindNextPathSeparator_L1:
 LEAY p
 LDIL    ; dereference 
 LDI  
#debug usint p^
 LD   usint 47
 EQ
 NEG
 LEAY p
 LDIL    ; dereference 
 LDI  
#debug usint p^
 LD   usint 0
 EQ
 NEG
 AND
 JMC  _FindNextPathSeparator_L2
 DBG 
#srcline 19 ;    Pos := Pos + 1;
 LDX  Pos
 LDIL 
#debug udint Pos
 LD   udint 1
 ADD
 LDX  Pos
 WRIL 
#debug_left udint Pos
#srcline 20 ;    p   := p + 1;
 LEAY p
 LDIL 
#debug pointer p
 LD   udint 1
 ADD
 LEAY p
 WRIL 
#debug_left pointer p
#srcline 21 ;  END_WHILE;
 JMP  _FindNextPathSeparator_L1
_FindNextPathSeparator_L2:
 NOP  -1
#srcline 22 ;  
#srcline 23 ;  IF p^ <> 0 THEN
 LEAY p
 LDIL    ; dereference 
 LDI  
#debug usint p^
 LD   usint 0
 EQ
 NEG
 JMC  _FindNextPathSeparator_L3
#srcline 24 ;    _FindNextPathSeparator := true;
 LD   bool -1       ; true
 WRX  __fc___FindNextPathSeparator
#debug_left bool _FindNextPathSeparator
#srcline 25 ;  ELSE
 JMP  _FindNextPathSeparator_L4
_FindNextPathSeparator_L3:
#srcline 26 ;    _FindNextPathSeparator := false;
 LD   bool 0       ; false
 WRX  __fc___FindNextPathSeparator
#debug_left bool _FindNextPathSeparator
#srcline 27 ;    Pos := 0;
 LD   udint 0
 LDX  Pos
 WRIL 
#debug_left udint Pos
#srcline 28 ;  END_IF;
_FindNextPathSeparator_L4:
#srcline 29 ;  
#srcline 30 ;END_FUNCTION
 PRV  
 LDX  __fc___FindNextPathSeparator
 ULNK
RET
E     61
#endpou 



 

#srcfile ''
#srcfile 'C:\TECOLIBSRC\INTERNETLIB\INTERNETLIBVCONTROL\FBNSLOOKUP.ST'
#pou _internetlib_DnsLenOfDomainName
#srcline 72 ;FUNCTION _internetlib_DnsLenOfDomainName {HIDDEN} : UDINT

#struct _internetlib_DnsLenOfDomainName__temp__
  pointer BG,
  udint VAL
P     61
_internetlib_DnsLenOfDomainName_L0:
 LINK __SizeOf(_internetlib_DnsLenOfDomainName__temp__)
 NXT
; Initialize - variables
 LD   0
 WRX  __fc___internetlib_DnsLenOfDomainName
; End initialize - variables
; Initialize - dynamic variables
 LD   udint $FFFFFFFF    ; nil
 WRY  BG
; End initialize - dynamic variables
#srcline 83 ;  IF IN^ = 16#C0 THEN //pointer
 LEAX IN
 LDIL    ; dereference 
 LDI  
#debug usint IN^
 LD   usint $C0
 EQ
 JMC  _internetlib_DnsLenOfDomainName_L1
#srcline 84 ;    _internetlib_dnsLenOfDomainName := 2;
 LD   udint 2
 WRX  __fc___internetlib_dnsLenOfDomainName
#debug_left udint _internetlib_dnsLenOfDomainName
#srcline 85 ;  ELSE
 JMP  _internetlib_DnsLenOfDomainName_L2
_internetlib_DnsLenOfDomainName_L1:
#srcline 86 ;    BG := IN;
 LEAX IN
 LDIL 
#debug pointer IN
 LEAY BG
 WRIL 
#debug_left pointer BG
#srcline 88 ;    WHILE IN^ > 0 DO
_internetlib_DnsLenOfDomainName_L3:
 LEAX IN
 LDIL    ; dereference 
 LDI  
#debug usint IN^
 LD   usint 0
 GT
 JMC  _internetlib_DnsLenOfDomainName_L4
 DBG 
#srcline 89 ;      VAL := USINT_TO_UDINT(IN^)+1;
 LEAX IN
 LDIL    ; dereference 
 LDI  
#debug usint IN^
 LD   udint 1
 ADD
 WRY  VAL
#debug_left udint VAL
#srcline 90 ;      IN := IN + VAL;
 LEAX IN
 LDIL 
#debug pointer IN
 LDY  VAL
#debug udint VAL
 ADD
 LEAX IN
 WRIL 
#debug_left pointer IN
#srcline 91 ;    END_WHILE;
 JMP  _internetlib_DnsLenOfDomainName_L3
_internetlib_DnsLenOfDomainName_L4:
 NOP  -1
#srcline 93 ;    _internetlib_dnsLenOfDomainName := PTR_TO_UDINT(IN) - PTR_TO_UDINT(BG) + 1;
 LEAX IN
 LDIL 
#debug pointer IN
 LEAY BG
 LDIL 
#debug pointer BG
 SUB
 LD   udint 1
 ADD
 WRX  __fc___internetlib_dnsLenOfDomainName
#debug_left udint _internetlib_dnsLenOfDomainName
#srcline 94 ;  END_IF;
_internetlib_DnsLenOfDomainName_L2:
#srcline 95 ;END_FUNCTION
 PRV  
 LDX  __fc___internetlib_DnsLenOfDomainName
 ULNK
RET
E     61
#endpou 

#pou _internetlib_DnsCodeDomainName
#srcline 98 ;FUNCTION _internetlib_DnsCodeDomainName {HIDDEN} : STRING[80]

#struct _internetlib_DnsCodeDomainName__temp__
  pointer pUsint1,
  pointer pString,
  string[82] PS0__st__
#data byte _str__internetlib_DnsCodeDomainName_0 = 
  '.',0
#data byte _str__internetlib_DnsCodeDomainName_1 = 
  '.',0
P     61
_internetlib_DnsCodeDomainName_L0:
 LINK __SizeOf(_internetlib_DnsCodeDomainName__temp__)
 NXT
; Initialize - variables
 LD   0
 WRX  __fc___internetlib_DnsCodeDomainName
 WRX  I
; End initialize - variables
; Initialize - dynamic variables
 LD   udint $FFFFFFFF    ; nil
 WRY  pUsint1
 LD   udint $FFFFFFFF    ; nil
 WRY  pString
; End initialize - dynamic variables
#srcline 114 ;  _internetlib_dnsCodeDomainName := INTERNETLIB_EMPTY_STRING_;
 LD   0   ; null string
 LEAX __fc___internetlib_dnsCodeDomainName
 WRI  
 LEAX __fc___internetlib_dnsCodeDomainName
 LD   80
 DST    ; Level 1
 LEA  INTERNETLIB_EMPTY_STRING_
 SCON 
#debug_left string _internetlib_dnsCodeDomainName
 PDST   ; Level 1
#srcline 116 ;  pUsint1  := ADR(IN)-81;
 LEAX IN
#debug pointer IN
 LD   udint 81
 SUB
 LEAY pUsint1
 WRIL 
#debug_left pointer pUsint1
#srcline 117 ;  pString  := pUsint1 + 1;
 LEAY pUsint1
 LDIL 
#debug pointer pUsint1
 LD   udint 1
 ADD
 LEAY pString
 WRIL 
#debug_left pointer pString
#srcline 118 ;  pString^ := IN + '.';
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   80
 DST    ; Level 1
 LEAX IN
#debug string IN
 SCON 
 LEA  _str__internetlib_DnsCodeDomainName_0
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAY pString
 LDIL    ; dereference 
 WRI  
 LEAY pString
 LDIL    ; dereference 
 LD   80
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string pString^
 PDST   ; Level 1
#srcline 120 ;  REPEAT
_internetlib_DnsCodeDomainName_L1:
 DBG
#srcline 121 ;   I := FIND(pString^, '.');
 LEAY pString
 LDIL    ; dereference 
#debug string pString^
 LEA  _str__internetlib_DnsCodeDomainName_1
 SFND 
 WRX  I
#debug_left int I
#srcline 122 ;   pUsint1^ := MAX(1,INT_TO_USINT(I))-1;
 LD   usint 1
 LDX  I
#debug int I
 EXTW 
 AND  $FF
 MAX
 LD   usint 1
 SUB
 AND  $FF
 LEAY pUsint1
 LDIL    ; dereference 
 WRI 
#debug_left usint pUsint1^
#srcline 123 ;   pUsint1  := pUsint1 + INT_TO_UDINT(I);
 LEAY pUsint1
 LDIL 
#debug pointer pUsint1
 LDX  I
#debug int I
 EXTW 
 ADD
 LEAY pUsint1
 WRIL 
#debug_left pointer pUsint1
#srcline 124 ;   pString  := pUsint1 + 1;
 LEAY pUsint1
 LDIL 
#debug pointer pUsint1
 LD   udint 1
 ADD
 LEAY pString
 WRIL 
#debug_left pointer pString
#srcline 125 ;  UNTIL I = 0 END_REPEAT;
 LDX  I
#debug int I
 EXTW 
 LD   int 0
 EQ
 JMC  _internetlib_DnsCodeDomainName_L1
_internetlib_DnsCodeDomainName_L2:
 NOP  -1
#srcline 127 ;END_FUNCTION
 PRV  
 LEAX  __fc___internetlib_DnsCodeDomainName
 ULNK
RET
E     61
#endpou 

#pou _internetlib_DnsDecodeDomainName
#srcline 129 ;FUNCTION _internetlib_DnsDecodeDomainName {HIDDEN} : STRING[80]

#struct _internetlib_DnsDecodeDomainName__temp__
  bool FIRST,
  udint VAL,
  pointer pUsint1,
  string[82] PS0__st__
P     61
_internetlib_DnsDecodeDomainName_L0:
 LINK __SizeOf(_internetlib_DnsDecodeDomainName__temp__)
 NXT
; Initialize - variables
 LD   0
 WRX  __fc___internetlib_DnsDecodeDomainName
; End initialize - variables
; Initialize - dynamic variables
 LD   bool -1   ; true
 WRY  FIRST
 LD   udint $FFFFFFFF    ; nil
 WRY  pUsint1
; End initialize - dynamic variables
#srcline 146 ;  _internetlib_dnsDecodeDomainName := INTERNETLIB_EMPTY_STRING_;
 LD   0   ; null string
 LEAX __fc___internetlib_dnsDecodeDomainName
 WRI  
 LEAX __fc___internetlib_dnsDecodeDomainName
 LD   80
 DST    ; Level 1
 LEA  INTERNETLIB_EMPTY_STRING_
 SCON 
#debug_left string _internetlib_dnsDecodeDomainName
 PDST   ; Level 1
#srcline 148 ;  pUsint1 := ADR(IN)-81;
 LEAX IN
#debug pointer IN
 LD   udint 81
 SUB
 LEAY pUsint1
 WRIL 
#debug_left pointer pUsint1
#srcline 150 ;  WHILE IN^ > 0 DO
_internetlib_DnsDecodeDomainName_L1:
 LEAX IN
 LDIL    ; dereference 
 LDI  
#debug usint IN^
 LD   usint 0
 GT
 JMC  _internetlib_DnsDecodeDomainName_L2
 DBG 
#srcline 151 ;    IF IN^ = 16#C0 THEN //pointer
 LEAX IN
 LDIL    ; dereference 
 LDI  
#debug usint IN^
 LD   usint $C0
 EQ
 JMC  _internetlib_DnsDecodeDomainName_L3
#srcline 152 ;      IN := IN + 1;
 LEAX IN
 LDIL 
#debug pointer IN
 LD   udint 1
 ADD
 LEAX IN
 WRIL 
#debug_left pointer IN
#srcline 153 ;      VAL := USINT_TO_UDINT(IN^);
 LEAX IN
 LDIL    ; dereference 
 LDI  
#debug usint IN^
 WRY  VAL
#debug_left udint VAL
#srcline 154 ;      IN := BG + VAL;
 LEAX BG
 LDIL 
#debug pointer BG
 LDY  VAL
#debug udint VAL
 ADD
 LEAX IN
 WRIL 
#debug_left pointer IN
#srcline 155 ;    ELSE
 JMP  _internetlib_DnsDecodeDomainName_L4
_internetlib_DnsDecodeDomainName_L3:
#srcline 156 ;      VAL := USINT_TO_UDINT(IN^)+1;
 LEAX IN
 LDIL    ; dereference 
 LDI  
#debug usint IN^
 LD   udint 1
 ADD
 WRY  VAL
#debug_left udint VAL
#srcline 157 ;      pUsint1^ := 16#2E;
 LD   usint $2E
 LEAY pUsint1
 LDIL    ; dereference 
 WRI 
#debug_left usint pUsint1^
#srcline 158 ;      IF FIRST THEN
 LDY  FIRST
#debug bool FIRST
 JMC  _internetlib_DnsDecodeDomainName_L5
#srcline 159 ;        pUsint1 := pUsint1-1;
 LEAY pUsint1
 LDIL 
#debug pointer pUsint1
 LD   udint 1
 SUB
 LEAY pUsint1
 WRIL 
#debug_left pointer pUsint1
#srcline 160 ;        FIRST := false;
 LD   bool 0       ; false
 WRY  FIRST
#debug_left bool FIRST
#srcline 161 ;      END_IF;
_internetlib_DnsDecodeDomainName_L5:
#srcline 162 ;      WHILE VAL > 0 DO
_internetlib_DnsDecodeDomainName_L7:
 LDY  VAL
#debug udint VAL
 LD   udint 0
 GT
 JMC  _internetlib_DnsDecodeDomainName_L8
 DBG 
#srcline 163 ;        IN := IN + 1;
 LEAX IN
 LDIL 
#debug pointer IN
 LD   udint 1
 ADD
 LEAX IN
 WRIL 
#debug_left pointer IN
#srcline 164 ;        pUsint1 := pUsint1+1;
 LEAY pUsint1
 LDIL 
#debug pointer pUsint1
 LD   udint 1
 ADD
 LEAY pUsint1
 WRIL 
#debug_left pointer pUsint1
#srcline 165 ;        pUsint1^ := IN^;
 LEAX IN
 LDIL    ; dereference 
 LDI  
#debug usint IN^
 LEAY pUsint1
 LDIL    ; dereference 
 WRI 
#debug_left usint pUsint1^
#srcline 166 ;        VAL := VAL - 1;
 LDY  VAL
#debug udint VAL
 LD   udint 1
 SUB
 WRY  VAL
#debug_left udint VAL
#srcline 167 ;      END_WHILE;
 JMP  _internetlib_DnsDecodeDomainName_L7
_internetlib_DnsDecodeDomainName_L8:
 NOP  -1
#srcline 168 ;    END_IF;
_internetlib_DnsDecodeDomainName_L4:
#srcline 169 ;  END_WHILE;
 JMP  _internetlib_DnsDecodeDomainName_L1
_internetlib_DnsDecodeDomainName_L2:
 NOP  -1
#srcline 170 ;  pUsint1^ := 0;
 LD   usint 0
 LEAY pUsint1
 LDIL    ; dereference 
 WRI 
#debug_left usint pUsint1^
#srcline 171 ;END_FUNCTION
 PRV  
 LEAX  __fc___internetlib_DnsDecodeDomainName
 ULNK
RET
E     61
#endpou 

#pou fbNsLookUp
#srcline 173 ;FUNCTION_BLOCK fbNsLookUp

#struct fbNsLookUp__temp__
  bool b,
  udint l,
  uint offset,
  pointer pWord,
  uint Answers,
  uint val,
  usint replycode,
  TRemoteEthAdr dnsEthAdr,
  TUniDesc UniDesc,
  string[82] PS0__st__,
  string[82] PS1__st__
P     61
fbNsLookUp_L0:
 LINK __SizeOf(fbNsLookUp__temp__)
; Initialize - dynamic variables
 LD   udint $FFFFFFFF    ; nil
 WRY  pWord
; End initialize - dynamic variables
; R_EDGE, F_EDGE 
 LDX  getIP
 LETX __EDGE_R__getIP
 WRX  getIP
#srcline 216 ;  Done := false;
 LD   bool 0       ; false
 WRX  Done
#debug_left bool Done
#srcline 218 ;  IF GetChanIndex( chanCode) <> -1 THEN
 NXT
 LDX  chanCode
#debug uint chanCode
 WR   __Instance__GetChanIndex~chanCode
#debug_left uint __Instance__GetChanIndex~chanCode
 PRV
 LEA  __Instance__GetChanIndex
 CAL  GetChanIndex_L0
 LD   int -1
 EQ
 NEG
 JMC  fbNsLookUp_L1
#srcline 219 ;    // kanal zalozen pomoci #module => kontrola nutna
#srcline 220 ;    UniDesc := GetChanDesc(chanCode := chanCode);
 NXT
 LDX  chanCode
#debug uint chanCode
 WR   __Instance__GetChanDesc~chanCode
#debug_left uint __Instance__GetChanDesc~chanCode
 PRV
 LEA  __Instance__GetChanDesc
 CAL  GetChanDesc_L0
 LEAY UniDesc
#debug_left pointer UniDesc
 LD   26   ;SizeOf() 
 MOV  %IB0
#srcline 221 ;    IF (UniDesc.modeChan <> 5) OR UniDesc.lenUniIn < SIZEOF(TDnsReply)+4 OR UniDesc.lenUniOut < SIZEOF(TDnsQuery)+4 THEN
 LDY  UniDesc~modeChan
#debug byte UniDesc.modeChan
 LD   byte 5
 EQ
 NEG
 LDY  UniDesc~lenUniIn
#debug uint UniDesc.lenUniIn
 LD   524  ; SizeOf()
 LD   uint 4
 ADD
 AND  $FFFF
 LT
 OR  
 LDY  UniDesc~lenUniOut
#debug uint UniDesc.lenUniOut
 LD   93  ; SizeOf()
 LD   uint 4
 ADD
 AND  $FFFF
 LT
 OR  
 JMC  fbNsLookUp_L3
#srcline 222 ;      Err    := 1;
 LD   bool -1      ; true
 WRX  Err
#debug_left bool Err
#srcline 223 ;      ErrId  := 255;
 LD   usint 255
 WRX  ErrId
#debug_left usint ErrId
#srcline 224 ;      RETURN;
 JMP  fbNsLookUp_RET
#srcline 225 ;    END_IF;
fbNsLookUp_L3:
#srcline 226 ;  END_IF;
fbNsLookUp_L1:
#srcline 229 ;  IF getIP & NOT Busy OR timeout2.Q THEN
 LDX  getIP
#debug bool getIP
 LDX  Busy
#debug bool Busy
 NEG
 AND
 LDX  timeout2~Q
#debug bool timeout2.Q
 OR  
 JMC  fbNsLookUp_L5
#srcline 230 ;    IF DnsIP = Any_IP THEN
 LEAX DnsIP
 LEA  Any_IP
 LD   4   ; SizeOf()
 BCMP 
 EQ   0
 JMC  fbNsLookUp_L7
#srcline 231 ;      Err    := 1;
 LD   bool -1      ; true
 WRX  Err
#debug_left bool Err
#srcline 232 ;      ErrId := 254;
 LD   usint 254
 WRX  ErrId
#debug_left usint ErrId
#srcline 233 ;      RETURN;
 JMP  fbNsLookUp_RET
#srcline 234 ;    END_IF;
fbNsLookUp_L7:
#srcline 235 ;    timeout2.IN := getIP;
 LDX  getIP
#debug bool getIP
 WRX  timeout2~IN
#debug_left bool timeout2.IN
#srcline 236 ;    ErrId := 0;
 LD   usint 0
 WRX  ErrId
#debug_left usint ErrId
#srcline 237 ;    Busy   := true;
 LD   bool -1       ; true
 WRX  Busy
#debug_left bool Busy
#srcline 238 ;    Err    := false;
 LD   bool 0       ; false
 WRX  Err
#debug_left bool Err
#srcline 239 ;    //set socket
#srcline 240 ;    dnsEthAdr.remoteIP   := DnsIP;
 LEAX DnsIP
#debug pointer DnsIP
 SRC  %IB0
 LEAY dnsEthAdr~remoteIP
#debug_left pointer dnsEthAdr.remoteIP
 LD   4   ;SizeOf() 
 MOV  %IB0
#srcline 241 ;    dnsEthAdr.remotePort := 53;
 LD   uint 53
 WRY  dnsEthAdr~remotePort
#debug_left uint dnsEthAdr.remotePort
#srcline 242 ;    dnsEthAdr.localPort  := 0;
 LD   uint 0
 WRY  dnsEthAdr~localPort
#debug_left uint dnsEthAdr.localPort
#srcline 243 ;    b := SetRemoteIPaddress(rq := 1, chanCode := chanCode, ethAdr := dnsEthAdr);
 NXT
 LD   1
 WR   __Instance__SetRemoteIPaddress~rq
#debug_left bool __Instance__SetRemoteIPaddress~rq
 LDX  chanCode
#debug uint chanCode
 WR   __Instance__SetRemoteIPaddress~chanCode
#debug_left uint __Instance__SetRemoteIPaddress~chanCode
 LEAY dnsEthAdr
 WR   __Instance__SetRemoteIPaddress~ethAdr
#debug_left pointer __Instance__SetRemoteIPaddress.ethAdr
 PRV
 LEA  __Instance__SetRemoteIPaddress
 CAL  SetRemoteIPaddress_L0
 WRY  b
#debug_left bool b
#srcline 244 ;    //prepare query
#srcline 245 ;    TransID := TransID + 1;
 LDX  TransID
#debug uint TransID
 LD   uint 1
 ADD
 AND  $FFFF
 WRX  TransID
#debug_left uint TransID
#srcline 246 ;    netDnsQuery.Header.TransactionID := WORD_TO_UINT(SHL(UINT_TO_WORD(TransID),8) OR SHR(UINT_TO_WORD(TransID),8));
 LDX  TransID
#debug uint TransID
 LD   uint 8
 SHL
 AND  $FFFF
 LDX  TransID
#debug uint TransID
 LD   uint 8
 SHR
 AND  $FFFF
 OR  
 WRX  netDnsQuery~Header~TransactionID
#debug_left uint netDnsQuery.Header.TransactionID
#srcline 247 ;    netDnsQuery.Header.Question      := 16#0100;
 LD   uint $0100
 WRX  netDnsQuery~Header~Question
#debug_left uint netDnsQuery.Header.Question
#srcline 248 ;    netDnsQuery.Header.NonAutheticated := 1;
 LD   bool -1      ; true
 WRX  netDnsQuery~Header~NonAutheticated
#debug_left bool netDnsQuery.Header.NonAutheticated
#srcline 249 ;    netDnsQuery.Header.Recursion_des := 1;
 LD   bool -1      ; true
 WRX  netDnsQuery~Header~Recursion_des
#debug_left bool netDnsQuery.Header.Recursion_des
#srcline 250 ;    netDnsQuery.QueryString := _internetlib_dnsCodeDomainName(Name);
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   80
 DST    ; Level 1
 NXT
 LD   0   ; null string
 LEA  __Instance___internetlib_DnsCodeDomainName~IN
 WRI 
 LEA  __Instance___internetlib_DnsCodeDomainName~IN
 LD   80
 DST    ; Level 2
 LDX  Name
#debug string Name
 SCON 
#debug_left string __Instance___internetlib_DnsCodeDomainName~IN
 PDST   ; Level 2
 PRV
 LEA  __Instance___internetlib_DnsCodeDomainName
 CAL  _internetlib_DnsCodeDomainName_L0

 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX netDnsQuery
 ADD  12  ; + offset 
 WRI  
 LEAX netDnsQuery
 ADD  12  ; + offset 
 LD   80
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string netDnsQuery.QueryString
 PDST   ; Level 1
#srcline 251 ;    l := _internetlib_dnsLenOfDomainName(IN := ADR(netDnsQuery.QueryString));
 NXT
 LEAX netDnsQuery
 ADD  12  ; + offset 
#debug pointer netDnsQuery.QueryString
 LEA  __Instance___internetlib_DnsLenOfDomainName~IN
 WRIL 
#debug_left udint __Instance___internetlib_DnsLenOfDomainName~IN
 PRV
 LEA  __Instance___internetlib_DnsLenOfDomainName
 CAL  _internetlib_DnsLenOfDomainName_L0
 WRY  l
#debug_left udint l
#srcline 252 ;    pWord := ADR(netDnsQuery.QueryString) + l;
 LEAX netDnsQuery
 ADD  12  ; + offset 
#debug pointer netDnsQuery.QueryString
 LDY  l
#debug udint l
 ADD
 LEAY pWord
 WRIL 
#debug_left pointer pWord
#srcline 253 ;    pWord^ := 16#0100;
 LD   uint $0100
 LEAY pWord
 LDIL    ; dereference 
 WRIW 
#debug_left uint pWord^
#srcline 254 ;    pWord := pWord + 2;
 LEAY pWord
 LDIL 
#debug pointer pWord
 LD   udint 2
 ADD
 LEAY pWord
 WRIL 
#debug_left pointer pWord
#srcline 255 ;    pWord^ := 16#0100;
 LD   uint $0100
 LEAY pWord
 LDIL    ; dereference 
 WRIW 
#debug_left uint pWord^
#srcline 256 ;    
#srcline 257 ;    //send query
#srcline 258 ;    SendTo(rq := 1, chanCode := chanCode,
 LD   1
 WRX  SendTo~rq
#debug_left bool SendTo~rq
 LDX  chanCode
#debug uint chanCode
 WRX  SendTo~chanCode
#debug_left uint SendTo~chanCode
#srcline 259 ;           lenTx := UDINT_TO_UINT(SIZEOF(TDnsQueryHeader)+4+l),
 LD   12  ; SizeOf()
 LD   udint 4
 ADD
 LDY  l
#debug udint l
 ADD
 AND  $FFFF
 WRX  SendTo~lenTx
#debug_left uint SendTo~lenTx
#srcline 260 ;           data := void(netDnsQuery));
 LEAX netDnsQuery
 WRX  SendTo~data
#debug_left pointer SendTo.data
 LEAX SendTo
 CAL  fbSendTo_L0
#srcline 261 ;  END_IF;
fbNsLookUp_L5:
#srcline 263 ;  timeout(IN := Busy, PT := T#15s);
 LDX  Busy
#debug bool Busy
 WRX  timeout~IN
#debug_left bool timeout~IN
 LD   time 15000
 WRX  timeout~PT
#debug_left time timeout~PT
 LEAX timeout
 CAL  TON_L0
#srcline 264 ;  timeout2(PT := T#3s);
 LD   time 3000
 WRX  timeout2~PT
#debug_left time timeout2~PT
 LEAX timeout2
 CAL  TON_L0
#srcline 266 ;  IF Busy THEN
 LDX  Busy
#debug bool Busy
 JMC  fbNsLookUp_L9
#srcline 267 ;    RecvFrom(rq := 1, chanCode := chanCode, lenRx := SIZEOF(netDnsReply),
 LD   1
 WRX  RecvFrom~rq
#debug_left bool RecvFrom~rq
 LDX  chanCode
#debug uint chanCode
 WRX  RecvFrom~chanCode
#debug_left uint RecvFrom~chanCode
 LD   524  ; SizeOf()
 WRX  RecvFrom~lenRx
#debug_left uint RecvFrom~lenRx
#srcline 268 ;             data := void(netDnsReply));
 LEAX netDnsReply
 WRX  RecvFrom~data
#debug_left pointer RecvFrom.data
 LEAX RecvFrom
 CAL  fbRecvFrom_L0
#srcline 269 ;    IF RecvFrom.mesRec & RecvFrom.error = 0 THEN
 LDX  RecvFrom~mesRec
#debug bool RecvFrom.mesRec
 LDX  RecvFrom~error
#debug usint RecvFrom.error
 LD   usint 0
 EQ
 AND
 JMC  fbNsLookUp_L11
#srcline 270 ;      IF RecvFrom.lenRx > SIZEOF(TDnsQueryHeader) THEN
 LDX  RecvFrom~lenRx
#debug uint RecvFrom.lenRx
 LD   12  ; SizeOf()
 GT
 JMC  fbNsLookUp_L13
#srcline 271 ;        IF netDnsReply.Header.TransactionID = netDnsQuery.Header.TransactionID THEN
 LDX  netDnsReply~Header~TransactionID
#debug uint netDnsReply.Header.TransactionID
 LDX  netDnsQuery~Header~TransactionID
#debug uint netDnsQuery.Header.TransactionID
 EQ
 JMC  fbNsLookUp_L15
#srcline 272 ;          replycode.0 := netDnsReply.Header.ReplyCode_0;
 LDX  netDnsReply~Header~ReplyCode_0
#debug bool netDnsReply.Header.ReplyCode_0
 WRY  replycode.0
#debug_left bool replycode.0
#srcline 273 ;          replycode.1 := netDnsReply.Header.ReplyCode_1;
 LDX  netDnsReply~Header~ReplyCode_1
#debug bool netDnsReply.Header.ReplyCode_1
 WRY  replycode.1
#debug_left bool replycode.1
#srcline 274 ;          replycode.2 := netDnsReply.Header.ReplyCode_2;
 LDX  netDnsReply~Header~ReplyCode_2
#debug bool netDnsReply.Header.ReplyCode_2
 WRY  replycode.2
#debug_left bool replycode.2
#srcline 275 ;          replycode.3 := netDnsReply.Header.ReplyCode_3;
 LDX  netDnsReply~Header~ReplyCode_3
#debug bool netDnsReply.Header.ReplyCode_3
 WRY  replycode.3
#debug_left bool replycode.3
#srcline 276 ;          IF replycode > 0 THEN
 LDY  replycode
#debug usint replycode
 LD   usint 0
 GT
 JMC  fbNsLookUp_L17
#srcline 277 ;            IP     := Any_IP;
 LEA  Any_IP
#debug pointer Any_IP
 SRC  %IB0
 LDX  IP
#debug_left pointer IP
 LD   4   ;SizeOf() 
 MOV  %IB0
#srcline 278 ;            Busy   := false;
 LD   bool 0       ; false
 WRX  Busy
#debug_left bool Busy
#srcline 279 ;            Err    := true;
 LD   bool -1       ; true
 WRX  Err
#debug_left bool Err
#srcline 280 ;            ErrId  := 1+replycode;
 LD   usint 1
 LDY  replycode
#debug usint replycode
 ADD
 AND  $FF
 WRX  ErrId
#debug_left usint ErrId
#srcline 281 ;          ELSE
 JMP  fbNsLookUp_L18
fbNsLookUp_L17:
#srcline 282 ;            Answers := WORD_TO_UINT(SHL(UINT_TO_WORD(netDnsReply.Header.AnswerRRs),8) OR SHR(UINT_TO_WORD(netDnsReply.Header.AnswerRRs),8));
 LDX  netDnsReply~Header~AnswerRRs
#debug uint netDnsReply.Header.AnswerRRs
 LD   uint 8
 SHL
 AND  $FFFF
 LDX  netDnsReply~Header~AnswerRRs
#debug uint netDnsReply.Header.AnswerRRs
 LD   uint 8
 SHR
 AND  $FFFF
 OR  
 WRY  Answers
#debug_left uint Answers
#srcline 283 ;            pWord := ADR(netDnsReply.Data);
 LEAX netDnsReply
 ADD  12  ; + offset 
#debug pointer netDnsReply.Data
 LEAY pWord
 WRIL 
#debug_left pointer pWord
#srcline 284 ;            pWord := pWord + _internetlib_dnsLenOfDomainName(pWord) + 4; //step over query
 LEAY pWord
 LDIL 
#debug pointer pWord
 NXT
 LEAY pWord
 LDIL 
#debug pointer pWord
 LEA  __Instance___internetlib_DnsLenOfDomainName~IN
 WRIL 
#debug_left udint __Instance___internetlib_DnsLenOfDomainName~IN
 PRV
 LEA  __Instance___internetlib_DnsLenOfDomainName
 CAL  _internetlib_DnsLenOfDomainName_L0
 ADD
 LD   udint 4
 ADD
 LEAY pWord
 WRIL 
#debug_left pointer pWord
#srcline 285 ;            pWord := pWord + _internetlib_dnsLenOfDomainName(pWord);     //step to type
 LEAY pWord
 LDIL 
#debug pointer pWord
 NXT
 LEAY pWord
 LDIL 
#debug pointer pWord
 LEA  __Instance___internetlib_DnsLenOfDomainName~IN
 WRIL 
#debug_left udint __Instance___internetlib_DnsLenOfDomainName~IN
 PRV
 LEA  __Instance___internetlib_DnsLenOfDomainName
 CAL  _internetlib_DnsLenOfDomainName_L0
 ADD
 LEAY pWord
 WRIL 
#debug_left pointer pWord
#srcline 286 ;            WHILE pWord^ <> 16#0100 DO                      //wait for type A (host address)
fbNsLookUp_L19:
 LEAY pWord
 LDIL    ; dereference 
 LDIW 
#debug uint pWord^
 LD   uint $0100
 EQ
 NEG
 JMC  fbNsLookUp_L20
 DBG 
#srcline 287 ;              IF Answers = 0 THEN RETURN; END_IF;           //if there is no other answers exit
 LDY  Answers
#debug uint Answers
 LD   uint 0
 EQ
 JMC  fbNsLookUp_L21
 JMP  fbNsLookUp_RET
fbNsLookUp_L21:
#srcline 288 ;              Answers := Answers - 1;                       //decrease answers number
 LDY  Answers
#debug uint Answers
 LD   uint 1
 SUB
 AND  $FFFF
 WRY  Answers
#debug_left uint Answers
#srcline 289 ;              pWord := pWord + 8;                           //step over type, class and ttl
 LEAY pWord
 LDIL 
#debug pointer pWord
 LD   udint 8
 ADD
 LEAY pWord
 WRIL 
#debug_left pointer pWord
#srcline 290 ;              val := WORD_TO_UINT(SHL(UINT_TO_WORD(pWord^),8) OR SHR(UINT_TO_WORD(pWord^),8)); //read size of data
 LEAY pWord
 LDIL    ; dereference 
 LDIW 
#debug uint pWord^
 LD   uint 8
 SHL
 AND  $FFFF
 LEAY pWord
 LDIL    ; dereference 
 LDIW 
#debug uint pWord^
 LD   uint 8
 SHR
 AND  $FFFF
 OR  
 WRY  val
#debug_left uint val
#srcline 291 ;              pWord := pWord + UINT_TO_UDINT(val) + 2;      //step over data
 LEAY pWord
 LDIL 
#debug pointer pWord
 LDY  val
#debug uint val
 ADD
 LD   udint 2
 ADD
 LEAY pWord
 WRIL 
#debug_left pointer pWord
#srcline 292 ;//              cName  := dnsDecodeDomainName(IN := pWord, BG := ADR(netDnsReply));
#srcline 293 ;              pWord := pWord + _internetlib_dnsLenOfDomainName(pWord);   //step over name
 LEAY pWord
 LDIL 
#debug pointer pWord
 NXT
 LEAY pWord
 LDIL 
#debug pointer pWord
 LEA  __Instance___internetlib_DnsLenOfDomainName~IN
 WRIL 
#debug_left udint __Instance___internetlib_DnsLenOfDomainName~IN
 PRV
 LEA  __Instance___internetlib_DnsLenOfDomainName
 CAL  _internetlib_DnsLenOfDomainName_L0
 ADD
 LEAY pWord
 WRIL 
#debug_left pointer pWord
#srcline 294 ;            END_WHILE;
 JMP  fbNsLookUp_L19
fbNsLookUp_L20:
 NOP  -1
#srcline 295 ;            pWord := pWord + 8;                             //step over type, class and ttl
 LEAY pWord
 LDIL 
#debug pointer pWord
 LD   udint 8
 ADD
 LEAY pWord
 WRIL 
#debug_left pointer pWord
#srcline 296 ;            IF pWord^ = 16#0400 THEN                        //it should be 4 bytes of host address
 LEAY pWord
 LDIL    ; dereference 
 LDIW 
#debug uint pWord^
 LD   uint $0400
 EQ
 JMC  fbNsLookUp_L23
#srcline 297 ;              pWord := pWord + 2;                           //step over size
 LEAY pWord
 LDIL 
#debug pointer pWord
 LD   udint 2
 ADD
 LEAY pWord
 WRIL 
#debug_left pointer pWord
#srcline 298 ;              offset := UDINT_TO_UINT(PTR_TO_UDINT(pWord) - PTR_TO_UDINT(ADR(netDnsReply.Data[0]))); //offset of ip
 LEAY pWord
 LDIL 
#debug pointer pWord
 LEAX netDnsReply
 ADD  12  ; + offset 
#debug pointer netDnsReply.Data[0]
 SUB
 AND  $FFFF
 WRY  offset
#debug_left uint offset
#srcline 299 ;              IP[0] := netDnsReply.Data[offset];            //read IP
 LEAX netDnsReply
 ADD  12  ; + offset 
 LDY  offset
#debug uint offset
 RCHK 511   ; Range Check
 ADD     ; + offset 
 LDI  
#debug usint netDnsReply.Data[offset]
 LDX  IP
 WRI 
#debug_left usint IP[0]
#srcline 300 ;              IP[1] := netDnsReply.Data[offset+1];
 LEAX netDnsReply
 ADD  12  ; + offset 
 LDY  offset
#debug uint offset
 LD   uint 1
 ADD
 AND  $FFFF
 RCHK 511   ; Range Check
 ADD     ; + offset 
 LDI  
#debug usint netDnsReply.Data[offset+1]
 LDX  IP
 ADD  1  ; + offset 
 WRI 
#debug_left usint IP[1]
#srcline 301 ;              IP[2] := netDnsReply.Data[offset+2];
 LEAX netDnsReply
 ADD  12  ; + offset 
 LDY  offset
#debug uint offset
 LD   uint 2
 ADD
 AND  $FFFF
 RCHK 511   ; Range Check
 ADD     ; + offset 
 LDI  
#debug usint netDnsReply.Data[offset+2]
 LDX  IP
 ADD  2  ; + offset 
 WRI 
#debug_left usint IP[2]
#srcline 302 ;              IP[3] := netDnsReply.Data[offset+3];
 LEAX netDnsReply
 ADD  12  ; + offset 
 LDY  offset
#debug uint offset
 LD   uint 3
 ADD
 AND  $FFFF
 RCHK 511   ; Range Check
 ADD     ; + offset 
 LDI  
#debug usint netDnsReply.Data[offset+3]
 LDX  IP
 ADD  3  ; + offset 
 WRI 
#debug_left usint IP[3]
#srcline 303 ;              Done  := true;
 LD   bool -1       ; true
 WRX  Done
#debug_left bool Done
#srcline 304 ;              Busy  := false;
 LD   bool 0       ; false
 WRX  Busy
#debug_left bool Busy
#srcline 305 ;            END_IF;
fbNsLookUp_L23:
#srcline 306 ;          END_IF;
fbNsLookUp_L18:
#srcline 307 ;        END_IF;
fbNsLookUp_L15:
#srcline 308 ;      END_IF;
fbNsLookUp_L13:
#srcline 309 ;    END_IF;
fbNsLookUp_L11:
#srcline 310 ;  END_IF;
fbNsLookUp_L9:
#srcline 312 ;  IF timeout.Q THEN
 LDX  timeout~Q
#debug bool timeout.Q
 JMC  fbNsLookUp_L25
#srcline 313 ;    IP     := Any_IP;
 LEA  Any_IP
#debug pointer Any_IP
 SRC  %IB0
 LDX  IP
#debug_left pointer IP
 LD   4   ;SizeOf() 
 MOV  %IB0
#srcline 314 ;    Busy   := false;
 LD   bool 0       ; false
 WRX  Busy
#debug_left bool Busy
#srcline 315 ;    Err    := true;
 LD   bool -1       ; true
 WRX  Err
#debug_left bool Err
#srcline 316 ;    ErrId  := 1;
 LD   usint 1
 WRX  ErrId
#debug_left usint ErrId
#srcline 317 ;  END_IF;
fbNsLookUp_L25:
#srcline 318 ;  
#srcline 319 ;  timeout2.IN := timeout2.IN & Busy;
 LDX  timeout2~IN
#debug bool timeout2.IN
 LDX  Busy
#debug bool Busy
 AND
 WRX  timeout2~IN
#debug_left bool timeout2.IN
#srcline 321 ;END_FUNCTION_BLOCK
fbNsLookUp_RET:
 ULNK
RET
E     61

; Initialize - variables
P     61
fbNsLookUp__InstanceInit__:
 LINK 0
 LEAX RecvFrom
 CAL  fbRecvFrom__InstanceInit__
 LEAX SendTo
 CAL  fbSendTo__InstanceInit__
 ULNK
RET
E     61
; End initialize - variables
#endpou 



 

#srcfile ''
#srcfile 'C:\TECOLIBSRC\INTERNETLIB\INTERNETLIBVCONTROL\FBNSLOOKUPEX.ST'
#pou fbNsLookUpEx
#srcline 1 ;FUNCTION_BLOCK fbNsLookUpEx

#struct fbNsLookUpEx__temp__
  dint tmp,
  TIPadr tmpIP,  ;IP adresa
  string[82] PS0__st__
P     61
fbNsLookUpEx_L0:
 LINK __SizeOf(fbNsLookUpEx__temp__)
; Initialize - dynamic variables
; End initialize - dynamic variables
; R_EDGE, F_EDGE 
 LDX  getIP
 LETX __EDGE_R__getIP
 WRX  getIP
#srcline 31 ;  Done := 0;
 LD   bool 0       ; false
 WRX  Done
#debug_left bool Done
#srcline 32 ;  IF getIP AND NOT busy THEN
 LDX  getIP
#debug bool getIP
 LDX  busy
#debug bool busy
 NEG
 AND
 JMC  fbNsLookUpEx_L1
#srcline 33 ;    Err := 0;
 LD   bool 0       ; false
 WRX  Err
#debug_left bool Err
#srcline 34 ;    ErrId := 0;
 LD   usint 0
 WRX  ErrId
#debug_left usint ErrId
#srcline 35 ;    tmpIP := STRING_TO_IPADR( IPAdr := Name);   // zkusit, jestli v Name neni IP adresa
 NXT
 LD   0   ; null string
 LEA  __Instance__STRING_TO_IPADR~IPAdr
 WRI 
 LEA  __Instance__STRING_TO_IPADR~IPAdr
 LD   80
 DST    ; Level 1
 LEAX Name
#debug string Name
 SCON 
#debug_left string __Instance__STRING_TO_IPADR~IPAdr
 PDST   ; Level 1
 PRV
 LEA  __Instance__STRING_TO_IPADR
 CAL  STRING_TO_IPADR_L0
 LEAY tmpIP
#debug_left pointer tmpIP
 LD   4   ;SizeOf() 
 MOV  %IB0
#srcline 36 ;    IF tmpIP <> HTTP_IP_NULL THEN               // je-to IP adresa, neni treba DNS dotaz
 LEAY tmpIP
 LEA  __Const__fbNsLookUpEx_HTTP_IP_NULL
 LD   4   ; SizeOf()
 BCMP 
 EQ   0
 NEG
 JMC  fbNsLookUpEx_L3
#srcline 37 ;      IP := tmpIP; Done := 1;                   // vratit IP adresu
 LEAY tmpIP
#debug pointer tmpIP
 SRC  %IB0
 LDX  IP
#debug_left pointer IP
 LD   4   ;SizeOf() 
 MOV  %IB0
 LD   bool -1      ; true
 WRX  Done
#debug_left bool Done
#srcline 38 ;      RETURN;                                   // hotovo
 JMP  fbNsLookUpEx_RET
#srcline 39 ;    END_IF;
fbNsLookUpEx_L3:
#srcline 40 ;    busy := 1;
 LD   bool -1      ; true
 WRX  busy
#debug_left bool busy
#srcline 41 ;    CurrName := Name;
 LD   0   ; null string
 LEAX CurrName
 WRI  
 LEAX CurrName
 LD   80
 DST    ; Level 1
 LEAX Name
#debug string Name
 SCON 
#debug_left string CurrName
 PDST   ; Level 1
#srcline 42 ;  END_IF;
fbNsLookUpEx_L1:
#srcline 43 ;  IF busy THEN
 LDX  busy
#debug bool busy
 JMC  fbNsLookUpEx_L5
#srcline 44 ;    {asm}
#srcline 45
      LDX    long dnsIP ; IP address of DNS server
#srcline 46
      LEAX   CurrName   ; ptr to domain name
#srcline 47
      LDX    IP         ; ptr to result IP
#srcline 48
      SYS    80         ; dns_register()
#srcline 49
      WRY    tmp
#srcline 50 ;    {end_asm}
#srcline 51 ;    IF tmp = 1 THEN
 LDY  tmp
#debug dint tmp
 LD   dint 1
 EQ
 JMC  fbNsLookUpEx_L7
#srcline 52 ;      Done := 1; Busy := 0;    // OK
 LD   bool -1      ; true
 WRX  Done
#debug_left bool Done
 LD   bool 0       ; false
 WRX  Busy
#debug_left bool Busy
#srcline 53 ;    ELSE
 JMP  fbNsLookUpEx_L8
fbNsLookUpEx_L7:
#srcline 54 ;      IF tmp <> 0 THEN
 LDY  tmp
#debug dint tmp
 LD   dint 0
 EQ
 NEG
 JMC  fbNsLookUpEx_L9
#srcline 55 ;        Busy := 0; Err := 1; ErrId := DINT_TO_USINT(-1 * tmp);  // error
 LD   bool 0       ; false
 WRX  Busy
#debug_left bool Busy
 LD   bool -1      ; true
 WRX  Err
#debug_left bool Err
 LD   dint -1
 LDY  tmp
#debug dint tmp
 MULS
 AND  $FF
 WRX  ErrId
#debug_left usint ErrId
#srcline 56 ;      END_IF;
fbNsLookUpEx_L9:
#srcline 57 ;    END_IF;
fbNsLookUpEx_L8:
#srcline 58 ;  END_IF;
fbNsLookUpEx_L5:
#srcline 59 ;END_FUNCTION_BLOCK
fbNsLookUpEx_RET:
 ULNK
RET
E     61

; Initialize - variables
P     61
fbNsLookUpEx__InstanceInit__:
 LINK 0
 ULNK
RET
E     61
; End initialize - variables
#endpou 



 

#srcfile ''
#srcfile 'C:\TECOLIBSRC\INTERNETLIB\INTERNETLIBVCONTROL\GETDATEANDTIME_RFC2822.ST'


 

#srcfile ''
#srcfile 'C:\TECOLIBSRC\INTERNETLIB\INTERNETLIBVCONTROL\FBHTTP.ST'
#pou fbHttpRequest
#srcline 6 ;FUNCTION_BLOCK fbHttpRequest

#struct fbHttpRequest__temp__
  string[81] lNamePass,
  usint r,
  uint i,
  uint BodyLen,
  pointer pHelpString,
  pointer pUint,
  pointer pUsint,
  TUniDesc UniDesc,
  TRemoteEthAdr rea,
  udint l,
  uint authPos,
  uint j,
  usint P0__st__,
  string[257] PS0__st__,
  string[62] PS1__st__,
  string[257] PSC__st__
#data byte _str_fbHttpRequest_0 = 
  '@',0
#data byte _str_fbHttpRequest_1 = 
  'G','E','T',' ',0
#data byte _str_fbHttpRequest_2 = 
  'P','O','S','T',' ',0
#data byte _str_fbHttpRequest_3 = 
  ' ','H','T','T','P','/','1','.','0',$0D,$0A,'U','s','e','r','-','A','g','e','n',
  't',':',' ','F','o','x','t','r','o','t','/',0
#data byte _str_fbHttpRequest_4 = 
  '.',0
#data byte _str_fbHttpRequest_5 = 
  ' ','(','T','e','c','o','m','a','t',';',' ','N',';',' ','e','n','-','U','S',')',
  $0D,$0A,'C','a','c','h','e','-','C','o','n','t','r','o','l',':',' ','m','a','x',
  '-','a','g','e','=','0',$0D,$0A,'A','c','c','e','p','t',':',' ','*','/','*',$0D,
  $0A,'H','o','s','t',':',' ',0
#data byte _str_fbHttpRequest_6 = 
  $0D,$0A,'A','u','t','h','o','r','i','z','a','t','i','o','n',':',' ','B','a','s',
  'i','c',' ',0
#data byte _str_fbHttpRequest_7 = 
  $0D,$0A,'C','o','n','t','e','n','t','-','T','y','p','e',':',' ','a','p','p','l',
  'i','c','a','t','i','o','n','/','x','-','w','w','w','-','f','o','r','m','-','u',
  'r','l','e','n','c','o','d','e','d',$0D,$0A,'C','o','n','t','e','n','t','-','L',
  'e','n','g','t','h',':',' ',0
#data byte _str_fbHttpRequest_8 = 
  $0D,$0A,'C','o','n','n','e','c','t','i','o','n',':',' ','C','l','o','s','e',$0D,
  $0A,$0D,$0A,0
#data byte _str_fbHttpRequest_9 = 
  $0D,$0A,'C','o','n','n','e','c','t','i','o','n',':',' ','C','l','o','s','e',$0D,
  $0A,$0D,$0A,0
#data byte _str_fbHttpRequest_10 = 
  $0D,$0A,0
#data byte _str_fbHttpRequest_11 = 
  'H','T','T','P',0
#data byte _str_fbHttpRequest_12 = 
  'C','o','n','t','e','n','t','-','L','e','n','g','t','h',':',0
#data byte _str_fbHttpRequest_13 = 
  $0D,$0A,$0D,$0A,0
P     61
fbHttpRequest_L0:
 LINK __SizeOf(fbHttpRequest__temp__)
; Initialize - dynamic variables
 LD   udint $FFFFFFFF    ; nil
 WRY  pHelpString
 LD   udint $FFFFFFFF    ; nil
 WRY  pUint
 LD   udint $FFFFFFFF    ; nil
 WRY  pUsint
; End initialize - dynamic variables
; R_EDGE, F_EDGE 
 LDX  Post
 LETX __EDGE_R__Post
 WRX  Post
 LDX  Get
 LETX __EDGE_R__Get
 WRX  Get
 LDX  Cancel
 LETX __EDGE_R__Cancel
 WRX  Cancel
#srcline 71 ;  IF GetChanIndex( chanCode) <> -1 THEN
 NXT
 LDX  chanCode
#debug uint chanCode
 WR   __Instance__GetChanIndex~chanCode
#debug_left uint __Instance__GetChanIndex~chanCode
 PRV
 LEA  __Instance__GetChanIndex
 CAL  GetChanIndex_L0
 LD   int -1
 EQ
 NEG
 JMC  fbHttpRequest_L1
#srcline 72 ;    // kanal zalozen pomoci #module => kontrola nutna
#srcline 73 ;    UniDesc := GetChanDesc( chanCode := chanCode);
 NXT
 LDX  chanCode
#debug uint chanCode
 WR   __Instance__GetChanDesc~chanCode
#debug_left uint __Instance__GetChanDesc~chanCode
 PRV
 LEA  __Instance__GetChanDesc
 CAL  GetChanDesc_L0
 LEAY UniDesc
#debug_left pointer UniDesc
 LD   26   ;SizeOf() 
 MOV  %IB0
#srcline 74 ;    IF (UniDesc.modeChan <> 5) OR (UniDesc.lenUniIn <> 516) OR (UniDesc.lenUniOut < 516) THEN
 LDY  UniDesc~modeChan
#debug byte UniDesc.modeChan
 LD   byte 5
 EQ
 NEG
 LDY  UniDesc~lenUniIn
#debug uint UniDesc.lenUniIn
 LD   uint 516
 EQ
 NEG
 OR  
 LDY  UniDesc~lenUniOut
#debug uint UniDesc.lenUniOut
 LD   uint 516
 LT
 OR  
 JMC  fbHttpRequest_L3
#srcline 75 ;      Err   := true;
 LD   bool -1       ; true
 WRX  Err
#debug_left bool Err
#srcline 76 ;      ErrId := 255;
 LD   usint 255
 WRX  ErrId
#debug_left usint ErrId
#srcline 77 ;      RETURN;
 JMP  fbHttpRequest_RET
#srcline 78 ;    END_IF;
fbHttpRequest_L3:
#srcline 79 ;  END_IF;
fbHttpRequest_L1:
#srcline 81 ;  Busy := State <> hs_HttpIdle;
 LDX  State
#debug usint State
 LD   udint 0  ; THttpState#hs_HttpIdle
 EQ
 NEG
 WRX  Busy
#debug_left bool Busy
#srcline 83 ;  TimeOutTon(IN := Busy & NOT DataReady, PT := T#2m);
 LDX  Busy
#debug bool Busy
 LDX  DataReady
#debug bool DataReady
 NEG
 AND
 WRX  TimeOutTon~IN
#debug_left bool TimeOutTon~IN
 LD   time 120000
 WRX  TimeOutTon~PT
#debug_left time TimeOutTon~PT
 LEAX TimeOutTon
 CAL  TON_L0
#srcline 85 ;  DataReady := false;
 LD   bool 0       ; false
 WRX  DataReady
#debug_left bool DataReady
#srcline 87 ;  IF TimeOutTon.Q THEN
 LDX  TimeOutTon~Q
#debug bool TimeOutTon.Q
 JMC  fbHttpRequest_L5
#srcline 88 ;    Err   := true;
 LD   bool -1       ; true
 WRX  Err
#debug_left bool Err
#srcline 89 ;    ErrId := 1;
 LD   usint 1
 WRX  ErrId
#debug_left usint ErrId
#srcline 90 ;    State := hs_HttpIdle;
 LD   udint 0  ; THttpState#hs_HttpIdle
 WRX  State
#debug_left usint State
#srcline 91 ;  END_IF;
fbHttpRequest_L5:
#srcline 93 ;  IF Cancel THEN
 LDX  Cancel
#debug bool Cancel
 JMC  fbHttpRequest_L7
#srcline 94 ;    State := hs_HttpIdle;
 LD   udint 0  ; THttpState#hs_HttpIdle
 WRX  State
#debug_left usint State
#srcline 95 ;    Err   := ContLen > 0;
 LDX  ContLen
#debug dint ContLen
 LD   dint 0
 GTS
 WRX  Err
#debug_left bool Err
#srcline 96 ;  END_IF;
fbHttpRequest_L7:
#srcline 98 ;  CASE State OF
 LDX  State
#debug usint State
 WRY  P0__st__
 LD   0
 LDY  P0__st__
 EQ  
 JMC  fbHttpRequest_L10
#srcline 99 ;    hs_HttpIdle   :
#srcline 100 ;      r := CloseTCPconnection(chanCode := chanCode);
 NXT
 LDX  chanCode
#debug uint chanCode
 WR   __Instance__CloseTCPconnection~chanCode
#debug_left uint __Instance__CloseTCPconnection~chanCode
 PRV
 LEA  __Instance__CloseTCPconnection
 CAL  CloseTCPconnection_L0
 WRY  r
#debug_left usint r
#srcline 101 ;      Done := false;
 LD   bool 0       ; false
 WRX  Done
#debug_left bool Done
#srcline 102 ;      IF Post OR Get THEN
 LDX  Post
#debug bool Post
 LDX  Get
#debug bool Get
 OR  
 JMC  fbHttpRequest_L11
#srcline 103 ;        sOff := 0;
 LD   uint 0
 WRX  sOff
#debug_left uint sOff
#srcline 104 ;        rLen := 0;
 LD   uint 0
 WRX  rLen
#debug_left uint rLen
#srcline 105 ;        WholeLen := 0;
 LD   dint 0
 WRX  WholeLen
#debug_left dint WholeLen
#srcline 106 ;        Err     := false;
 LD   bool 0       ; false
 WRX  Err
#debug_left bool Err
#srcline 107 ;        ErrId   := 0;
 LD   usint 0
 WRX  ErrId
#debug_left usint ErrId
#srcline 108 ;        Result  := 0;
 LD   int 0
 WRX  Result
#debug_left int Result
#srcline 109 ;        authPos := FIND(IN1 := Host, IN2 := '@');
 LDX  Host
#debug string Host
 LEA  _str_fbHttpRequest_0
 SFND 
 WRY  authPos
#debug_left uint authPos
#srcline 110 ;        IF authPos > 0 THEN
 LDY  authPos
#debug uint authPos
 LD   uint 0
 GT
 JMC  fbHttpRequest_L13
#srcline 111 ;          lHost := MID(IN := Host, L := 80, P := authPos+1);
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   80
 DST    ; Level 1
 LDX  Host
#debug string Host
 LD   80
 LDY  authPos
#debug uint authPos
 LD   uint 1
 ADD
 AND  $FFFF
 SUB  1
 SMID 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX lHost
 WRI  
 LEAX lHost
 LD   80
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string lHost
 PDST   ; Level 1
#srcline 112 ;          lNamePass := LEFT(IN := Host, L := authPos-1);
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   80
 DST    ; Level 1
 LDX  Host
#debug string Host
 LDY  authPos
#debug uint authPos
 LD   uint 1
 SUB
 AND  $FFFF
 SLFT 
 PDST   ; Level 1
 LD   0   ; null string
 LEAY lNamePass
 WRI  
 LEAY lNamePass
 LD   80
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string lNamePass
 PDST   ; Level 1
#srcline 113 ;        ELSE
 JMP  fbHttpRequest_L14
fbHttpRequest_L13:
#srcline 114 ;          lHost := Host;
 LD   0   ; null string
 LEAX lHost
 WRI  
 LEAX lHost
 LD   80
 DST    ; Level 1
 LDX  Host
#debug string Host
 SCON 
#debug_left string lHost
 PDST   ; Level 1
#srcline 115 ;        END_IF;
fbHttpRequest_L14:
#srcline 116 ;        (*
#srcline 117 ;        pUint := ADR(RecvData);
#srcline 118 ;        pHelpString := pUint;
#srcline 119 ;        *)
#srcline 120 ;        IF Get THEN
 LDX  Get
#debug bool Get
 JMC  fbHttpRequest_L15
#srcline 121 ;          BodyLen := 0;
 LD   uint 0
 WRY  BodyLen
#debug_left uint BodyLen
#srcline 122 ;          HelpString := 'GET ' + Action;
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LEA  _str_fbHttpRequest_1
 SCON 
 LDX  Action
#debug string Action
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX HelpString
 WRI  
 LEAX HelpString
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string HelpString
 PDST   ; Level 1
#srcline 123 ;        ELSE
 JMP  fbHttpRequest_L16
fbHttpRequest_L15:
#srcline 124 ;          BodyLen := LEN(Data);
 LDX  Data
#debug string Data
 SLEN 
 WRY  BodyLen
#debug_left uint BodyLen
#srcline 125 ;          HelpString := 'POST ' + Action;
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LEA  _str_fbHttpRequest_2
 SCON 
 LDX  Action
#debug string Action
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX HelpString
 WRI  
 LEAX HelpString
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string HelpString
 PDST   ; Level 1
#srcline 126 ;        END_IF;
fbHttpRequest_L16:
#srcline 127 ;        //TODO: Dodelat kontrolu delky vstupnich dat
#srcline 128 ;        pUint := ADR(RecvData);
 LDX  RecvData
#debug pointer RecvData
 LEAY pUint
 WRIL 
#debug_left pointer pUint
#srcline 129 ;        pUsint := pUint  + MemcpyPtr(length := LEN(helpstring), source := ADR(helpstring), dest := pUint);
 LEAY pUint
 LDIL 
#debug pointer pUint
 NXT
 LEAX helpstring
#debug string helpstring
 SLEN 
 WR   __Instance__MemcpyPtr~length
#debug_left udint __Instance__MemcpyPtr~length
 LEAX helpstring
#debug pointer helpstring
 LEA  __Instance__MemcpyPtr~source
 WRIL 
#debug_left udint __Instance__MemcpyPtr~source
 LEAY pUint
 LDIL 
#debug pointer pUint
 LEA  __Instance__MemcpyPtr~dest
 WRIL 
#debug_left udint __Instance__MemcpyPtr~dest
 PRV
 LEA  __Instance__MemcpyPtr
 CAL  MemcpyPtr_L0
 ADD
 LEAY pUsint
 WRIL 
#debug_left pointer pUsint
#srcline 130 ;        //max len 5+255 = 300
#srcline 131 ;        helpstring := ' HTTP/1.0$r$nUser-Agent: Foxtrot/' + USINT_TO_STRING(%S40) + '.' + USINT_TO_STRING(%S41);
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LEA  _str_fbHttpRequest_3
 SCON 
 LD   0   ; null string
 WRY  PSC__st__[0]
 LEAY PSC__st__[0]
 LD   255
 DST    ; Level 2
 LD   %S40
 SCNV $0830;  IEC_USINT _TO_ IEC_STRING
 PDST   ; Level 2
 LEAY PSC__st__[0]

 SCON 
 LEA  _str_fbHttpRequest_4
 SCON 
 LD   0   ; null string
 WRY  PSC__st__[0]
 LEAY PSC__st__[0]
 LD   255
 DST    ; Level 2
 LD   %S41
 SCNV $0830;  IEC_USINT _TO_ IEC_STRING
 PDST   ; Level 2
 LEAY PSC__st__[0]

 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX helpstring
 WRI  
 LEAX helpstring
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string helpstring
 PDST   ; Level 1
#srcline 132 ;        pUsint := pUsint + MemcpyPtr(length := LEN(helpstring), source := ADR(helpstring), dest := pUsint);
 LEAY pUsint
 LDIL 
#debug pointer pUsint
 NXT
 LEAX helpstring
#debug string helpstring
 SLEN 
 WR   __Instance__MemcpyPtr~length
#debug_left udint __Instance__MemcpyPtr~length
 LEAX helpstring
#debug pointer helpstring
 LEA  __Instance__MemcpyPtr~source
 WRIL 
#debug_left udint __Instance__MemcpyPtr~source
 LEAY pUsint
 LDIL 
#debug pointer pUsint
 LEA  __Instance__MemcpyPtr~dest
 WRIL 
#debug_left udint __Instance__MemcpyPtr~dest
 PRV
 LEA  __Instance__MemcpyPtr
 CAL  MemcpyPtr_L0
 ADD
 LEAY pUsint
 WRIL 
#debug_left pointer pUsint
#srcline 133 ;        //max len 300+33+1+1+1 = 336
#srcline 134 ;        helpstring := ' (Tecomat; N; en-US)$r$nCache-Control: max-age=0$r$nAccept: */*$r$nHost: ';
 LD   0   ; null string
 LEAX helpstring
 WRI  
 LEAX helpstring
 LD   255
 DST    ; Level 1
 LEA  _str_fbHttpRequest_5
 SCON 
#debug_left string helpstring
 PDST   ; Level 1
#srcline 135 ;        pUsint := pUsint + MemcpyPtr(length := LEN(helpstring), source := ADR(helpstring), dest := pUsint);
 LEAY pUsint
 LDIL 
#debug pointer pUsint
 NXT
 LEAX helpstring
#debug string helpstring
 SLEN 
 WR   __Instance__MemcpyPtr~length
#debug_left udint __Instance__MemcpyPtr~length
 LEAX helpstring
#debug pointer helpstring
 LEA  __Instance__MemcpyPtr~source
 WRIL 
#debug_left udint __Instance__MemcpyPtr~source
 LEAY pUsint
 LDIL 
#debug pointer pUsint
 LEA  __Instance__MemcpyPtr~dest
 WRIL 
#debug_left udint __Instance__MemcpyPtr~dest
 PRV
 LEA  __Instance__MemcpyPtr
 CAL  MemcpyPtr_L0
 ADD
 LEAY pUsint
 WRIL 
#debug_left pointer pUsint
#srcline 136 ;        //max len 336+140 = 476
#srcline 137 ;        Err := true;
 LD   bool -1       ; true
 WRX  Err
#debug_left bool Err
#srcline 138 ;        REPEAT
fbHttpRequest_L17:
 DBG
#srcline 139 ;          l := LEN(lHost);
 LEAX lHost
#debug string lHost
 SLEN 
 WRY  l
#debug_left udint l
#srcline 140 ;          IF PTR_TO_UDINT(pUsint) - PTR_TO_UDINT(pUint) + l > 512 THEN EXIT; END_IF;
 LEAY pUsint
 LDIL 
#debug pointer pUsint
 LEAY pUint
 LDIL 
#debug pointer pUint
 SUB
 LDY  l
#debug udint l
 ADD
 LD   udint 512
 GT
 JMC  fbHttpRequest_L19
 JMP  fbHttpRequest_L18
fbHttpRequest_L19:
#srcline 141 ;          pUsint := pUsint + MemcpyPtr(length := l, source := ADR(lHost), dest := pUsint);
 LEAY pUsint
 LDIL 
#debug pointer pUsint
 NXT
 LDY  l
#debug udint l
 WR   __Instance__MemcpyPtr~length
#debug_left udint __Instance__MemcpyPtr~length
 LEAX lHost
#debug pointer lHost
 LEA  __Instance__MemcpyPtr~source
 WRIL 
#debug_left udint __Instance__MemcpyPtr~source
 LEAY pUsint
 LDIL 
#debug pointer pUsint
 LEA  __Instance__MemcpyPtr~dest
 WRIL 
#debug_left udint __Instance__MemcpyPtr~dest
 PRV
 LEA  __Instance__MemcpyPtr
 CAL  MemcpyPtr_L0
 ADD
 LEAY pUsint
 WRIL 
#debug_left pointer pUsint
#srcline 142 ;          
#srcline 143 ;          IF authPos > 0 THEN
 LDY  authPos
#debug uint authPos
 LD   uint 0
 GT
 JMC  fbHttpRequest_L21
#srcline 144 ;            //Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==
#srcline 145 ;            helpstring := '$r$nAuthorization: Basic ' + Base64_encode_string(lNamePass);
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LEA  _str_fbHttpRequest_6
 SCON 
 NXT
 LD   0   ; null string
 LEA  __Instance__Base64_encode_string~data
 WRI 
 LEA  __Instance__Base64_encode_string~data
 LD   60
 DST    ; Level 2
 LEAY lNamePass
#debug string lNamePass
 SCON 
#debug_left string __Instance__Base64_encode_string~data
 PDST   ; Level 2
 PRV
 LEA  __Instance__Base64_encode_string
 CAL  Base64_encode_string_L0

 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX helpstring
 WRI  
 LEAX helpstring
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string helpstring
 PDST   ; Level 1
#srcline 146 ;            l := LEN(helpstring);
 LEAX helpstring
#debug string helpstring
 SLEN 
 WRY  l
#debug_left udint l
#srcline 147 ;            IF PTR_TO_UDINT(pUsint) - PTR_TO_UDINT(pUint) + l > 512 THEN EXIT; END_IF;
 LEAY pUsint
 LDIL 
#debug pointer pUsint
 LEAY pUint
 LDIL 
#debug pointer pUint
 SUB
 LDY  l
#debug udint l
 ADD
 LD   udint 512
 GT
 JMC  fbHttpRequest_L23
 JMP  fbHttpRequest_L18
fbHttpRequest_L23:
#srcline 148 ;            pUsint := pUsint + MemcpyPtr(length := l, source := ADR(helpstring), dest := pUsint);
 LEAY pUsint
 LDIL 
#debug pointer pUsint
 NXT
 LDY  l
#debug udint l
 WR   __Instance__MemcpyPtr~length
#debug_left udint __Instance__MemcpyPtr~length
 LEAX helpstring
#debug pointer helpstring
 LEA  __Instance__MemcpyPtr~source
 WRIL 
#debug_left udint __Instance__MemcpyPtr~source
 LEAY pUsint
 LDIL 
#debug pointer pUsint
 LEA  __Instance__MemcpyPtr~dest
 WRIL 
#debug_left udint __Instance__MemcpyPtr~dest
 PRV
 LEA  __Instance__MemcpyPtr
 CAL  MemcpyPtr_L0
 ADD
 LEAY pUsint
 WRIL 
#debug_left pointer pUsint
#srcline 149 ;          END_IF;
fbHttpRequest_L21:
#srcline 150 ;          
#srcline 151 ;          //max len 476+80 = 556!!!
#srcline 152 ;          IF BodyLen > 0 THEN
 LDY  BodyLen
#debug uint BodyLen
 LD   uint 0
 GT
 JMC  fbHttpRequest_L25
#srcline 153 ;            helpstring := '$r$nContent-Type: application/x-www-form-urlencoded$r$nContent-Length: ' + UINT_TO_STRING(BodyLen) + '$r$nConnection: Close$r$n$r$n';
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LEA  _str_fbHttpRequest_7
 SCON 
 LD   0   ; null string
 WRY  PSC__st__[0]
 LEAY PSC__st__[0]
 LD   255
 DST    ; Level 2
 LDY  BodyLen
#debug uint BodyLen
 SCNV $0A30;  IEC_UINT _TO_ IEC_STRING
 PDST   ; Level 2
 LEAY PSC__st__[0]

 SCON 
 LEA  _str_fbHttpRequest_8
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX helpstring
 WRI  
 LEAX helpstring
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string helpstring
 PDST   ; Level 1
#srcline 154 ;          ELSE
 JMP  fbHttpRequest_L26
fbHttpRequest_L25:
#srcline 155 ;            helpstring := '$r$nConnection: Close$r$n$r$n';
 LD   0   ; null string
 LEAX helpstring
 WRI  
 LEAX helpstring
 LD   255
 DST    ; Level 1
 LEA  _str_fbHttpRequest_9
 SCON 
#debug_left string helpstring
 PDST   ; Level 1
#srcline 156 ;          END_IF;
fbHttpRequest_L26:
#srcline 157 ;          l := LEN(helpstring);
 LEAX helpstring
#debug string helpstring
 SLEN 
 WRY  l
#debug_left udint l
#srcline 158 ;          IF PTR_TO_UDINT(pUsint) - PTR_TO_UDINT(pUint) + l > 512 THEN EXIT; END_IF;
 LEAY pUsint
 LDIL 
#debug pointer pUsint
 LEAY pUint
 LDIL 
#debug pointer pUint
 SUB
 LDY  l
#debug udint l
 ADD
 LD   udint 512
 GT
 JMC  fbHttpRequest_L27
 JMP  fbHttpRequest_L18
fbHttpRequest_L27:
#srcline 159 ;          pUsint := pUsint + MemcpyPtr(length := l, source := ADR(helpstring), dest := pUsint);
 LEAY pUsint
 LDIL 
#debug pointer pUsint
 NXT
 LDY  l
#debug udint l
 WR   __Instance__MemcpyPtr~length
#debug_left udint __Instance__MemcpyPtr~length
 LEAX helpstring
#debug pointer helpstring
 LEA  __Instance__MemcpyPtr~source
 WRIL 
#debug_left udint __Instance__MemcpyPtr~source
 LEAY pUsint
 LDIL 
#debug pointer pUsint
 LEA  __Instance__MemcpyPtr~dest
 WRIL 
#debug_left udint __Instance__MemcpyPtr~dest
 PRV
 LEA  __Instance__MemcpyPtr
 CAL  MemcpyPtr_L0
 ADD
 LEAY pUsint
 WRIL 
#debug_left pointer pUsint
#srcline 161 ;          //max len 556+44=600!!!
#srcline 162 ;          IF POST THEN //copy data to post
 LDX  POST
#debug bool POST
 JMC  fbHttpRequest_L29
#srcline 163 ;            l := LEN(data);
 LDX  data
#debug string data
 SLEN 
 WRY  l
#debug_left udint l
#srcline 164 ;            IF PTR_TO_UDINT(pUsint) - PTR_TO_UDINT(pUint) + l > 512 THEN EXIT; END_IF;
 LEAY pUsint
 LDIL 
#debug pointer pUsint
 LEAY pUint
 LDIL 
#debug pointer pUint
 SUB
 LDY  l
#debug udint l
 ADD
 LD   udint 512
 GT
 JMC  fbHttpRequest_L31
 JMP  fbHttpRequest_L18
fbHttpRequest_L31:
#srcline 165 ;            pUsint := pUsint + MemcpyPtr(length := LEN(data), source := ADR(data), dest := pUsint);
 LEAY pUsint
 LDIL 
#debug pointer pUsint
 NXT
 LDX  data
#debug string data
 SLEN 
 WR   __Instance__MemcpyPtr~length
#debug_left udint __Instance__MemcpyPtr~length
 LDX  data
#debug pointer data
 LEA  __Instance__MemcpyPtr~source
 WRIL 
#debug_left udint __Instance__MemcpyPtr~source
 LEAY pUsint
 LDIL 
#debug pointer pUsint
 LEA  __Instance__MemcpyPtr~dest
 WRIL 
#debug_left udint __Instance__MemcpyPtr~dest
 PRV
 LEA  __Instance__MemcpyPtr
 CAL  MemcpyPtr_L0
 ADD
 LEAY pUsint
 WRIL 
#debug_left pointer pUsint
#srcline 166 ;            //max len 600+80=680!!!
#srcline 167 ;          END_IF;
fbHttpRequest_L29:
#srcline 168 ;          Err := false;
 LD   bool 0       ; false
 WRX  Err
#debug_left bool Err
#srcline 169 ;        UNTIL true END_REPEAT;
 LD   bool -1       ; true
 JMC  fbHttpRequest_L17
fbHttpRequest_L18:
 NOP  -1
#srcline 170 ;        IF Err THEN
 LDX  Err
#debug bool Err
 JMC  fbHttpRequest_L33
#srcline 171 ;          ErrId := 3; //prilis mnoho dat k odeslani
 LD   usint 3
 WRX  ErrId
#debug_left usint ErrId
#srcline 172 ;        ELSE
 JMP  fbHttpRequest_L34
fbHttpRequest_L33:
#srcline 173 ;          SendTo.lenTx := UDINT_TO_UINT(PTR_TO_UDINT(pUsint) - PTR_TO_UDINT(pUint));
 LEAY pUsint
 LDIL 
#debug pointer pUsint
 LEAY pUint
 LDIL 
#debug pointer pUint
 SUB
 AND  $FFFF
 WRX  SendTo~lenTx
#debug_left uint SendTo.lenTx
#srcline 174 ;          State := hs_HttpSetIP;
 LD   udint 1  ; THttpState#hs_HttpSetIP
 WRX  State
#debug_left usint State
#srcline 175 ;          Busy  := true; //Busy is set in the same cycle when we left idle state!!!
 LD   bool -1       ; true
 WRX  Busy
#debug_left bool Busy
#srcline 176 ;        END_IF;
fbHttpRequest_L34:
#srcline 177 ;      END_IF;
fbHttpRequest_L11:
 JMP  fbHttpRequest_L9
fbHttpRequest_L10:
 LD   1
 LDY  P0__st__
 EQ  
 JMC  fbHttpRequest_L35
#srcline 178 ;    hs_HttpSetIP:
#srcline 179 ;      IF IPadr = Any_IP THEN
 LEAX IPadr
 LEA  Any_IP
 LD   4   ; SizeOf()
 BCMP 
 EQ   0
 JMC  fbHttpRequest_L36
#srcline 180 ;          Err   := true;
 LD   bool -1       ; true
 WRX  Err
#debug_left bool Err
#srcline 181 ;          ErrId := 254;
 LD   usint 254
 WRX  ErrId
#debug_left usint ErrId
#srcline 182 ;          State := hs_HttpIdle;
 LD   udint 0  ; THttpState#hs_HttpIdle
 WRX  State
#debug_left usint State
#srcline 183 ;      ELSE
 JMP  fbHttpRequest_L37
fbHttpRequest_L36:
#srcline 184 ;        rea.remoteIP   := IPadr;
 LEAX IPadr
#debug pointer IPadr
 SRC  %IB0
 LEAY rea~remoteIP
#debug_left pointer rea.remoteIP
 LD   4   ;SizeOf() 
 MOV  %IB0
#srcline 185 ;        rea.remotePort := port;
 LDX  port
#debug uint port
 WRY  rea~remotePort
#debug_left uint rea.remotePort
#srcline 186 ;/////////nem 21.5.2019
#srcline 187 ;        uniDesc := GetChanDesc( chanCode := chanCode);
 NXT
 LDX  chanCode
#debug uint chanCode
 WR   __Instance__GetChanDesc~chanCode
#debug_left uint __Instance__GetChanDesc~chanCode
 PRV
 LEA  __Instance__GetChanDesc
 CAL  GetChanDesc_L0
 LEAY uniDesc
#debug_left pointer uniDesc
 LD   26   ;SizeOf() 
 MOV  %IB0
#srcline 188 ;        IF uniDesc.res = USINT_TO_BYTE( UNI_SSL_CLIENT) THEN
 LDY  uniDesc~res
#debug byte uniDesc.res
 LD   usint 35
 AND  $FF
 EQ
 JMC  fbHttpRequest_L38
#srcline 189 ;          SetUniChanHostName( chanHandle := chanCode, hostName := Host);  // nastavit host name pro SSL socket
 NXT
 LDX  chanCode
#debug uint chanCode
 WR   __Instance__SetUniChanHostName~chanHandle
#debug_left uint __Instance__SetUniChanHostName~chanHandle
 LD   0   ; null string
 LEA  __Instance__SetUniChanHostName~hostName
 WRI 
 LEA  __Instance__SetUniChanHostName~hostName
 LD   80
 DST    ; Level 1
 LDX  Host
#debug string Host
 SCON 
#debug_left string __Instance__SetUniChanHostName~hostName
 PDST   ; Level 1
 PRV
 LEA  __Instance__SetUniChanHostName
 CAL  SetUniChanHostName_L0
#srcline 190 ;        END_IF;
fbHttpRequest_L38:
#srcline 191 ;/////////
#srcline 192 ;        IF SetRemoteIPaddress(rq := 1, chanCode := chanCode, ethAdr := rea) THEN
 NXT
 LD   1
 WR   __Instance__SetRemoteIPaddress~rq
#debug_left bool __Instance__SetRemoteIPaddress~rq
 LDX  chanCode
#debug uint chanCode
 WR   __Instance__SetRemoteIPaddress~chanCode
#debug_left uint __Instance__SetRemoteIPaddress~chanCode
 LEAY rea
 WR   __Instance__SetRemoteIPaddress~ethAdr
#debug_left pointer __Instance__SetRemoteIPaddress.ethAdr
 PRV
 LEA  __Instance__SetRemoteIPaddress
 CAL  SetRemoteIPaddress_L0
 JMC  fbHttpRequest_L40
#srcline 193 ;          State := hs_HttpConnect;
 LD   udint 2  ; THttpState#hs_HttpConnect
 WRX  State
#debug_left usint State
#srcline 194 ;        END_IF;
fbHttpRequest_L40:
#srcline 195 ;      END_IF;
fbHttpRequest_L37:
 JMP  fbHttpRequest_L9
fbHttpRequest_L35:
 LD   2
 LDY  P0__st__
 EQ  
 JMC  fbHttpRequest_L42
#srcline 196 ;    hs_HttpConnect:
#srcline 197 ;      r := EstabTCPconnection(chanCode := chanCode);
 NXT
 LDX  chanCode
#debug uint chanCode
 WR   __Instance__EstabTCPconnection~chanCode
#debug_left uint __Instance__EstabTCPconnection~chanCode
 PRV
 LEA  __Instance__EstabTCPconnection
 CAL  EstabTCPconnection_L0
 WRY  r
#debug_left usint r
#srcline 198 ;      IF IsEstabTCPconnection(chanCode := chanCode) THEN
 NXT
 LDX  chanCode
#debug uint chanCode
 WR   __Instance__IsEstabTCPconnection~chanCode
#debug_left uint __Instance__IsEstabTCPconnection~chanCode
 PRV
 LEA  __Instance__IsEstabTCPconnection
 CAL  IsEstabTCPconnection_L0
 JMC  fbHttpRequest_L43
#srcline 199 ;        State := hs_HttpSend;
 LD   udint 3  ; THttpState#hs_HttpSend
 WRX  State
#debug_left usint State
#srcline 200 ;      END_IF;
fbHttpRequest_L43:
 JMP  fbHttpRequest_L9
fbHttpRequest_L42:
 LD   3
 LDY  P0__st__
 EQ  
 JMC  fbHttpRequest_L45
#srcline 201 ;    hs_HttpSend   :
#srcline 202 ;      SendTo(rq := 1, chanCode:= chanCode, data := void(RecvData));
 LD   1
 WRX  SendTo~rq
#debug_left bool SendTo~rq
 LDX  chanCode
#debug uint chanCode
 WRX  SendTo~chanCode
#debug_left uint SendTo~chanCode
 LDX  RecvData
 WRX  SendTo~data
#debug_left pointer SendTo.data
 LEAX SendTo
 CAL  fbSendTo_L0
#srcline 203 ;      ResRecv    := false;
 LD   bool 0       ; false
 WRX  ResRecv
#debug_left bool ResRecv
#srcline 204 ;      LenRecv    := false;
 LD   bool 0       ; false
 WRX  LenRecv
#debug_left bool LenRecv
#srcline 205 ;      HeaderRecv := false;
 LD   bool 0       ; false
 WRX  HeaderRecv
#debug_left bool HeaderRecv
#srcline 206 ;      ContLen    := -1;
 LD   dint -1
 WRX  ContLen
#debug_left dint ContLen
#srcline 207 ;      State      := hs_HttpReceivingData;
 LD   udint 4  ; THttpState#hs_HttpReceivingData
 WRX  State
#debug_left usint State
 JMP  fbHttpRequest_L9
fbHttpRequest_L45:
 LD   4
 LDY  P0__st__
 EQ  
 JMC  fbHttpRequest_L46
#srcline 208 ;    hs_HttpReceivingData  :
#srcline 209 ;      RecvFrom(rq := 1, chanCode := chanCode, lenRx := 512, data := void(RecvData));
 LD   1
 WRX  RecvFrom~rq
#debug_left bool RecvFrom~rq
 LDX  chanCode
#debug uint chanCode
 WRX  RecvFrom~chanCode
#debug_left uint RecvFrom~chanCode
 LD   uint 512
 WRX  RecvFrom~lenRx
#debug_left uint RecvFrom~lenRx
 LDX  RecvData
 WRX  RecvFrom~data
#debug_left pointer RecvFrom.data
 LEAX RecvFrom
 CAL  fbRecvFrom_L0
#srcline 210 ;      IF RecvFrom.mesRec THEN                                                   //byla prijata data
 LDX  RecvFrom~mesRec
#debug bool RecvFrom.mesRec
 JMC  fbHttpRequest_L47
#srcline 211 ;        IF HeaderRecv THEN                                                      //uz byla prijata hlavicka
 LDX  HeaderRecv
#debug bool HeaderRecv
 JMC  fbHttpRequest_L49
#srcline 212 ;          DataLen := RecvFrom.lenData;                                          //delka dat je rovna delce prijateho paketu
 LDX  RecvFrom~lenData
#debug uint RecvFrom.lenData
 WRX  DataLen
#debug_left uint DataLen
#srcline 213 ;          ContLen := ContLen - UINT_TO_DINT(DataLen);                           //snizit contlen o prijatou delku
 LDX  ContLen
#debug dint ContLen
 LDX  DataLen
#debug uint DataLen
 SUB
 WRX  ContLen
#debug_left dint ContLen
#srcline 214 ;          pUsint  := ADR(RecvData);                                             //nastavit pointer na zacatek dat
 LDX  RecvData
#debug pointer RecvData
 LEAY pUsint
 WRIL 
#debug_left pointer pUsint
#srcline 215 ;        ELSE                                                                    //jeste nebyla prijata hlavicka
 JMP  fbHttpRequest_L50
fbHttpRequest_L49:
#srcline 216 ;          i := TO_UINT(MemcpyEx(length := MIN(TO_UDINT(RecvFrom.lenData), 255-TO_UDINT(sOff)),
 NXT
 LDX  RecvFrom~lenData
#debug uint RecvFrom.lenData
 LD   udint 255
 LDX  sOff
#debug uint sOff
 SUB
 MIN
 WR   __Instance__MemcpyEx~length
#debug_left udint __Instance__MemcpyEx~length
#srcline 217 ;               offDest := TO_UDINT(sOff),
 LDX  sOff
#debug uint sOff
 WR   __Instance__MemcpyEx~offDest
#debug_left udint __Instance__MemcpyEx~offDest
#srcline 218 ;               source := RecvData[0], dest := void(helpstring)));
 LDX  RecvData
 WR   __Instance__MemcpyEx~source
#debug_left pointer __Instance__MemcpyEx.source
 LEAX helpstring
 WR   __Instance__MemcpyEx~dest
#debug_left pointer __Instance__MemcpyEx.dest
 LD   0
 WR   __Instance__MemcpyEx~offSource
 PRV
 LEA  __Instance__MemcpyEx
 CAL  MemcpyEx_L0
 WRY  i
#debug_left uint i
#srcline 220 ;          sOff := sOff + i;
 LDX  sOff
#debug uint sOff
 LDY  i
#debug uint i
 ADD
 AND  $FFFF
 WRX  sOff
#debug_left uint sOff
#srcline 221 ;          rLen := RecvFrom.lenData - i;
 LDX  RecvFrom~lenData
#debug uint RecvFrom.lenData
 LDY  i
#debug uint i
 SUB
 AND  $FFFF
 WRX  rLen
#debug_left uint rLen
#srcline 223 ;          pUsint := ADR(helpstring) + TO_UDINT(sOff);
 LEAX helpstring
#debug pointer helpstring
 LDX  sOff
#debug uint sOff
 ADD
 LEAY pUsint
 WRIL 
#debug_left pointer pUsint
#srcline 224 ;          pUsint^ := 0;
 LD   usint 0
 LEAY pUsint
 LDIL    ; dereference 
 WRI 
#debug_left usint pUsint^
#srcline 226 ;          WHILE true DO
fbHttpRequest_L51:
 LD   bool -1       ; true
 JMC  fbHttpRequest_L52
 DBG 
#srcline 227 ;            i :=  FIND(IN1 := helpstring, IN2 := '$r$n');
 LEAX helpstring
#debug string helpstring
 LEA  _str_fbHttpRequest_10
 SFND 
 WRY  i
#debug_left uint i
#srcline 228 ;            IF i = 1 THEN //konec
 LDY  i
#debug uint i
 LD   uint 1
 EQ
 JMC  fbHttpRequest_L53
#srcline 229 ;              rLen := rLen - 2 + sOff - i + 1;
 LDX  rLen
#debug uint rLen
 LD   uint 2
 SUB
 AND  $FFFF
 LDX  sOff
#debug uint sOff
 ADD
 AND  $FFFF
 LDY  i
#debug uint i
 SUB
 AND  $FFFF
 LD   uint 1
 ADD
 AND  $FFFF
 WRX  rLen
#debug_left uint rLen
#srcline 230 ;              HeaderRecv := true;
 LD   bool -1       ; true
 WRX  HeaderRecv
#debug_left bool HeaderRecv
#srcline 231 ;              EXIT;
 JMP  fbHttpRequest_L52
#srcline 232 ;            ELSIF i > 1 THEN  //je tam enter
 JMP  fbHttpRequest_L54
fbHttpRequest_L53:
 LDY  i
#debug uint i
 LD   uint 1
 GT
 JMC  fbHttpRequest_L55
#srcline 233 ;              IF NOT ResRecv THEN
 LDX  ResRecv
#debug bool ResRecv
 NEG
 JMC  fbHttpRequest_L56
#srcline 234 ;                IF FIND(IN1 := helpstring, IN2 := 'HTTP') = 1 THEN      //vyhledani zda je to HTTP hlavicka
 LEAX helpstring
#debug string helpstring
 LEA  _str_fbHttpRequest_11
 SFND 
 LD   int 1
 EQ
 JMC  fbHttpRequest_L58
#srcline 235 ;                  ResRecv := true;                                      //prijat zacatek hlavicky
 LD   bool -1       ; true
 WRX  ResRecv
#debug_left bool ResRecv
#srcline 236 ;                  pHelpString := ADR(helpstring) + 9;                   //posunout pointer
 LEAX helpstring
#debug pointer helpstring
 LD   udint 9
 ADD
 LEAY pHelpString
 WRIL 
#debug_left pointer pHelpString
#srcline 237 ;                  Result := STRING_TO_INT(pHelpString^);                //rozkodovat navratovy kod
 LEAY pHelpString
 LDIL    ; dereference 
#debug string pHelpString^
 SCNV $300B;  IEC_STRING _TO_ IEC_INT
 WRX  Result
#debug_left int Result
#srcline 238 ;    //            Debug1       := pHelpString^;
#srcline 239 ;                END_IF;
fbHttpRequest_L58:
#srcline 240 ;              END_IF;
fbHttpRequest_L56:
#srcline 241 ;              IF NOT LenRecv THEN                                                   //hledat delku jen kdyz se jeste nenasla 121108
 LDX  LenRecv
#debug bool LenRecv
 NEG
 JMC  fbHttpRequest_L60
#srcline 242 ;                                                     //012345678901234
#srcline 243 ;                j := FIND(IN1 := helpstring, IN2 := 'Content-Length:');           //hledat delku tela
 LEAX helpstring
#debug string helpstring
 LEA  _str_fbHttpRequest_12
 SFND 
 WRY  j
#debug_left uint j
#srcline 244 ;                IF j > 0 AND j < i THEN                                            //nasla se delka
 LDY  j
#debug uint j
 LD   uint 0
 GT
 LDY  j
#debug uint j
 LDY  i
#debug uint i
 LT
 AND
 JMC  fbHttpRequest_L62
#srcline 245 ;                  LenRecv := true;                                                //nastavit priznak ze byla nalezena
 LD   bool -1       ; true
 WRX  LenRecv
#debug_left bool LenRecv
#srcline 246 ;                  pHelpString := ADR(helpstring) + UINT_TO_UDINT(j+15);           //posunout pointer
 LEAX helpstring
#debug pointer helpstring
 LDY  j
#debug uint j
 LD   uint 15
 ADD
 AND  $FFFF
 ADD
 LEAY pHelpString
 WRIL 
#debug_left pointer pHelpString
#srcline 247 ;                  ContLen     := STRING_TO_DINT(pHelpString^);                    //zapsat delku
 LEAY pHelpString
 LDIL    ; dereference 
#debug string pHelpString^
 SCNV $300D;  IEC_STRING _TO_ IEC_DINT
 WRX  ContLen
#debug_left dint ContLen
#srcline 248 ;      //            Debug2       := pHelpString^;
#srcline 249 ;                END_IF;
fbHttpRequest_L62:
#srcline 250 ;              END_IF;
fbHttpRequest_L60:
#srcline 251 ;              IF i = FIND(IN1 := helpstring, IN2 := '$r$n$r$n') THEN //konec
 LDY  i
#debug uint i
 LEAX helpstring
#debug string helpstring
 LEA  _str_fbHttpRequest_13
 SFND 
 EQ
 JMC  fbHttpRequest_L64
#srcline 252 ;                rLen := rLen - 4 + sOff - i + 1;
 LDX  rLen
#debug uint rLen
 LD   uint 4
 SUB
 AND  $FFFF
 LDX  sOff
#debug uint sOff
 ADD
 AND  $FFFF
 LDY  i
#debug uint i
 SUB
 AND  $FFFF
 LD   uint 1
 ADD
 AND  $FFFF
 WRX  rLen
#debug_left uint rLen
#srcline 253 ;                HeaderRecv := true;
 LD   bool -1       ; true
 WRX  HeaderRecv
#debug_left bool HeaderRecv
#srcline 254 ;                EXIT;
 JMP  fbHttpRequest_L52
#srcline 255 ;              END_IF;
fbHttpRequest_L64:
#srcline 256 ;              (** )
#srcline 257 ;              WHILE sOff < i DO
#srcline 258 ;                //DEBUG!!!!!
#srcline 259 ;              END_WHILE;
#srcline 260 ;              (**)
#srcline 261 ;              MemcpyEx(length := TO_UDINT(sOff - i), offSource := TO_UDINT(i) + 1,
 NXT
 LDX  sOff
#debug uint sOff
 LDY  i
#debug uint i
 SUB
 WR   __Instance__MemcpyEx~length
#debug_left udint __Instance__MemcpyEx~length
 LDY  i
#debug uint i
 LD   udint 1
 ADD
 WR   __Instance__MemcpyEx~offSource
#debug_left udint __Instance__MemcpyEx~offSource
#srcline 262 ;                       source := void(helpstring), dest := void(helpstring));
 LEAX helpstring
 WR   __Instance__MemcpyEx~source
#debug_left pointer __Instance__MemcpyEx.source
 LEAX helpstring
 WR   __Instance__MemcpyEx~dest
#debug_left pointer __Instance__MemcpyEx.dest
 LD   0
 WR   __Instance__MemcpyEx~offDest
 PRV
 LEA  __Instance__MemcpyEx
 CAL  MemcpyEx_L0
#srcline 263 ;              sOff := sOff - i - 1;
 LDX  sOff
#debug uint sOff
 LDY  i
#debug uint i
 SUB
 AND  $FFFF
 LD   uint 1
 SUB
 AND  $FFFF
 WRX  sOff
#debug_left uint sOff
#srcline 264 ;            ELSE
 JMP  fbHttpRequest_L54
fbHttpRequest_L55:
#srcline 265 ;              IF sOff = 255 THEN //je to bez enteru a plne - zahodit
 LDX  sOff
#debug uint sOff
 LD   uint 255
 EQ
 JMC  fbHttpRequest_L66
#srcline 266 ;                MemcpyEx(length := 1, offSource := 254,
 NXT
 LD   udint 1
 WR   __Instance__MemcpyEx~length
#debug_left udint __Instance__MemcpyEx~length
 LD   udint 254
 WR   __Instance__MemcpyEx~offSource
#debug_left udint __Instance__MemcpyEx~offSource
#srcline 267 ;                         source := void(helpstring), dest := void(helpstring));
 LEAX helpstring
 WR   __Instance__MemcpyEx~source
#debug_left pointer __Instance__MemcpyEx.source
 LEAX helpstring
 WR   __Instance__MemcpyEx~dest
#debug_left pointer __Instance__MemcpyEx.dest
 LD   0
 WR   __Instance__MemcpyEx~offDest
 PRV
 LEA  __Instance__MemcpyEx
 CAL  MemcpyEx_L0
#srcline 268 ;                sOff := 1;
 LD   uint 1
 WRX  sOff
#debug_left uint sOff
#srcline 269 ;              END_IF;
fbHttpRequest_L66:
#srcline 270 ;            END_IF;
fbHttpRequest_L54:
#srcline 272 ;            IF rLen > 0 THEN
 LDX  rLen
#debug uint rLen
 LD   uint 0
 GT
 JMC  fbHttpRequest_L68
#srcline 273 ;              i := TO_UINT(MemcpyEx(length := MIN(TO_UDINT(rLen), 255-TO_UDINT(sOff)),
 NXT
 LDX  rLen
#debug uint rLen
 LD   udint 255
 LDX  sOff
#debug uint sOff
 SUB
 MIN
 WR   __Instance__MemcpyEx~length
#debug_left udint __Instance__MemcpyEx~length
#srcline 274 ;                   offDest := TO_UDINT(sOff),
 LDX  sOff
#debug uint sOff
 WR   __Instance__MemcpyEx~offDest
#debug_left udint __Instance__MemcpyEx~offDest
#srcline 275 ;                   offSource := TO_UDINT(RecvFrom.lenData) - TO_UDINT(rLen),
 LDX  RecvFrom~lenData
#debug uint RecvFrom.lenData
 LDX  rLen
#debug uint rLen
 SUB
 WR   __Instance__MemcpyEx~offSource
#debug_left udint __Instance__MemcpyEx~offSource
#srcline 276 ;                   source := RecvData[0], dest := void(helpstring)));
 LDX  RecvData
 WR   __Instance__MemcpyEx~source
#debug_left pointer __Instance__MemcpyEx.source
 LEAX helpstring
 WR   __Instance__MemcpyEx~dest
#debug_left pointer __Instance__MemcpyEx.dest
 PRV
 LEA  __Instance__MemcpyEx
 CAL  MemcpyEx_L0
 WRY  i
#debug_left uint i
#srcline 277 ;              sOff := sOff + i;
 LDX  sOff
#debug uint sOff
 LDY  i
#debug uint i
 ADD
 AND  $FFFF
 WRX  sOff
#debug_left uint sOff
#srcline 278 ;              rLen := rLen - i;
 LDX  rLen
#debug uint rLen
 LDY  i
#debug uint i
 SUB
 AND  $FFFF
 WRX  rLen
#debug_left uint rLen
#srcline 279 ;              pUsint := ADR(helpstring) + TO_UDINT(sOff);
 LEAX helpstring
#debug pointer helpstring
 LDX  sOff
#debug uint sOff
 ADD
 LEAY pUsint
 WRIL 
#debug_left pointer pUsint
#srcline 280 ;              pUsint^ := 0;
 LD   usint 0
 LEAY pUsint
 LDIL    ; dereference 
 WRI 
#debug_left usint pUsint^
#srcline 281 ;            ELSIF i = 0 THEN
 JMP  fbHttpRequest_L69
fbHttpRequest_L68:
 LDY  i
#debug uint i
 LD   uint 0
 EQ
 JMC  fbHttpRequest_L70
#srcline 282 ;              EXIT;
 JMP  fbHttpRequest_L52
#srcline 283 ;            END_IF;
 JMP  fbHttpRequest_L69
fbHttpRequest_L70:
fbHttpRequest_L69:
#srcline 284 ;          END_WHILE;
 JMP  fbHttpRequest_L51
fbHttpRequest_L52:
 NOP  -1
#srcline 286 ;          DataLen := 0;
 LD   uint 0
 WRX  DataLen
#debug_left uint DataLen
#srcline 287 ;          IF HeaderRecv THEN
 LDX  HeaderRecv
#debug bool HeaderRecv
 JMC  fbHttpRequest_L71
#srcline 288 ;            IF rLen > 0 THEN
 LDX  rLen
#debug uint rLen
 LD   uint 0
 GT
 JMC  fbHttpRequest_L73
#srcline 289 ;              DataLen := rLen;
 LDX  rLen
#debug uint rLen
 WRX  DataLen
#debug_left uint DataLen
#srcline 290 ;              rLen := RecvFrom.lenData - rLen;
 LDX  RecvFrom~lenData
#debug uint RecvFrom.lenData
 LDX  rLen
#debug uint rLen
 SUB
 AND  $FFFF
 WRX  rLen
#debug_left uint rLen
#srcline 291 ;              Memcpy(length := DataLen, source := RecvData[rLen], dest := RecvData[0]);
 NXT
 LDX  DataLen
#debug uint DataLen
 WR   __Instance__Memcpy~length
#debug_left uint __Instance__Memcpy~length
 LDX  RecvData
 LDX  rLen
#debug uint rLen
 RCHK 511   ; Range Check
 ADD     ; + offset 
 WR   __Instance__Memcpy~source
#debug_left pointer __Instance__Memcpy.source
 LDX  RecvData
 WR   __Instance__Memcpy~dest
#debug_left pointer __Instance__Memcpy.dest
 PRV
 LEA  __Instance__Memcpy
 CAL  Memcpy_L0
#srcline 292 ;            END_IF;
fbHttpRequest_L73:
#srcline 293 ;            WholeLen := ContLen;                                                //zapamatovat si kolik jeste budu prijimat
 LDX  ContLen
#debug dint ContLen
 WRX  WholeLen
#debug_left dint WholeLen
#srcline 294 ;            ContLen  := ContLen - TO_DINT(DataLen);                         //odecist delku od celkove delky k prijmuti
 LDX  ContLen
#debug dint ContLen
 LDX  DataLen
#debug uint DataLen
 SUB
 WRX  ContLen
#debug_left dint ContLen
#srcline 295 ;          END_IF;
fbHttpRequest_L71:
#srcline 296 ;        END_IF;
fbHttpRequest_L50:
#srcline 297 ;        DataReady := DataLen > 0;                                               //vydat priznak ze byla prijata data
 LDX  DataLen
#debug uint DataLen
 LD   uint 0
 GT
 WRX  DataReady
#debug_left bool DataReady
#srcline 298 ;      ELSE                                                                      //nic neprislo
 JMP  fbHttpRequest_L48
fbHttpRequest_L47:
#srcline 299 ;        DataLen := 0;
 LD   uint 0
 WRX  DataLen
#debug_left uint DataLen
#srcline 300 ;      END_IF;
fbHttpRequest_L48:
#srcline 301 ;      
#srcline 302 ;      //bDebug := NOT IsEstabTCPconnection(chanCode := chanCode) & ContLen > 0 & NOT DataReady;
#srcline 304 ;      IF NOT IsEstabTCPconnection(chanCode := chanCode) & NOT DataReady THEN //spojeni se zavrelo a nejsou zadna data
 NXT
 LDX  chanCode
#debug uint chanCode
 WR   __Instance__IsEstabTCPconnection~chanCode
#debug_left uint __Instance__IsEstabTCPconnection~chanCode
 PRV
 LEA  __Instance__IsEstabTCPconnection
 CAL  IsEstabTCPconnection_L0
 NEG
 LDX  DataReady
#debug bool DataReady
 NEG
 AND
 JMC  fbHttpRequest_L75
#srcline 305 ;        Err    := ContLen > 0;                                               //jeste jsem mel neco prijmout => Error
 LDX  ContLen
#debug dint ContLen
 LD   dint 0
 GTS
 WRX  Err
#debug_left bool Err
#srcline 306 ;        IF Err THEN
 LDX  Err
#debug bool Err
 JMC  fbHttpRequest_L77
#srcline 307 ;          ErrId := 2;
 LD   usint 2
 WRX  ErrId
#debug_left usint ErrId
#srcline 308 ;        END_IF;
fbHttpRequest_L77:
#srcline 309 ;//        ErrId  := BOOL_TO_USINT(Err)*2; //Set 2 if error occured
#srcline 310 ;        Done   := NOT Err;                                                   //pokud nebyl error je hotovo
 LDX  Err
#debug bool Err
 NEG
 WRX  Done
#debug_left bool Done
#srcline 311 ;        State  := hs_HttpIdle;                                               //klidovy stav
 LD   udint 0  ; THttpState#hs_HttpIdle
 WRX  State
#debug_left usint State
#srcline 312 ;      END_IF;
fbHttpRequest_L75:
#srcline 314 ;      IF Close & ContLen = 0 THEN
 LDX  Close
#debug bool Close
 LDX  ContLen
#debug dint ContLen
 LD   dint 0
 EQ
 AND
 JMC  fbHttpRequest_L79
#srcline 315 ;        CloseTCPconnection(chanCode := chanCode);
 NXT
 LDX  chanCode
#debug uint chanCode
 WR   __Instance__CloseTCPconnection~chanCode
#debug_left uint __Instance__CloseTCPconnection~chanCode
 PRV
 LEA  __Instance__CloseTCPconnection
 CAL  CloseTCPconnection_L0
#srcline 316 ;      END_IF;
fbHttpRequest_L79:
 JMP  fbHttpRequest_L9
fbHttpRequest_L46:
fbHttpRequest_L9:
#srcline 320 ;  IF Busy THEN
 LDX  Busy
#debug bool Busy
 JMC  fbHttpRequest_L81
#srcline 321 ;    IF WholeLen > 0 THEN
 LDX  WholeLen
#debug dint WholeLen
 LD   dint 0
 GTS
 JMC  fbHttpRequest_L83
#srcline 322 ;      Progress := DINT_TO_SINT(((WholeLen - ContLen) * 100 + WholeLen / 2) / WholeLen);
 LDX  WholeLen
#debug dint WholeLen
 LDX  ContLen
#debug dint ContLen
 SUB
 LD   dint 100
 MULS
 LDX  WholeLen
#debug dint WholeLen
 LD   dint 2
 DIVS
 ADD
 LDX  WholeLen
#debug dint WholeLen
 DIVS
 EXTB
 WRX  Progress
#debug_left sint Progress
#srcline 323 ;    ELSE
 JMP  fbHttpRequest_L84
fbHttpRequest_L83:
#srcline 324 ;      Progress := -1;
 LD   sint -1
 WRX  Progress
#debug_left sint Progress
#srcline 325 ;    END_IF;
fbHttpRequest_L84:
#srcline 326 ;  END_IF;
fbHttpRequest_L81:
#srcline 328 ;END_FUNCTION_BLOCK
fbHttpRequest_RET:
 ULNK
RET
E     61

; Initialize - variables
P     61
fbHttpRequest__InstanceInit__:
 LINK 0
 LD   uint 80
 WRX  port
 LEAX RecvFrom
 CAL  fbRecvFrom__InstanceInit__
 LEAX SendTo
 CAL  fbSendTo__InstanceInit__
 ULNK
RET
E     61
; End initialize - variables
#endpou 



 

#srcfile ''
#srcfile 'C:\TECOLIBSRC\INTERNETLIB\INTERNETLIBVCONTROL\FBSMTP.ST'
#pou fbSmtp
#srcline 19 ;FUNCTION_BLOCK fbSmtp

#struct fbSmtp__temp__
  pointer ptrUsint,
  TMacAdr mac,  ;MAC adresa
  udint tmpud,
  int pos,
  TRemoteEthAdr rea,
  uint tmpReplyCode,
  TUniDesc UniDesc,
  bool timeout_elapsed,  ; true pokud nastal timeout
  usint P0__st__,
  string[257] PS0__st__,
  string[82] PS1__st__
#data byte _str_fbSmtp_0 = 
  '-',0
#data byte _str_fbSmtp_1 = 
  ' ',$0D,$0A,0
#data byte _str_fbSmtp_2 = 
  'E','H','L','O',' ','t','e','c','o','m','a','t','.','P','L','C',$0D,$0A,0
#data byte _str_fbSmtp_3 = 
  'H','E','L','O',' ','t','e','c','o','m','a','t','.','P','L','C',$0D,$0A,0
#data byte _str_fbSmtp_4 = 
  'A','U','T','H',' ','L','O','G','I','N',$0D,$0A,0
#data byte _str_fbSmtp_5 = 
  'M','A','I','L',' ','F','R','O','M',':',' ','<',0
#data byte _str_fbSmtp_6 = 
  ';',0
#data byte _str_fbSmtp_7 = 
  '<',0
#data byte _str_fbSmtp_8 = 
  '>',0
#data byte _str_fbSmtp_9 = 
  ',','<',0
#data byte _str_fbSmtp_10 = 
  '>',0
#data byte _str_fbSmtp_11 = 
  'R','C','P','T',' ','T','O',':','<',0
#data byte _str_fbSmtp_12 = 
  'D','A','T','A',$0D,$0A,0
#data byte _str_fbSmtp_13 = 
  'D','A','T','E',':',' ',0
#data byte _str_fbSmtp_14 = 
  'F','R','O','M',':',' ','"',0
#data byte _str_fbSmtp_15 = 
  '"',' ','<',0
#data byte _str_fbSmtp_16 = 
  'T','O',':',' ',0
#data byte _str_fbSmtp_17 = 
  '@',0
#data byte _str_fbSmtp_18 = 
  'M','e','s','s','a','g','e','-','I','D',':',' ','<',0
#data byte _str_fbSmtp_19 = 
  '%','T','Y','Y','M','M','D','D','h','h','m','m','s','s','z','z','z',0
#data byte _str_fbSmtp_20 = 
  'S','U','B','J','E','C','T',':',' ','=','?',0
#data byte _str_fbSmtp_21 = 
  '?','B','?',0
#data byte _str_fbSmtp_22 = 
  '?','=',$0D,$0A,0
#data byte _str_fbSmtp_23 = 
  'S','U','B','J','E','C','T',':',' ',0
#data byte _str_fbSmtp_24 = 
  'M','I','M','E','-','V','e','r','s','i','o','n',':',' ','1','.','0',$0D,$0A,'C',
  'o','n','t','e','n','t','-','T','y','p','e',':',' ','m','u','l','t','i','p','a',
  'r','t','/','m','i','x','e','d',';',$0D,$0A,' ','b','o','u','n','d','a','r','y',
  '=','"','-','-','-','-','=','_','N','e','x','t','P','a','r','t','_','0','0','0',
  '_','0','0','0','D','_','6','6','6','F','7','8','7','4','.','7','4','6','5','6',
  '3','6','F','"',$0D,$0A,$0D,$0A,'T','h','i','s',' ','i','s',' ','a',' ','m','e',
  's','s','a','g','e',' ','w','i','t','h',' ','m','u','l','t','i','p','l','e',' ',
  'p','a','r','t','s',' ','i','n',' ','M','I','M','E',' ','f','o','r','m','a','t',
  '.',$0D,$0A,$0D,$0A,'-','-','-','-','-','-','=','_','N','e','x','t','P','a','r',
  't','_','0','0','0','_','0','0','0','D','_','6','6','6','F','7','8','7','4','.',
  '7','4','6','5','6','3','6','F',$0D,$0A,0
#data byte _str_fbSmtp_25 = 
  'C','o','n','t','e','n','t','-','T','y','p','e',':',' ','t','e','x','t','/','p',
  'l','a','i','n',';',' ','c','h','a','r','s','e','t','=',0
#data byte _str_fbSmtp_26 = 
  $0D,$0A,$0D,$0A,0
#data byte _str_fbSmtp_27 = 
  'C','o','n','t','e','n','t','-','T','y','p','e',':',' ','t','e','x','t','/','p',
  'l','a','i','n',';',$0D,$0A,$0D,$0A,0
#data byte _str_fbSmtp_28 = 
  '',0
#data byte _str_fbSmtp_29 = 
  'a','p','p','l','i','c','a','t','i','o','n','/','o','c','t','e','t','-','s','t',
  'r','e','a','m',0
#data byte _str_fbSmtp_30 = 
  '-','-','-','-','-','-','=','_','N','e','x','t','P','a','r','t','_','0','0','0',
  '_','0','0','0','D','_','6','6','6','F','7','8','7','4','.','7','4','6','5','6',
  '3','6','F',$0D,$0A,'C','o','n','t','e','n','t','-','T','y','p','e',':',' ',0
#data byte _str_fbSmtp_31 = 
  ';',' ','n','a','m','e','=','"',0
#data byte _str_fbSmtp_32 = 
  '"',$0D,$0A,0
#data byte _str_fbSmtp_33 = 
  'C','o','n','t','e','n','t','-','T','r','a','n','s','f','e','r','-','E','n','c',
  'o','d','i','n','g',':',' ','b','a','s','e','6','4',$0D,$0A,'C','o','n','t','e',
  'n','t','-','D','i','s','p','o','s','i','t','i','o','n',':',' ','a','t','t','a',
  'c','h','m','e','n','t',';',' ','f','i','l','e','n','a','m','e','=','"',0
#data byte _str_fbSmtp_34 = 
  '"',$0D,$0A,$0D,$0A,0
#data byte _str_fbSmtp_35 = 
  $0D,$0A,0
#data byte _str_fbSmtp_36 = 
  $0D,$0A,0
#data byte _str_fbSmtp_37 = 
  $0D,$0A,0
#data byte _str_fbSmtp_38 = 
  '-','-','-','-','-','-','=','_','N','e','x','t','P','a','r','t','_','0','0','0',
  '_','0','0','0','D','_','6','6','6','F','7','8','7','4','.','7','4','6','5','6',
  '3','6','F','-','-',$0D,$0A,'.',$0D,$0A,0
#data byte _str_fbSmtp_39 = 
  'Q','U','I','T',$0D,$0A,0
P     61
fbSmtp_L0:
 LINK __SizeOf(fbSmtp__temp__)
; Initialize - dynamic variables
 LD   udint $FFFFFFFF    ; nil
 WRY  ptrUsint
; End initialize - dynamic variables
; R_EDGE, F_EDGE 
 LDX  Send
 LETX __EDGE_R__Send
 WRX  Send
 LDX  Cancel
 LETX __EDGE_R__Cancel
 WRX  Cancel
#srcline 97 ;  mesRec := Recv_from.lenMes > 0;
 LDX  Recv_from~lenMes
#debug uint Recv_from.lenMes
 LD   uint 0
 GT
 WRX  mesRec
#debug_left bool mesRec
#srcline 99 ;  IF GetChanIndex( chanCode) <> -1 THEN
 NXT
 LDX  chanCode
#debug uint chanCode
 WR   __Instance__GetChanIndex~chanCode
#debug_left uint __Instance__GetChanIndex~chanCode
 PRV
 LEA  __Instance__GetChanIndex
 CAL  GetChanIndex_L0
 LD   int -1
 EQ
 NEG
 JMC  fbSmtp_L1
#srcline 100 ;    // kanal zalozen pomoci #module => kontrola nutna
#srcline 101 ;    UniDesc := GetChanDesc(chanCode := chanCode);
 NXT
 LDX  chanCode
#debug uint chanCode
 WR   __Instance__GetChanDesc~chanCode
#debug_left uint __Instance__GetChanDesc~chanCode
 PRV
 LEA  __Instance__GetChanDesc
 CAL  GetChanDesc_L0
 LEAY UniDesc
#debug_left pointer UniDesc
 LD   26   ;SizeOf() 
 MOV  %IB0
#srcline 102 ;    IF (UniDesc.modeChan <> 5) OR (UniDesc.lenUniIn <> 259) OR (UniDesc.lenUniOut < 259) THEN
 LDY  UniDesc~modeChan
#debug byte UniDesc.modeChan
 LD   byte 5
 EQ
 NEG
 LDY  UniDesc~lenUniIn
#debug uint UniDesc.lenUniIn
 LD   uint 259
 EQ
 NEG
 OR  
 LDY  UniDesc~lenUniOut
#debug uint UniDesc.lenUniOut
 LD   uint 259
 LT
 OR  
 JMC  fbSmtp_L3
#srcline 103 ;      Err   := true;
 LD   bool -1       ; true
 WRX  Err
#debug_left bool Err
#srcline 104 ;      ErrId := 255;
 LD   usint 255
 WRX  ErrId
#debug_left usint ErrId
#srcline 105 ;      RETURN;
 JMP  fbSmtp_RET
#srcline 106 ;    END_IF;
fbSmtp_L3:
#srcline 107 ;  END_IF;
fbSmtp_L1:
#srcline 109 ;  IF Cancel THEN
 LDX  Cancel
#debug bool Cancel
 JMC  fbSmtp_L5
#srcline 110 ;    state := ss_SmtpInit;
 LD   udint 0  ; TSmtpState#ss_SmtpInit
 WRX  state
#debug_left usint state
#srcline 111 ;  END_IF;
fbSmtp_L5:
#srcline 113 ;  IF state <> ss_Smtptxattachementbody & state <> ss_Smtptxattachement THEN
 LDX  state
#debug usint state
 LD   udint 25  ; TSmtpState#ss_SmtpTxAttachementBody
 EQ
 NEG
 LDX  state
#debug usint state
 LD   udint 24  ; TSmtpState#ss_SmtpTxAttachement
 EQ
 NEG
 AND
 JMC  fbSmtp_L7
#srcline 114 ;    IF h <> INVALID_HANDLE_VALUE THEN
 LDX  h
#debug udint h
 LD   udint 0
 EQ
 NEG
 JMC  fbSmtp_L9
#srcline 115 ;      FileClose(h);
 NXT
 LDX  h
#debug udint h
 WR   __Instance__FileClose~hFile
#debug_left udint __Instance__FileClose~hFile
 PRV
 LEA  __Instance__FileClose
 CAL  FileClose_L0
#srcline 116 ;      h := INVALID_HANDLE_VALUE;
 LD   udint 0
 WRX  h
#debug_left udint h
#srcline 117 ;    END_IF;
fbSmtp_L9:
#srcline 118 ;  END_IF;
fbSmtp_L7:
#srcline 120 ;  timeout_cntr( IN := Recv_from.getMes & NOT Send_to.rq, PT := T#1m50s, Q => timeout_elapsed); // timeout
 LDX  Recv_from~getMes
#debug bool Recv_from.getMes
 LDX  Send_to~rq
#debug bool Send_to.rq
 NEG
 AND
 WRX  timeout_cntr~IN
#debug_left bool timeout_cntr~IN
 LD   time 110000
 WRX  timeout_cntr~PT
#debug_left time timeout_cntr~PT
 LEAX timeout_cntr
 CAL  TON_L0
; output assigment 
 LDX  timeout_cntr~Q
#debug bool timeout_cntr~Q
 WRY  timeout_elapsed
#debug_left bool timeout_elapsed
#srcline 122 ;  IF NOT TRO THEN
 LDX  TRO
#debug bool TRO
 NEG
 JMC  fbSmtp_L11
#srcline 123 ;    if mesRec then
 LDX  mesRec
#debug bool mesRec
 JMC  fbSmtp_L13
#srcline 124 ;      tmpReplyCode := STRING_TO_UINT(cmd);
 LEAX cmd
#debug string cmd
 SCNV $300A;  IEC_STRING _TO_ IEC_UINT
 WRY  tmpReplyCode
#debug_left uint tmpReplyCode
#srcline 125 ;      IF Busy AND NOT Err THEN
 LDX  Busy
#debug bool Busy
 LDX  Err
#debug bool Err
 NEG
 AND
 JMC  fbSmtp_L15
#srcline 126 ;        ReplyCode := tmpReplyCode;
 LDY  tmpReplyCode
#debug uint tmpReplyCode
 WRX  ReplyCode
#debug_left uint ReplyCode
#srcline 127 ;      END_IF;
fbSmtp_L15:
#srcline 128 ;      IF FIND(IN1 := cmd, IN2 := '-') = 4 THEN //pokracuje na dalsim radku
 LEAX cmd
#debug string cmd
 LEA  _str_fbSmtp_0
 SFND 
 LD   int 4
 EQ
 JMC  fbSmtp_L17
#srcline 129 ;        mesRec := 0;
 LD   bool 0       ; false
 WRX  mesRec
#debug_left bool mesRec
#srcline 130 ;      END_IF;
fbSmtp_L17:
#srcline 131 ;    end_if;
fbSmtp_L13:
#srcline 133 ;    CASE state OF
 LDX  state
#debug usint state
 WRY  P0__st__
 LD   0
 LDY  P0__st__
 EQ  
 JMC  fbSmtp_L20
#srcline 134 ;      // inicializace ------------------------------------------------------------
#srcline 135 ;      ss_Smtpinit :
#srcline 136 ;        busy        := false;
 LD   bool 0       ; false
 WRX  busy
#debug_left bool busy
#srcline 137 ;        Done        := false;
 LD   bool 0       ; false
 WRX  Done
#debug_left bool Done
#srcline 138 ;        lSend       := Send;
 LDX  Send
#debug bool Send
 WRX  lSend
#debug_left bool lSend
#srcline 139 ;        state       := ss_Smtpidle;
 LD   udint 1  ; TSmtpState#ss_SmtpIdle
 WRX  state
#debug_left usint state
#srcline 140 ;        // nenavazovat spojeni : r0_p0_Control_ETH1_UNI0.CONTROL.0 := 1;
#srcline 141 ;        CloseTCPconnection( chanCode);
 NXT
 LDX  chanCode
#debug uint chanCode
 WR   __Instance__CloseTCPconnection~chanCode
#debug_left uint __Instance__CloseTCPconnection~chanCode
 PRV
 LEA  __Instance__CloseTCPconnection
 CAL  CloseTCPconnection_L0
 JMP  fbSmtp_L19
fbSmtp_L20:
 LD   1
 LDY  P0__st__
 EQ  
 JMC  fbSmtp_L21
#srcline 143 ;      // cekani na start ---------------------------------------------------------
#srcline 144 ;      ss_Smtpidle :
#srcline 145 ;        if Send OR lSend then
 LDX  Send
#debug bool Send
 LDX  lSend
#debug bool lSend
 OR  
 JMC  fbSmtp_L22
#srcline 146 ;          lSend := false;
 LD   bool 0       ; false
 WRX  lSend
#debug_left bool lSend
#srcline 147 ;          lAuth := Auth;
 LDX  Auth
#debug bool Auth
 WRX  lAuth
#debug_left bool lAuth
#srcline 148 ;          // vycistime prijimaci a vysilaci buffer
#srcline 149 ;          Recv_from.getMes := FALSE;
 LD   bool 0       ; false
 WRX  Recv_from~getMes
#debug_left bool Recv_from.getMes
#srcline 150 ;          Send_to.rq   := FALSE;   Send_to.lenTx := 1;
 LD   bool 0       ; false
 WRX  Send_to~rq
#debug_left bool Send_to.rq
 LD   uint 1
 WRX  Send_to~lenTx
#debug_left uint Send_to.lenTx
#srcline 151 ;          state := ss_SmtpSetIp;
 LD   udint 2  ; TSmtpState#ss_SmtpSetIP
 WRX  state
#debug_left usint state
#srcline 152 ;          busy  := true; body_lines := USINT_TO_SINT(lines);
 LD   bool -1       ; true
 WRX  busy
#debug_left bool busy
 LDX  lines
#debug usint lines
 EXTB
 WRX  body_lines
#debug_left sint body_lines
#srcline 153 ;          Err   := false;
 LD   bool 0       ; false
 WRX  Err
#debug_left bool Err
#srcline 154 ;          ErrId := 0;
 LD   usint 0
 WRX  ErrId
#debug_left usint ErrId
#srcline 155 ;          ReplyCode := 0;
 LD   uint 0
 WRX  ReplyCode
#debug_left uint ReplyCode
#srcline 156 ;        end_if;
fbSmtp_L22:
 JMP  fbSmtp_L19
fbSmtp_L21:
 LD   2
 LDY  P0__st__
 EQ  
 JMC  fbSmtp_L24
#srcline 157 ;      // nastaveni IP adresy
#srcline 158 ;      ss_SmtpSetIp:
#srcline 159 ;        IF IPadr = Any_IP THEN
 LEAX IPadr
 LEA  Any_IP
 LD   4   ; SizeOf()
 BCMP 
 EQ   0
 JMC  fbSmtp_L25
#srcline 160 ;          Err    := 1;
 LD   bool -1      ; true
 WRX  Err
#debug_left bool Err
#srcline 161 ;          ErrId  := 254;
 LD   usint 254
 WRX  ErrId
#debug_left usint ErrId
#srcline 162 ;          state  := ss_Smtpidle;
 LD   udint 1  ; TSmtpState#ss_SmtpIdle
 WRX  state
#debug_left usint state
#srcline 163 ;        ELSE
 JMP  fbSmtp_L26
fbSmtp_L25:
#srcline 164 ;          rea.remoteIP   := IPadr;
 LEAX IPadr
#debug pointer IPadr
 SRC  %IB0
 LEAY rea~remoteIP
#debug_left pointer rea.remoteIP
 LD   4   ;SizeOf() 
 MOV  %IB0
#srcline 165 ;          rea.remotePort := port;
 LDX  port
#debug uint port
 WRY  rea~remotePort
#debug_left uint rea.remotePort
#srcline 166 ;          IF SetRemoteIPaddress(rq := 1, chanCode := chanCode, ethAdr := rea) THEN
 NXT
 LD   1
 WR   __Instance__SetRemoteIPaddress~rq
#debug_left bool __Instance__SetRemoteIPaddress~rq
 LDX  chanCode
#debug uint chanCode
 WR   __Instance__SetRemoteIPaddress~chanCode
#debug_left uint __Instance__SetRemoteIPaddress~chanCode
 LEAY rea
 WR   __Instance__SetRemoteIPaddress~ethAdr
#debug_left pointer __Instance__SetRemoteIPaddress.ethAdr
 PRV
 LEA  __Instance__SetRemoteIPaddress
 CAL  SetRemoteIPaddress_L0
 JMC  fbSmtp_L27
#srcline 167 ;            //EstabTCPconnection( chanCode);
#srcline 168 ;            state := ss_Smtprxconnect; //ss_Smtptxconnect;
 LD   udint 4  ; TSmtpState#ss_SmtpRxConnect
 WRX  state
#debug_left usint state
#srcline 169 ;          END_IF;
fbSmtp_L27:
#srcline 170 ;        END_IF;
fbSmtp_L26:
 JMP  fbSmtp_L19
fbSmtp_L24:
 LD   3
 LDY  P0__st__
 EQ  
 JMC  fbSmtp_L29
#srcline 171 ;      // kontaktujeme server -----------------------------------------------------
#srcline 172 ;      ss_Smtptxconnect :
#srcline 173 ;        // navazat spojeni se serverem : r0_p0_Control_ETH1_UNI0.CONTROL.0 := 0;
#srcline 174 ;        cmd := ' $r$l';
 LD   0   ; null string
 LEAX cmd
 WRI  
 LEAX cmd
 LD   255
 DST    ; Level 1
 LEA  _str_fbSmtp_1
 SCON 
#debug_left string cmd
 PDST   ; Level 1
#srcline 175 ;        Send_to.rq := TRUE;
 LD   bool -1       ; true
 WRX  Send_to~rq
#debug_left bool Send_to.rq
#srcline 176 ;        state := ss_Smtprxconnect;
 LD   udint 4  ; TSmtpState#ss_SmtpRxConnect
 WRX  state
#debug_left usint state
 JMP  fbSmtp_L19
fbSmtp_L29:
 LD   4
 LDY  P0__st__
 EQ  
 JMC  fbSmtp_L30
#srcline 177 ;      // cekani na odezvu --------------------------------------------------------
#srcline 178 ;      ss_Smtprxconnect :
#srcline 179 ;        EstabTCPconnection( chanCode);
 NXT
 LDX  chanCode
#debug uint chanCode
 WR   __Instance__EstabTCPconnection~chanCode
#debug_left uint __Instance__EstabTCPconnection~chanCode
 PRV
 LEA  __Instance__EstabTCPconnection
 CAL  EstabTCPconnection_L0
#srcline 180 ;        Send_to.rq   := FALSE;
 LD   bool 0       ; false
 WRX  Send_to~rq
#debug_left bool Send_to.rq
#srcline 181 ;        Recv_from.getMes := TRUE;
 LD   bool -1       ; true
 WRX  Recv_from~getMes
#debug_left bool Recv_from.getMes
#srcline 182 ;        if mesRec then
 LDX  mesRec
#debug bool mesRec
 JMC  fbSmtp_L31
#srcline 183 ;          {$IFDEF _DEBUG} dbg1 := cmd; {$END_IF}
#srcline 184 ;          if tmpReplyCode = 220 then //je to odezva typu '220 proxy.tecomat.cz ESMTP ready'?
 LDY  tmpReplyCode
#debug uint tmpReplyCode
 LD   uint 220
 EQ
 JMC  fbSmtp_L33
#srcline 185 ;            state := ss_Smtptxhelo;
 LD   udint 5  ; TSmtpState#ss_SmtpTxHelo
 WRX  state
#debug_left usint state
#srcline 186 ;          else
 JMP  fbSmtp_L34
fbSmtp_L33:
#srcline 187 ;            state := ss_Smtprxerror;        //chybna odezva
 LD   udint 31  ; TSmtpState#ss_SmtpRxError
 WRX  state
#debug_left usint state
#srcline 188 ;          end_if;
fbSmtp_L34:
#srcline 189 ;        else
 JMP  fbSmtp_L32
fbSmtp_L31:
#srcline 190 ;          if timeout_elapsed then    //server neodpovida
 LDY  timeout_elapsed
#debug bool timeout_elapsed
 JMC  fbSmtp_L35
#srcline 191 ;            state := ss_Smtprxtimeout;
 LD   udint 30  ; TSmtpState#ss_SmtpRxTimeout
 WRX  state
#debug_left usint state
#srcline 192 ;          end_if;
fbSmtp_L35:
#srcline 193 ;        end_if;
fbSmtp_L32:
 JMP  fbSmtp_L19
fbSmtp_L30:
 LD   5
 LDY  P0__st__
 EQ  
 JMC  fbSmtp_L37
#srcline 196 ;      // posleme prikaz helo -----------------------------------------------------
#srcline 197 ;      ss_Smtptxhelo :
#srcline 198 ;        IF lAuth THEN
 LDX  lAuth
#debug bool lAuth
 JMC  fbSmtp_L38
#srcline 199 ;          cmd := 'EHLO tecomat.PLC$r$l'; //ESMTP
 LD   0   ; null string
 LEAX cmd
 WRI  
 LEAX cmd
 LD   255
 DST    ; Level 1
 LEA  _str_fbSmtp_2
 SCON 
#debug_left string cmd
 PDST   ; Level 1
#srcline 200 ;        ELSE
 JMP  fbSmtp_L39
fbSmtp_L38:
#srcline 201 ;          cmd := 'HELO tecomat.PLC$r$l';
 LD   0   ; null string
 LEAX cmd
 WRI  
 LEAX cmd
 LD   255
 DST    ; Level 1
 LEA  _str_fbSmtp_3
 SCON 
#debug_left string cmd
 PDST   ; Level 1
#srcline 202 ;        END_IF;
fbSmtp_L39:
#srcline 203 ;        Send_to.rq  := TRUE;
 LD   bool -1       ; true
 WRX  Send_to~rq
#debug_left bool Send_to.rq
#srcline 204 ;        state := ss_Smtprxhelo;
 LD   udint 6  ; TSmtpState#ss_SmtpRxHelo
 WRX  state
#debug_left usint state
 JMP  fbSmtp_L19
fbSmtp_L37:
 LD   6
 LDY  P0__st__
 EQ  
 JMC  fbSmtp_L40
#srcline 206 ;      // cekani na odezvu --------------------------------------------------------
#srcline 207 ;      ss_Smtprxhelo :
#srcline 208 ;        Send_to.rq   := FALSE;
 LD   bool 0       ; false
 WRX  Send_to~rq
#debug_left bool Send_to.rq
#srcline 209 ;        if mesRec then
 LDX  mesRec
#debug bool mesRec
 JMC  fbSmtp_L41
#srcline 210 ;          {$IFDEF _DEBUG} dbg2 := cmd; {$END_IF}
#srcline 211 ;          if tmpReplyCode = 250 then //je to odezva typu '250'?
 LDY  tmpReplyCode
#debug uint tmpReplyCode
 LD   uint 250
 EQ
 JMC  fbSmtp_L43
#srcline 212 ;            if lAuth then
 LDX  lAuth
#debug bool lAuth
 JMC  fbSmtp_L45
#srcline 213 ;              state := ss_Smtptxauthlogin;
 LD   udint 7  ; TSmtpState#ss_SmtpTxAuthlogin
 WRX  state
#debug_left usint state
#srcline 214 ;            else
 JMP  fbSmtp_L46
fbSmtp_L45:
#srcline 215 ;              state := ss_Smtptxmailfrom;
 LD   udint 13  ; TSmtpState#ss_SmtpTxMailFrom
 WRX  state
#debug_left usint state
#srcline 216 ;            end_if;
fbSmtp_L46:
#srcline 217 ;          else
 JMP  fbSmtp_L44
fbSmtp_L43:
#srcline 218 ;            state := ss_Smtprxerror;        //chybna odezva
 LD   udint 31  ; TSmtpState#ss_SmtpRxError
 WRX  state
#debug_left usint state
#srcline 219 ;          end_if;
fbSmtp_L44:
#srcline 220 ;        elsif timeout_elapsed then   //server neodpovida
 JMP  fbSmtp_L42
fbSmtp_L41:
 LDY  timeout_elapsed
#debug bool timeout_elapsed
 JMC  fbSmtp_L47
#srcline 221 ;          state := ss_Smtprxtimeout;
 LD   udint 30  ; TSmtpState#ss_SmtpRxTimeout
 WRX  state
#debug_left usint state
#srcline 222 ;        end_if;
 JMP  fbSmtp_L42
fbSmtp_L47:
fbSmtp_L42:
 JMP  fbSmtp_L19
fbSmtp_L40:
 LD   7
 LDY  P0__st__
 EQ  
 JMC  fbSmtp_L48
#srcline 224 ;      // AUTH LOGIN
#srcline 225 ;      ss_Smtptxauthlogin:
#srcline 226 ;        cmd := 'AUTH LOGIN$r$l';
 LD   0   ; null string
 LEAX cmd
 WRI  
 LEAX cmd
 LD   255
 DST    ; Level 1
 LEA  _str_fbSmtp_4
 SCON 
#debug_left string cmd
 PDST   ; Level 1
#srcline 227 ;        Send_to.rq   := TRUE;
 LD   bool -1       ; true
 WRX  Send_to~rq
#debug_left bool Send_to.rq
#srcline 228 ;        state := ss_Smtprxauthlogin;
 LD   udint 8  ; TSmtpState#ss_SmtpRxAuthlogin
 WRX  state
#debug_left usint state
 JMP  fbSmtp_L19
fbSmtp_L48:
 LD   8
 LDY  P0__st__
 EQ  
 JMC  fbSmtp_L49
#srcline 230 ;      // 334
#srcline 231 ;      ss_Smtprxauthlogin:
#srcline 232 ;        Send_to.rq  := FALSE;
 LD   bool 0       ; false
 WRX  Send_to~rq
#debug_left bool Send_to.rq
#srcline 233 ;        if mesRec then
 LDX  mesRec
#debug bool mesRec
 JMC  fbSmtp_L50
#srcline 234 ;          {$IFDEF _DEBUG} dbg2 := cmd; {$END_IF}
#srcline 235 ;          if tmpReplyCode = 334 then //je to odezva typu '334'?
 LDY  tmpReplyCode
#debug uint tmpReplyCode
 LD   uint 334
 EQ
 JMC  fbSmtp_L52
#srcline 236 ;            state := ss_Smtptxusername;
 LD   udint 9  ; TSmtpState#ss_SmtpTxUserName
 WRX  state
#debug_left usint state
#srcline 237 ;          else
 JMP  fbSmtp_L53
fbSmtp_L52:
#srcline 238 ;            state := ss_Smtprxerror;        //chybna odezva
 LD   udint 31  ; TSmtpState#ss_SmtpRxError
 WRX  state
#debug_left usint state
#srcline 239 ;          end_if;
fbSmtp_L53:
#srcline 240 ;        elsif timeout_elapsed then   // server neodpovida
 JMP  fbSmtp_L51
fbSmtp_L50:
 LDY  timeout_elapsed
#debug bool timeout_elapsed
 JMC  fbSmtp_L54
#srcline 241 ;          state := ss_Smtptxusername;
 LD   udint 9  ; TSmtpState#ss_SmtpTxUserName
 WRX  state
#debug_left usint state
#srcline 242 ;        end_if;
 JMP  fbSmtp_L51
fbSmtp_L54:
fbSmtp_L51:
 JMP  fbSmtp_L19
fbSmtp_L49:
 LD   9
 LDY  P0__st__
 EQ  
 JMC  fbSmtp_L55
#srcline 244 ;      // Username:
#srcline 245 ;      ss_Smtptxusername:
#srcline 246 ;        cmd := Base64_encode_string(username) + INTERNETLIB_END_OF_LINE_;
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 NXT
 LD   0   ; null string
 LEA  __Instance__Base64_encode_string~data
 WRI 
 LEA  __Instance__Base64_encode_string~data
 LD   60
 DST    ; Level 2
 LDX  username
#debug string username
 SCON 
#debug_left string __Instance__Base64_encode_string~data
 PDST   ; Level 2
 PRV
 LEA  __Instance__Base64_encode_string
 CAL  Base64_encode_string_L0

 SCON 
 LEA  INTERNETLIB_END_OF_LINE_
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX cmd
 WRI  
 LEAX cmd
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string cmd
 PDST   ; Level 1
#srcline 247 ;        Send_to.rq  := TRUE;
 LD   bool -1       ; true
 WRX  Send_to~rq
#debug_left bool Send_to.rq
#srcline 248 ;        state := ss_Smtprxusername;
 LD   udint 10  ; TSmtpState#ss_SmtpRxUserName
 WRX  state
#debug_left usint state
 JMP  fbSmtp_L19
fbSmtp_L55:
 LD   10
 LDY  P0__st__
 EQ  
 JMC  fbSmtp_L56
#srcline 250 ;      // 334
#srcline 251 ;      ss_Smtprxusername:
#srcline 252 ;        Send_to.rq   := FALSE;
 LD   bool 0       ; false
 WRX  Send_to~rq
#debug_left bool Send_to.rq
#srcline 253 ;        if mesRec then
 LDX  mesRec
#debug bool mesRec
 JMC  fbSmtp_L57
#srcline 254 ;          {$IFDEF _DEBUG} dbg2 := cmd; {$END_IF}
#srcline 255 ;          if tmpReplyCode = 334 then //je to odezva typu '334'?
 LDY  tmpReplyCode
#debug uint tmpReplyCode
 LD   uint 334
 EQ
 JMC  fbSmtp_L59
#srcline 256 ;            state := ss_Smtptxpassword;
 LD   udint 11  ; TSmtpState#ss_SmtpTxPassword
 WRX  state
#debug_left usint state
#srcline 257 ;          else
 JMP  fbSmtp_L60
fbSmtp_L59:
#srcline 258 ;            state := ss_Smtprxerror;          //chybna odezva
 LD   udint 31  ; TSmtpState#ss_SmtpRxError
 WRX  state
#debug_left usint state
#srcline 259 ;          end_if;
fbSmtp_L60:
#srcline 260 ;        elsif timeout_elapsed then     //server neodpovida
 JMP  fbSmtp_L58
fbSmtp_L57:
 LDY  timeout_elapsed
#debug bool timeout_elapsed
 JMC  fbSmtp_L61
#srcline 261 ;          state := ss_Smtprxtimeout;
 LD   udint 30  ; TSmtpState#ss_SmtpRxTimeout
 WRX  state
#debug_left usint state
#srcline 262 ;        end_if;
 JMP  fbSmtp_L58
fbSmtp_L61:
fbSmtp_L58:
 JMP  fbSmtp_L19
fbSmtp_L56:
 LD   11
 LDY  P0__st__
 EQ  
 JMC  fbSmtp_L62
#srcline 264 ;      // Password:
#srcline 265 ;      ss_Smtptxpassword:
#srcline 266 ;        cmd := Base64_encode_string(password) + INTERNETLIB_END_OF_LINE_;
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 NXT
 LD   0   ; null string
 LEA  __Instance__Base64_encode_string~data
 WRI 
 LEA  __Instance__Base64_encode_string~data
 LD   60
 DST    ; Level 2
 LDX  password
#debug string password
 SCON 
#debug_left string __Instance__Base64_encode_string~data
 PDST   ; Level 2
 PRV
 LEA  __Instance__Base64_encode_string
 CAL  Base64_encode_string_L0

 SCON 
 LEA  INTERNETLIB_END_OF_LINE_
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX cmd
 WRI  
 LEAX cmd
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string cmd
 PDST   ; Level 1
#srcline 267 ;        Send_to.rq  := TRUE;
 LD   bool -1       ; true
 WRX  Send_to~rq
#debug_left bool Send_to.rq
#srcline 268 ;        state := ss_Smtprxpassword;
 LD   udint 12  ; TSmtpState#ss_SmtpRxPassword
 WRX  state
#debug_left usint state
 JMP  fbSmtp_L19
fbSmtp_L62:
 LD   12
 LDY  P0__st__
 EQ  
 JMC  fbSmtp_L63
#srcline 270 ;      // 235
#srcline 271 ;      ss_Smtprxpassword:
#srcline 272 ;        Send_to.rq  := FALSE;
 LD   bool 0       ; false
 WRX  Send_to~rq
#debug_left bool Send_to.rq
#srcline 273 ;        if mesRec then
 LDX  mesRec
#debug bool mesRec
 JMC  fbSmtp_L64
#srcline 274 ;          {$IFDEF _DEBUG} dbg2 := cmd; {$END_IF}
#srcline 275 ;          if tmpReplyCode = 235 then   //je to odezva typu '235'?
 LDY  tmpReplyCode
#debug uint tmpReplyCode
 LD   uint 235
 EQ
 JMC  fbSmtp_L66
#srcline 276 ;            state := ss_Smtptxmailfrom;
 LD   udint 13  ; TSmtpState#ss_SmtpTxMailFrom
 WRX  state
#debug_left usint state
#srcline 277 ;          else
 JMP  fbSmtp_L67
fbSmtp_L66:
#srcline 278 ;            state := ss_Smtprxerror;          //chybna odezva
 LD   udint 31  ; TSmtpState#ss_SmtpRxError
 WRX  state
#debug_left usint state
#srcline 279 ;          end_if;
fbSmtp_L67:
#srcline 280 ;        elsif timeout_elapsed then     //server neodpovida
 JMP  fbSmtp_L65
fbSmtp_L64:
 LDY  timeout_elapsed
#debug bool timeout_elapsed
 JMC  fbSmtp_L68
#srcline 281 ;          state := ss_Smtprxtimeout;
 LD   udint 30  ; TSmtpState#ss_SmtpRxTimeout
 WRX  state
#debug_left usint state
#srcline 282 ;        end_if;
 JMP  fbSmtp_L65
fbSmtp_L68:
fbSmtp_L65:
 JMP  fbSmtp_L19
fbSmtp_L63:
 LD   13
 LDY  P0__st__
 EQ  
 JMC  fbSmtp_L69
#srcline 285 ;      // posleme adresu odesilatele ----------------------------------------------
#srcline 286 ;      ss_Smtptxmailfrom :
#srcline 287 ;        cmd := 'MAIL FROM: <'+sender+SMTP_END_OF_LINE_2_;
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LEA  _str_fbSmtp_5
 SCON 
 LDX  sender
#debug string sender
 SCON 
 LEA  SMTP_END_OF_LINE_2_
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX cmd
 WRI  
 LEAX cmd
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string cmd
 PDST   ; Level 1
#srcline 288 ;        Send_to.rq  := TRUE;
 LD   bool -1       ; true
 WRX  Send_to~rq
#debug_left bool Send_to.rq
#srcline 289 ;        state := ss_Smtprxmailfrom;
 LD   udint 14  ; TSmtpState#ss_SmtpRxMailFrom
 WRX  state
#debug_left usint state
 JMP  fbSmtp_L19
fbSmtp_L69:
 LD   14
 LDY  P0__st__
 EQ  
 JMC  fbSmtp_L70
#srcline 291 ;      // cekani na odezvu --------------------------------------------------------
#srcline 292 ;      ss_Smtprxmailfrom :
#srcline 293 ;        Send_to.rq  := FALSE;
 LD   bool 0       ; false
 WRX  Send_to~rq
#debug_left bool Send_to.rq
#srcline 294 ;        if mesRec then
 LDX  mesRec
#debug bool mesRec
 JMC  fbSmtp_L71
#srcline 295 ;          {$IFDEF _DEBUG} dbg3 := cmd; {$END_IF}
#srcline 296 ;          if tmpReplyCode = 250 then //je to odezva typu '250'?
 LDY  tmpReplyCode
#debug uint tmpReplyCode
 LD   uint 250
 EQ
 JMC  fbSmtp_L73
#srcline 297 ;            state := ss_Smtptxrcptto;
 LD   udint 15  ; TSmtpState#ss_SmtpTxRcptTo
 WRX  state
#debug_left usint state
#srcline 298 ;            copy_rcpt := rcpt;
 LD   0   ; null string
 LEAX copy_rcpt
 WRI  
 LEAX copy_rcpt
 LD   255
 DST    ; Level 1
 LDX  rcpt
#debug string rcpt
 SCON 
#debug_left string copy_rcpt
 PDST   ; Level 1
#srcline 299 ;            body_rcpt := INTERNETLIB_EMPTY_STRING_;
 LD   0   ; null string
 LEAX body_rcpt
 WRI  
 LEAX body_rcpt
 LD   80
 DST    ; Level 1
 LEA  INTERNETLIB_EMPTY_STRING_
 SCON 
#debug_left string body_rcpt
 PDST   ; Level 1
#srcline 300 ;          else
 JMP  fbSmtp_L74
fbSmtp_L73:
#srcline 301 ;            state := ss_Smtprxerror;        //chybna odezva
 LD   udint 31  ; TSmtpState#ss_SmtpRxError
 WRX  state
#debug_left usint state
#srcline 302 ;          end_if;
fbSmtp_L74:
#srcline 303 ;        elsif timeout_elapsed then   //server neodpovida
 JMP  fbSmtp_L72
fbSmtp_L71:
 LDY  timeout_elapsed
#debug bool timeout_elapsed
 JMC  fbSmtp_L75
#srcline 304 ;          state := ss_Smtprxtimeout;
 LD   udint 30  ; TSmtpState#ss_SmtpRxTimeout
 WRX  state
#debug_left usint state
#srcline 305 ;        end_if;
 JMP  fbSmtp_L72
fbSmtp_L75:
fbSmtp_L72:
 JMP  fbSmtp_L19
fbSmtp_L70:
 LD   15
 LDY  P0__st__
 EQ  
 JMC  fbSmtp_L76
#srcline 307 ;      // posleme adresu prijemce -------------------------------------------------
#srcline 308 ;      ss_Smtptxrcptto :
#srcline 309 ;        Send_to.rq  := TRUE;
 LD   bool -1       ; true
 WRX  Send_to~rq
#debug_left bool Send_to.rq
#srcline 310 ;        pos := find( copy_rcpt, ';');
 LEAX copy_rcpt
#debug string copy_rcpt
 LEA  _str_fbSmtp_6
 SFND 
 WRY  pos
#debug_left int pos
#srcline 311 ;        ptrUsint := ADR(temp_rcpt);
 LEAX temp_rcpt
#debug pointer temp_rcpt
 LEAY ptrUsint
 WRIL 
#debug_left pointer ptrUsint
#srcline 312 ;        if pos <> 0 then
 LDY  pos
#debug int pos
 EXTW 
 LD   int 0
 EQ
 NEG
 JMC  fbSmtp_L77
#srcline 313 ;          temp_rcpt := left( copy_rcpt, pos-1);
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   180
 DST    ; Level 1
 LEAX copy_rcpt
#debug string copy_rcpt
 LDY  pos
#debug int pos
 EXTW 
 LD   int 1
 SUB
 EXTW
 SLFT 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX temp_rcpt
 WRI  
 LEAX temp_rcpt
 LD   180
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string temp_rcpt
 PDST   ; Level 1
#srcline 314 ;          copy_rcpt := delete(IN := copy_rcpt, L := pos, P := 1);
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LEAX copy_rcpt
#debug string copy_rcpt
 LDY  pos
#debug int pos
 EXTW 
 LD   1
 SUB  1
 SDEL 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX copy_rcpt
 WRI  
 LEAX copy_rcpt
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string copy_rcpt
 PDST   ; Level 1
#srcline 315 ;        else
 JMP  fbSmtp_L78
fbSmtp_L77:
#srcline 316 ;          temp_rcpt := copy_rcpt;
 LD   0   ; null string
 LEAX temp_rcpt
 WRI  
 LEAX temp_rcpt
 LD   180
 DST    ; Level 1
 LEAX copy_rcpt
#debug string copy_rcpt
 SCON 
#debug_left string temp_rcpt
 PDST   ; Level 1
#srcline 317 ;          copy_rcpt := INTERNETLIB_EMPTY_STRING_;
 LD   0   ; null string
 LEAX copy_rcpt
 WRI  
 LEAX copy_rcpt
 LD   255
 DST    ; Level 1
 LEA  INTERNETLIB_EMPTY_STRING_
 SCON 
#debug_left string copy_rcpt
 PDST   ; Level 1
#srcline 318 ;        end_if;
fbSmtp_L78:
#srcline 319 ;        if ptrUsint^ = 46 then
 LEAY ptrUsint
 LDIL    ; dereference 
 LDI  
#debug usint ptrUsint^
 LD   usint 46
 EQ
 JMC  fbSmtp_L79
#srcline 320 ;           temp_rcpt := delete(IN := temp_rcpt, L := 1, P := 1); //vymazat prvni znak ktery urcil ze je to hidden
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   180
 DST    ; Level 1
 LEAX temp_rcpt
#debug string temp_rcpt
 LD   1
 LD   1
 SUB  1
 SDEL 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX temp_rcpt
 WRI  
 LEAX temp_rcpt
 LD   180
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string temp_rcpt
 PDST   ; Level 1
#srcline 321 ;        else
 JMP  fbSmtp_L80
fbSmtp_L79:
#srcline 322 ;          ptrUsint := ADR(body_rcpt);
 LEAX body_rcpt
#debug pointer body_rcpt
 LEAY ptrUsint
 WRIL 
#debug_left pointer ptrUsint
#srcline 323 ;          if ptrUsint^ = 0 then
 LEAY ptrUsint
 LDIL    ; dereference 
 LDI  
#debug usint ptrUsint^
 LD   usint 0
 EQ
 JMC  fbSmtp_L81
#srcline 324 ;            body_rcpt := '<'+temp_rcpt+'>';    //priprava pro telo zpravy
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   80
 DST    ; Level 1
 LEA  _str_fbSmtp_7
 SCON 
 LEAX temp_rcpt
#debug string temp_rcpt
 SCON 
 LEA  _str_fbSmtp_8
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX body_rcpt
 WRI  
 LEAX body_rcpt
 LD   80
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string body_rcpt
 PDST   ; Level 1
#srcline 325 ;          else
 JMP  fbSmtp_L82
fbSmtp_L81:
#srcline 326 ;            body_rcpt := body_rcpt+',<'+temp_rcpt+'>';    //priprava pro telo zpravy
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   80
 DST    ; Level 1
 LEAX body_rcpt
#debug string body_rcpt
 SCON 
 LEA  _str_fbSmtp_9
 SCON 
 LEAX temp_rcpt
#debug string temp_rcpt
 SCON 
 LEA  _str_fbSmtp_10
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX body_rcpt
 WRI  
 LEAX body_rcpt
 LD   80
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string body_rcpt
 PDST   ; Level 1
#srcline 327 ;          end_if;
fbSmtp_L82:
#srcline 328 ;        end_if;
fbSmtp_L80:
#srcline 329 ;//        body_rcpt := body_rcpt+'<'+temp_rcpt+'>';    //priprava pro telo zpravy
#srcline 330 ;        cmd := 'RCPT TO:<'+temp_rcpt+SMTP_END_OF_LINE_2_;
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LEA  _str_fbSmtp_11
 SCON 
 LEAX temp_rcpt
#debug string temp_rcpt
 SCON 
 LEA  SMTP_END_OF_LINE_2_
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX cmd
 WRI  
 LEAX cmd
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string cmd
 PDST   ; Level 1
#srcline 331 ;        state := ss_Smtprxrcptto;
 LD   udint 16  ; TSmtpState#ss_SmtpRxRcptTo
 WRX  state
#debug_left usint state
 JMP  fbSmtp_L19
fbSmtp_L76:
 LD   16
 LDY  P0__st__
 EQ  
 JMC  fbSmtp_L83
#srcline 333 ;      // cekani na odezvu --------------------------------------------------------
#srcline 334 ;      ss_Smtprxrcptto :
#srcline 335 ;        Send_to.rq  := FALSE;
 LD   bool 0       ; false
 WRX  Send_to~rq
#debug_left bool Send_to.rq
#srcline 336 ;        if mesRec then
 LDX  mesRec
#debug bool mesRec
 JMC  fbSmtp_L84
#srcline 337 ;          {$IFDEF _DEBUG} dbg4 := cmd; {$END_IF}
#srcline 338 ;          if tmpReplyCode = 250 or tmpReplyCode = 251 then //je to odezva typu '250' nebo '251'?
 LDY  tmpReplyCode
#debug uint tmpReplyCode
 LD   uint 250
 EQ
 LDY  tmpReplyCode
#debug uint tmpReplyCode
 LD   uint 251
 EQ
 OR  
 JMC  fbSmtp_L86
#srcline 339 ;            if len(copy_rcpt) = 0 then
 LEAX copy_rcpt
#debug string copy_rcpt
 SLEN 
 LD   int 0
 EQ
 JMC  fbSmtp_L88
#srcline 340 ;              state := ss_Smtptxdata;         //telo zpravy
 LD   udint 17  ; TSmtpState#ss_SmtpTxData
 WRX  state
#debug_left usint state
#srcline 341 ;            else
 JMP  fbSmtp_L89
fbSmtp_L88:
#srcline 342 ;              state := ss_Smtptxrcptto;       //dalsi prijemce
 LD   udint 15  ; TSmtpState#ss_SmtpTxRcptTo
 WRX  state
#debug_left usint state
#srcline 343 ;//              body_rcpt := body_rcpt+',';
#srcline 344 ;            end_if;
fbSmtp_L89:
#srcline 345 ;          else
 JMP  fbSmtp_L87
fbSmtp_L86:
#srcline 346 ;            state := ss_Smtprxerror;          //chybna odezva
 LD   udint 31  ; TSmtpState#ss_SmtpRxError
 WRX  state
#debug_left usint state
#srcline 347 ;          end_if;
fbSmtp_L87:
#srcline 348 ;        elsif timeout_elapsed then   //server neodpovida
 JMP  fbSmtp_L85
fbSmtp_L84:
 LDY  timeout_elapsed
#debug bool timeout_elapsed
 JMC  fbSmtp_L90
#srcline 349 ;          state := ss_Smtprxtimeout;
 LD   udint 30  ; TSmtpState#ss_SmtpRxTimeout
 WRX  state
#debug_left usint state
#srcline 350 ;        end_if;
 JMP  fbSmtp_L85
fbSmtp_L90:
fbSmtp_L85:
 JMP  fbSmtp_L19
fbSmtp_L83:
 LD   17
 LDY  P0__st__
 EQ  
 JMC  fbSmtp_L91
#srcline 351 ;      // posleme telo zpravy -----------------------------------------------------
#srcline 352 ;      ss_Smtptxdata :
#srcline 353 ;        cmd := 'DATA$r$l';
 LD   0   ; null string
 LEAX cmd
 WRI  
 LEAX cmd
 LD   255
 DST    ; Level 1
 LEA  _str_fbSmtp_12
 SCON 
#debug_left string cmd
 PDST   ; Level 1
#srcline 354 ;        Send_to.rq  := TRUE;
 LD   bool -1       ; true
 WRX  Send_to~rq
#debug_left bool Send_to.rq
#srcline 355 ;        state := ss_Smtprxdata;
 LD   udint 18  ; TSmtpState#ss_SmtpRxData
 WRX  state
#debug_left usint state
 JMP  fbSmtp_L19
fbSmtp_L91:
 LD   18
 LDY  P0__st__
 EQ  
 JMC  fbSmtp_L92
#srcline 357 ;      // cekani na odezvu --------------------------------------------------------
#srcline 358 ;      ss_Smtprxdata :
#srcline 359 ;        Send_to.rq  := FALSE;
 LD   bool 0       ; false
 WRX  Send_to~rq
#debug_left bool Send_to.rq
#srcline 360 ;        if mesRec then
 LDX  mesRec
#debug bool mesRec
 JMC  fbSmtp_L93
#srcline 361 ;          {$IFDEF _DEBUG} dbg5 := cmd; {$END_IF}
#srcline 362 ;          if tmpReplyCode = 354 then //je to odezva typu '354'?
 LDY  tmpReplyCode
#debug uint tmpReplyCode
 LD   uint 354
 EQ
 JMC  fbSmtp_L95
#srcline 363 ;            state := ss_Smtptxdate;
 LD   udint 32  ; TSmtpState#ss_SmtpTxDate
 WRX  state
#debug_left usint state
#srcline 364 ;          else
 JMP  fbSmtp_L96
fbSmtp_L95:
#srcline 365 ;            state := ss_Smtprxerror;        //chybna odezva
 LD   udint 31  ; TSmtpState#ss_SmtpRxError
 WRX  state
#debug_left usint state
#srcline 366 ;          end_if;
fbSmtp_L96:
#srcline 367 ;        elsif timeout_elapsed then   //server neodpovida
 JMP  fbSmtp_L94
fbSmtp_L93:
 LDY  timeout_elapsed
#debug bool timeout_elapsed
 JMC  fbSmtp_L97
#srcline 368 ;          state := ss_Smtprxtimeout;
 LD   udint 30  ; TSmtpState#ss_SmtpRxTimeout
 WRX  state
#debug_left usint state
#srcline 369 ;        end_if;
 JMP  fbSmtp_L94
fbSmtp_L97:
fbSmtp_L94:
 JMP  fbSmtp_L19
fbSmtp_L92:
 LD   32
 LDY  P0__st__
 EQ  
 JMC  fbSmtp_L98
#srcline 371 ;      // posleme datum kdy jsme zpravu poslali -----------------------------------
#srcline 372 ;      ss_Smtptxdate :
#srcline 373 ;        cmd := 'DATE: ' + GetDateAndTime_RFC2822(UtcOff := UtcOff)+INTERNETLIB_END_OF_LINE_;
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LEA  _str_fbSmtp_13
 SCON 
 NXT
 LDX  UtcOff
#debug int UtcOff
 EXTW 
 WR   __Instance__GetDateAndTime_RFC2822~UtcOff
#debug_left int __Instance__GetDateAndTime_RFC2822~UtcOff
 PRV
 LEA  __Instance__GetDateAndTime_RFC2822
 CAL  GetDateAndTime_RFC2822_L0

 SCON 
 LEA  INTERNETLIB_END_OF_LINE_
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX cmd
 WRI  
 LEAX cmd
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string cmd
 PDST   ; Level 1
#srcline 374 ;        Send_to.rq  := TRUE;
 LD   bool -1       ; true
 WRX  Send_to~rq
#debug_left bool Send_to.rq
#srcline 375 ;        state := ss_Smtptxdatafrom;
 LD   udint 19  ; TSmtpState#ss_SmtpTxDataFrom
 WRX  state
#debug_left usint state
 JMP  fbSmtp_L19
fbSmtp_L98:
 LD   19
 LDY  P0__st__
 EQ  
 JMC  fbSmtp_L99
#srcline 377 ;      // posleme telo zpravy - odesilatel ----------------------------------------
#srcline 378 ;      ss_Smtptxdatafrom :
#srcline 379 ;        cmd := 'FROM: "'+SendName+'" <'+sender+SMTP_END_OF_LINE_2_;
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LEA  _str_fbSmtp_14
 SCON 
 LDX  SendName
#debug string SendName
 SCON 
 LEA  _str_fbSmtp_15
 SCON 
 LDX  sender
#debug string sender
 SCON 
 LEA  SMTP_END_OF_LINE_2_
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX cmd
 WRI  
 LEAX cmd
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string cmd
 PDST   ; Level 1
#srcline 380 ;        Send_to.rq  := TRUE;
 LD   bool -1       ; true
 WRX  Send_to~rq
#debug_left bool Send_to.rq
#srcline 381 ;        state := ss_Smtptxdatato;
 LD   udint 20  ; TSmtpState#ss_SmtpTxDataTo
 WRX  state
#debug_left usint state
 JMP  fbSmtp_L19
fbSmtp_L99:
 LD   20
 LDY  P0__st__
 EQ  
 JMC  fbSmtp_L100
#srcline 383 ;      // posleme telo zpravy - prijemce ------------------------------------------
#srcline 384 ;      ss_Smtptxdatato :
#srcline 385 ;        cmd := 'TO: '+body_rcpt+INTERNETLIB_END_OF_LINE_;
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LEA  _str_fbSmtp_16
 SCON 
 LEAX body_rcpt
#debug string body_rcpt
 SCON 
 LEA  INTERNETLIB_END_OF_LINE_
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX cmd
 WRI  
 LEAX cmd
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string cmd
 PDST   ; Level 1
#srcline 386 ;        IF genMessageID THEN
 LDX  genMessageID
#debug bool genMessageID
 JMC  fbSmtp_L101
#srcline 387 ;          state := ss_SmtpTxMessageId;
 LD   udint 34  ; TSmtpState#ss_SmtpTxMessageId
 WRX  state
#debug_left usint state
#srcline 388 ;        ELSE
 JMP  fbSmtp_L102
fbSmtp_L101:
#srcline 389 ;          state := ss_Smtptxdatasubject;
 LD   udint 21  ; TSmtpState#ss_SmtpTxDataSubject
 WRX  state
#debug_left usint state
#srcline 390 ;        END_IF;
fbSmtp_L102:
 JMP  fbSmtp_L19
fbSmtp_L100:
 LD   34
 LDY  P0__st__
 EQ  
 JMC  fbSmtp_L103
#srcline 392 ;      //pokus o vygenerovani Message-ID
#srcline 393 ;      ss_SmtpTxMessageId:
#srcline 394 ;        pos := FIND(Sender, '@');
 LDX  Sender
#debug string Sender
 LEA  _str_fbSmtp_17
 SFND 
 WRY  pos
#debug_left int pos
#srcline 395 ;        ptrText := ADR(Sender) + INT_TO_UDINT(pos) - 1;
 LDX  Sender
#debug pointer Sender
 LDY  pos
#debug int pos
 EXTW 
 ADD
 LD   udint 1
 SUB
 LEAX ptrText
 WRIL 
#debug_left pointer ptrText
#srcline 396 ;        IF pos > 0 THEN
 LDY  pos
#debug int pos
 EXTW 
 LD   int 0
 GTS
 JMC  fbSmtp_L104
#srcline 397 ;          GetMACaddress(ethChan := ETH1, MacAdr := mac);
 NXT
 LD   usint 225
 WR   __Instance__GetMACaddress~ethChan
#debug_left usint __Instance__GetMACaddress~ethChan
 LEAY mac
 WR   __Instance__GetMACaddress~MacAdr
#debug_left pointer __Instance__GetMACaddress.MacAdr
 PRV
 LEA  __Instance__GetMACaddress
 CAL  GetMACaddress_L0
#srcline 398 ;          {ASM}
#srcline 399
             LDY word mac[0]
#srcline 400
             BAS
#srcline 401
             WRX dword cmd[0]
#srcline 402
             LDY word mac[2]
#srcline 403
             BAS
#srcline 404
             WRX dword cmd[4]
#srcline 405
             LDY word mac[4]
#srcline 406
             BAS
#srcline 407
             WRX dword cmd[8]
#srcline 408
             LD  0
#srcline 409
             WRX cmd[12]
#srcline 410 ;          {END_ASM}
#srcline 411 ;          cmd := 'Message-ID: <' + DT_TO_STRINGF(in := GetRTC(), format := '%TYYMMDDhhmmsszzz') +
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LEA  _str_fbSmtp_18
 SCON 
 NXT
 LEA  __Instance__GetRTC
 CAL  GetRTC_L0
 WR   __Instance__DT_TO_STRINGF~in
#debug_left dt __Instance__DT_TO_STRINGF~in
 LD   0   ; null string
 LEA  __Instance__DT_TO_STRINGF~format
 WRI 
 LEA  __Instance__DT_TO_STRINGF~format
 LD   80
 DST    ; Level 2
 LEA  _str_fbSmtp_19
 SCON 
#debug_left string __Instance__DT_TO_STRINGF~format
 PDST   ; Level 2
 PRV
 LEA  __Instance__DT_TO_STRINGF
 CAL  DT_TO_STRINGF_L0

 SCON 
#srcline 412 ;                  cmd +
 LEAX cmd
#debug string cmd
 SCON 
#srcline 413 ;                  ptrText^ +
 LEAX ptrText
 LDIL    ; dereference 
#debug string ptrText^
 SCON 
#srcline 414 ;                  SMTP_END_OF_LINE_2_;
 LEA  SMTP_END_OF_LINE_2_
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX cmd
 WRI  
 LEAX cmd
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string cmd
 PDST   ; Level 1
#srcline 415 ;        END_IF;
fbSmtp_L104:
#srcline 416 ;        state := ss_Smtptxdatasubject;
 LD   udint 21  ; TSmtpState#ss_SmtpTxDataSubject
 WRX  state
#debug_left usint state
 JMP  fbSmtp_L19
fbSmtp_L103:
 LD   21
 LDY  P0__st__
 EQ  
 JMC  fbSmtp_L106
#srcline 417 ;      // posleme telo zpravy - predmet -------------------------------------------
#srcline 418 ;      ss_Smtptxdatasubject :
#srcline 419 ;        IF LEN(charset) > 0 THEN
 LEAX charset
#debug string charset
 SLEN 
 LD   int 0
 GTS
 JMC  fbSmtp_L107
#srcline 420 ;          cmd := 'SUBJECT: =?'+charset+'?B?'+Base64_encode_string(subject)+'?=$r$l';
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LEA  _str_fbSmtp_20
 SCON 
 LEAX charset
#debug string charset
 SCON 
 LEA  _str_fbSmtp_21
 SCON 
 NXT
 LD   0   ; null string
 LEA  __Instance__Base64_encode_string~data
 WRI 
 LEA  __Instance__Base64_encode_string~data
 LD   60
 DST    ; Level 2
 LDX  subject
#debug string subject
 SCON 
#debug_left string __Instance__Base64_encode_string~data
 PDST   ; Level 2
 PRV
 LEA  __Instance__Base64_encode_string
 CAL  Base64_encode_string_L0

 SCON 
 LEA  _str_fbSmtp_22
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX cmd
 WRI  
 LEAX cmd
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string cmd
 PDST   ; Level 1
#srcline 421 ;        ELSE
 JMP  fbSmtp_L108
fbSmtp_L107:
#srcline 422 ;          cmd := 'SUBJECT: '+subject+INTERNETLIB_END_OF_LINE_;
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LEA  _str_fbSmtp_23
 SCON 
 LDX  subject
#debug string subject
 SCON 
 LEA  INTERNETLIB_END_OF_LINE_
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX cmd
 WRI  
 LEAX cmd
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string cmd
 PDST   ; Level 1
#srcline 423 ;        END_IF;
fbSmtp_L108:
#srcline 424 ;        state := ss_Smtptxmultipart;
 LD   udint 22  ; TSmtpState#ss_SmtpTxMultipart
 WRX  state
#debug_left usint state
 JMP  fbSmtp_L19
fbSmtp_L106:
 LD   22
 LDY  P0__st__
 EQ  
 JMC  fbSmtp_L109
#srcline 425 ;      // posleme odelovac casti --------------------------------------------------
#srcline 426 ;     // posleme odelovac casti v2 --------------------------------------------------
#srcline 427 ;      ss_Smtptxmultipart :
#srcline 428 ;        cmd := 'MIME-Version: 1.0$r$lContent-Type: multipart/mixed;$r$l boundary="----=_NextPart_000_000D_666F7874.7465636F"$r$l$r$lThis is a message with multiple parts in MIME format.$r$l$r$l------=_NextPart_000_000D_666F7874.7465636F$r$l';
 LD   0   ; null string
 LEAX cmd
 WRI  
 LEAX cmd
 LD   255
 DST    ; Level 1
 LEA  _str_fbSmtp_24
 SCON 
#debug_left string cmd
 PDST   ; Level 1
#srcline 429 ;        state := ss_SmtptxContentType;
 LD   udint 33  ; TSmtpState#ss_SmtpTxContentType
 WRX  state
#debug_left usint state
 JMP  fbSmtp_L19
fbSmtp_L109:
 LD   33
 LDY  P0__st__
 EQ  
 JMC  fbSmtp_L110
#srcline 430 ;     // posleme kodovani tela textu-------------------------------------------------
#srcline 431 ;      ss_SmtptxContentType :
#srcline 432 ;        IF LEN(charset) > 0 THEN
 LEAX charset
#debug string charset
 SLEN 
 LD   int 0
 GTS
 JMC  fbSmtp_L111
#srcline 433 ;          cmd := 'Content-Type: text/plain; charset='+charset+'$r$l$r$l';
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LEA  _str_fbSmtp_25
 SCON 
 LEAX charset
#debug string charset
 SCON 
 LEA  _str_fbSmtp_26
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX cmd
 WRI  
 LEAX cmd
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string cmd
 PDST   ; Level 1
#srcline 434 ;        ELSE
 JMP  fbSmtp_L112
fbSmtp_L111:
#srcline 435 ;          cmd := 'Content-Type: text/plain;$r$l$r$l';
 LD   0   ; null string
 LEAX cmd
 WRI  
 LEAX cmd
 LD   255
 DST    ; Level 1
 LEA  _str_fbSmtp_27
 SCON 
#debug_left string cmd
 PDST   ; Level 1
#srcline 436 ;        END_IF;
fbSmtp_L112:
#srcline 437 ;        ptrText := ADR(text);
 LDX  text
#debug pointer text
 LEAX ptrText
 WRIL 
#debug_left pointer ptrText
#srcline 438 ;        state := ss_Smtptxdatatext;
 LD   udint 23  ; TSmtpState#ss_SmtpTxDataText
 WRX  state
#debug_left usint state
 JMP  fbSmtp_L19
fbSmtp_L110:
 LD   23
 LDY  P0__st__
 EQ  
 JMC  fbSmtp_L113
#srcline 439 ;      // posleme telo zpravy - text zpravy ---------------------------------------
#srcline 440 ;      ss_Smtptxdatatext :
#srcline 441 ;        IF body_lines < 1 THEN
 LDX  body_lines
#debug sint body_lines
 EXTB 
 LD   sint 1
 LTS
 JMC  fbSmtp_L114
#srcline 442 ;          cmd := INTERNETLIB_END_OF_LINE_;   //nedavat nic kdyz je pocet radek mensi nez 1
 LD   0   ; null string
 LEAX cmd
 WRI  
 LEAX cmd
 LD   255
 DST    ; Level 1
 LEA  INTERNETLIB_END_OF_LINE_
 SCON 
#debug_left string cmd
 PDST   ; Level 1
#srcline 443 ;        ELSE
 JMP  fbSmtp_L115
fbSmtp_L114:
#srcline 444 ;          cmd := ptrText^+INTERNETLIB_END_OF_LINE_;
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LEAX ptrText
 LDIL    ; dereference 
#debug string ptrText^
 SCON 
 LEA  INTERNETLIB_END_OF_LINE_
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX cmd
 WRI  
 LEAX cmd
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string cmd
 PDST   ; Level 1
#srcline 445 ;        END_IF;
fbSmtp_L115:
#srcline 446 ;        body_lines := body_lines - 1; ptrText := ptrText + 81; // sizeof(string)
 LDX  body_lines
#debug sint body_lines
 EXTB 
 LD   sint 1
 SUB
 EXTB
 WRX  body_lines
#debug_left sint body_lines
 LEAX ptrText
 LDIL 
#debug pointer ptrText
 LD   udint 81
 ADD
 LEAX ptrText
 WRIL 
#debug_left pointer ptrText
#srcline 448 ;        if body_lines < 1 then
 LDX  body_lines
#debug sint body_lines
 EXTB 
 LD   sint 1
 LTS
 JMC  fbSmtp_L116
#srcline 449 ;          IF LEN(Attach) > 0 THEN
 LDX  Attach
#debug string Attach
 SLEN 
 LD   int 0
 GTS
 JMC  fbSmtp_L118
#srcline 450 ;            h := FileOpen(fileName := Attach, mode := F_READ);
 NXT
 LDX  Attach
 WR   __Instance__FileOpen~fileName
#debug_left pointer __Instance__FileOpen.fileName
 LD   udint 0  ; TF_MODE#F_READ
 WR   __Instance__FileOpen~mode
#debug_left usint __Instance__FileOpen~mode
 PRV
 LEA  __Instance__FileOpen
 CAL  FileOpen_L0
 WRX  h
#debug_left udint h
#srcline 451 ;            state := ss_Smtptxattachement;
 LD   udint 24  ; TSmtpState#ss_SmtpTxAttachement
 WRX  state
#debug_left usint state
#srcline 452 ;          ELSE
 JMP  fbSmtp_L119
fbSmtp_L118:
#srcline 453 ;            state := ss_Smtptxendofmail;
 LD   udint 26  ; TSmtpState#ss_SmtpTxEndOfMail
 WRX  state
#debug_left usint state
#srcline 454 ;          END_IF;
fbSmtp_L119:
#srcline 455 ;          IF state = ss_Smtptxattachement & h = INVALID_HANDLE_VALUE THEN
 LDX  state
#debug usint state
 LD   udint 24  ; TSmtpState#ss_SmtpTxAttachement
 EQ
 LDX  h
#debug udint h
 LD   udint 0
 EQ
 AND
 JMC  fbSmtp_L120
#srcline 456 ;            Err   := 1;
 LD   bool -1      ; true
 WRX  Err
#debug_left bool Err
#srcline 457 ;            ErrId := 3; //cannot open file
 LD   usint 3
 WRX  ErrId
#debug_left usint ErrId
#srcline 458 ;            state := ss_Smtptxendofmail;
 LD   udint 26  ; TSmtpState#ss_SmtpTxEndOfMail
 WRX  state
#debug_left usint state
#srcline 459 ;          END_IF;
fbSmtp_L120:
#srcline 460 ;        END_IF;
fbSmtp_L116:
 JMP  fbSmtp_L19
fbSmtp_L113:
 LD   24
 LDY  P0__st__
 EQ  
 JMC  fbSmtp_L122
#srcline 461 ;      // priloha zacatek----------------------------------------------------------
#srcline 462 ;      ss_Smtptxattachement:
#srcline 463 ;        //najit posledni lomitko
#srcline 464 ;        ptrUsint := ADR(Attach);
 LDX  Attach
#debug pointer Attach
 LEAY ptrUsint
 WRIL 
#debug_left pointer ptrUsint
#srcline 465 ;        ptrText  := ptrUsint;
 LEAY ptrUsint
 LDIL 
#debug pointer ptrUsint
 LEAX ptrText
 WRIL 
#debug_left pointer ptrText
#srcline 466 ;        WHILE ptrUsint^ <> 0 DO
fbSmtp_L123:
 LEAY ptrUsint
 LDIL    ; dereference 
 LDI  
#debug usint ptrUsint^
 LD   usint 0
 EQ
 NEG
 JMC  fbSmtp_L124
 DBG 
#srcline 467 ;          IF ptrUsint^ = 16#2F THEN //'/'
 LEAY ptrUsint
 LDIL    ; dereference 
 LDI  
#debug usint ptrUsint^
 LD   usint $2F
 EQ
 JMC  fbSmtp_L125
#srcline 468 ;            ptrText  := ptrUsint+1;
 LEAY ptrUsint
 LDIL 
#debug pointer ptrUsint
 LD   udint 1
 ADD
 LEAX ptrText
 WRIL 
#debug_left pointer ptrText
#srcline 469 ;          END_IF;
fbSmtp_L125:
#srcline 470 ;          ptrUsint := ptrUsint + 1;
 LEAY ptrUsint
 LDIL 
#debug pointer ptrUsint
 LD   udint 1
 ADD
 LEAY ptrUsint
 WRIL 
#debug_left pointer ptrUsint
#srcline 471 ;        END_WHILE;
 JMP  fbSmtp_L123
fbSmtp_L124:
 NOP  -1
#srcline 473 ;        IF attachementType = '' THEN
 LEAX attachementType
#debug string attachementType
 LEA  _str_fbSmtp_28
 SCMP 
 EQ   0
 JMC  fbSmtp_L127
#srcline 474 ;          attachementType := 'application/octet-stream';
 LD   0   ; null string
 LEAX attachementType
 WRI  
 LEAX attachementType
 LD   32
 DST    ; Level 1
 LEA  _str_fbSmtp_29
 SCON 
#debug_left string attachementType
 PDST   ; Level 1
#srcline 475 ;        END_IF;
fbSmtp_L127:
#srcline 477 ;        cmd := '------=_NextPart_000_000D_666F7874.7465636F$r$lContent-Type: '+attachementType+'; name="'+ptrText^+'"$r$l'+
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LEA  _str_fbSmtp_30
 SCON 
 LEAX attachementType
#debug string attachementType
 SCON 
 LEA  _str_fbSmtp_31
 SCON 
 LEAX ptrText
 LDIL    ; dereference 
#debug string ptrText^
 SCON 
 LEA  _str_fbSmtp_32
 SCON 
#srcline 478 ;               'Content-Transfer-Encoding: base64$r$lContent-Disposition: attachment; filename="'+ptrText^+'"$r$l$r$l';
 LEA  _str_fbSmtp_33
 SCON 
 LEAX ptrText
 LDIL    ; dereference 
#debug string ptrText^
 SCON 
 LEA  _str_fbSmtp_34
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX cmd
 WRI  
 LEAX cmd
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string cmd
 PDST   ; Level 1
#srcline 480 ;        state := ss_Smtptxattachementbody;
 LD   udint 25  ; TSmtpState#ss_SmtpTxAttachementBody
 WRX  state
#debug_left usint state
 JMP  fbSmtp_L19
fbSmtp_L122:
 LD   25
 LDY  P0__st__
 EQ  
 JMC  fbSmtp_L129
#srcline 481 ;      // priloha telo----------------------------------------------------------
#srcline 482 ;      ss_Smtptxattachementbody:
#srcline 483 ;        tmpud := FileRead(h, PTR_TO_UDINT(ADR(temp_rcpt)), SMTP_MAXIMUM_FILE_LINE_LENGTH_);
 NXT
 LDX  h
#debug udint h
 WR   __Instance__FileRead~hFile
#debug_left udint __Instance__FileRead~hFile
 LEAX temp_rcpt
#debug pointer temp_rcpt
 WR   __Instance__FileRead~adrBuf
#debug_left udint __Instance__FileRead~adrBuf
 LD   udint 171
 WR   __Instance__FileRead~size
#debug_left udint __Instance__FileRead~size
 PRV
 LEA  __Instance__FileRead
 CAL  FileRead_L0
 WRY  tmpud
#debug_left udint tmpud
#srcline 484 ;        cmd := Base64_encode_ptr_string(ADR(temp_rcpt), UDINT_TO_UINT(min(SMTP_BASE64_LEN_,tmpud))) + '$r$l';
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 NXT
 LEAX temp_rcpt
#debug pointer temp_rcpt
 LEA  __Instance__Base64_encode_ptr_string~data
 WRIL 
#debug_left udint __Instance__Base64_encode_ptr_string~data
 LD   udint 57
 LDY  tmpud
#debug udint tmpud
 MIN
 AND  $FFFF
 WR   __Instance__Base64_encode_ptr_string~dataLen
#debug_left uint __Instance__Base64_encode_ptr_string~dataLen
 PRV
 LEA  __Instance__Base64_encode_ptr_string
 CAL  Base64_encode_ptr_string_L0

 SCON 
 LEA  _str_fbSmtp_35
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX cmd
 WRI  
 LEAX cmd
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string cmd
 PDST   ; Level 1
#srcline 485 ;        IF tmpud > SMTP_BASE64_LEN_ THEN
 LDY  tmpud
#debug udint tmpud
 LD   udint 57
 GT
 JMC  fbSmtp_L130
#srcline 486 ;           cmd := cmd + Base64_encode_ptr_string(ADR(temp_rcpt)+SMTP_BASE64_LEN_, UDINT_TO_UINT(min(SMTP_BASE64_LEN_,tmpud-SMTP_BASE64_LEN_))) + '$r$l';
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LEAX cmd
#debug string cmd
 SCON 
 NXT
 LEAX temp_rcpt
#debug pointer temp_rcpt
 LD   udint 57
 ADD
 LEA  __Instance__Base64_encode_ptr_string~data
 WRIL 
#debug_left udint __Instance__Base64_encode_ptr_string~data
 LD   udint 57
 LDY  tmpud
#debug udint tmpud
 LD   udint 57
 SUB
 MIN
 AND  $FFFF
 WR   __Instance__Base64_encode_ptr_string~dataLen
#debug_left uint __Instance__Base64_encode_ptr_string~dataLen
 PRV
 LEA  __Instance__Base64_encode_ptr_string
 CAL  Base64_encode_ptr_string_L0

 SCON 
 LEA  _str_fbSmtp_36
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX cmd
 WRI  
 LEAX cmd
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string cmd
 PDST   ; Level 1
#srcline 487 ;        END_IF;
fbSmtp_L130:
#srcline 488 ;        IF tmpud > SMTP_BASE64_LEN2_ THEN
 LDY  tmpud
#debug udint tmpud
 LD   udint 114
 GT
 JMC  fbSmtp_L132
#srcline 489 ;           cmd := cmd + Base64_encode_ptr_string(ADR(temp_rcpt)+SMTP_BASE64_LEN2_, UDINT_TO_UINT(tmpud-SMTP_BASE64_LEN2_)) + '$r$l';
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LEAX cmd
#debug string cmd
 SCON 
 NXT
 LEAX temp_rcpt
#debug pointer temp_rcpt
 LD   udint 114
 ADD
 LEA  __Instance__Base64_encode_ptr_string~data
 WRIL 
#debug_left udint __Instance__Base64_encode_ptr_string~data
 LDY  tmpud
#debug udint tmpud
 LD   udint 114
 SUB
 AND  $FFFF
 WR   __Instance__Base64_encode_ptr_string~dataLen
#debug_left uint __Instance__Base64_encode_ptr_string~dataLen
 PRV
 LEA  __Instance__Base64_encode_ptr_string
 CAL  Base64_encode_ptr_string_L0

 SCON 
 LEA  _str_fbSmtp_37
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX cmd
 WRI  
 LEAX cmd
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string cmd
 PDST   ; Level 1
#srcline 490 ;        END_IF;
fbSmtp_L132:
#srcline 491 ;        //Send_to.rq  := TRUE;
#srcline 492 ;        IF tmpud < SMTP_MAXIMUM_FILE_LINE_LENGTH_ THEN
 LDY  tmpud
#debug udint tmpud
 LD   udint 171
 LT
 JMC  fbSmtp_L134
#srcline 493 ;          state := ss_Smtptxendofmail;
 LD   udint 26  ; TSmtpState#ss_SmtpTxEndOfMail
 WRX  state
#debug_left usint state
#srcline 494 ;        END_IF;
fbSmtp_L134:
 JMP  fbSmtp_L19
fbSmtp_L129:
 LD   26
 LDY  P0__st__
 EQ  
 JMC  fbSmtp_L136
#srcline 495 ;      // konec emailu ------------------------------------------------------------
#srcline 496 ;      (*
#srcline 497 ;      ss_SmtpPause:
#srcline 498 ;        IF timpause - %SL52 <= T#0s THEN
#srcline 499 ;          state := ss_Smtptxattachementbody;
#srcline 500 ;        END_IF;
#srcline 501 ;        return;
#srcline 502 ;      *)
#srcline 503 ;      ss_Smtptxendofmail:
#srcline 504 ;        cmd := '------=_NextPart_000_000D_666F7874.7465636F--$r$l.$r$l';
 LD   0   ; null string
 LEAX cmd
 WRI  
 LEAX cmd
 LD   255
 DST    ; Level 1
 LEA  _str_fbSmtp_38
 SCON 
#debug_left string cmd
 PDST   ; Level 1
#srcline 505 ;        state := ss_Smtprxack;
 LD   udint 27  ; TSmtpState#ss_SmtpRxAck
 WRX  state
#debug_left usint state
 JMP  fbSmtp_L19
fbSmtp_L136:
 LD   27
 LDY  P0__st__
 EQ  
 JMC  fbSmtp_L137
#srcline 506 ;      // cekani na odezvu --------------------------------------------------------
#srcline 507 ;      ss_Smtprxack :
#srcline 508 ;        Send_to.rq  := FALSE;
 LD   bool 0       ; false
 WRX  Send_to~rq
#debug_left bool Send_to.rq
#srcline 509 ;        if mesRec then
 LDX  mesRec
#debug bool mesRec
 JMC  fbSmtp_L138
#srcline 510 ;          {$IFDEF _DEBUG} dbg6 := cmd; {$END_IF}
#srcline 511 ;          if tmpReplyCode = 250 then //je to odezva typu '250'?
 LDY  tmpReplyCode
#debug uint tmpReplyCode
 LD   uint 250
 EQ
 JMC  fbSmtp_L140
#srcline 512 ;            state := ss_Smtptxquit;
 LD   udint 28  ; TSmtpState#ss_SmtpTxQuit
 WRX  state
#debug_left usint state
#srcline 513 ;          else
 JMP  fbSmtp_L141
fbSmtp_L140:
#srcline 514 ;            state := ss_Smtprxerror;          //chybna odezva
 LD   udint 31  ; TSmtpState#ss_SmtpRxError
 WRX  state
#debug_left usint state
#srcline 515 ;          end_if;
fbSmtp_L141:
#srcline 516 ;        elsif timeout_elapsed then     //server neodpovida
 JMP  fbSmtp_L139
fbSmtp_L138:
 LDY  timeout_elapsed
#debug bool timeout_elapsed
 JMC  fbSmtp_L142
#srcline 517 ;          state := ss_Smtprxtimeout;
 LD   udint 30  ; TSmtpState#ss_SmtpRxTimeout
 WRX  state
#debug_left usint state
#srcline 518 ;        end_if;
 JMP  fbSmtp_L139
fbSmtp_L142:
fbSmtp_L139:
 JMP  fbSmtp_L19
fbSmtp_L137:
 LD   28
 LDY  P0__st__
 EQ  
 JMC  fbSmtp_L143
#srcline 520 ;      // ukonceni spojeni --------------------------------------------------------
#srcline 521 ;      ss_Smtptxquit :
#srcline 522 ;        cmd := 'QUIT$r$l';
 LD   0   ; null string
 LEAX cmd
 WRI  
 LEAX cmd
 LD   255
 DST    ; Level 1
 LEA  _str_fbSmtp_39
 SCON 
#debug_left string cmd
 PDST   ; Level 1
#srcline 523 ;        Send_to.rq  := TRUE;
 LD   bool -1       ; true
 WRX  Send_to~rq
#debug_left bool Send_to.rq
#srcline 524 ;        state := ss_Smtprxclose;
 LD   udint 29  ; TSmtpState#ss_SmtpRxClose
 WRX  state
#debug_left usint state
 JMP  fbSmtp_L19
fbSmtp_L143:
 LD   29
 LDY  P0__st__
 EQ  
 JMC  fbSmtp_L144
#srcline 526 ;      // cekani na ukonceni spojeni ----------------------------------------------
#srcline 527 ;      ss_Smtprxclose :
#srcline 528 ;        Send_to.rq  := FALSE;
 LD   bool 0       ; false
 WRX  Send_to~rq
#debug_left bool Send_to.rq
#srcline 529 ;        if IsEstabTCPconnection(chanCode := chanCode) = false then  // spojeni ukonceno
 NXT
 LDX  chanCode
#debug uint chanCode
 WR   __Instance__IsEstabTCPconnection~chanCode
#debug_left uint __Instance__IsEstabTCPconnection~chanCode
 PRV
 LEA  __Instance__IsEstabTCPconnection
 CAL  IsEstabTCPconnection_L0
 LD   bool 0       ; false
 XOR
 NEG
 JMC  fbSmtp_L145
#srcline 530 ;          Done := NOT Err;
 LDX  Err
#debug bool Err
 NEG
 WRX  Done
#debug_left bool Done
#srcline 531 ;          state  := ss_Smtpinit;
 LD   udint 0  ; TSmtpState#ss_SmtpInit
 WRX  state
#debug_left usint state
#srcline 532 ;        elsif mesRec then            //prijata odezva
 JMP  fbSmtp_L146
fbSmtp_L145:
 LDX  mesRec
#debug bool mesRec
 JMC  fbSmtp_L147
#srcline 533 ;          {$IFDEF _DEBUG} dbg7 := cmd; {$END_IF}
#srcline 534 ;          if tmpReplyCode = 221 then //je to odezva typu '221'?
 LDY  tmpReplyCode
#debug uint tmpReplyCode
 LD   uint 221
 EQ
 JMC  fbSmtp_L148
#srcline 535 ;            Done := NOT Err;
 LDX  Err
#debug bool Err
 NEG
 WRX  Done
#debug_left bool Done
#srcline 536 ;            state  := ss_Smtpinit;
 LD   udint 0  ; TSmtpState#ss_SmtpInit
 WRX  state
#debug_left usint state
#srcline 537 ;          elsif tmpReplyCode = 250 then //je to odezva typu '250'?
 JMP  fbSmtp_L149
fbSmtp_L148:
 LDY  tmpReplyCode
#debug uint tmpReplyCode
 LD   uint 250
 EQ
 JMC  fbSmtp_L150
#srcline 538 ;            state := ss_Smtptxquit;  //nechce nas pustit posleme jeste jednou
 LD   udint 28  ; TSmtpState#ss_SmtpTxQuit
 WRX  state
#debug_left usint state
#srcline 539 ;          else
 JMP  fbSmtp_L149
fbSmtp_L150:
#srcline 540 ;            state := ss_Smtprxerror;          //chybna odezva
 LD   udint 31  ; TSmtpState#ss_SmtpRxError
 WRX  state
#debug_left usint state
#srcline 541 ;          end_if;
fbSmtp_L149:
#srcline 542 ;        elsif timeout_elapsed then     //server neodpovida
 JMP  fbSmtp_L146
fbSmtp_L147:
 LDY  timeout_elapsed
#debug bool timeout_elapsed
 JMC  fbSmtp_L151
#srcline 543 ;          state := ss_Smtpinit;
 LD   udint 0  ; TSmtpState#ss_SmtpInit
 WRX  state
#debug_left usint state
#srcline 544 ;        end_if;
 JMP  fbSmtp_L146
fbSmtp_L151:
fbSmtp_L146:
 JMP  fbSmtp_L19
fbSmtp_L144:
 LD   30
 LDY  P0__st__
 EQ  
 JMC  fbSmtp_L152
#srcline 546 ;      // osetreni kdyz je timeout prijmu -----------------------------------------
#srcline 547 ;      ss_Smtprxtimeout :
#srcline 548 ;        state := ss_Smtpinit;
 LD   udint 0  ; TSmtpState#ss_SmtpInit
 WRX  state
#debug_left usint state
#srcline 549 ;        Err   := true;
 LD   bool -1       ; true
 WRX  Err
#debug_left bool Err
#srcline 550 ;        ErrId := 1; //timeout
 LD   usint 1
 WRX  ErrId
#debug_left usint ErrId
 JMP  fbSmtp_L19
fbSmtp_L152:
 LD   31
 LDY  P0__st__
 EQ  
 JMC  fbSmtp_L153
#srcline 552 ;      // osetreni kdyz je chybna odezva ------------------------------------------
#srcline 553 ;      ss_Smtprxerror :
#srcline 554 ;        state := ss_Smtptxquit;
 LD   udint 28  ; TSmtpState#ss_SmtpTxQuit
 WRX  state
#debug_left usint state
#srcline 555 ;        Err   := true;
 LD   bool -1       ; true
 WRX  Err
#debug_left bool Err
#srcline 556 ;        ErrId := 2; //unexpected reply
 LD   usint 2
 WRX  ErrId
#debug_left usint ErrId
 JMP  fbSmtp_L19
fbSmtp_L153:
#srcline 558 ;    // ilegalni stav, provedeme restart stavoveho automatu -----------------------
#srcline 559 ;    ELSE
#srcline 560 ;      state := ss_Smtpinit;
 LD   udint 0  ; TSmtpState#ss_SmtpInit
 WRX  state
#debug_left usint state
#srcline 561 ;    END_CASE;
fbSmtp_L19:
#srcline 562 ;  END_IF;
fbSmtp_L11:
#srcline 564 ;  Send_to   (lenTx := len(cmd), chanCode := chanCode, data := void(cmd));
 LEAX cmd
#debug string cmd
 SLEN 
 WRX  Send_to~lenTx
#debug_left uint Send_to~lenTx
 LDX  chanCode
#debug uint chanCode
 WRX  Send_to~chanCode
#debug_left uint Send_to~chanCode
 LEAX cmd
 WRX  Send_to~data
#debug_left pointer Send_to.data
 LEAX Send_to
 CAL  fbSendTo_L0
#srcline 565 ;  TRO := Send_to.error = COM_ERR5; //buffer is full wait
 LDX  Send_to~error
#debug usint Send_to.error
 LD   usint 5
 EQ
 WRX  TRO
#debug_left bool TRO
#srcline 566 ;//  Recv_from (lenRx := 255, chanCode := chanCode,      data := void(cmd));
#srcline 567 ;  IF NOT TRO THEN //pokud je TRO nesmim to volat, jinak mi to prepise moje data
 LDX  TRO
#debug bool TRO
 NEG
 JMC  fbSmtp_L154
#srcline 568 ;    Recv_from(chanCode := chanCode, lenBuf := 512, lenTxt := 255, buffer := buff[0], txtMes := void(cmd));
 LDX  chanCode
#debug uint chanCode
 WRX  Recv_from~chanCode
#debug_left uint Recv_from~chanCode
 LD   uint 512
 WRX  Recv_from~lenBuf
#debug_left uint Recv_from~lenBuf
 LD   uint 255
 WRX  Recv_from~lenTxt
#debug_left uint Recv_from~lenTxt
 LEAX buff
 WRX  Recv_from~buffer
#debug_left pointer Recv_from.buffer
 LEAX cmd
 WRX  Recv_from~txtMes
#debug_left pointer Recv_from.txtMes
 LEAX Recv_from
 CAL  fbRecvTxt_L0
#srcline 569 ;  END_IF;
fbSmtp_L154:
#srcline 571 ;END_FUNCTION_BLOCK
fbSmtp_RET:
 ULNK
RET
E     61

; Initialize - variables
P     61
fbSmtp__InstanceInit__:
 LINK 0
 LD   uint 25
 WRX  port
 LD   udint $FFFFFFFF    ; nil
 WRX  ptrText
 LEAX Recv_from
 CAL  fbRecvTxt__InstanceInit__
 LEAX Send_to
 CAL  fbSendTo__InstanceInit__
 ULNK
RET
E     61
; End initialize - variables
#endpou 



 

#srcfile ''
#srcfile 'C:\TECOLIBSRC\INTERNETLIB\INTERNETLIBVCONTROL\FBSNTP.ST'
#pou fbSntp
#srcline 22 ;FUNCTION_BLOCK fbSntp
#table byte __Init___fbSntp_NtpPacket = 
     27, 15,  8,248;

#struct fbSntp__temp__
  pointer pu,
  pointer pue,
  lreal x,
  lreal y,
  lreal tmpoff,
  lreal tmperr,
  lreal OriginateTime,
  lreal ReceiveTime,
  lreal TransmitTime,
  TUniDesc UniDesc,
  TRemoteEthAdr rea
P     61
fbSntp_L0:
 LINK __SizeOf(fbSntp__temp__)
; Initialize - dynamic variables
 LD   udint $FFFFFFFF    ; nil
 WRY  pu
 LD   udint $FFFFFFFF    ; nil
 WRY  pue
; End initialize - dynamic variables
; R_EDGE, F_EDGE 
 LDX  Get
 LETX __EDGE_R__Get
 WRX  Get
 LDX  Accept
 LETX __EDGE_R__Accept
 WRX  Accept
#srcline 93 ;  Err   := false; //err jen na jednu otocku
 LD   bool 0       ; false
 WRX  Err
#debug_left bool Err
#srcline 95 ;  IF GetChanIndex( chanCode) <> -1 THEN
 NXT
 LDX  chanCode
#debug uint chanCode
 WR   __Instance__GetChanIndex~chanCode
#debug_left uint __Instance__GetChanIndex~chanCode
 PRV
 LEA  __Instance__GetChanIndex
 CAL  GetChanIndex_L0
 LD   int -1
 EQ
 NEG
 JMC  fbSntp_L1
#srcline 96 ;    // kanal zalozen pomoci #module => kontrola nutna
#srcline 97 ;    UniDesc := GetChanDesc(chanCode := chanCode);
 NXT
 LDX  chanCode
#debug uint chanCode
 WR   __Instance__GetChanDesc~chanCode
#debug_left uint __Instance__GetChanDesc~chanCode
 PRV
 LEA  __Instance__GetChanDesc
 CAL  GetChanDesc_L0
 LEAY UniDesc
#debug_left pointer UniDesc
 LD   26   ;SizeOf() 
 MOV  %IB0
#srcline 98 ;    IF (UniDesc.modeChan <> 5) OR (UniDesc.lenUniIn <> 64) OR (UniDesc.lenUniOut < 64) THEN
 LDY  UniDesc~modeChan
#debug byte UniDesc.modeChan
 LD   byte 5
 EQ
 NEG
 LDY  UniDesc~lenUniIn
#debug uint UniDesc.lenUniIn
 LD   uint 64
 EQ
 NEG
 OR  
 LDY  UniDesc~lenUniOut
#debug uint UniDesc.lenUniOut
 LD   uint 64
 LT
 OR  
 JMC  fbSntp_L3
#srcline 99 ;      Err   := true;
 LD   bool -1       ; true
 WRX  Err
#debug_left bool Err
#srcline 100 ;      ErrId := 255;
 LD   usint 255
 WRX  ErrId
#debug_left usint ErrId
#srcline 101 ;      RETURN;
 JMP  fbSntp_RET
#srcline 102 ;    END_IF;
fbSntp_L3:
#srcline 103 ;  END_IF;
fbSntp_L1:
#srcline 105 ;  Done := false;
 LD   bool 0       ; false
 WRX  Done
#debug_left bool Done
#srcline 107 ;  IF Get AND NOT Busy THEN
 LDX  Get
#debug bool Get
 LDX  Busy
#debug bool Busy
 NEG
 AND
 JMC  fbSntp_L5
#srcline 108 ;    IF IPadr = Any_IP THEN
 LEAX IPadr
 LEA  Any_IP
 LD   4   ; SizeOf()
 BCMP 
 EQ   0
 JMC  fbSntp_L7
#srcline 109 ;      Err    := true;
 LD   bool -1       ; true
 WRX  Err
#debug_left bool Err
#srcline 110 ;      ErrId := 254;
 LD   usint 254
 WRX  ErrId
#debug_left usint ErrId
#srcline 111 ;    ELSE
 JMP  fbSntp_L8
fbSntp_L7:
#srcline 112 ;      Busy    := true;   //pracujeme
 LD   bool -1       ; true
 WRX  Busy
#debug_left bool Busy
#srcline 113 ;      Attemps := 5;
 LD   udint 5
 WRX  Attemps
#debug_left udint Attemps
#srcline 114 ;      Success := 0;
 LD   udint 0
 WRX  Success
#debug_left udint Success
#srcline 115 ;      Error   := 3600.0;
 LDQ  lreal 3600.0
 WRX  Error
#debug_left lreal Error
#srcline 116 ;      Offset  := 0.0;
 LDQ  lreal 0.0
 WRX  Offset
#debug_left lreal Offset
#srcline 117 ;      Recv    := false;
 LD   bool 0       ; false
 WRX  Recv
#debug_left bool Recv
#srcline 118 ;      //Err     := false;
#srcline 119 ;      ErrId   := 0;
 LD   usint 0
 WRX  ErrId
#debug_left usint ErrId
#srcline 120 ;      TimeSet := false;
 LD   bool 0       ; false
 WRX  TimeSet
#debug_left bool TimeSet
#srcline 121 ;      rea.remoteIP   := IPadr;
 LEAX IPadr
#debug pointer IPadr
 SRC  %IB0
 LEAY rea~remoteIP
#debug_left pointer rea.remoteIP
 LD   4   ;SizeOf() 
 MOV  %IB0
#srcline 122 ;      rea.remotePort := port;
 LDX  port
#debug uint port
 WRY  rea~remotePort
#debug_left uint rea.remotePort
#srcline 123 ;      SetRemoteIPaddress(rq := 1, chanCode := chanCode, ethAdr := rea);
 NXT
 LD   1
 WR   __Instance__SetRemoteIPaddress~rq
#debug_left bool __Instance__SetRemoteIPaddress~rq
 LDX  chanCode
#debug uint chanCode
 WR   __Instance__SetRemoteIPaddress~chanCode
#debug_left uint __Instance__SetRemoteIPaddress~chanCode
 LEAY rea
 WR   __Instance__SetRemoteIPaddress~ethAdr
#debug_left pointer __Instance__SetRemoteIPaddress.ethAdr
 PRV
 LEA  __Instance__SetRemoteIPaddress
 CAL  SetRemoteIPaddress_L0
#srcline 124 ;    END_IF;
fbSntp_L8:
#srcline 125 ;  END_IF;
fbSntp_L5:
#srcline 127 ;  Timeout(IN := Busy, PT := T#15s);         //celkovy timeout
 LDX  Busy
#debug bool Busy
 WRX  Timeout~IN
#debug_left bool Timeout~IN
 LD   time 15000
 WRX  Timeout~PT
#debug_left time Timeout~PT
 LEAX Timeout
 CAL  TON_L0
#srcline 128 ;  ShortTimeout(IN := Recv, PT := T#4s);     //timeout na zpravu
 LDX  Recv
#debug bool Recv
 WRX  ShortTimeout~IN
#debug_left bool ShortTimeout~IN
 LD   time 4000
 WRX  ShortTimeout~PT
#debug_left time ShortTimeout~PT
 LEAX ShortTimeout
 CAL  TON_L0
#srcline 129 ;  Delay(IN := Delay.IN AND Recv AND NOT Delay.Q, PT := T#500ms);
 LDX  Delay~IN
#debug bool Delay.IN
 LDX  Recv
#debug bool Recv
 AND
 LDX  Delay~Q
#debug bool Delay.Q
 NEG
 AND
 WRX  Delay~IN
#debug_left bool Delay~IN
 LD   time 500
 WRX  Delay~PT
#debug_left time Delay~PT
 LEAX Delay
 CAL  TON_L0
#srcline 130 ;  IF Delay.Q THEN
 LDX  Delay~Q
#debug bool Delay.Q
 JMC  fbSntp_L9
#srcline 131 ;    Recv := false;
 LD   bool 0       ; false
 WRX  Recv
#debug_left bool Recv
#srcline 132 ;  END_IF;
fbSntp_L9:
#srcline 134 ;  //Get RTC
#srcline 135 ;  {asm}
#srcline 136
    #def  __SNTP_R0__ %R0
#srcline 137
    LEAX  NowTeco
#srcline 138
    LEA   __SNTP_R0__
#srcline 139
    SUB
#srcline 140
    SYS   3           ; //RDT -> nacist okamzity cas
#srcline 141
    LEAX  NowTeco
#srcline 142
    SYS   18          ; //konverze TTecoDateTime -> DATE_AND_TIME;
#srcline 143
    WRX   NowLocal
#srcline 144 ;  {end_asm}
#srcline 146 ;  IF Busy THEN
 LDX  Busy
#debug bool Busy
 JMC  fbSntp_L11
#srcline 147 ;    Now := LREAL_TO_DT(DT_TO_LREAL(NowLocal) - DINT_TO_LREAL((INT_TO_DINT(UtcOff)+BOOL_TO_DINT(System_S.IS_SUMMER_TIME AND System_S.SUMMER_TIME_REQUEST)*60)*60) + 2208988800.0); //korekce na UTC
 LDX  NowLocal
#debug dt NowLocal
 LDX  UtcOff
#debug int UtcOff
 EXTW 
 EXTW
 LD   System_S~IS_SUMMER_TIME
#debug bool System_S.IS_SUMMER_TIME
 LD   System_S~SUMMER_TIME_REQUEST
#debug bool System_S.SUMMER_TIME_REQUEST
 AND
 AND  1
 LD   dint 60
 MULS
 ADD
 LD   dint 60
 MULS
 ILDF
 SUDF
 LDQ  lreal 2208988800.0
 ADDF
 WRX  Now
#debug_left dt Now
#srcline 148 ;    //pointery pro obraceni dwordu
#srcline 149 ;    pu := ADR(NtpPacket.RootDelay);
 LEAX NtpPacket
 ADD  4  ; + offset 
#debug pointer NtpPacket.RootDelay
 LEAY pu
 WRIL 
#debug_left pointer pu
#srcline 150 ;    pue := ADR(NtpPacket.TransmitTSFrac)+4;
 LEAX NtpPacket
 ADD  44  ; + offset 
#debug pointer NtpPacket.TransmitTSFrac
 LD   udint 4
 ADD
 LEAY pue
 WRIL 
#debug_left pointer pue
#srcline 152 ;    IF Recv THEN
 LDX  Recv
#debug bool Recv
 JMC  fbSntp_L13
#srcline 153 ;      RecvFrom(rq := true, chanCode := chanCode, lenRx := SIZEOF(NtpPacket), data := void(NtpPacket));
 LD   bool -1       ; true
 WRX  RecvFrom~rq
#debug_left bool RecvFrom~rq
 LDX  chanCode
#debug uint chanCode
 WRX  RecvFrom~chanCode
#debug_left uint RecvFrom~chanCode
 LD   48  ; SizeOf()
 WRX  RecvFrom~lenRx
#debug_left uint RecvFrom~lenRx
 LEAX NtpPacket
 WRX  RecvFrom~data
#debug_left pointer RecvFrom.data
 LEAX RecvFrom
 CAL  fbRecvFrom_L0
#srcline 154 ;      IF RecvFrom.mesRec THEN
 LDX  RecvFrom~mesRec
#debug bool RecvFrom.mesRec
 JMC  fbSntp_L15
#srcline 155 ;        //obracenÌ dword
#srcline 156 ;        WHILE PTR_TO_UDINT(pu) <> PTR_TO_UDINT(pue) DO
fbSntp_L17:
 LEAY pu
 LDIL 
#debug pointer pu
 LEAY pue
 LDIL 
#debug pointer pue
 EQ
 NEG
 JMC  fbSntp_L18
 DBG 
#srcline 157 ;          {asm}
#srcline 158
            ldy pu
#srcline 159
            ldil
#srcline 160
            swp
#srcline 161
            swl
#srcline 162
            swp
#srcline 163
            ldy pu
#srcline 164
            wril
#srcline 165 ;          {end_asm}
#srcline 166 ;          pu := pu + 4;
 LEAY pu
 LDIL 
#debug pointer pu
 LD   udint 4
 ADD
 LEAY pu
 WRIL 
#debug_left pointer pu
#srcline 167 ;        END_WHILE;
 JMP  fbSntp_L17
fbSntp_L18:
 NOP  -1
#srcline 169 ;        //prepocet casu
#srcline 170 ;        ReceiveTime   := UDINT_TO_LREAL(NtpPacket.ReceiveTS)+UDINT_TO_LREAL(NtpPacket.ReceiveTSFrac)/4294967296.0;
 LDX  NtpPacket~ReceiveTS
#debug udint NtpPacket.ReceiveTS
 ULDF
 LDX  NtpPacket~ReceiveTSFrac
#debug udint NtpPacket.ReceiveTSFrac
 ULDF
 LDQ  lreal 4294967296.0
 DIDF
 ADDF
 WRY  ReceiveTime
#debug_left lreal ReceiveTime
#srcline 171 ;        TransmitTime  := UDINT_TO_LREAL(NtpPacket.TransmitTS)+UDINT_TO_LREAL(NtpPacket.TransmitTSFrac)/4294967296.0;
 LDX  NtpPacket~TransmitTS
#debug udint NtpPacket.TransmitTS
 ULDF
 LDX  NtpPacket~TransmitTSFrac
#debug udint NtpPacket.TransmitTSFrac
 ULDF
 LDQ  lreal 4294967296.0
 DIDF
 ADDF
 WRY  TransmitTime
#debug_left lreal TransmitTime
#srcline 172 ;        OriginateTime := UDINT_TO_LREAL(NtpPacket.OriginateTS)+UDINT_TO_LREAL(NtpPacket.OriginateTSFrac)/4294967296.0;
 LDX  NtpPacket~OriginateTS
#debug udint NtpPacket.OriginateTS
 ULDF
 LDX  NtpPacket~OriginateTSFrac
#debug udint NtpPacket.OriginateTSFrac
 ULDF
 LDQ  lreal 4294967296.0
 DIDF
 ADDF
 WRY  OriginateTime
#debug_left lreal OriginateTime
#srcline 174 ;        Delay.IN := true; //prepnout na vysilani se zpozdenim
 LD   bool -1       ; true
 WRX  Delay~IN
#debug_left bool Delay.IN
#srcline 175 ;        //Recv := false; //prepnout na vysilani
#srcline 177 ;        IF (TransmitTime - ReceiveTime) < (DT_TO_LREAL(Now) - OriginateTime) THEN
 LDY  TransmitTime
#debug lreal TransmitTime
 LDY  ReceiveTime
#debug lreal ReceiveTime
 SUDF
 LDX  Now
#debug dt Now
 LDY  OriginateTime
#debug lreal OriginateTime
 SUDF
 LTDF
 JMC  fbSntp_L19
#srcline 178 ;          //vypocet offsetu
#srcline 179 ;          x := ReceiveTime - OriginateTime;
 LDY  ReceiveTime
#debug lreal ReceiveTime
 LDY  OriginateTime
#debug lreal OriginateTime
 SUDF
 WRY  x
#debug_left lreal x
#srcline 180 ;          IF TransmitTime = 0.0 THEN
 LDY  TransmitTime
#debug lreal TransmitTime
 LDQ  lreal 0.0
 EQDF
 JMC  fbSntp_L21
#srcline 181 ;            y := 0.0;
 LDQ  lreal 0.0
 WRY  y
#debug_left lreal y
#srcline 182 ;          ELSE
 JMP  fbSntp_L22
fbSntp_L21:
#srcline 183 ;            y := TransmitTime - DT_TO_LREAL(Now);
 LDY  TransmitTime
#debug lreal TransmitTime
 LDX  Now
#debug dt Now
 SUDF
 WRY  y
#debug_left lreal y
#srcline 184 ;          END_IF;
fbSntp_L22:
#srcline 185 ;          tmpoff  := 0.5*(x+y);
 LDQ  lreal 0.5
 LDY  x
#debug lreal x
 LDY  y
#debug lreal y
 ADDF
 MUDF
 WRY  tmpoff
#debug_left lreal tmpoff
#srcline 186 ;          tmperr  := x - y;
 LDY  x
#debug lreal x
 LDY  y
#debug lreal y
 SUDF
 WRY  tmperr
#debug_left lreal tmperr
#srcline 187 ;          x    := DT_TO_LREAL(Now) - OriginateTime;
 LDX  Now
#debug dt Now
 LDY  OriginateTime
#debug lreal OriginateTime
 SUDF
 WRY  x
#debug_left lreal x
#srcline 188 ;          tmperr  := max(tmperr, 0.5*x);
 LDY  tmperr
#debug lreal tmperr
 LDQ  lreal 0.5
 LDY  x
#debug lreal x
 MUDF
 MAXD
 WRY  tmperr
#debug_left lreal tmperr
#srcline 190 ;          IF tmperr < Error THEN //vzit ten s nejmesi chybou
 LDY  tmperr
#debug lreal tmperr
 LDX  Error
#debug lreal Error
 LTDF
 JMC  fbSntp_L23
#srcline 191 ;            Error  := tmperr;
 LDY  tmperr
#debug lreal tmperr
 WRX  Error
#debug_left lreal Error
#srcline 192 ;            Offset := tmpoff;
 LDY  tmpoff
#debug lreal tmpoff
 WRX  Offset
#debug_left lreal Offset
#srcline 193 ;          END_IF;
fbSntp_L23:
#srcline 194 ;          Success := Success + 1;
 LDX  Success
#debug udint Success
 LD   udint 1
 ADD
 WRX  Success
#debug_left udint Success
#srcline 195 ;        END_IF;
fbSntp_L19:
#srcline 196 ;      END_IF;
fbSntp_L15:
#srcline 197 ;    ELSE
 JMP  fbSntp_L14
fbSntp_L13:
#srcline 198 ;      IF attemps > 0 THEN
 LDX  attemps
#debug udint attemps
 LD   udint 0
 GT
 JMC  fbSntp_L25
#srcline 199 ;        attemps := attemps - 1;
 LDX  attemps
#debug udint attemps
 LD   udint 1
 SUB
 WRX  attemps
#debug_left udint attemps
#srcline 201 ;        NtpPacket := _fbSntp_EMPTY_NTP_MESSAGE_;
 LEA  __Const__fbSntp__fbSntp_EMPTY_NTP_MESSAGE_
#debug pointer _fbSntp_EMPTY_NTP_MESSAGE_
 SRC  %IB0
 LEAX NtpPacket
#debug_left pointer NtpPacket
 LD   48   ;SizeOf() 
 MOV  %IB0
#srcline 203 ;        NtpPacket.TransmitTS := LREAL_TO_UDINT(DATE_AND_TIME_TO_LREAL(Now)-0.5);
 LDX  Now
#debug dt Now
 LDQ  lreal 0.5
 SUDF
 RNDD
 UDFL
 WRX  NtpPacket~TransmitTS
#debug_left udint NtpPacket.TransmitTS
#srcline 204 ;        NtpPacket.TransmitTSFrac := DWORD_TO_UDINT(SHL(UDINT_TO_DWORD(UINT_TO_UDINT(NowMili)*65536/1000),16));
 LDX  NowMili
#debug uint NowMili
 LD   udint 65536
 MUL
 LD   udint 1000
 DIVL
 LD   uint 16
 SHL
 WRX  NtpPacket~TransmitTSFrac
#debug_left udint NtpPacket.TransmitTSFrac
#srcline 206 ;        //obracenÌ dword
#srcline 207 ;        WHILE PTR_TO_UDINT(pu) <> PTR_TO_UDINT(pue) DO
fbSntp_L27:
 LEAY pu
 LDIL 
#debug pointer pu
 LEAY pue
 LDIL 
#debug pointer pue
 EQ
 NEG
 JMC  fbSntp_L28
 DBG 
#srcline 208 ;          {asm}
#srcline 209
            ldy pu
#srcline 210
            ldil
#srcline 211
            swp
#srcline 212
            swl
#srcline 213
            swp
#srcline 214
            ldy pu
#srcline 215
            wril
#srcline 216 ;          {end_asm}
#srcline 217 ;          pu := pu + 4;
 LEAY pu
 LDIL 
#debug pointer pu
 LD   udint 4
 ADD
 LEAY pu
 WRIL 
#debug_left pointer pu
#srcline 218 ;        END_WHILE;
 JMP  fbSntp_L27
fbSntp_L28:
 NOP  -1
#srcline 220 ;        SendTo(rq := true, chanCode := chanCode, lenTx := SIZEOF(NtpPacket), data := void(NtpPacket));
 LD   bool -1       ; true
 WRX  SendTo~rq
#debug_left bool SendTo~rq
 LDX  chanCode
#debug uint chanCode
 WRX  SendTo~chanCode
#debug_left uint SendTo~chanCode
 LD   48  ; SizeOf()
 WRX  SendTo~lenTx
#debug_left uint SendTo~lenTx
 LEAX NtpPacket
 WRX  SendTo~data
#debug_left pointer SendTo.data
 LEAX SendTo
 CAL  fbSendTo_L0
#srcline 221 ;        Recv := true; //cekat na prijem
 LD   bool -1       ; true
 WRX  Recv
#debug_left bool Recv
#srcline 222 ;      ELSE
 JMP  fbSntp_L26
fbSntp_L25:
#srcline 223 ;        Done := Success > 2 OR Error < 3600.0;
 LDX  Success
#debug udint Success
 LD   udint 2
 GT
 LDX  Error
#debug lreal Error
 LDQ  lreal 3600.0
 LTDF
 OR  
 WRX  Done
#debug_left bool Done
#srcline 224 ;        Busy := false;
 LD   bool 0       ; false
 WRX  Busy
#debug_left bool Busy
#srcline 225 ;        IF NOT Done THEN
 LDX  Done
#debug bool Done
 NEG
 JMC  fbSntp_L29
#srcline 226 ;          Err   := 1;
 LD   bool -1      ; true
 WRX  Err
#debug_left bool Err
#srcline 227 ;          ErrId := 2;
 LD   usint 2
 WRX  ErrId
#debug_left usint ErrId
#srcline 228 ;        END_IF;
fbSntp_L29:
#srcline 229 ;      END_IF;
fbSntp_L26:
#srcline 230 ;    END_IF;
fbSntp_L14:
#srcline 231 ;  END_IF;
fbSntp_L11:
#srcline 233 ;  IF Accept & NOT Busy & NOT Err & NOT TimeSet THEN
 LDX  Accept
#debug bool Accept
 LDX  Busy
#debug bool Busy
 NEG
 AND
 LDX  Err
#debug bool Err
 NEG
 AND
 LDX  TimeSet
#debug bool TimeSet
 NEG
 AND
 JMC  fbSntp_L31
#srcline 234 ;    SettingTime := true;
 LD   bool -1       ; true
 WRX  SettingTime
#debug_left bool SettingTime
#srcline 235 ;    maxSW22     := %SW22;
 LD   %SW22
 WRX  maxSW22
#debug_left uint maxSW22
#srcline 236 ;  END_IF;
fbSntp_L31:
#srcline 238 ;  IF SettingTime THEN
 LDX  SettingTime
#debug bool SettingTime
 JMC  fbSntp_L33
#srcline 239 ;    maxSW22 := max(maxSW22,%SW22);
 LDX  maxSW22
#debug uint maxSW22
 LD   %SW22
 MAX
 WRX  maxSW22
#debug_left uint maxSW22
#srcline 240 ;    NowLocal := LREAL_TO_DT(DT_TO_LREAL(NowLocal) + Offset);
 LDX  NowLocal
#debug dt NowLocal
 LDX  Offset
#debug lreal Offset
 ADDF
 WRX  NowLocal
#debug_left dt NowLocal
#srcline 241 ;    IF (UINT_TO_LREAL(maxSW22) * 0.0001) > (DT_TO_LREAL(NowLocal) - UDINT_TO_LREAL(TRUNC(DT_TO_LREAL(NowLocal)))) THEN
 LDX  maxSW22
#debug uint maxSW22
 ULDF
 LDQ  lreal 0.0001
 MUDF
 LDX  NowLocal
#debug dt NowLocal
 LDX  NowLocal
#debug dt NowLocal
 FLOD
 UDFL
 ULDF
 SUDF
 GTDF
 JMC  fbSntp_L35
#srcline 242 ;      Offset := 0.0;
 LDQ  lreal 0.0
 WRX  Offset
#debug_left lreal Offset
#srcline 243 ;      SettingTime := false;
 LD   bool 0       ; false
 WRX  SettingTime
#debug_left bool SettingTime
#srcline 244 ;      TimeSet     := true;
 LD   bool -1       ; true
 WRX  TimeSet
#debug_left bool TimeSet
#srcline 245 ;      {ASM}
#srcline 246
        LEAX  NowTeco
#srcline 247
        LDX   NowLocal
#srcline 248
        SYS   19                ;//konverze DATE_AND_TIME -> TTecoDateTime
#srcline 249
        LEAX  NowTeco
#srcline 250
        LEA   __SNTP_R0__
#srcline 251
        SUB
#srcline 252
        SYS   4                 ;//WRT -> nacist okamzity cas
#srcline 253 ;      {END_ASM}
#srcline 254 ;    END_IF;
fbSntp_L35:
#srcline 255 ;  END_IF;
fbSntp_L33:
#srcline 257 ;  IF Timeout.Q THEN
 LDX  Timeout~Q
#debug bool Timeout.Q
 JMC  fbSntp_L37
#srcline 258 ;    Busy  := false;
 LD   bool 0       ; false
 WRX  Busy
#debug_left bool Busy
#srcline 259 ;    Err   := true;
 LD   bool -1       ; true
 WRX  Err
#debug_left bool Err
#srcline 260 ;    ErrId := 1;
 LD   usint 1
 WRX  ErrId
#debug_left usint ErrId
#srcline 261 ;  END_IF;
fbSntp_L37:
#srcline 263 ;  Recv := Recv XOR (ShortTimeout.Q AND Attemps > 0);  //dosel timeout a je co vysilat prejit do vysilani
 LDX  Recv
#debug bool Recv
 LDX  ShortTimeout~Q
#debug bool ShortTimeout.Q
 LDX  Attemps
#debug udint Attemps
 LD   udint 0
 GT
 AND
 XOR 
 WRX  Recv
#debug_left bool Recv
#srcline 265 ;END_FUNCTION_BLOCK
fbSntp_RET:
 ULNK
RET
E     61

; Initialize - variables
P     61
fbSntp__InstanceInit__:
 LINK 0
 LD   uint 123
 WRX  port
 LD   0
 SRC  byte __Init___fbSntp_NtpPacket
 LEAX byte NtpPacket
 LD   48
 MOV  %X0
 LEAX SendTo
 CAL  fbSendTo__InstanceInit__
 LEAX RecvFrom
 CAL  fbRecvFrom__InstanceInit__
 ULNK
RET
E     61
; End initialize - variables
#endpou 



 

#srcfile ''
#srcfile 'C:\TECOLIBSRC\INTERNETLIB\INTERNETLIBVCONTROL\FBNSLOOKUPBYTABLE.ST'
#pou fbNsLookUpByTable
#srcline 15 ;FUNCTION_BLOCK fbNsLookUpByTable

#struct fbNsLookUpByTable__temp__
  uint P0__st__
P     61
fbNsLookUpByTable_L0:
 LINK __SizeOf(fbNsLookUpByTable__temp__)
; Initialize - dynamic variables
; End initialize - dynamic variables
#srcline 40 ;  NsLookUp(getIP := Busy, chanCode := chanCode,
 LDX  Busy
#debug bool Busy
 WRX  NsLookUp~getIP
#debug_left bool NsLookUp~getIP
 LDX  chanCode
#debug uint chanCode
 WRX  NsLookUp~chanCode
#debug_left uint NsLookUp~chanCode
#srcline 41 ;           Err => NsLookUpItem.Err,
#srcline 42 ;           ErrId => ErrId,
#srcline 43 ;           Done => NsLookUpItem.Done,
#srcline 44 ;           Name := NsLookUpItem.Name,
 LEAX NsLookUpItem
 ADD  5  ; + offset 
 WRX  NsLookUp~Name
#debug_left pointer NsLookUp.Name
#srcline 45 ;           DnsIP := DnsIP,
 LEAX DnsIP
#debug pointer DnsIP
 SRC  %IB0
 LEAX NsLookUp~DnsIP
 LD   4   ;SizeOf() 
 MOV  %IB0
#srcline 46 ;           IP := NsLookUpItem.IP);
 LEAX NsLookUpItem
 ADD  1  ; + offset 
 WRX  NsLookUp~IP
#debug_left pointer NsLookUp.IP
 LEAX NsLookUp
 CAL  fbNsLookUp_L0
; output assigment 
 LDX  NsLookUp~Err
#debug bool NsLookUp~Err
 WRX  NsLookUpItem~Err
#debug_left bool NsLookUpItem.Err
 LDX  NsLookUp~ErrId
#debug usint NsLookUp~ErrId
 WRX  ErrId
#debug_left usint ErrId
 LDX  NsLookUp~Done
#debug bool NsLookUp~Done
 WRX  NsLookUpItem~Done
#debug_left bool NsLookUpItem.Done
#srcline 48 ;  Err := NsLookUpItem.Err;
 LDX  NsLookUpItem~Err
#debug bool NsLookUpItem.Err
 WRX  Err
#debug_left bool Err
#srcline 50 ;  //nic se nedeje hledame pozadavky
#srcline 51 ;  IF NOT Busy THEN
 LDX  Busy
#debug bool Busy
 NEG
 JMC  fbNsLookUpByTable_L1
#srcline 52 ;    FOR i := 0 TO 15 DO
 LD   uint 0
 WRX  i
 LD   uint 15
 WRY  P0__st__
fbNsLookUpByTable_L3:
 LDX  i
 LDY  P0__st__
 GT   
 JMD  fbNsLookUpByTable_L4
 DBG  
#srcline 53 ;      //smazat vsechny priznaky Done
#srcline 54 ;      NsLookUpTable[i].Done := false;
 LD   bool 0       ; false
 LDX  NsLookUpTable
 LDX  i
#debug uint i
 RCHK 15   ; Range Check
 MUL  86   ; SizeOf(...)
 ADD     ; + offset 
 MUL  8   ; -> bool pointer 
 ADD  2   ; Bool offset 
 WRIB 
#debug_left bool NsLookUpTable[i].Done
#srcline 55 ;      //zjistit jestli je zadost
#srcline 56 ;      IF NsLookUpTable[i].Request & NOT Busy THEN
 LDX  NsLookUpTable
 LDX  i
#debug uint i
 RCHK 15   ; Range Check
 MUL  86   ; SizeOf(...)
 ADD     ; + offset 
 MUL  8   ; -> bool pointer 
 LDIB 
#debug bool NsLookUpTable[i].Request
 LDX  Busy
#debug bool Busy
 NEG
 AND
 JMC  fbNsLookUpByTable_L5
#srcline 57 ;        //je-li zadost nastavit polozku a busy
#srcline 58 ;        NsLookUpTable[i].Request := false;
 LD   bool 0       ; false
 LDX  NsLookUpTable
 LDX  i
#debug uint i
 RCHK 15   ; Range Check
 MUL  86   ; SizeOf(...)
 ADD     ; + offset 
 MUL  8   ; -> bool pointer 
 WRIB 
#debug_left bool NsLookUpTable[i].Request
#srcline 59 ;        NsLookUpTable[i].Set     := false;
 LD   bool 0       ; false
 LDX  NsLookUpTable
 LDX  i
#debug uint i
 RCHK 15   ; Range Check
 MUL  86   ; SizeOf(...)
 ADD     ; + offset 
 MUL  8   ; -> bool pointer 
 ADD  1   ; Bool offset 
 WRIB 
#debug_left bool NsLookUpTable[i].Set
#srcline 60 ;        NsLookUpItem := NsLookUpTable[i];
 LDX  NsLookUpTable
 LDX  i
#debug uint i
 RCHK 15   ; Range Check
 MUL  86   ; SizeOf(...)
 ADD     ; + offset 
#debug pointer NsLookUpTable[i]
 SRC  %IB0
 LEAX NsLookUpItem
#debug_left pointer NsLookUpItem
 LD   86   ;SizeOf() 
 MOV  %IB0
#srcline 61 ;        Busy := true; NsLookUp.Err := false;
 LD   bool -1       ; true
 WRX  Busy
#debug_left bool Busy
 LD   bool 0       ; false
 WRX  NsLookUp~Err
#debug_left bool NsLookUp.Err
#srcline 62 ;        j := i;
 LDX  i
#debug uint i
 WRX  j
#debug_left uint j
#srcline 63 ;      END_IF;
fbNsLookUpByTable_L5:
#srcline 64 ;    END_FOR;
 LDX  i
 LD   1
 ADD  
 WRX  i
 JMP  fbNsLookUpByTable_L3
fbNsLookUpByTable_L4:
 NOP  -1
#srcline 65 ;  END_IF;
fbNsLookUpByTable_L1:
#srcline 67 ;  IF Busy THEN
 LDX  Busy
#debug bool Busy
 JMC  fbNsLookUpByTable_L7
#srcline 68 ;    //ziskali jsme IP adresu - hotovo
#srcline 69 ;    IF NsLookUp.Done OR NsLookUp.Err THEN
 LDX  NsLookUp~Done
#debug bool NsLookUp.Done
 LDX  NsLookUp~Err
#debug bool NsLookUp.Err
 OR  
 JMC  fbNsLookUpByTable_L9
#srcline 70 ;      NsLookUpItem.Set := NsLookUp.Done;
 LDX  NsLookUp~Done
#debug bool NsLookUp.Done
 WRX  NsLookUpItem~Set
#debug_left bool NsLookUpItem.Set
#srcline 71 ;      NsLookUpTable[j] := NsLookUpItem;
 LEAX NsLookUpItem
#debug pointer NsLookUpItem
 SRC  %IB0
 LDX  NsLookUpTable
 LDX  j
#debug uint j
 RCHK 15   ; Range Check
 MUL  86   ; SizeOf(...)
 ADD     ; + offset 
#debug_left pointer NsLookUpTable[j]
 LD   86   ;SizeOf() 
 MOV  %IB0
#srcline 72 ;      Err              := NsLookUp.Err;
 LDX  NsLookUp~Err
#debug bool NsLookUp.Err
 WRX  Err
#debug_left bool Err
#srcline 73 ;      Busy             := false;
 LD   bool 0       ; false
 WRX  Busy
#debug_left bool Busy
#srcline 74 ;    END_IF;
fbNsLookUpByTable_L9:
#srcline 75 ;  END_IF;
fbNsLookUpByTable_L7:
#srcline 78 ;END_FUNCTION_BLOCK
 ULNK
RET
E     61

; Initialize - variables
P     61
fbNsLookUpByTable__InstanceInit__:
 LINK 0
 LEAX NsLookUp
 CAL  fbNsLookUp__InstanceInit__
 ULNK
RET
E     61
; End initialize - variables
#endpou 



 

#srcfile ''
#srcfile 'C:\TECOLIBSRC\INTERNETLIB\INTERNETLIBVCONTROL\FBFTP.ST'
#pou fbStoreToFtp
#srcline 28 ;FUNCTION_BLOCK fbStoreToFtp
#table byte __Init___fbStoreToFtp_h = 
      0,  0;

#struct fbStoreToFtp__temp__
  TUniDesc UniDescCom,
  uint tmpReplyCode,
  udint tmpud,
  pointer pStr,
  uint iPos,
  uint iIdx,
  string[2] endLocal,
  string[2] endRemot,
  uint ReplyCodeClass,
  usint P0__st__,
  usint P1__st__,
  string[257] PS0__st__
#data byte _str_fbStoreToFtp_0 = 
  'U','S','E','R',' ',0
#data byte _str_fbStoreToFtp_1 = 
  'P','A','S','S',' ',0
#data byte _str_fbStoreToFtp_2 = 
  'T','Y','P','E',' ','I',0
#data byte _str_fbStoreToFtp_3 = 
  'P','A','S','V',$0D,$0A,0
#data byte _str_fbStoreToFtp_4 = 
  '(',0
#data byte _str_fbStoreToFtp_5 = 
  ',',0
#data byte _str_fbStoreToFtp_6 = 
  'A','P','P','E',' ',0
#data byte _str_fbStoreToFtp_7 = 
  'S','T','O','R',' ',0
#data byte _str_fbStoreToFtp_8 = 
  '/',0
#data byte _str_fbStoreToFtp_9 = 
  '/',0
#data byte _str_fbStoreToFtp_10 = 
  '/',0
#data byte _str_fbStoreToFtp_11 = 
  'M','K','D',' ',0
#data byte _str_fbStoreToFtp_12 = 
  'Q','U','I','T',0
P     61
fbStoreToFtp_L0:
 LINK __SizeOf(fbStoreToFtp__temp__)
; Initialize - dynamic variables
 LD   udint $FFFFFFFF    ; nil
 WRY  pStr
; End initialize - dynamic variables
; R_EDGE, F_EDGE 
 LDX  Send
 LETX __EDGE_R__Send
 WRX  Send
#srcline 105 ;  IF GetChanIndex( chanCodeCom) <> -1 THEN
 NXT
 LDX  chanCodeCom
#debug uint chanCodeCom
 WR   __Instance__GetChanIndex~chanCode
#debug_left uint __Instance__GetChanIndex~chanCode
 PRV
 LEA  __Instance__GetChanIndex
 CAL  GetChanIndex_L0
 LD   int -1
 EQ
 NEG
 JMC  fbStoreToFtp_L1
#srcline 106 ;    // kanal zalozen pomoci #module => kontrola nutna
#srcline 107 ;    UniDescCom := GetChanDesc(chanCode := chanCodeCom);
 NXT
 LDX  chanCodeCom
#debug uint chanCodeCom
 WR   __Instance__GetChanDesc~chanCode
#debug_left uint __Instance__GetChanDesc~chanCode
 PRV
 LEA  __Instance__GetChanDesc
 CAL  GetChanDesc_L0
 LEAY UniDescCom
#debug_left pointer UniDescCom
 LD   26   ;SizeOf() 
 MOV  %IB0
#srcline 108 ;    IF (UniDescCom.modeChan <> 5) OR (UniDescCom.lenUniIn <> 259) OR (UniDescCom.lenUniOut < 259) THEN
 LDY  UniDescCom~modeChan
#debug byte UniDescCom.modeChan
 LD   byte 5
 EQ
 NEG
 LDY  UniDescCom~lenUniIn
#debug uint UniDescCom.lenUniIn
 LD   uint 259
 EQ
 NEG
 OR  
 LDY  UniDescCom~lenUniOut
#debug uint UniDescCom.lenUniOut
 LD   uint 259
 LT
 OR  
 JMC  fbStoreToFtp_L3
#srcline 109 ;      Err   := true;
 LD   bool -1       ; true
 WRX  Err
#debug_left bool Err
#srcline 110 ;      ErrId := 255;
 LD   usint 255
 WRX  ErrId
#debug_left usint ErrId
#srcline 111 ;      RETURN;
 JMP  fbStoreToFtp_RET
#srcline 112 ;    END_IF;
fbStoreToFtp_L3:
#srcline 113 ;  END_IF;
fbStoreToFtp_L1:
#srcline 115 ;  IF GetChanIndex( chanCodeDat) <> -1 THEN
 NXT
 LDX  chanCodeDat
#debug uint chanCodeDat
 WR   __Instance__GetChanIndex~chanCode
#debug_left uint __Instance__GetChanIndex~chanCode
 PRV
 LEA  __Instance__GetChanIndex
 CAL  GetChanIndex_L0
 LD   int -1
 EQ
 NEG
 JMC  fbStoreToFtp_L5
#srcline 116 ;    // kanal zalozen pomoci #module => kontrola nutna
#srcline 117 ;    UniDescCom := GetChanDesc(chanCode := chanCodeDat);
 NXT
 LDX  chanCodeDat
#debug uint chanCodeDat
 WR   __Instance__GetChanDesc~chanCode
#debug_left uint __Instance__GetChanDesc~chanCode
 PRV
 LEA  __Instance__GetChanDesc
 CAL  GetChanDesc_L0
 LEAY UniDescCom
#debug_left pointer UniDescCom
 LD   26   ;SizeOf() 
 MOV  %IB0
#srcline 118 ;    IF (UniDescCom.modeChan <> 5) OR (UniDescCom.lenUniOut < 259) THEN
 LDY  UniDescCom~modeChan
#debug byte UniDescCom.modeChan
 LD   byte 5
 EQ
 NEG
 LDY  UniDescCom~lenUniOut
#debug uint UniDescCom.lenUniOut
 LD   uint 259
 LT
 OR  
 JMC  fbStoreToFtp_L7
#srcline 119 ;      Err   := true;
 LD   bool -1       ; true
 WRX  Err
#debug_left bool Err
#srcline 120 ;      ErrId := 253;
 LD   usint 253
 WRX  ErrId
#debug_left usint ErrId
#srcline 121 ;      RETURN;
 JMP  fbStoreToFtp_RET
#srcline 122 ;    END_IF;
fbStoreToFtp_L7:
#srcline 123 ;  END_IF;
fbStoreToFtp_L5:
#srcline 125 ;  Err   := false;
 LD   bool 0       ; false
 WRX  Err
#debug_left bool Err
#srcline 126 ;  Done  := false;
 LD   bool 0       ; false
 WRX  Done
#debug_left bool Done
#srcline 128 ;  timeoutCom(PT := T#30s); //timeout
 LD   time 30000
 WRX  timeoutCom~PT
#debug_left time timeoutCom~PT
 LEAX timeoutCom
 CAL  TON_L0
#srcline 129 ;  KeepAliveTCP(rq := State = fss_TxData, chanCode := chanCodeCom, PT := T#30s);
 LDX  State
#debug usint State
 LD   udint 17  ; TFtpStoreState#fss_TxData
 EQ
 WRX  KeepAliveTCP~rq
#debug_left bool KeepAliveTCP~rq
 LDX  chanCodeCom
#debug uint chanCodeCom
 WRX  KeepAliveTCP~chanCode
#debug_left uint KeepAliveTCP~chanCode
 LD   time 30000
 WRX  KeepAliveTCP~PT
#debug_left time KeepAliveTCP~PT
 LEAX KeepAliveTCP
 CAL  fbKeepAliveTCP_L0
#srcline 131 ;  IF timeoutCom.Q THEN
 LDX  timeoutCom~Q
#debug bool timeoutCom.Q
 JMC  fbStoreToFtp_L9
#srcline 132 ;    state  := fss_Error;
 LD   udint 22  ; TFtpStoreState#fss_Error
 WRX  state
#debug_left usint state
#srcline 133 ;    eErrId := 1;
 LD   usint 1
 WRX  eErrId
#debug_left usint eErrId
#srcline 134 ;  END_IF;
fbStoreToFtp_L9:
#srcline 136 ;  IF NOT TRO THEN
 LDX  TRO
#debug bool TRO
 NEG
 JMC  fbStoreToFtp_L11
#srcline 137 ;    if mesRec then
 LDX  mesRec
#debug bool mesRec
 JMC  fbStoreToFtp_L13
#srcline 138 ;      tmpReplyCode := STRING_TO_UINT(cmdCom);
 LEAX cmdCom
#debug string cmdCom
 SCNV $300A;  IEC_STRING _TO_ IEC_UINT
 WRY  tmpReplyCode
#debug_left uint tmpReplyCode
#srcline 139 ;      ReplyCodeClass := tmpReplyCode / 100;
 LDY  tmpReplyCode
#debug uint tmpReplyCode
 LD   uint 100
 DIVL
 AND  $FFFF
 WRY  ReplyCodeClass
#debug_left uint ReplyCodeClass
#srcline 140 ;      IF Busy AND NOT Err THEN
 LDX  Busy
#debug bool Busy
 LDX  Err
#debug bool Err
 NEG
 AND
 JMC  fbStoreToFtp_L15
#srcline 141 ;        ReplyCode := tmpReplyCode;
 LDY  tmpReplyCode
#debug uint tmpReplyCode
 WRX  ReplyCode
#debug_left uint ReplyCode
#srcline 142 ;      END_IF;
fbStoreToFtp_L15:
#srcline 143 ;    end_if;
fbStoreToFtp_L13:
#srcline 145 ;    CASE state OF
 LDX  state
#debug usint state
 WRY  P0__st__
 LD   0
 LDY  P0__st__
 EQ  
 JMC  fbStoreToFtp_L18
#srcline 146 ;      // inicializace ------------------------------------------------------------
#srcline 147 ;      fss_Init :
#srcline 148 ;        busy        := false;
 LD   bool 0       ; false
 WRX  busy
#debug_left bool busy
#srcline 149 ;        state       := fss_Idle;
 LD   udint 1  ; TFtpStoreState#fss_Idle
 WRX  state
#debug_left usint state
#srcline 150 ;        // nenavazovat spojeni
#srcline 151 ;        CloseTCPconnection(chanCodeCom);
 NXT
 LDX  chanCodeCom
#debug uint chanCodeCom
 WR   __Instance__CloseTCPconnection~chanCode
#debug_left uint __Instance__CloseTCPconnection~chanCode
 PRV
 LEA  __Instance__CloseTCPconnection
 CAL  CloseTCPconnection_L0
#srcline 152 ;        CloseTCPconnection(chanCodeDat);
 NXT
 LDX  chanCodeDat
#debug uint chanCodeDat
 WR   __Instance__CloseTCPconnection~chanCode
#debug_left uint __Instance__CloseTCPconnection~chanCode
 PRV
 LEA  __Instance__CloseTCPconnection
 CAL  CloseTCPconnection_L0
#srcline 153 ;        IF h <> INVALID_HANDLE_VALUE THEN
 LDX  h
#debug udint h
 LD   udint 0
 EQ
 NEG
 JMC  fbStoreToFtp_L19
#srcline 154 ;          FileClose(hFile := h);
 NXT
 LDX  h
#debug udint h
 WR   __Instance__FileClose~hFile
#debug_left udint __Instance__FileClose~hFile
 PRV
 LEA  __Instance__FileClose
 CAL  FileClose_L0
#srcline 155 ;          h := INVALID_HANDLE_VALUE;
 LD   udint 0
 WRX  h
#debug_left udint h
#srcline 156 ;        END_IF;
fbStoreToFtp_L19:
#srcline 158 ;        FOR i := 0 TO dirStackLev DO
 LD   usint 0
 WRX  i
 LDX  dirStackLev
#debug usint dirStackLev
 WRY  P1__st__
fbStoreToFtp_L21:
 LDX  i
 LDY  P1__st__
 GT   
 JMD  fbStoreToFtp_L22
 DBG  
#srcline 159 ;          IF dirStack[i].hDir <> INVALID_HANDLE_VALUE THEN
 LEAX dirStack
 LDX  i
#debug usint i
 RCHK 4   ; Range Check
 MUL  17   ; SizeOf(...)
 ADD     ; + offset 
 LDIL 
#debug udint dirStack[i].hDir
 LD   udint 0
 EQ
 NEG
 JMC  fbStoreToFtp_L23
#srcline 160 ;            DirClose(hDir := dirStack[i].hDir);
 NXT
 LEAX dirStack
 LDX  i
#debug usint i
 RCHK 4   ; Range Check
 MUL  17   ; SizeOf(...)
 ADD     ; + offset 
 LDIL 
#debug udint dirStack[i].hDir
 WR   __Instance__DirClose~hDir
#debug_left udint __Instance__DirClose~hDir
 PRV
 LEA  __Instance__DirClose
 CAL  DirClose_L0
#srcline 161 ;            dirStack[i].hDir := INVALID_HANDLE_VALUE;
 LD   udint 0
 LEAX dirStack
 LDX  i
#debug usint i
 RCHK 4   ; Range Check
 MUL  17   ; SizeOf(...)
 ADD     ; + offset 
 WRIL 
#debug_left udint dirStack[i].hDir
#srcline 162 ;            dirStack[i].sDir := INTERNETLIB_EMPTY_STRING_;
 LD   0   ; null string
 LEAX dirStack
 LDX  i
#debug usint i
 RCHK 4   ; Range Check
 MUL  17   ; SizeOf(...)
 ADD     ; + offset 
 ADD  4  ; + offset 
 WRI  
 LEAX dirStack
 LDX  i
#debug usint i
 RCHK 4   ; Range Check
 MUL  17   ; SizeOf(...)
 ADD     ; + offset 
 ADD  4  ; + offset 
 LD   12
 DST    ; Level 1
 LEA  INTERNETLIB_EMPTY_STRING_
 SCON 
#debug_left string dirStack[i].sDir
 PDST   ; Level 1
#srcline 163 ;          END_IF;
fbStoreToFtp_L23:
#srcline 164 ;        END_FOR;
 LDX  i
 LD   1
 ADD  
 WRX  i
 JMP  fbStoreToFtp_L21
fbStoreToFtp_L22:
 NOP  -1
#srcline 166 ;        dirStackLev := 0;
 LD   usint 0
 WRX  dirStackLev
#debug_left usint dirStackLev
 JMP  fbStoreToFtp_L17
fbStoreToFtp_L18:
 LD   1
 LDY  P0__st__
 EQ  
 JMC  fbStoreToFtp_L25
#srcline 168 ;      // cekani na start ---------------------------------------------------------
#srcline 169 ;      fss_Idle :
#srcline 170 ;        if Send then
 LDX  Send
#debug bool Send
 JMC  fbStoreToFtp_L26
#srcline 171 ;          // vycistime prijimaci a vysilaci buffer
#srcline 172 ;          Recv_From_Com.rq  := 0;
 LD   bool 0       ; false
 WRX  Recv_From_Com~rq
#debug_left bool Recv_From_Com.rq
#srcline 173 ;          //Send_To_Com.rq    := 0;
#srcline 174 ;          Send_To_Com.lenTx := 0;
 LD   uint 0
 WRX  Send_To_Com~lenTx
#debug_left uint Send_To_Com.lenTx
#srcline 175 ;          state             := fss_OpenFile;
 LD   udint 2  ; TFtpStoreState#fss_OpenFile
 WRX  state
#debug_left usint state
#srcline 176 ;          busy              := true;
 LD   bool -1       ; true
 WRX  busy
#debug_left bool busy
#srcline 177 ;          ErrId             := 0;
 LD   usint 0
 WRX  ErrId
#debug_left usint ErrId
#srcline 178 ;          eErrId            := 0;
 LD   usint 0
 WRX  eErrId
#debug_left usint eErrId
#srcline 179 ;          ReplyCode         := 0;
 LD   uint 0
 WRX  ReplyCode
#debug_left uint ReplyCode
#srcline 180 ;          lRemotName        := RemotName;   //ulozit vzdalene jmeno
 LD   0   ; null string
 LEAX lRemotName
 WRI  
 LEAX lRemotName
 LD   80
 DST    ; Level 1
 LDX  RemotName
#debug string RemotName
 SCON 
#debug_left string lRemotName
 PDST   ; Level 1
#srcline 181 ;          idPos             := 0;
 LD   udint 0
 WRX  idPos
#debug_left udint idPos
#srcline 182 ;          Progress          := 0;
 LD   usint 0
 WRX  Progress
#debug_left usint Progress
#srcline 183 ;          _FindNextPathSeparator(In := lRemotName, Pos := idPos);
 NXT
 LEAX lRemotName
 WR   __Instance___FindNextPathSeparator~In
#debug_left pointer __Instance___FindNextPathSeparator.In
 LEAX idPos
 WR   __Instance___FindNextPathSeparator~Pos
#debug_left pointer __Instance___FindNextPathSeparator.Pos
 PRV
 LEA  __Instance___FindNextPathSeparator
 CAL  _FindNextPathSeparator_L0
#srcline 184 ;        end_if;
fbStoreToFtp_L26:
 JMP  fbStoreToFtp_L17
fbStoreToFtp_L25:
 LD   3
 LDY  P0__st__
 EQ  
 JMC  fbStoreToFtp_L28
#srcline 185 ;      // nastavit IP
#srcline 186 ;      fss_IpCom :
#srcline 187 ;        IF IPadr = Any_IP THEN
 LEAX IPadr
 LEA  Any_IP
 LD   4   ; SizeOf()
 BCMP 
 EQ   0
 JMC  fbStoreToFtp_L29
#srcline 188 ;          Err    := 1;
 LD   bool -1      ; true
 WRX  Err
#debug_left bool Err
#srcline 189 ;          ErrId  := 254;
 LD   usint 254
 WRX  ErrId
#debug_left usint ErrId
#srcline 190 ;          state  := fss_Init;
 LD   udint 0  ; TFtpStoreState#fss_Init
 WRX  state
#debug_left usint state
#srcline 191 ;        ELSE
 JMP  fbStoreToFtp_L30
fbStoreToFtp_L29:
#srcline 192 ;          rea.remoteIP   := IPadr;
 LEAX IPadr
#debug pointer IPadr
 SRC  %IB0
 LEAX rea~remoteIP
#debug_left pointer rea.remoteIP
 LD   4   ;SizeOf() 
 MOV  %IB0
#srcline 193 ;          rea.remotePort := port;
 LDX  port
#debug uint port
 WRX  rea~remotePort
#debug_left uint rea.remotePort
#srcline 194 ;          rea.localPort  := 0;
 LD   uint 0
 WRX  rea~localPort
#debug_left uint rea.localPort
#srcline 195 ;          IF SetRemoteIPaddress(rq := 1, chanCode := chanCodeCom, ethAdr := rea) THEN
 NXT
 LD   1
 WR   __Instance__SetRemoteIPaddress~rq
#debug_left bool __Instance__SetRemoteIPaddress~rq
 LDX  chanCodeCom
#debug uint chanCodeCom
 WR   __Instance__SetRemoteIPaddress~chanCode
#debug_left uint __Instance__SetRemoteIPaddress~chanCode
 LEAX rea
 WR   __Instance__SetRemoteIPaddress~ethAdr
#debug_left pointer __Instance__SetRemoteIPaddress.ethAdr
 PRV
 LEA  __Instance__SetRemoteIPaddress
 CAL  SetRemoteIPaddress_L0
 JMC  fbStoreToFtp_L31
#srcline 196 ;            state := fss_Connect;
 LD   udint 4  ; TFtpStoreState#fss_Connect
 WRX  state
#debug_left usint state
#srcline 197 ;          END_IF;
fbStoreToFtp_L31:
#srcline 198 ;        END_IF;
fbStoreToFtp_L30:
 JMP  fbStoreToFtp_L17
fbStoreToFtp_L28:
 LD   4
 LDY  P0__st__
 EQ  
 JMC  fbStoreToFtp_L33
#srcline 199 ;      fss_Connect :
#srcline 200 ;        EstabTCPconnection(chanCode := chanCodeCom);
 NXT
 LDX  chanCodeCom
#debug uint chanCodeCom
 WR   __Instance__EstabTCPconnection~chanCode
#debug_left uint __Instance__EstabTCPconnection~chanCode
 PRV
 LEA  __Instance__EstabTCPconnection
 CAL  EstabTCPconnection_L0
#srcline 201 ;        Recv_From_Com.rq := 1;
 LD   bool -1      ; true
 WRX  Recv_From_Com~rq
#debug_left bool Recv_From_Com.rq
#srcline 202 ;        IF IsEstabTCPconnection(chanCode := chanCodeCom) THEN
 NXT
 LDX  chanCodeCom
#debug uint chanCodeCom
 WR   __Instance__IsEstabTCPconnection~chanCode
#debug_left uint __Instance__IsEstabTCPconnection~chanCode
 PRV
 LEA  __Instance__IsEstabTCPconnection
 CAL  IsEstabTCPconnection_L0
 JMC  fbStoreToFtp_L34
#srcline 203 ;          state := fss_Rx220;
 LD   udint 5  ; TFtpStoreState#fss_Rx220
 WRX  state
#debug_left usint state
#srcline 204 ;        END_IF;
fbStoreToFtp_L34:
 JMP  fbStoreToFtp_L17
fbStoreToFtp_L33:
 LD   5
 LDY  P0__st__
 EQ  
 JMC  fbStoreToFtp_L36
#srcline 205 ;      fss_Rx220 :
#srcline 206 ;        IF mesRec THEN
 LDX  mesRec
#debug bool mesRec
 JMC  fbStoreToFtp_L37
#srcline 207 ;          Recv_From_Com.rq := 0;
 LD   bool 0       ; false
 WRX  Recv_From_Com~rq
#debug_left bool Recv_From_Com.rq
#srcline 208 ;          IF tmpReplyCode = 220 THEN
 LDY  tmpReplyCode
#debug uint tmpReplyCode
 LD   uint 220
 EQ
 JMC  fbStoreToFtp_L39
#srcline 209 ;            state := fss_TxUser;
 LD   udint 6  ; TFtpStoreState#fss_TxUser
 WRX  state
#debug_left usint state
#srcline 210 ;          ELSE
 JMP  fbStoreToFtp_L40
fbStoreToFtp_L39:
#srcline 211 ;            state := fss_UnexpectedReply;
 LD   udint 23  ; TFtpStoreState#fss_UnexpectedReply
 WRX  state
#debug_left usint state
#srcline 212 ;          END_IF;
fbStoreToFtp_L40:
#srcline 213 ;        END_IF;
fbStoreToFtp_L37:
 JMP  fbStoreToFtp_L17
fbStoreToFtp_L36:
 LD   6
 LDY  P0__st__
 EQ  
 JMC  fbStoreToFtp_L41
#srcline 214 ;      fss_TxUser:
#srcline 215 ;        Recv_From_Com.rq := 1;
 LD   bool -1      ; true
 WRX  Recv_From_Com~rq
#debug_left bool Recv_From_Com.rq
#srcline 216 ;        Send_To_Com.rq   := 1;
 LD   bool -1      ; true
 WRX  Send_To_Com~rq
#debug_left bool Send_To_Com.rq
#srcline 217 ;        cmdCom := 'USER ' + User + INTERNETLIB_END_OF_LINE_;
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LEA  _str_fbStoreToFtp_0
 SCON 
 LDX  User
#debug string User
 SCON 
 LEA  INTERNETLIB_END_OF_LINE_
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX cmdCom
 WRI  
 LEAX cmdCom
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string cmdCom
 PDST   ; Level 1
#srcline 218 ;        state := fss_RxUser;
 LD   udint 7  ; TFtpStoreState#fss_RxUser
 WRX  state
#debug_left usint state
 JMP  fbStoreToFtp_L17
fbStoreToFtp_L41:
 LD   7
 LDY  P0__st__
 EQ  
 JMC  fbStoreToFtp_L42
#srcline 219 ;      fss_RxUser:
#srcline 220 ;        IF mesRec THEN
 LDX  mesRec
#debug bool mesRec
 JMC  fbStoreToFtp_L43
#srcline 221 ;          Recv_From_Com.rq := 0;
 LD   bool 0       ; false
 WRX  Recv_From_Com~rq
#debug_left bool Recv_From_Com.rq
#srcline 222 ;          IF tmpReplyCode = 331 THEN
 LDY  tmpReplyCode
#debug uint tmpReplyCode
 LD   uint 331
 EQ
 JMC  fbStoreToFtp_L45
#srcline 223 ;            state := fss_TxPass;
 LD   udint 8  ; TFtpStoreState#fss_TxPass
 WRX  state
#debug_left usint state
#srcline 224 ;          ELSE
 JMP  fbStoreToFtp_L46
fbStoreToFtp_L45:
#srcline 225 ;            state := fss_UnexpectedReply;
 LD   udint 23  ; TFtpStoreState#fss_UnexpectedReply
 WRX  state
#debug_left usint state
#srcline 226 ;          END_IF;
fbStoreToFtp_L46:
#srcline 227 ;        END_IF;
fbStoreToFtp_L43:
 JMP  fbStoreToFtp_L17
fbStoreToFtp_L42:
 LD   8
 LDY  P0__st__
 EQ  
 JMC  fbStoreToFtp_L47
#srcline 228 ;      fss_TxPass:
#srcline 229 ;        Recv_From_Com.rq := 1;
 LD   bool -1      ; true
 WRX  Recv_From_Com~rq
#debug_left bool Recv_From_Com.rq
#srcline 230 ;        Send_To_Com.rq   := 1;
 LD   bool -1      ; true
 WRX  Send_To_Com~rq
#debug_left bool Send_To_Com.rq
#srcline 231 ;        cmdCom := 'PASS ' + Pass + INTERNETLIB_END_OF_LINE_;
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LEA  _str_fbStoreToFtp_1
 SCON 
 LDX  Pass
#debug string Pass
 SCON 
 LEA  INTERNETLIB_END_OF_LINE_
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX cmdCom
 WRI  
 LEAX cmdCom
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string cmdCom
 PDST   ; Level 1
#srcline 232 ;        state := fss_RxPass;
 LD   udint 9  ; TFtpStoreState#fss_RxPass
 WRX  state
#debug_left usint state
 JMP  fbStoreToFtp_L17
fbStoreToFtp_L47:
 LD   9
 LDY  P0__st__
 EQ  
 JMC  fbStoreToFtp_L48
#srcline 233 ;      fss_RxPass:
#srcline 234 ;        IF mesRec THEN
 LDX  mesRec
#debug bool mesRec
 JMC  fbStoreToFtp_L49
#srcline 235 ;          Recv_From_Com.rq := 0;
 LD   bool 0       ; false
 WRX  Recv_From_Com~rq
#debug_left bool Recv_From_Com.rq
#srcline 236 ;          IF tmpReplyCode = 230 THEN
 LDY  tmpReplyCode
#debug uint tmpReplyCode
 LD   uint 230
 EQ
 JMC  fbStoreToFtp_L51
#srcline 237 ;            state := fss_TxType;
 LD   udint 10  ; TFtpStoreState#fss_TxType
 WRX  state
#debug_left usint state
#srcline 238 ;          ELSE
 JMP  fbStoreToFtp_L52
fbStoreToFtp_L51:
#srcline 239 ;            state := fss_UnexpectedReply;
 LD   udint 23  ; TFtpStoreState#fss_UnexpectedReply
 WRX  state
#debug_left usint state
#srcline 240 ;          END_IF;
fbStoreToFtp_L52:
#srcline 241 ;        END_IF;
fbStoreToFtp_L49:
 JMP  fbStoreToFtp_L17
fbStoreToFtp_L48:
 LD   10
 LDY  P0__st__
 EQ  
 JMC  fbStoreToFtp_L53
#srcline 242 ;      fss_TxType:
#srcline 243 ;        Recv_From_Com.rq := 1;
 LD   bool -1      ; true
 WRX  Recv_From_Com~rq
#debug_left bool Recv_From_Com.rq
#srcline 244 ;        Send_To_Com.rq   := 1;
 LD   bool -1      ; true
 WRX  Send_To_Com~rq
#debug_left bool Send_To_Com.rq
#srcline 245 ;        cmdCom := 'TYPE I' + INTERNETLIB_END_OF_LINE_;
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LEA  _str_fbStoreToFtp_2
 SCON 
 LEA  INTERNETLIB_END_OF_LINE_
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX cmdCom
 WRI  
 LEAX cmdCom
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string cmdCom
 PDST   ; Level 1
#srcline 246 ;        state := fss_RxType;
 LD   udint 11  ; TFtpStoreState#fss_RxType
 WRX  state
#debug_left usint state
 JMP  fbStoreToFtp_L17
fbStoreToFtp_L53:
 LD   11
 LDY  P0__st__
 EQ  
 JMC  fbStoreToFtp_L54
#srcline 247 ;      fss_RxType:
#srcline 248 ;        IF mesRec THEN
 LDX  mesRec
#debug bool mesRec
 JMC  fbStoreToFtp_L55
#srcline 249 ;          Recv_From_Com.rq := 0;
 LD   bool 0       ; false
 WRX  Recv_From_Com~rq
#debug_left bool Recv_From_Com.rq
#srcline 250 ;          IF tmpReplyCode = 200 THEN
 LDY  tmpReplyCode
#debug uint tmpReplyCode
 LD   uint 200
 EQ
 JMC  fbStoreToFtp_L57
#srcline 251 ;            state := fss_TxPasv;
 LD   udint 12  ; TFtpStoreState#fss_TxPasv
 WRX  state
#debug_left usint state
#srcline 252 ;          ELSE
 JMP  fbStoreToFtp_L58
fbStoreToFtp_L57:
#srcline 253 ;            state := fss_UnexpectedReply;
 LD   udint 23  ; TFtpStoreState#fss_UnexpectedReply
 WRX  state
#debug_left usint state
#srcline 254 ;          END_IF;
fbStoreToFtp_L58:
#srcline 255 ;        END_IF;
fbStoreToFtp_L55:
 JMP  fbStoreToFtp_L17
fbStoreToFtp_L54:
 LD   12
 LDY  P0__st__
 EQ  
 JMC  fbStoreToFtp_L59
#srcline 256 ;      fss_TxPasv:
#srcline 257 ;        Recv_From_Com.rq := 1;
 LD   bool -1      ; true
 WRX  Recv_From_Com~rq
#debug_left bool Recv_From_Com.rq
#srcline 258 ;        Send_To_Com.rq   := 1;
 LD   bool -1      ; true
 WRX  Send_To_Com~rq
#debug_left bool Send_To_Com.rq
#srcline 259 ;        cmdCom := 'PASV$r$l';
 LD   0   ; null string
 LEAX cmdCom
 WRI  
 LEAX cmdCom
 LD   255
 DST    ; Level 1
 LEA  _str_fbStoreToFtp_3
 SCON 
#debug_left string cmdCom
 PDST   ; Level 1
#srcline 260 ;        state := fss_RxPasv;
 LD   udint 13  ; TFtpStoreState#fss_RxPasv
 WRX  state
#debug_left usint state
 JMP  fbStoreToFtp_L17
fbStoreToFtp_L59:
 LD   13
 LDY  P0__st__
 EQ  
 JMC  fbStoreToFtp_L60
#srcline 261 ;      fss_RxPasv:
#srcline 262 ;        IF mesRec THEN
 LDX  mesRec
#debug bool mesRec
 JMC  fbStoreToFtp_L61
#srcline 263 ;          Recv_From_Com.rq := 0;
 LD   bool 0       ; false
 WRX  Recv_From_Com~rq
#debug_left bool Recv_From_Com.rq
#srcline 264 ;          IF tmpReplyCode = 227 THEN
 LDY  tmpReplyCode
#debug uint tmpReplyCode
 LD   uint 227
 EQ
 JMC  fbStoreToFtp_L63
#srcline 265 ;            iPos := FIND(IN1 := cmdCom, IN2 := '(');
 LEAX cmdCom
#debug string cmdCom
 LEA  _str_fbStoreToFtp_4
 SFND 
 WRY  iPos
#debug_left uint iPos
#srcline 266 ;            pStr := ADR(cmdCom);
 LEAX cmdCom
#debug pointer cmdCom
 LEAY pStr
 WRIL 
#debug_left pointer pStr
#srcline 267 ;            WHILE iPos > 0 & iIdx < 6 DO
fbStoreToFtp_L65:
 LDY  iPos
#debug uint iPos
 LD   uint 0
 GT
 LDY  iIdx
#debug uint iIdx
 LD   uint 6
 LT
 AND
 JMC  fbStoreToFtp_L66
 DBG 
#srcline 268 ;              pStr := pStr + UINT_TO_UDINT(iPos);
 LEAY pStr
 LDIL 
#debug pointer pStr
 LDY  iPos
#debug uint iPos
 ADD
 LEAY pStr
 WRIL 
#debug_left pointer pStr
#srcline 269 ;              pasvDat[iIdx] := STRING_TO_USINT(pStr^);
 LEAY pStr
 LDIL    ; dereference 
#debug string pStr^
 SCNV $3008;  IEC_STRING _TO_ IEC_USINT
 LEAX pasvDat
 LDY  iIdx
#debug uint iIdx
 RCHK 5   ; Range Check
 ADD     ; + offset 
 WRI 
#debug_left usint pasvDat[iIdx]
#srcline 270 ;              iIdx := iIdx + 1;
 LDY  iIdx
#debug uint iIdx
 LD   uint 1
 ADD
 AND  $FFFF
 WRY  iIdx
#debug_left uint iIdx
#srcline 271 ;              iPos := FIND(IN1 := pStr^, IN2 := ',');
 LEAY pStr
 LDIL    ; dereference 
#debug string pStr^
 LEA  _str_fbStoreToFtp_5
 SFND 
 WRY  iPos
#debug_left uint iPos
#srcline 272 ;            END_WHILE;
 JMP  fbStoreToFtp_L65
fbStoreToFtp_L66:
 NOP  -1
#srcline 273 ;            state := fss_TxStor;
 LD   udint 14  ; TFtpStoreState#fss_TxStor
 WRX  state
#debug_left usint state
#srcline 274 ;          ELSE
 JMP  fbStoreToFtp_L64
fbStoreToFtp_L63:
#srcline 275 ;            state := fss_UnexpectedReply;
 LD   udint 23  ; TFtpStoreState#fss_UnexpectedReply
 WRX  state
#debug_left usint state
#srcline 276 ;          END_IF;
fbStoreToFtp_L64:
#srcline 277 ;        END_IF;
fbStoreToFtp_L61:
 JMP  fbStoreToFtp_L17
fbStoreToFtp_L60:
 LD   14
 LDY  P0__st__
 EQ  
 JMC  fbStoreToFtp_L67
#srcline 278 ;      fss_TxStor:
#srcline 279 ;        Recv_From_Com.rq := 1;
 LD   bool -1      ; true
 WRX  Recv_From_Com~rq
#debug_left bool Recv_From_Com.rq
#srcline 280 ;        Send_To_Com.rq   := 1;
 LD   bool -1      ; true
 WRX  Send_To_Com~rq
#debug_left bool Send_To_Com.rq
#srcline 281 ;        IF append THEN
 LDX  append
#debug bool append
 JMC  fbStoreToFtp_L68
#srcline 282 ;          cmdCom := 'APPE ' + lRemotName + INTERNETLIB_END_OF_LINE_;
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LEA  _str_fbStoreToFtp_6
 SCON 
 LEAX lRemotName
#debug string lRemotName
 SCON 
 LEA  INTERNETLIB_END_OF_LINE_
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX cmdCom
 WRI  
 LEAX cmdCom
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string cmdCom
 PDST   ; Level 1
#srcline 283 ;        ELSE
 JMP  fbStoreToFtp_L69
fbStoreToFtp_L68:
#srcline 284 ;          cmdCom := 'STOR ' + lRemotName + INTERNETLIB_END_OF_LINE_;
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LEA  _str_fbStoreToFtp_7
 SCON 
 LEAX lRemotName
#debug string lRemotName
 SCON 
 LEA  INTERNETLIB_END_OF_LINE_
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX cmdCom
 WRI  
 LEAX cmdCom
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string cmdCom
 PDST   ; Level 1
#srcline 285 ;        END_IF;
fbStoreToFtp_L69:
#srcline 286 ;        data   := 0;
 LD   udint 0
 WRX  data
#debug_left udint data
#srcline 287 ;        IF IsEstabTCPconnection(chanCode := chanCodeDat) THEN
 NXT
 LDX  chanCodeDat
#debug uint chanCodeDat
 WR   __Instance__IsEstabTCPconnection~chanCode
#debug_left uint __Instance__IsEstabTCPconnection~chanCode
 PRV
 LEA  __Instance__IsEstabTCPconnection
 CAL  IsEstabTCPconnection_L0
 JMC  fbStoreToFtp_L70
#srcline 288 ;          state  := fss_WaitForOpen;
 LD   udint 16  ; TFtpStoreState#fss_WaitForOpen
 WRX  state
#debug_left usint state
#srcline 289 ;        ELSE
 JMP  fbStoreToFtp_L71
fbStoreToFtp_L70:
#srcline 290 ;          state  := fss_IpDat;
 LD   udint 15  ; TFtpStoreState#fss_IpDat
 WRX  state
#debug_left usint state
#srcline 291 ;        END_IF;
fbStoreToFtp_L71:
 JMP  fbStoreToFtp_L17
fbStoreToFtp_L67:
 LD   2
 LDY  P0__st__
 EQ  
 JMC  fbStoreToFtp_L72
#srcline 292 ;      fss_OpenFile:
#srcline 293 ;        state  := fss_Error;
 LD   udint 22  ; TFtpStoreState#fss_Error
 WRX  state
#debug_left usint state
#srcline 294 ;        eErrId := 3;
 LD   usint 3
 WRX  eErrId
#debug_left usint eErrId
#srcline 295 ;        CurrFile := LocalName;
 LD   0   ; null string
 LEAX CurrFile
 WRI  
 LEAX CurrFile
 LD   80
 DST    ; Level 1
 LDX  LocalName
#debug string LocalName
 SCON 
#debug_left string CurrFile
 PDST   ; Level 1
#srcline 296 ;        h := FileOpen(fileName := LocalName, mode := F_READ);
 NXT
 LDX  LocalName
 WR   __Instance__FileOpen~fileName
#debug_left pointer __Instance__FileOpen.fileName
 LD   udint 0  ; TF_MODE#F_READ
 WR   __Instance__FileOpen~mode
#debug_left usint __Instance__FileOpen~mode
 PRV
 LEA  __Instance__FileOpen
 CAL  FileOpen_L0
 WRX  h
#debug_left udint h
#srcline 297 ;        IF h <> INVALID_HANDLE_VALUE THEN //je to soubor klasicky
 LDX  h
#debug udint h
 LD   udint 0
 EQ
 NEG
 JMC  fbStoreToFtp_L73
#srcline 298 ;          lSize  := FileSize(hFile := h);
 NXT
 LDX  h
#debug udint h
 WR   __Instance__FileSize~hFile
#debug_left udint __Instance__FileSize~hFile
 PRV
 LEA  __Instance__FileSize
 CAL  FileSize_L0
 WRX  lSize
#debug_left udint lSize
#srcline 299 ;          state  := fss_IpCom;
 LD   udint 3  ; TFtpStoreState#fss_IpCom
 WRX  state
#debug_left usint state
#srcline 300 ;        ELSE
 JMP  fbStoreToFtp_L74
fbStoreToFtp_L73:
#srcline 301 ;          endLocal := RIGHT(LocalName,1);
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   1
 DST    ; Level 1
 LDX  LocalName
#debug string LocalName
 LD   1
 SRGT 
 PDST   ; Level 1
 LD   0   ; null string
 LEAY endLocal
 WRI  
 LEAY endLocal
 LD   1
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string endLocal
 PDST   ; Level 1
#srcline 302 ;          IF endLocal = '/' THEN
 LEAY endLocal
#debug string endLocal
 LEA  _str_fbStoreToFtp_8
 SCMP 
 EQ   0
 JMC  fbStoreToFtp_L75
#srcline 303 ;            endRemot := RIGHT(RemotName,1);
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   1
 DST    ; Level 1
 LDX  RemotName
#debug string RemotName
 LD   1
 SRGT 
 PDST   ; Level 1
 LD   0   ; null string
 LEAY endRemot
 WRI  
 LEAY endRemot
 LD   1
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string endRemot
 PDST   ; Level 1
#srcline 304 ;            IF endRemot = '/' THEN
 LEAY endRemot
#debug string endRemot
 LEA  _str_fbStoreToFtp_9
 SCMP 
 EQ   0
 JMC  fbStoreToFtp_L77
#srcline 305 ;              dirStack[0].hDir := DirOpen(dirName := LocalName, dirInfo := lLocalFileInfo);
 NXT
 LDX  LocalName
 WR   __Instance__DirOpen~dirName
#debug_left pointer __Instance__DirOpen.dirName
 LEAX lLocalFileInfo
 WR   __Instance__DirOpen~dirInfo
#debug_left pointer __Instance__DirOpen.dirInfo
 PRV
 LEA  __Instance__DirOpen
 CAL  DirOpen_L0
 LEAX dirStack
 WRIL 
#debug_left udint dirStack[0].hDir
#srcline 306 ;              IF dirStack[0].hDir <> INVALID_HANDLE_VALUE THEN
 LEAX dirStack
 LDIL 
#debug udint dirStack[0].hDir
 LD   udint 0
 EQ
 NEG
 JMC  fbStoreToFtp_L79
#srcline 307 ;                iniDir    := true;
 LD   bool -1       ; true
 WRX  iniDir
#debug_left bool iniDir
#srcline 308 ;                state     := fss_ReadDir;
 LD   udint 26  ; TFtpStoreState#fss_ReadDir
 WRX  state
#debug_left usint state
#srcline 309 ;              END_IF;
fbStoreToFtp_L79:
#srcline 310 ;            ELSE
 JMP  fbStoreToFtp_L78
fbStoreToFtp_L77:
#srcline 311 ;              State  := fss_Error;
 LD   udint 22  ; TFtpStoreState#fss_Error
 WRX  State
#debug_left usint State
#srcline 312 ;              eErrId := 7; //dest is not dir
 LD   usint 7
 WRX  eErrId
#debug_left usint eErrId
#srcline 313 ;            END_IF;
fbStoreToFtp_L78:
#srcline 314 ;          END_IF;
fbStoreToFtp_L75:
#srcline 315 ;        END_IF;
fbStoreToFtp_L74:
 JMP  fbStoreToFtp_L17
fbStoreToFtp_L72:
 LD   26
 LDY  P0__st__
 EQ  
 JMC  fbStoreToFtp_L81
#srcline 316 ;      fss_ReadDir:
#srcline 317 ;        {$IFDEF _DEBUG}
#srcline 318 ;        Stop := true;
#srcline 319 ;        {$END_IF}
#srcline 321 ;        IF dirStack[dirStackLev].hDir <> INVALID_HANDLE_VALUE THEN //je adresar
 LEAX dirStack
 LDX  dirStackLev
#debug usint dirStackLev
 RCHK 4   ; Range Check
 MUL  17   ; SizeOf(...)
 ADD     ; + offset 
 LDIL 
#debug udint dirStack[dirStackLev].hDir
 LD   udint 0
 EQ
 NEG
 JMC  fbStoreToFtp_L82
#srcline 322 ;          IF lLocalFileInfo.fileName <> INTERNETLIB_EMPTY_STRING_ THEN
 LEAX lLocalFileInfo
 ADD  24  ; + offset 
#debug string lLocalFileInfo.fileName
 LEA  INTERNETLIB_EMPTY_STRING_
 SCMP 
 EQ   0
 NEG
 JMC  fbStoreToFtp_L84
#srcline 323 ;//            lRemotName := RemotName + dirStack[1].sDir + dirStack[2].sDir + dirStack[3].sDir + dirStack[4].sDir + lLocalFileInfo.fileName;
#srcline 324 ;            lRemotName := dirStack[1].sDir + dirStack[2].sDir + dirStack[3].sDir + dirStack[4].sDir + lLocalFileInfo.fileName;
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   80
 DST    ; Level 1
 LEAX dirStack
 ADD  21  ; + offset 
#debug string dirStack[1].sDir
 SCON 
 LEAX dirStack
 ADD  38  ; + offset 
#debug string dirStack[2].sDir
 SCON 
 LEAX dirStack
 ADD  55  ; + offset 
#debug string dirStack[3].sDir
 SCON 
 LEAX dirStack
 ADD  72  ; + offset 
#debug string dirStack[4].sDir
 SCON 
 LEAX lLocalFileInfo
 ADD  24  ; + offset 
#debug string lLocalFileInfo.fileName
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX lRemotName
 WRI  
 LEAX lRemotName
 LD   80
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string lRemotName
 PDST   ; Level 1
#srcline 325 ;            CurrFile := LocalName + dirStack[1].sDir + dirStack[2].sDir + dirStack[3].sDir + dirStack[4].sDir + lLocalFileInfo.fileName;
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   80
 DST    ; Level 1
 LDX  LocalName
#debug string LocalName
 SCON 
 LEAX dirStack
 ADD  21  ; + offset 
#debug string dirStack[1].sDir
 SCON 
 LEAX dirStack
 ADD  38  ; + offset 
#debug string dirStack[2].sDir
 SCON 
 LEAX dirStack
 ADD  55  ; + offset 
#debug string dirStack[3].sDir
 SCON 
 LEAX dirStack
 ADD  72  ; + offset 
#debug string dirStack[4].sDir
 SCON 
 LEAX lLocalFileInfo
 ADD  24  ; + offset 
#debug string lLocalFileInfo.fileName
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX CurrFile
 WRI  
 LEAX CurrFile
 LD   80
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string CurrFile
 PDST   ; Level 1
#srcline 326 ;            IF LEN(lRemotName) + LEN(RemotName) > 80 THEN
 LEAX lRemotName
#debug string lRemotName
 SLEN 
 LDX  RemotName
#debug string RemotName
 SLEN 
 ADD
 EXTW
 LD   int 80
 GTS
 JMC  fbStoreToFtp_L86
#srcline 327 ;              State  := fss_Error;
 LD   udint 22  ; TFtpStoreState#fss_Error
 WRX  State
#debug_left usint State
#srcline 328 ;              eErrId := 4; //remote name to long
 LD   usint 4
 WRX  eErrId
#debug_left usint eErrId
#srcline 329 ;              RETURN;
 JMP  fbStoreToFtp_RET
#srcline 330 ;            ELSE
 JMP  fbStoreToFtp_L87
fbStoreToFtp_L86:
#srcline 331 ;              lRemotName := RemotName + lRemotName;
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   80
 DST    ; Level 1
 LDX  RemotName
#debug string RemotName
 SCON 
 LEAX lRemotName
#debug string lRemotName
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX lRemotName
 WRI  
 LEAX lRemotName
 LD   80
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string lRemotName
 PDST   ; Level 1
#srcline 332 ;            END_IF;
fbStoreToFtp_L87:
#srcline 334 ;            idPos  := 0;
 LD   udint 0
 WRX  idPos
#debug_left udint idPos
#srcline 335 ;            _FindNextPathSeparator(In := lRemotName, Pos := idPos);
 NXT
 LEAX lRemotName
 WR   __Instance___FindNextPathSeparator~In
#debug_left pointer __Instance___FindNextPathSeparator.In
 LEAX idPos
 WR   __Instance___FindNextPathSeparator~Pos
#debug_left pointer __Instance___FindNextPathSeparator.Pos
 PRV
 LEA  __Instance___FindNextPathSeparator
 CAL  _FindNextPathSeparator_L0
#srcline 337 ;            h := FileOpen(fileName := CurrFile, mode := F_READ); //otevrit file
 NXT
 LEAX CurrFile
 WR   __Instance__FileOpen~fileName
#debug_left pointer __Instance__FileOpen.fileName
 LD   udint 0  ; TF_MODE#F_READ
 WR   __Instance__FileOpen~mode
#debug_left usint __Instance__FileOpen~mode
 PRV
 LEA  __Instance__FileOpen
 CAL  FileOpen_L0
 WRX  h
#debug_left udint h
#srcline 338 ;            Progress := 0;
 LD   usint 0
 WRX  Progress
#debug_left usint Progress
#srcline 339 ;            IF h = INVALID_HANDLE_VALUE THEN
 LDX  h
#debug udint h
 LD   udint 0
 EQ
 JMC  fbStoreToFtp_L88
#srcline 340 ;              IF dirStackLev < FTP_DIR_STACK_ THEN
 LDX  dirStackLev
#debug usint dirStackLev
 LD   usint 4
 LT
 JMC  fbStoreToFtp_L90
#srcline 341 ;                dirStackLev := dirStackLev + 1;
 LDX  dirStackLev
#debug usint dirStackLev
 LD   usint 1
 ADD
 AND  $FF
 WRX  dirStackLev
#debug_left usint dirStackLev
#srcline 342 ;                dirStack[dirStackLev].sDir := lLocalFileInfo.fileName + '/';
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   12
 DST    ; Level 1
 LEAX lLocalFileInfo
 ADD  24  ; + offset 
#debug string lLocalFileInfo.fileName
 SCON 
 LEA  _str_fbStoreToFtp_10
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX dirStack
 LDX  dirStackLev
#debug usint dirStackLev
 RCHK 4   ; Range Check
 MUL  17   ; SizeOf(...)
 ADD     ; + offset 
 ADD  4  ; + offset 
 WRI  
 LEAX dirStack
 LDX  dirStackLev
#debug usint dirStackLev
 RCHK 4   ; Range Check
 MUL  17   ; SizeOf(...)
 ADD     ; + offset 
 ADD  4  ; + offset 
 LD   12
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string dirStack[dirStackLev].sDir
 PDST   ; Level 1
#srcline 343 ;                dirStack[dirStackLev].hDir := DirOpen(dirName := CurrFile, dirInfo := lLocalFileInfo);
 NXT
 LEAX CurrFile
 WR   __Instance__DirOpen~dirName
#debug_left pointer __Instance__DirOpen.dirName
 LEAX lLocalFileInfo
 WR   __Instance__DirOpen~dirInfo
#debug_left pointer __Instance__DirOpen.dirInfo
 PRV
 LEA  __Instance__DirOpen
 CAL  DirOpen_L0
 LEAX dirStack
 LDX  dirStackLev
#debug usint dirStackLev
 RCHK 4   ; Range Check
 MUL  17   ; SizeOf(...)
 ADD     ; + offset 
 WRIL 
#debug_left udint dirStack[dirStackLev].hDir
#srcline 344 ;                IF dirStack[dirStackLev].hDir = INVALID_HANDLE_VALUE THEN
 LEAX dirStack
 LDX  dirStackLev
#debug usint dirStackLev
 RCHK 4   ; Range Check
 MUL  17   ; SizeOf(...)
 ADD     ; + offset 
 LDIL 
#debug udint dirStack[dirStackLev].hDir
 LD   udint 0
 EQ
 JMC  fbStoreToFtp_L92
#srcline 345 ;                  (* ignorovat chybu, vznikne na prazdnem adresary
#srcline 346 ;                  State  := fss_Error;
#srcline 347 ;                  eErrId := !; //failed to open dir
#srcline 348 ;                  *)
#srcline 349 ;                  dirStack[dirStackLev].sDir := INTERNETLIB_EMPTY_STRING_;
 LD   0   ; null string
 LEAX dirStack
 LDX  dirStackLev
#debug usint dirStackLev
 RCHK 4   ; Range Check
 MUL  17   ; SizeOf(...)
 ADD     ; + offset 
 ADD  4  ; + offset 
 WRI  
 LEAX dirStack
 LDX  dirStackLev
#debug usint dirStackLev
 RCHK 4   ; Range Check
 MUL  17   ; SizeOf(...)
 ADD     ; + offset 
 ADD  4  ; + offset 
 LD   12
 DST    ; Level 1
 LEA  INTERNETLIB_EMPTY_STRING_
 SCON 
#debug_left string dirStack[dirStackLev].sDir
 PDST   ; Level 1
#srcline 350 ;                  dirStackLev := dirStackLev - 1;
 LDX  dirStackLev
#debug usint dirStackLev
 LD   usint 1
 SUB
 AND  $FF
 WRX  dirStackLev
#debug_left usint dirStackLev
#srcline 351 ;                END_IF;
fbStoreToFtp_L92:
#srcline 352 ;              ELSE
 JMP  fbStoreToFtp_L91
fbStoreToFtp_L90:
#srcline 353 ;                State  := fss_Error;
 LD   udint 22  ; TFtpStoreState#fss_Error
 WRX  State
#debug_left usint State
#srcline 354 ;                eErrId := 5; //to many subdirectories
 LD   usint 5
 WRX  eErrId
#debug_left usint eErrId
#srcline 355 ;              END_IF;
fbStoreToFtp_L91:
#srcline 356 ;              RETURN;
 JMP  fbStoreToFtp_RET
#srcline 357 ;            ELSE
 JMP  fbStoreToFtp_L89
fbStoreToFtp_L88:
#srcline 358 ;              lSize := lLocalFileInfo.fileSize;
 LDX  lLocalFileInfo~fileSize
#debug udint lLocalFileInfo.fileSize
 WRX  lSize
#debug_left udint lSize
#srcline 359 ;            END_IF;
fbStoreToFtp_L89:
#srcline 360 ;          END_IF;
fbStoreToFtp_L84:
#srcline 362 ;          IF NOT DirRead(hDir := dirStack[dirStackLev].hDir, dirInfo := lLocalFileInfo) THEN        //nacist dalsi jmeno
 NXT
 LEAX dirStack
 LDX  dirStackLev
#debug usint dirStackLev
 RCHK 4   ; Range Check
 MUL  17   ; SizeOf(...)
 ADD     ; + offset 
 LDIL 
#debug udint dirStack[dirStackLev].hDir
 WR   __Instance__DirRead~hDir
#debug_left udint __Instance__DirRead~hDir
 LEAX lLocalFileInfo
 WR   __Instance__DirRead~dirInfo
#debug_left pointer __Instance__DirRead.dirInfo
 PRV
 LEA  __Instance__DirRead
 CAL  DirRead_L0
 NEG
 JMC  fbStoreToFtp_L94
#srcline 363 ;            DirClose(hDir := dirStack[dirStackLev].hDir);
 NXT
 LEAX dirStack
 LDX  dirStackLev
#debug usint dirStackLev
 RCHK 4   ; Range Check
 MUL  17   ; SizeOf(...)
 ADD     ; + offset 
 LDIL 
#debug udint dirStack[dirStackLev].hDir
 WR   __Instance__DirClose~hDir
#debug_left udint __Instance__DirClose~hDir
 PRV
 LEA  __Instance__DirClose
 CAL  DirClose_L0
#srcline 364 ;            dirStack[dirStackLev].hDir := INVALID_HANDLE_VALUE;
 LD   udint 0
 LEAX dirStack
 LDX  dirStackLev
#debug usint dirStackLev
 RCHK 4   ; Range Check
 MUL  17   ; SizeOf(...)
 ADD     ; + offset 
 WRIL 
#debug_left udint dirStack[dirStackLev].hDir
#srcline 365 ;            dirStack[dirStackLev].sDir := INTERNETLIB_EMPTY_STRING_;
 LD   0   ; null string
 LEAX dirStack
 LDX  dirStackLev
#debug usint dirStackLev
 RCHK 4   ; Range Check
 MUL  17   ; SizeOf(...)
 ADD     ; + offset 
 ADD  4  ; + offset 
 WRI  
 LEAX dirStack
 LDX  dirStackLev
#debug usint dirStackLev
 RCHK 4   ; Range Check
 MUL  17   ; SizeOf(...)
 ADD     ; + offset 
 ADD  4  ; + offset 
 LD   12
 DST    ; Level 1
 LEA  INTERNETLIB_EMPTY_STRING_
 SCON 
#debug_left string dirStack[dirStackLev].sDir
 PDST   ; Level 1
#srcline 366 ;            IF dirStackLev > 0 THEN
 LDX  dirStackLev
#debug usint dirStackLev
 LD   usint 0
 GT
 JMC  fbStoreToFtp_L96
#srcline 367 ;              dirStackLev := dirStackLev - 1;
 LDX  dirStackLev
#debug usint dirStackLev
 LD   usint 1
 SUB
 AND  $FF
 WRX  dirStackLev
#debug_left usint dirStackLev
#srcline 368 ;            END_IF;
fbStoreToFtp_L96:
#srcline 369 ;          END_IF;
fbStoreToFtp_L94:
#srcline 370 ;        END_IF;
fbStoreToFtp_L82:
#srcline 372 ;        endDir := dirStack[0].hDir = INVALID_HANDLE_VALUE AND h = INVALID_HANDLE_VALUE;
 LEAX dirStack
 LDIL 
#debug udint dirStack[0].hDir
 LD   udint 0
 EQ
 LDX  h
#debug udint h
 LD   udint 0
 EQ
 AND
 WRX  endDir
#debug_left bool endDir
#srcline 373 ;        IF iniDir THEN //prvni soubor k vyslani
 LDX  iniDir
#debug bool iniDir
 JMC  fbStoreToFtp_L98
#srcline 374 ;          IF endDir THEN //adresar skoncil chyba
 LDX  endDir
#debug bool endDir
 JMC  fbStoreToFtp_L100
#srcline 375 ;            State  := fss_Error;
 LD   udint 22  ; TFtpStoreState#fss_Error
 WRX  State
#debug_left usint State
#srcline 376 ;            eErrId := 6; //empty dir
 LD   usint 6
 WRX  eErrId
#debug_left usint eErrId
#srcline 377 ;          ELSIF h <> INVALID_HANDLE_VALUE THEN //nasel se file navazat spojeni
 JMP  fbStoreToFtp_L101
fbStoreToFtp_L100:
 LDX  h
#debug udint h
 LD   udint 0
 EQ
 NEG
 JMC  fbStoreToFtp_L102
#srcline 378 ;            State  := fss_IpCom;
 LD   udint 3  ; TFtpStoreState#fss_IpCom
 WRX  State
#debug_left usint State
#srcline 379 ;          END_IF;
 JMP  fbStoreToFtp_L101
fbStoreToFtp_L102:
fbStoreToFtp_L101:
#srcline 380 ;        ELSE //dalsi
 JMP  fbStoreToFtp_L99
fbStoreToFtp_L98:
#srcline 381 ;          IF endDir THEN //adresar skoncil konec
 LDX  endDir
#debug bool endDir
 JMC  fbStoreToFtp_L103
#srcline 382 ;            State := fss_TxQuit;
 LD   udint 19  ; TFtpStoreState#fss_TxQuit
 WRX  State
#debug_left usint State
#srcline 383 ;          ELSIF h <> INVALID_HANDLE_VALUE THEN //nasel se file odeslat
 JMP  fbStoreToFtp_L104
fbStoreToFtp_L103:
 LDX  h
#debug udint h
 LD   udint 0
 EQ
 NEG
 JMC  fbStoreToFtp_L105
#srcline 384 ;            State  := fss_TxPasv;
 LD   udint 12  ; TFtpStoreState#fss_TxPasv
 WRX  State
#debug_left usint State
#srcline 385 ;          END_IF;
 JMP  fbStoreToFtp_L104
fbStoreToFtp_L105:
fbStoreToFtp_L104:
#srcline 386 ;        END_IF;
fbStoreToFtp_L99:
 JMP  fbStoreToFtp_L17
fbStoreToFtp_L81:
 LD   15
 LDY  P0__st__
 EQ  
 JMC  fbStoreToFtp_L106
#srcline 387 ;      fss_IpDat:
#srcline 388 ;        rea.remoteIP[0]   := pasvDat[0];
 LDX  pasvDat[0]
#debug usint pasvDat[0]
 WRX  rea~remoteIP[0]
#debug_left usint rea.remoteIP[0]
#srcline 389 ;        rea.remoteIP[1]   := pasvDat[1];
 LDX  pasvDat[1]
#debug usint pasvDat[1]
 WRX  rea~remoteIP[1]
#debug_left usint rea.remoteIP[1]
#srcline 390 ;        rea.remoteIP[2]   := pasvDat[2];
 LDX  pasvDat[2]
#debug usint pasvDat[2]
 WRX  rea~remoteIP[2]
#debug_left usint rea.remoteIP[2]
#srcline 391 ;        rea.remoteIP[3]   := pasvDat[3];
 LDX  pasvDat[3]
#debug usint pasvDat[3]
 WRX  rea~remoteIP[3]
#debug_left usint rea.remoteIP[3]
#srcline 392 ;        rea.remotePort    := USINT_TO_UINT(pasvDat[4])*256+USINT_TO_UINT(pasvDat[5]);
 LDX  pasvDat[4]
#debug usint pasvDat[4]
 AND  $FFFF
 LD   uint 256
 MUL
 AND  $FFFF
 LDX  pasvDat[5]
#debug usint pasvDat[5]
 AND  $FFFF
 ADD
 AND  $FFFF
 WRX  rea~remotePort
#debug_left uint rea.remotePort
#srcline 393 ;        rea.localPort  := 0;
 LD   uint 0
 WRX  rea~localPort
#debug_left uint rea.localPort
#srcline 394 ;        IF SetRemoteIPaddress(rq := 1, chanCode := chanCodeDat, ethAdr := rea) THEN
 NXT
 LD   1
 WR   __Instance__SetRemoteIPaddress~rq
#debug_left bool __Instance__SetRemoteIPaddress~rq
 LDX  chanCodeDat
#debug uint chanCodeDat
 WR   __Instance__SetRemoteIPaddress~chanCode
#debug_left uint __Instance__SetRemoteIPaddress~chanCode
 LEAX rea
 WR   __Instance__SetRemoteIPaddress~ethAdr
#debug_left pointer __Instance__SetRemoteIPaddress.ethAdr
 PRV
 LEA  __Instance__SetRemoteIPaddress
 CAL  SetRemoteIPaddress_L0
 JMC  fbStoreToFtp_L107
#srcline 395 ;          state := fss_WaitForOpen;
 LD   udint 16  ; TFtpStoreState#fss_WaitForOpen
 WRX  state
#debug_left usint state
#srcline 396 ;        END_IF;
fbStoreToFtp_L107:
 JMP  fbStoreToFtp_L17
fbStoreToFtp_L106:
 LD   16
 LDY  P0__st__
 EQ  
 JMC  fbStoreToFtp_L109
#srcline 397 ;      fss_WaitForOpen:
#srcline 398 ;        EstabTCPconnection(chanCode := chanCodeDat);
 NXT
 LDX  chanCodeDat
#debug uint chanCodeDat
 WR   __Instance__EstabTCPconnection~chanCode
#debug_left uint __Instance__EstabTCPconnection~chanCode
 PRV
 LEA  __Instance__EstabTCPconnection
 CAL  EstabTCPconnection_L0
#srcline 399 ;        IF mesRec THEN
 LDX  mesRec
#debug bool mesRec
 JMC  fbStoreToFtp_L110
#srcline 400 ;          IF ReplyCode = 150 OR ReplyCode = 125 THEN
 LDX  ReplyCode
#debug uint ReplyCode
 LD   uint 150
 EQ
 LDX  ReplyCode
#debug uint ReplyCode
 LD   uint 125
 EQ
 OR  
 JMC  fbStoreToFtp_L112
#srcline 401 ;            lTrans := 0;
 LD   udint 0
 WRX  lTrans
#debug_left udint lTrans
#srcline 402 ;            state := fss_TxData;
 LD   udint 17  ; TFtpStoreState#fss_TxData
 WRX  state
#debug_left usint state
#srcline 403 ;          ELSIF ReplyCodeClass = 5 AND idPos > 0 THEN
 JMP  fbStoreToFtp_L113
fbStoreToFtp_L112:
 LDY  ReplyCodeClass
#debug uint ReplyCodeClass
 LD   uint 5
 EQ
 LDX  idPos
#debug udint idPos
 LD   udint 0
 GT
 AND
 JMC  fbStoreToFtp_L114
#srcline 404 ;            State := fss_TxCreateDir;
 LD   udint 24  ; TFtpStoreState#fss_TxCreateDir
 WRX  State
#debug_left usint State
#srcline 405 ;          ELSE
 JMP  fbStoreToFtp_L113
fbStoreToFtp_L114:
#srcline 406 ;            state := fss_UnexpectedReply;
 LD   udint 23  ; TFtpStoreState#fss_UnexpectedReply
 WRX  state
#debug_left usint state
#srcline 407 ;          END_IF;
fbStoreToFtp_L113:
#srcline 408 ;        END_IF;
fbStoreToFtp_L110:
 JMP  fbStoreToFtp_L17
fbStoreToFtp_L109:
 LD   24
 LDY  P0__st__
 EQ  
 JMC  fbStoreToFtp_L115
#srcline 409 ;      fss_TxCreateDir:
#srcline 410 ;        Recv_From_Com.rq := 1;
 LD   bool -1      ; true
 WRX  Recv_From_Com~rq
#debug_left bool Recv_From_Com.rq
#srcline 411 ;        Send_To_Com.rq   := 1;
 LD   bool -1      ; true
 WRX  Send_To_Com~rq
#debug_left bool Send_To_Com.rq
#srcline 412 ;        cmdCom := LEFT(IN := lRemotName, L := UDINT_TO_UINT(idPos-1));
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LEAX lRemotName
#debug string lRemotName
 LDX  idPos
#debug udint idPos
 LD   udint 1
 SUB
 AND  $FFFF
 SLFT 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX cmdCom
 WRI  
 LEAX cmdCom
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string cmdCom
 PDST   ; Level 1
#srcline 413 ;        cmdCom := 'MKD ' + cmdCom  + INTERNETLIB_END_OF_LINE_;
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LEA  _str_fbStoreToFtp_11
 SCON 
 LEAX cmdCom
#debug string cmdCom
 SCON 
 LEA  INTERNETLIB_END_OF_LINE_
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX cmdCom
 WRI  
 LEAX cmdCom
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string cmdCom
 PDST   ; Level 1
#srcline 414 ;        state := fss_RxCreateDir;
 LD   udint 25  ; TFtpStoreState#fss_RxCreateDir
 WRX  state
#debug_left usint state
 JMP  fbStoreToFtp_L17
fbStoreToFtp_L115:
 LD   25
 LDY  P0__st__
 EQ  
 JMC  fbStoreToFtp_L116
#srcline 415 ;      fss_RxCreateDir:
#srcline 416 ;        IF mesRec THEN
 LDX  mesRec
#debug bool mesRec
 JMC  fbStoreToFtp_L117
#srcline 417 ;          Recv_From_Com.rq := 0;
 LD   bool 0       ; false
 WRX  Recv_From_Com~rq
#debug_left bool Recv_From_Com.rq
#srcline 418 ;          IF tmpReplyCode = 257 OR tmpReplyCode = 550 THEN //257 created - 550 already exists
 LDY  tmpReplyCode
#debug uint tmpReplyCode
 LD   uint 257
 EQ
 LDY  tmpReplyCode
#debug uint tmpReplyCode
 LD   uint 550
 EQ
 OR  
 JMC  fbStoreToFtp_L119
#srcline 419 ;            IF _FindNextPathSeparator(In := lRemotName, Pos := idPos) THEN
 NXT
 LEAX lRemotName
 WR   __Instance___FindNextPathSeparator~In
#debug_left pointer __Instance___FindNextPathSeparator.In
 LEAX idPos
 WR   __Instance___FindNextPathSeparator~Pos
#debug_left pointer __Instance___FindNextPathSeparator.Pos
 PRV
 LEA  __Instance___FindNextPathSeparator
 CAL  _FindNextPathSeparator_L0
 JMC  fbStoreToFtp_L121
#srcline 420 ;              state := fss_TxCreateDir;
 LD   udint 24  ; TFtpStoreState#fss_TxCreateDir
 WRX  state
#debug_left usint state
#srcline 421 ;            ELSE
 JMP  fbStoreToFtp_L122
fbStoreToFtp_L121:
#srcline 422 ;              state := fss_TxPasv; // fss_TxStor
 LD   udint 12  ; TFtpStoreState#fss_TxPasv
 WRX  state
#debug_left usint state
#srcline 423 ;            END_IF;
fbStoreToFtp_L122:
#srcline 424 ;          ELSE
 JMP  fbStoreToFtp_L120
fbStoreToFtp_L119:
#srcline 425 ;            state := fss_UnexpectedReply;
 LD   udint 23  ; TFtpStoreState#fss_UnexpectedReply
 WRX  state
#debug_left usint state
#srcline 426 ;          END_IF;
fbStoreToFtp_L120:
#srcline 427 ;        END_IF;
fbStoreToFtp_L117:
 JMP  fbStoreToFtp_L17
fbStoreToFtp_L116:
 LD   17
 LDY  P0__st__
 EQ  
 JMC  fbStoreToFtp_L123
#srcline 428 ;      fss_TxData:
#srcline 429 ;        Send_To_Dat.rq   := 1;
 LD   bool -1      ; true
 WRX  Send_To_Dat~rq
#debug_left bool Send_To_Dat.rq
#srcline 430 ;        tmpud := FileRead(h, PTR_TO_UDINT(ADR(cmdDat)), 255);
 NXT
 LDX  h
#debug udint h
 WR   __Instance__FileRead~hFile
#debug_left udint __Instance__FileRead~hFile
 LEAX cmdDat
#debug pointer cmdDat
 WR   __Instance__FileRead~adrBuf
#debug_left udint __Instance__FileRead~adrBuf
 LD   udint 255
 WR   __Instance__FileRead~size
#debug_left udint __Instance__FileRead~size
 PRV
 LEA  __Instance__FileRead
 CAL  FileRead_L0
 WRY  tmpud
#debug_left udint tmpud
#srcline 431 ;        Send_To_Dat.lenTx := UDINT_TO_UINT(tmpud);
 LDY  tmpud
#debug udint tmpud
 AND  $FFFF
 WRX  Send_To_Dat~lenTx
#debug_left uint Send_To_Dat.lenTx
#srcline 432 ;        lTrans := lTrans + tmpud;
 LDX  lTrans
#debug udint lTrans
 LDY  tmpud
#debug udint tmpud
 ADD
 WRX  lTrans
#debug_left udint lTrans
#srcline 433 ;        Progress := REAL_TO_USINT(UDINT_TO_REAL(lTrans)*100.0/UDINT_TO_REAL(lSize));
 LDX  lTrans
#debug udint lTrans
 ULF
 LD   real 100.0
 MUF
 LDX  lSize
#debug udint lSize
 ULF
 DIF
 RND
 UFW
 AND  $FF
 WRX  Progress
#debug_left usint Progress
#srcline 434 ;        IF tmpud < 255 THEN
 LDY  tmpud
#debug udint tmpud
 LD   udint 255
 LT
 JMC  fbStoreToFtp_L124
#srcline 435 ;          state := fss_RxComplete;
 LD   udint 18  ; TFtpStoreState#fss_RxComplete
 WRX  state
#debug_left usint state
#srcline 436 ;        END_IF;
fbStoreToFtp_L124:
 JMP  fbStoreToFtp_L17
fbStoreToFtp_L123:
 LD   18
 LDY  P0__st__
 EQ  
 JMC  fbStoreToFtp_L126
#srcline 437 ;      fss_RxComplete:
#srcline 438 ;        FileClose(hFile := h);
 NXT
 LDX  h
#debug udint h
 WR   __Instance__FileClose~hFile
#debug_left udint __Instance__FileClose~hFile
 PRV
 LEA  __Instance__FileClose
 CAL  FileClose_L0
#srcline 439 ;        h := INVALID_HANDLE_VALUE;
 LD   udint 0
 WRX  h
#debug_left udint h
#srcline 440 ;        CloseTCPconnection(chanCode := chanCodeDat);
 NXT
 LDX  chanCodeDat
#debug uint chanCodeDat
 WR   __Instance__CloseTCPconnection~chanCode
#debug_left uint __Instance__CloseTCPconnection~chanCode
 PRV
 LEA  __Instance__CloseTCPconnection
 CAL  CloseTCPconnection_L0
#srcline 441 ;        Send_To_Dat.rq   := 0;
 LD   bool 0       ; false
 WRX  Send_To_Dat~rq
#debug_left bool Send_To_Dat.rq
#srcline 442 ;//        Recv_From_Dat.rq := 0;
#srcline 443 ;        IF mesRec THEN
 LDX  mesRec
#debug bool mesRec
 JMC  fbStoreToFtp_L127
#srcline 444 ;          Recv_From_Com.rq := 0;
 LD   bool 0       ; false
 WRX  Recv_From_Com~rq
#debug_left bool Recv_From_Com.rq
#srcline 445 ;          IF tmpReplyCode = 226 THEN
 LDY  tmpReplyCode
#debug uint tmpReplyCode
 LD   uint 226
 EQ
 JMC  fbStoreToFtp_L129
#srcline 446 ;            iniDir := false;
 LD   bool 0       ; false
 WRX  iniDir
#debug_left bool iniDir
#srcline 447 ;            State := fss_ReadDir;
 LD   udint 26  ; TFtpStoreState#fss_ReadDir
 WRX  State
#debug_left usint State
#srcline 448 ;            //state := fss_TxQuit;
#srcline 449 ;          ELSE
 JMP  fbStoreToFtp_L130
fbStoreToFtp_L129:
#srcline 450 ;            state := fss_UnexpectedReply;
 LD   udint 23  ; TFtpStoreState#fss_UnexpectedReply
 WRX  state
#debug_left usint state
#srcline 451 ;          END_IF;
fbStoreToFtp_L130:
#srcline 452 ;        END_IF;
fbStoreToFtp_L127:
 JMP  fbStoreToFtp_L17
fbStoreToFtp_L126:
 LD   19
 LDY  P0__st__
 EQ  
 JMC  fbStoreToFtp_L131
#srcline 453 ;      fss_TxQuit:
#srcline 454 ;        Recv_From_Com.rq := 1;
 LD   bool -1      ; true
 WRX  Recv_From_Com~rq
#debug_left bool Recv_From_Com.rq
#srcline 455 ;        Send_To_Com.rq   := 1;
 LD   bool -1      ; true
 WRX  Send_To_Com~rq
#debug_left bool Send_To_Com.rq
#srcline 456 ;        cmdCom := 'QUIT' + INTERNETLIB_END_OF_LINE_;
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LEA  _str_fbStoreToFtp_12
 SCON 
 LEA  INTERNETLIB_END_OF_LINE_
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX cmdCom
 WRI  
 LEAX cmdCom
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string cmdCom
 PDST   ; Level 1
#srcline 457 ;        state := fss_RxQuit;
 LD   udint 20  ; TFtpStoreState#fss_RxQuit
 WRX  state
#debug_left usint state
 JMP  fbStoreToFtp_L17
fbStoreToFtp_L131:
 LD   20
 LDY  P0__st__
 EQ  
 JMC  fbStoreToFtp_L132
#srcline 458 ;      fss_RxQuit:
#srcline 459 ;        IF mesRec THEN
 LDX  mesRec
#debug bool mesRec
 JMC  fbStoreToFtp_L133
#srcline 460 ;          Recv_From_Com.rq := 0;
 LD   bool 0       ; false
 WRX  Recv_From_Com~rq
#debug_left bool Recv_From_Com.rq
#srcline 461 ;          IF tmpReplyCode = 221 THEN
 LDY  tmpReplyCode
#debug uint tmpReplyCode
 LD   uint 221
 EQ
 JMC  fbStoreToFtp_L135
#srcline 462 ;            state := fss_Close;
 LD   udint 21  ; TFtpStoreState#fss_Close
 WRX  state
#debug_left usint state
#srcline 463 ;          ELSE
 JMP  fbStoreToFtp_L136
fbStoreToFtp_L135:
#srcline 464 ;            state := fss_UnexpectedReply;
 LD   udint 23  ; TFtpStoreState#fss_UnexpectedReply
 WRX  state
#debug_left usint state
#srcline 465 ;          END_IF;
fbStoreToFtp_L136:
#srcline 466 ;        END_IF;
fbStoreToFtp_L133:
 JMP  fbStoreToFtp_L17
fbStoreToFtp_L132:
 LD   21
 LDY  P0__st__
 EQ  
 JMC  fbStoreToFtp_L137
#srcline 467 ;      fss_Close:
#srcline 468 ;        CloseTCPconnection(chanCode := chanCodeCom);
 NXT
 LDX  chanCodeCom
#debug uint chanCodeCom
 WR   __Instance__CloseTCPconnection~chanCode
#debug_left uint __Instance__CloseTCPconnection~chanCode
 PRV
 LEA  __Instance__CloseTCPconnection
 CAL  CloseTCPconnection_L0
#srcline 469 ;        IF IsEstabTCPconnection(chanCode := chanCodeCom) = false THEN
 NXT
 LDX  chanCodeCom
#debug uint chanCodeCom
 WR   __Instance__IsEstabTCPconnection~chanCode
#debug_left uint __Instance__IsEstabTCPconnection~chanCode
 PRV
 LEA  __Instance__IsEstabTCPconnection
 CAL  IsEstabTCPconnection_L0
 LD   bool 0       ; false
 XOR
 NEG
 JMC  fbStoreToFtp_L138
#srcline 470 ;          Done := true;
 LD   bool -1       ; true
 WRX  Done
#debug_left bool Done
#srcline 471 ;          state := fss_Init;
 LD   udint 0  ; TFtpStoreState#fss_Init
 WRX  state
#debug_left usint state
#srcline 472 ;        END_IF;
fbStoreToFtp_L138:
 JMP  fbStoreToFtp_L17
fbStoreToFtp_L137:
 LD   23
 LDY  P0__st__
 EQ  
 JMC  fbStoreToFtp_L140
#srcline 473 ;      fss_UnexpectedReply:
#srcline 474 ;        eErrId := 2;
 LD   usint 2
 WRX  eErrId
#debug_left usint eErrId
#srcline 475 ;        state := fss_Error;
 LD   udint 22  ; TFtpStoreState#fss_Error
 WRX  state
#debug_left usint state
 JMP  fbStoreToFtp_L17
fbStoreToFtp_L140:
 LD   22
 LDY  P0__st__
 EQ  
 JMC  fbStoreToFtp_L141
#srcline 476 ;      fss_Error :
#srcline 477 ;        Err := 1;
 LD   bool -1      ; true
 WRX  Err
#debug_left bool Err
#srcline 478 ;        ErrId := eErrId;
 LDX  eErrId
#debug usint eErrId
 WRX  ErrId
#debug_left usint ErrId
#srcline 479 ;        Recv_From_Com.rq  := 0;
 LD   bool 0       ; false
 WRX  Recv_From_Com~rq
#debug_left bool Recv_From_Com.rq
#srcline 480 ;        state := fss_Init;
 LD   udint 0  ; TFtpStoreState#fss_Init
 WRX  state
#debug_left usint state
 JMP  fbStoreToFtp_L17
fbStoreToFtp_L141:
fbStoreToFtp_L17:
#srcline 482 ;  END_IF;
fbStoreToFtp_L11:
#srcline 484 ;  timeoutCom.IN := Recv_From_Com.rq & NOT Send_To_Dat.rq;
 LDX  Recv_From_Com~rq
#debug bool Recv_From_Com.rq
 LDX  Send_To_Dat~rq
#debug bool Send_To_Dat.rq
 NEG
 AND
 WRX  timeoutCom~IN
#debug_left bool timeoutCom.IN
#srcline 486 ;  Send_To_Com   (lenTx := len(cmdCom), chanCode := chanCodeCom, data := void(cmdCom));
 LEAX cmdCom
#debug string cmdCom
 SLEN 
 WRX  Send_To_Com~lenTx
#debug_left uint Send_To_Com~lenTx
 LDX  chanCodeCom
#debug uint chanCodeCom
 WRX  Send_To_Com~chanCode
#debug_left uint Send_To_Com~chanCode
 LEAX cmdCom
 WRX  Send_To_Com~data
#debug_left pointer Send_To_Com.data
 LEAX Send_To_Com
 CAL  fbSendTo_L0
#srcline 488 ;  Recv_From_Com (lenRx := 255, chanCode := chanCodeCom, data := void(cmdCom), mesRec => mesRec);
 LD   uint 255
 WRX  Recv_From_Com~lenRx
#debug_left uint Recv_From_Com~lenRx
 LDX  chanCodeCom
#debug uint chanCodeCom
 WRX  Recv_From_Com~chanCode
#debug_left uint Recv_From_Com~chanCode
 LEAX cmdCom
 WRX  Recv_From_Com~data
#debug_left pointer Recv_From_Com.data
 LEAX Recv_From_Com
 CAL  fbRecvFrom_L0
; output assigment 
 LDX  Recv_From_Com~mesRec
#debug bool Recv_From_Com~mesRec
 WRX  mesRec
#debug_left bool mesRec
#srcline 490 ;  Send_To_Dat   (chanCode := chanCodeDat, data := void(cmdDat));
 LDX  chanCodeDat
#debug uint chanCodeDat
 WRX  Send_To_Dat~chanCode
#debug_left uint Send_To_Dat~chanCode
 LEAX cmdDat
 WRX  Send_To_Dat~data
#debug_left pointer Send_To_Dat.data
 LEAX Send_To_Dat
 CAL  fbSendTo_L0
#srcline 492 ;  TRO_dat := Send_To_Dat.error = 5; //buffer is full wait
 LDX  Send_To_Dat~error
#debug usint Send_To_Dat.error
 LD   usint 5
 EQ
 WRX  TRO_dat
#debug_left bool TRO_dat
#srcline 493 ;  TRO_com := Send_To_Com.error = 5;
 LDX  Send_To_Com~error
#debug usint Send_To_Com.error
 LD   usint 5
 EQ
 WRX  TRO_com
#debug_left bool TRO_com
#srcline 494 ;  TRO := TRO_com OR TRO_dat;
 LDX  TRO_com
#debug bool TRO_com
 LDX  TRO_dat
#debug bool TRO_dat
 OR  
 WRX  TRO
#debug_left bool TRO
#srcline 496 ;  Send_To_Com.rq := Send_To_Com.rq AND TRO_com;
 LDX  Send_To_Com~rq
#debug bool Send_To_Com.rq
 LDX  TRO_com
#debug bool TRO_com
 AND
 WRX  Send_To_Com~rq
#debug_left bool Send_To_Com.rq
#srcline 497 ;  Send_To_Dat.rq := Send_To_Dat.rq  AND TRO_dat;
 LDX  Send_To_Dat~rq
#debug bool Send_To_Dat.rq
 LDX  TRO_dat
#debug bool TRO_dat
 AND
 WRX  Send_To_Dat~rq
#debug_left bool Send_To_Dat.rq
#srcline 499 ;END_FUNCTION_BLOCK
fbStoreToFtp_RET:
 ULNK
RET
E     61

; Initialize - variables
P     61
fbStoreToFtp__InstanceInit__:
 LINK 0
 LD   uint 21
 WRX  port
 LEAX Send_To_Com
 CAL  fbSendTo__InstanceInit__
 LEAX Recv_From_Com
 CAL  fbRecvFrom__InstanceInit__
 LEAX Send_To_Dat
 CAL  fbSendTo__InstanceInit__
 LD   0
 SRC  byte __Init___fbStoreToFtp_h
 LEAX byte h
 LD   4
 MOV  %X0
 ULNK
RET
E     61
; End initialize - variables
#endpou 



 

#srcfile ''
#srcfile 'C:\TECOLIBSRC\INTERNETLIB\INTERNETLIBVCONTROL\FBHTTPREQUESTL.ST'
#pou fbHttpRequestL
#srcline 5 ;FUNCTION_BLOCK fbHttpRequestL

#struct fbHttpRequestL__temp__
  string[81] lNamePass,
  usint r,
  uint i,
  pointer pHelpString,
  pointer pUint,
  pointer pUsint,
  TUniDesc UniDesc,
  TRemoteEthAdr rea,
  udint l,
  uint authPos,
  uint j,
  usint P0__st__,
  string[257] PS0__st__,
  string[62] PS1__st__,
  string[257] PSC__st__
#data byte _str_fbHttpRequestL_0 = 
  '@',0
#data byte _str_fbHttpRequestL_1 = 
  'G','E','T',' ',0
#data byte _str_fbHttpRequestL_2 = 
  'P','O','S','T',' ',0
#data byte _str_fbHttpRequestL_3 = 
  ' ','H','T','T','P','/','1','.','0',$0D,$0A,'U','s','e','r','-','A','g','e','n',
  't',':',' ','F','o','x','t','r','o','t','/',0
#data byte _str_fbHttpRequestL_4 = 
  '.',0
#data byte _str_fbHttpRequestL_5 = 
  ' ','(','T','e','c','o','m','a','t',';',' ','N',';',' ','e','n','-','U','S',')',
  $0D,$0A,'C','a','c','h','e','-','C','o','n','t','r','o','l',':',' ','m','a','x',
  '-','a','g','e','=','0',$0D,$0A,'A','c','c','e','p','t',':',' ','*','/','*',$0D,
  $0A,'H','o','s','t',':',' ',0
#data byte _str_fbHttpRequestL_6 = 
  $0D,$0A,'A','u','t','h','o','r','i','z','a','t','i','o','n',':',' ','B','a','s',
  'i','c',' ',0
#data byte _str_fbHttpRequestL_7 = 
  $0D,$0A,'C','o','n','t','e','n','t','-','T','y','p','e',':',' ','a','p','p','l',
  'i','c','a','t','i','o','n','/','x','-','w','w','w','-','f','o','r','m','-','u',
  'r','l','e','n','c','o','d','e','d',$0D,$0A,'C','o','n','t','e','n','t','-','L',
  'e','n','g','t','h',':',' ',0
#data byte _str_fbHttpRequestL_8 = 
  $0D,$0A,'C','o','n','n','e','c','t','i','o','n',':',' ','C','l','o','s','e',$0D,
  $0A,$0D,$0A,0
#data byte _str_fbHttpRequestL_9 = 
  $0D,$0A,'C','o','n','n','e','c','t','i','o','n',':',' ','C','l','o','s','e',$0D,
  $0A,$0D,$0A,0
#data byte _str_fbHttpRequestL_10 = 
  $0D,$0A,0
#data byte _str_fbHttpRequestL_11 = 
  'H','T','T','P',0
#data byte _str_fbHttpRequestL_12 = 
  'C','o','n','t','e','n','t','-','L','e','n','g','t','h',':',0
#data byte _str_fbHttpRequestL_13 = 
  $0D,$0A,$0D,$0A,0
P     61
fbHttpRequestL_L0:
 LINK __SizeOf(fbHttpRequestL__temp__)
; Initialize - dynamic variables
 LD   udint $FFFFFFFF    ; nil
 WRY  pHelpString
 LD   udint $FFFFFFFF    ; nil
 WRY  pUint
 LD   udint $FFFFFFFF    ; nil
 WRY  pUsint
; End initialize - dynamic variables
; R_EDGE, F_EDGE 
 LDX  Post
 LETX __EDGE_R__Post
 WRX  Post
 LDX  Get
 LETX __EDGE_R__Get
 WRX  Get
 LDX  Cancel
 LETX __EDGE_R__Cancel
 WRX  Cancel
#srcline 75 ;  IF GetChanIndex( chanCode) <> -1 THEN
 NXT
 LDX  chanCode
#debug uint chanCode
 WR   __Instance__GetChanIndex~chanCode
#debug_left uint __Instance__GetChanIndex~chanCode
 PRV
 LEA  __Instance__GetChanIndex
 CAL  GetChanIndex_L0
 LD   int -1
 EQ
 NEG
 JMC  fbHttpRequestL_L1
#srcline 76 ;    // kanal zalozen pomoci #module => kontrola nutna
#srcline 77 ;    UniDesc := GetChanDesc(chanCode := chanCode);
 NXT
 LDX  chanCode
#debug uint chanCode
 WR   __Instance__GetChanDesc~chanCode
#debug_left uint __Instance__GetChanDesc~chanCode
 PRV
 LEA  __Instance__GetChanDesc
 CAL  GetChanDesc_L0
 LEAY UniDesc
#debug_left pointer UniDesc
 LD   26   ;SizeOf() 
 MOV  %IB0
#srcline 78 ;    IF (UniDesc.modeChan <> 5) OR (UniDesc.lenUniIn <> 516) OR (UniDesc.lenUniOut < 516) THEN
 LDY  UniDesc~modeChan
#debug byte UniDesc.modeChan
 LD   byte 5
 EQ
 NEG
 LDY  UniDesc~lenUniIn
#debug uint UniDesc.lenUniIn
 LD   uint 516
 EQ
 NEG
 OR  
 LDY  UniDesc~lenUniOut
#debug uint UniDesc.lenUniOut
 LD   uint 516
 LT
 OR  
 JMC  fbHttpRequestL_L3
#srcline 79 ;      Err   := true;
 LD   bool -1       ; true
 WRX  Err
#debug_left bool Err
#srcline 80 ;      ErrId := 255;
 LD   usint 255
 WRX  ErrId
#debug_left usint ErrId
#srcline 81 ;      RETURN;
 JMP  fbHttpRequestL_RET
#srcline 82 ;    END_IF;
fbHttpRequestL_L3:
#srcline 83 ;  END_IF;
fbHttpRequestL_L1:
#srcline 85 ;  Busy := State <> hs_HttpIdle;
 LDX  State
#debug usint State
 LD   udint 0  ; THttpState#hs_HttpIdle
 EQ
 NEG
 WRX  Busy
#debug_left bool Busy
#srcline 87 ;  TimeOutTon(IN := Busy & NOT DataReady, PT := T#2m);
 LDX  Busy
#debug bool Busy
 LDX  DataReady
#debug bool DataReady
 NEG
 AND
 WRX  TimeOutTon~IN
#debug_left bool TimeOutTon~IN
 LD   time 120000
 WRX  TimeOutTon~PT
#debug_left time TimeOutTon~PT
 LEAX TimeOutTon
 CAL  TON_L0
#srcline 89 ;  DataReady := false;
 LD   bool 0       ; false
 WRX  DataReady
#debug_left bool DataReady
#srcline 91 ;  IF TimeOutTon.Q THEN
 LDX  TimeOutTon~Q
#debug bool TimeOutTon.Q
 JMC  fbHttpRequestL_L5
#srcline 92 ;    Err   := true;
 LD   bool -1       ; true
 WRX  Err
#debug_left bool Err
#srcline 93 ;    ErrId := 1;
 LD   usint 1
 WRX  ErrId
#debug_left usint ErrId
#srcline 94 ;    State := hs_HttpIdle;
 LD   udint 0  ; THttpState#hs_HttpIdle
 WRX  State
#debug_left usint State
#srcline 95 ;  END_IF;
fbHttpRequestL_L5:
#srcline 97 ;  IF Cancel THEN
 LDX  Cancel
#debug bool Cancel
 JMC  fbHttpRequestL_L7
#srcline 98 ;    State := hs_HttpIdle;
 LD   udint 0  ; THttpState#hs_HttpIdle
 WRX  State
#debug_left usint State
#srcline 99 ;    Err   := ContLen > 0;
 LDX  ContLen
#debug dint ContLen
 LD   dint 0
 GTS
 WRX  Err
#debug_left bool Err
#srcline 100 ;  END_IF;
fbHttpRequestL_L7:
#srcline 102 ;  CASE State OF
 LDX  State
#debug usint State
 WRY  P0__st__
 LD   0
 LDY  P0__st__
 EQ  
 JMC  fbHttpRequestL_L10
#srcline 103 ;    hs_HttpIdle   :
#srcline 104 ;      r := CloseTCPconnection(chanCode := chanCode);
 NXT
 LDX  chanCode
#debug uint chanCode
 WR   __Instance__CloseTCPconnection~chanCode
#debug_left uint __Instance__CloseTCPconnection~chanCode
 PRV
 LEA  __Instance__CloseTCPconnection
 CAL  CloseTCPconnection_L0
 WRY  r
#debug_left usint r
#srcline 105 ;      Done := false;
 LD   bool 0       ; false
 WRX  Done
#debug_left bool Done
#srcline 106 ;      IF Post OR Get THEN
 LDX  Post
#debug bool Post
 LDX  Get
#debug bool Get
 OR  
 JMC  fbHttpRequestL_L11
#srcline 107 ;        sOff := 0;
 LD   uint 0
 WRX  sOff
#debug_left uint sOff
#srcline 108 ;        rLen := 0;
 LD   uint 0
 WRX  rLen
#debug_left uint rLen
#srcline 109 ;        WholeLen := 0;
 LD   dint 0
 WRX  WholeLen
#debug_left dint WholeLen
#srcline 110 ;        Err     := false;
 LD   bool 0       ; false
 WRX  Err
#debug_left bool Err
#srcline 111 ;        ErrId   := 0;
 LD   usint 0
 WRX  ErrId
#debug_left usint ErrId
#srcline 112 ;        Result  := 0;
 LD   int 0
 WRX  Result
#debug_left int Result
#srcline 113 ;        authPos := FIND(IN1 := Host, IN2 := '@');
 LDX  Host
#debug string Host
 LEA  _str_fbHttpRequestL_0
 SFND 
 WRY  authPos
#debug_left uint authPos
#srcline 114 ;        IF authPos > 0 THEN
 LDY  authPos
#debug uint authPos
 LD   uint 0
 GT
 JMC  fbHttpRequestL_L13
#srcline 115 ;          lHost := MID(IN := Host, L := 80, P := authPos+1);
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   80
 DST    ; Level 1
 LDX  Host
#debug string Host
 LD   80
 LDY  authPos
#debug uint authPos
 LD   uint 1
 ADD
 AND  $FFFF
 SUB  1
 SMID 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX lHost
 WRI  
 LEAX lHost
 LD   80
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string lHost
 PDST   ; Level 1
#srcline 116 ;          lNamePass := LEFT(IN := Host, L := authPos-1);
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   80
 DST    ; Level 1
 LDX  Host
#debug string Host
 LDY  authPos
#debug uint authPos
 LD   uint 1
 SUB
 AND  $FFFF
 SLFT 
 PDST   ; Level 1
 LD   0   ; null string
 LEAY lNamePass
 WRI  
 LEAY lNamePass
 LD   80
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string lNamePass
 PDST   ; Level 1
#srcline 117 ;        ELSE
 JMP  fbHttpRequestL_L14
fbHttpRequestL_L13:
#srcline 118 ;          lHost := Host;
 LD   0   ; null string
 LEAX lHost
 WRI  
 LEAX lHost
 LD   80
 DST    ; Level 1
 LDX  Host
#debug string Host
 SCON 
#debug_left string lHost
 PDST   ; Level 1
#srcline 119 ;        END_IF;
fbHttpRequestL_L14:
#srcline 120 ;        (*
#srcline 121 ;        pUint := ADR(RecvData);
#srcline 122 ;        pHelpString := pUint;
#srcline 123 ;        *)
#srcline 124 ;        IF Get THEN
 LDX  Get
#debug bool Get
 JMC  fbHttpRequestL_L15
#srcline 125 ;          BodyLen := 0;
 LD   uint 0
 WRX  BodyLen
#debug_left uint BodyLen
#srcline 126 ;          HelpString := 'GET ' + Action;
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LEA  _str_fbHttpRequestL_1
 SCON 
 LDX  Action
#debug string Action
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX HelpString
 WRI  
 LEAX HelpString
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string HelpString
 PDST   ; Level 1
#srcline 127 ;        ELSE
 JMP  fbHttpRequestL_L16
fbHttpRequestL_L15:
#srcline 128 ;          BodyLen := postLen;
 LDX  postLen
#debug uint postLen
 WRX  BodyLen
#debug_left uint BodyLen
#srcline 129 ;          lPostLen := postLen;
 LDX  postLen
#debug uint postLen
 WRX  lPostLen
#debug_left uint lPostLen
#srcline 130 ;          HelpString := 'POST ' + Action;
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LEA  _str_fbHttpRequestL_2
 SCON 
 LDX  Action
#debug string Action
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX HelpString
 WRI  
 LEAX HelpString
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string HelpString
 PDST   ; Level 1
#srcline 131 ;        END_IF;
fbHttpRequestL_L16:
#srcline 132 ;        //TODO: Dodelat kontrolu delky vstupnich dat
#srcline 133 ;        pUint := ADR(RecvData);
 LDX  RecvData
#debug pointer RecvData
 LEAY pUint
 WRIL 
#debug_left pointer pUint
#srcline 134 ;        pUsint := pUint  + MemcpyPtr(length := LEN(helpstring), source := ADR(helpstring), dest := pUint);
 LEAY pUint
 LDIL 
#debug pointer pUint
 NXT
 LEAX helpstring
#debug string helpstring
 SLEN 
 WR   __Instance__MemcpyPtr~length
#debug_left udint __Instance__MemcpyPtr~length
 LEAX helpstring
#debug pointer helpstring
 LEA  __Instance__MemcpyPtr~source
 WRIL 
#debug_left udint __Instance__MemcpyPtr~source
 LEAY pUint
 LDIL 
#debug pointer pUint
 LEA  __Instance__MemcpyPtr~dest
 WRIL 
#debug_left udint __Instance__MemcpyPtr~dest
 PRV
 LEA  __Instance__MemcpyPtr
 CAL  MemcpyPtr_L0
 ADD
 LEAY pUsint
 WRIL 
#debug_left pointer pUsint
#srcline 135 ;        //max len 5+255 = 300
#srcline 136 ;        helpstring := ' HTTP/1.0$r$nUser-Agent: Foxtrot/' + USINT_TO_STRING(%S40) + '.' + USINT_TO_STRING(%S41);
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LEA  _str_fbHttpRequestL_3
 SCON 
 LD   0   ; null string
 WRY  PSC__st__[0]
 LEAY PSC__st__[0]
 LD   255
 DST    ; Level 2
 LD   %S40
 SCNV $0830;  IEC_USINT _TO_ IEC_STRING
 PDST   ; Level 2
 LEAY PSC__st__[0]

 SCON 
 LEA  _str_fbHttpRequestL_4
 SCON 
 LD   0   ; null string
 WRY  PSC__st__[0]
 LEAY PSC__st__[0]
 LD   255
 DST    ; Level 2
 LD   %S41
 SCNV $0830;  IEC_USINT _TO_ IEC_STRING
 PDST   ; Level 2
 LEAY PSC__st__[0]

 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX helpstring
 WRI  
 LEAX helpstring
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string helpstring
 PDST   ; Level 1
#srcline 137 ;        pUsint := pUsint + MemcpyPtr(length := LEN(helpstring), source := ADR(helpstring), dest := pUsint);
 LEAY pUsint
 LDIL 
#debug pointer pUsint
 NXT
 LEAX helpstring
#debug string helpstring
 SLEN 
 WR   __Instance__MemcpyPtr~length
#debug_left udint __Instance__MemcpyPtr~length
 LEAX helpstring
#debug pointer helpstring
 LEA  __Instance__MemcpyPtr~source
 WRIL 
#debug_left udint __Instance__MemcpyPtr~source
 LEAY pUsint
 LDIL 
#debug pointer pUsint
 LEA  __Instance__MemcpyPtr~dest
 WRIL 
#debug_left udint __Instance__MemcpyPtr~dest
 PRV
 LEA  __Instance__MemcpyPtr
 CAL  MemcpyPtr_L0
 ADD
 LEAY pUsint
 WRIL 
#debug_left pointer pUsint
#srcline 138 ;        //max len 300+33+1+1+1 = 336
#srcline 139 ;        helpstring := ' (Tecomat; N; en-US)$r$nCache-Control: max-age=0$r$nAccept: */*$r$nHost: ';
 LD   0   ; null string
 LEAX helpstring
 WRI  
 LEAX helpstring
 LD   255
 DST    ; Level 1
 LEA  _str_fbHttpRequestL_5
 SCON 
#debug_left string helpstring
 PDST   ; Level 1
#srcline 140 ;        pUsint := pUsint + MemcpyPtr(length := LEN(helpstring), source := ADR(helpstring), dest := pUsint);
 LEAY pUsint
 LDIL 
#debug pointer pUsint
 NXT
 LEAX helpstring
#debug string helpstring
 SLEN 
 WR   __Instance__MemcpyPtr~length
#debug_left udint __Instance__MemcpyPtr~length
 LEAX helpstring
#debug pointer helpstring
 LEA  __Instance__MemcpyPtr~source
 WRIL 
#debug_left udint __Instance__MemcpyPtr~source
 LEAY pUsint
 LDIL 
#debug pointer pUsint
 LEA  __Instance__MemcpyPtr~dest
 WRIL 
#debug_left udint __Instance__MemcpyPtr~dest
 PRV
 LEA  __Instance__MemcpyPtr
 CAL  MemcpyPtr_L0
 ADD
 LEAY pUsint
 WRIL 
#debug_left pointer pUsint
#srcline 141 ;        //max len 336+140 = 476
#srcline 142 ;        Err := true;
 LD   bool -1       ; true
 WRX  Err
#debug_left bool Err
#srcline 143 ;        REPEAT
fbHttpRequestL_L17:
 DBG
#srcline 144 ;          l := LEN(lHost);
 LEAX lHost
#debug string lHost
 SLEN 
 WRY  l
#debug_left udint l
#srcline 145 ;          IF PTR_TO_UDINT(pUsint) - PTR_TO_UDINT(pUint) + l > 512 THEN EXIT; END_IF;
 LEAY pUsint
 LDIL 
#debug pointer pUsint
 LEAY pUint
 LDIL 
#debug pointer pUint
 SUB
 LDY  l
#debug udint l
 ADD
 LD   udint 512
 GT
 JMC  fbHttpRequestL_L19
 JMP  fbHttpRequestL_L18
fbHttpRequestL_L19:
#srcline 146 ;          pUsint := pUsint + MemcpyPtr(length := l, source := ADR(lHost), dest := pUsint);
 LEAY pUsint
 LDIL 
#debug pointer pUsint
 NXT
 LDY  l
#debug udint l
 WR   __Instance__MemcpyPtr~length
#debug_left udint __Instance__MemcpyPtr~length
 LEAX lHost
#debug pointer lHost
 LEA  __Instance__MemcpyPtr~source
 WRIL 
#debug_left udint __Instance__MemcpyPtr~source
 LEAY pUsint
 LDIL 
#debug pointer pUsint
 LEA  __Instance__MemcpyPtr~dest
 WRIL 
#debug_left udint __Instance__MemcpyPtr~dest
 PRV
 LEA  __Instance__MemcpyPtr
 CAL  MemcpyPtr_L0
 ADD
 LEAY pUsint
 WRIL 
#debug_left pointer pUsint
#srcline 147 ;          
#srcline 148 ;          IF authPos > 0 THEN
 LDY  authPos
#debug uint authPos
 LD   uint 0
 GT
 JMC  fbHttpRequestL_L21
#srcline 149 ;            //Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==
#srcline 150 ;            helpstring := '$r$nAuthorization: Basic ' + Base64_encode_string(lNamePass);
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LEA  _str_fbHttpRequestL_6
 SCON 
 NXT
 LD   0   ; null string
 LEA  __Instance__Base64_encode_string~data
 WRI 
 LEA  __Instance__Base64_encode_string~data
 LD   60
 DST    ; Level 2
 LEAY lNamePass
#debug string lNamePass
 SCON 
#debug_left string __Instance__Base64_encode_string~data
 PDST   ; Level 2
 PRV
 LEA  __Instance__Base64_encode_string
 CAL  Base64_encode_string_L0

 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX helpstring
 WRI  
 LEAX helpstring
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string helpstring
 PDST   ; Level 1
#srcline 151 ;            l := LEN(helpstring);
 LEAX helpstring
#debug string helpstring
 SLEN 
 WRY  l
#debug_left udint l
#srcline 152 ;            IF PTR_TO_UDINT(pUsint) - PTR_TO_UDINT(pUint) + l > 512 THEN EXIT; END_IF;
 LEAY pUsint
 LDIL 
#debug pointer pUsint
 LEAY pUint
 LDIL 
#debug pointer pUint
 SUB
 LDY  l
#debug udint l
 ADD
 LD   udint 512
 GT
 JMC  fbHttpRequestL_L23
 JMP  fbHttpRequestL_L18
fbHttpRequestL_L23:
#srcline 153 ;            pUsint := pUsint + MemcpyPtr(length := l, source := ADR(helpstring), dest := pUsint);
 LEAY pUsint
 LDIL 
#debug pointer pUsint
 NXT
 LDY  l
#debug udint l
 WR   __Instance__MemcpyPtr~length
#debug_left udint __Instance__MemcpyPtr~length
 LEAX helpstring
#debug pointer helpstring
 LEA  __Instance__MemcpyPtr~source
 WRIL 
#debug_left udint __Instance__MemcpyPtr~source
 LEAY pUsint
 LDIL 
#debug pointer pUsint
 LEA  __Instance__MemcpyPtr~dest
 WRIL 
#debug_left udint __Instance__MemcpyPtr~dest
 PRV
 LEA  __Instance__MemcpyPtr
 CAL  MemcpyPtr_L0
 ADD
 LEAY pUsint
 WRIL 
#debug_left pointer pUsint
#srcline 154 ;          END_IF;
fbHttpRequestL_L21:
#srcline 155 ;          
#srcline 156 ;          //max len 476+80 = 556!!!
#srcline 157 ;          IF BodyLen > 0 THEN
 LDX  BodyLen
#debug uint BodyLen
 LD   uint 0
 GT
 JMC  fbHttpRequestL_L25
#srcline 158 ;            helpstring := '$r$nContent-Type: application/x-www-form-urlencoded$r$nContent-Length: ' + UINT_TO_STRING(BodyLen) + '$r$nConnection: Close$r$n$r$n';
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LEA  _str_fbHttpRequestL_7
 SCON 
 LD   0   ; null string
 WRY  PSC__st__[0]
 LEAY PSC__st__[0]
 LD   255
 DST    ; Level 2
 LDX  BodyLen
#debug uint BodyLen
 SCNV $0A30;  IEC_UINT _TO_ IEC_STRING
 PDST   ; Level 2
 LEAY PSC__st__[0]

 SCON 
 LEA  _str_fbHttpRequestL_8
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX helpstring
 WRI  
 LEAX helpstring
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string helpstring
 PDST   ; Level 1
#srcline 159 ;          ELSE
 JMP  fbHttpRequestL_L26
fbHttpRequestL_L25:
#srcline 160 ;            helpstring := '$r$nConnection: Close$r$n$r$n';
 LD   0   ; null string
 LEAX helpstring
 WRI  
 LEAX helpstring
 LD   255
 DST    ; Level 1
 LEA  _str_fbHttpRequestL_9
 SCON 
#debug_left string helpstring
 PDST   ; Level 1
#srcline 161 ;          END_IF;
fbHttpRequestL_L26:
#srcline 162 ;          l := LEN(helpstring);
 LEAX helpstring
#debug string helpstring
 SLEN 
 WRY  l
#debug_left udint l
#srcline 163 ;          IF PTR_TO_UDINT(pUsint) - PTR_TO_UDINT(pUint) + l > 512 THEN EXIT; END_IF;
 LEAY pUsint
 LDIL 
#debug pointer pUsint
 LEAY pUint
 LDIL 
#debug pointer pUint
 SUB
 LDY  l
#debug udint l
 ADD
 LD   udint 512
 GT
 JMC  fbHttpRequestL_L27
 JMP  fbHttpRequestL_L18
fbHttpRequestL_L27:
#srcline 164 ;          pUsint := pUsint + MemcpyPtr(length := l, source := ADR(helpstring), dest := pUsint);
 LEAY pUsint
 LDIL 
#debug pointer pUsint
 NXT
 LDY  l
#debug udint l
 WR   __Instance__MemcpyPtr~length
#debug_left udint __Instance__MemcpyPtr~length
 LEAX helpstring
#debug pointer helpstring
 LEA  __Instance__MemcpyPtr~source
 WRIL 
#debug_left udint __Instance__MemcpyPtr~source
 LEAY pUsint
 LDIL 
#debug pointer pUsint
 LEA  __Instance__MemcpyPtr~dest
 WRIL 
#debug_left udint __Instance__MemcpyPtr~dest
 PRV
 LEA  __Instance__MemcpyPtr
 CAL  MemcpyPtr_L0
 ADD
 LEAY pUsint
 WRIL 
#debug_left pointer pUsint
#srcline 166 ;          //max len 556+44=600!!!
#srcline 167 ;          (*
#srcline 168 ;          IF POST THEN //copy data to post
#srcline 169 ;            l := LEN(data);
#srcline 170 ;            IF PTR_TO_UDINT(pUsint) - PTR_TO_UDINT(pUint) + l > 512 THEN EXIT; END_IF;
#srcline 171 ;            pUsint := pUsint + MemcpyPtr(length := LEN(data), source := ADR(data), dest := pUsint);
#srcline 172 ;            //max len 600+80=680!!!
#srcline 173 ;          END_IF;
#srcline 174 ;          *)
#srcline 175 ;          Err := false;
 LD   bool 0       ; false
 WRX  Err
#debug_left bool Err
#srcline 176 ;        UNTIL true END_REPEAT;
 LD   bool -1       ; true
 JMC  fbHttpRequestL_L17
fbHttpRequestL_L18:
 NOP  -1
#srcline 177 ;        IF Err THEN
 LDX  Err
#debug bool Err
 JMC  fbHttpRequestL_L29
#srcline 178 ;          ErrId := 3; //delka hlavicka protokolu presahla 512 bytes
 LD   usint 3
 WRX  ErrId
#debug_left usint ErrId
#srcline 179 ;        ELSE
 JMP  fbHttpRequestL_L30
fbHttpRequestL_L29:
#srcline 180 ;          SendTo.lenTx := UDINT_TO_UINT(PTR_TO_UDINT(pUsint) - PTR_TO_UDINT(pUint));
 LEAY pUsint
 LDIL 
#debug pointer pUsint
 LEAY pUint
 LDIL 
#debug pointer pUint
 SUB
 AND  $FFFF
 WRX  SendTo~lenTx
#debug_left uint SendTo.lenTx
#srcline 181 ;          State := hs_HttpSetIP;
 LD   udint 1  ; THttpState#hs_HttpSetIP
 WRX  State
#debug_left usint State
#srcline 182 ;          Busy  := true; //Busy is set in the same cycle when we left idle state!!!
 LD   bool -1       ; true
 WRX  Busy
#debug_left bool Busy
#srcline 183 ;        END_IF;
fbHttpRequestL_L30:
#srcline 184 ;      END_IF;
fbHttpRequestL_L11:
 JMP  fbHttpRequestL_L9
fbHttpRequestL_L10:
 LD   1
 LDY  P0__st__
 EQ  
 JMC  fbHttpRequestL_L31
#srcline 185 ;    hs_HttpSetIP:
#srcline 186 ;      IF IPadr = Any_IP THEN
 LEAX IPadr
 LEA  Any_IP
 LD   4   ; SizeOf()
 BCMP 
 EQ   0
 JMC  fbHttpRequestL_L32
#srcline 187 ;          Err   := true;
 LD   bool -1       ; true
 WRX  Err
#debug_left bool Err
#srcline 188 ;          ErrId := 254;
 LD   usint 254
 WRX  ErrId
#debug_left usint ErrId
#srcline 189 ;          State := hs_HttpIdle;
 LD   udint 0  ; THttpState#hs_HttpIdle
 WRX  State
#debug_left usint State
#srcline 190 ;      ELSE
 JMP  fbHttpRequestL_L33
fbHttpRequestL_L32:
#srcline 191 ;        rea.remoteIP   := IPadr;
 LEAX IPadr
#debug pointer IPadr
 SRC  %IB0
 LEAY rea~remoteIP
#debug_left pointer rea.remoteIP
 LD   4   ;SizeOf() 
 MOV  %IB0
#srcline 192 ;        rea.remotePort := port;
 LDX  port
#debug uint port
 WRY  rea~remotePort
#debug_left uint rea.remotePort
#srcline 193 ;/////////nem 21.5.2019
#srcline 194 ;        uniDesc := GetChanDesc( chanCode := chanCode);
 NXT
 LDX  chanCode
#debug uint chanCode
 WR   __Instance__GetChanDesc~chanCode
#debug_left uint __Instance__GetChanDesc~chanCode
 PRV
 LEA  __Instance__GetChanDesc
 CAL  GetChanDesc_L0
 LEAY uniDesc
#debug_left pointer uniDesc
 LD   26   ;SizeOf() 
 MOV  %IB0
#srcline 195 ;        IF uniDesc.res = USINT_TO_BYTE( UNI_SSL_CLIENT) THEN
 LDY  uniDesc~res
#debug byte uniDesc.res
 LD   usint 35
 AND  $FF
 EQ
 JMC  fbHttpRequestL_L34
#srcline 196 ;          SetUniChanHostName( chanHandle := chanCode, hostName := Host);  // nastavit host name pro SSL socket
 NXT
 LDX  chanCode
#debug uint chanCode
 WR   __Instance__SetUniChanHostName~chanHandle
#debug_left uint __Instance__SetUniChanHostName~chanHandle
 LD   0   ; null string
 LEA  __Instance__SetUniChanHostName~hostName
 WRI 
 LEA  __Instance__SetUniChanHostName~hostName
 LD   80
 DST    ; Level 1
 LDX  Host
#debug string Host
 SCON 
#debug_left string __Instance__SetUniChanHostName~hostName
 PDST   ; Level 1
 PRV
 LEA  __Instance__SetUniChanHostName
 CAL  SetUniChanHostName_L0
#srcline 197 ;        END_IF;
fbHttpRequestL_L34:
#srcline 198 ;/////////
#srcline 199 ;        IF SetRemoteIPaddress(rq := 1, chanCode := chanCode, ethAdr := rea) THEN
 NXT
 LD   1
 WR   __Instance__SetRemoteIPaddress~rq
#debug_left bool __Instance__SetRemoteIPaddress~rq
 LDX  chanCode
#debug uint chanCode
 WR   __Instance__SetRemoteIPaddress~chanCode
#debug_left uint __Instance__SetRemoteIPaddress~chanCode
 LEAY rea
 WR   __Instance__SetRemoteIPaddress~ethAdr
#debug_left pointer __Instance__SetRemoteIPaddress.ethAdr
 PRV
 LEA  __Instance__SetRemoteIPaddress
 CAL  SetRemoteIPaddress_L0
 JMC  fbHttpRequestL_L36
#srcline 200 ;          State := hs_HttpConnect;
 LD   udint 2  ; THttpState#hs_HttpConnect
 WRX  State
#debug_left usint State
#srcline 201 ;        END_IF;
fbHttpRequestL_L36:
#srcline 202 ;      END_IF;
fbHttpRequestL_L33:
 JMP  fbHttpRequestL_L9
fbHttpRequestL_L31:
 LD   2
 LDY  P0__st__
 EQ  
 JMC  fbHttpRequestL_L38
#srcline 203 ;    hs_HttpConnect:
#srcline 204 ;      r := EstabTCPconnection(chanCode := chanCode);
 NXT
 LDX  chanCode
#debug uint chanCode
 WR   __Instance__EstabTCPconnection~chanCode
#debug_left uint __Instance__EstabTCPconnection~chanCode
 PRV
 LEA  __Instance__EstabTCPconnection
 CAL  EstabTCPconnection_L0
 WRY  r
#debug_left usint r
#srcline 205 ;      IF IsEstabTCPconnection(chanCode := chanCode) THEN
 NXT
 LDX  chanCode
#debug uint chanCode
 WR   __Instance__IsEstabTCPconnection~chanCode
#debug_left uint __Instance__IsEstabTCPconnection~chanCode
 PRV
 LEA  __Instance__IsEstabTCPconnection
 CAL  IsEstabTCPconnection_L0
 JMC  fbHttpRequestL_L39
#srcline 206 ;        State := hs_HttpSend;
 LD   udint 3  ; THttpState#hs_HttpSend
 WRX  State
#debug_left usint State
#srcline 207 ;      END_IF;
fbHttpRequestL_L39:
 JMP  fbHttpRequestL_L9
fbHttpRequestL_L38:
 LD   3
 LDY  P0__st__
 EQ  
 JMC  fbHttpRequestL_L41
#srcline 208 ;    hs_HttpSend   :
#srcline 209 ;      SendTo(rq := 1, chanCode := chanCode, data := void(RecvData));
 LD   1
 WRX  SendTo~rq
#debug_left bool SendTo~rq
 LDX  chanCode
#debug uint chanCode
 WRX  SendTo~chanCode
#debug_left uint SendTo~chanCode
 LDX  RecvData
 WRX  SendTo~data
#debug_left pointer SendTo.data
 LEAX SendTo
 CAL  fbSendTo_L0
#srcline 210 ;      ResRecv    := false;
 LD   bool 0       ; false
 WRX  ResRecv
#debug_left bool ResRecv
#srcline 211 ;      LenRecv    := false;
 LD   bool 0       ; false
 WRX  LenRecv
#debug_left bool LenRecv
#srcline 212 ;      HeaderRecv := false;
 LD   bool 0       ; false
 WRX  HeaderRecv
#debug_left bool HeaderRecv
#srcline 213 ;      ContLen    := -1;
 LD   dint -1
 WRX  ContLen
#debug_left dint ContLen
#srcline 214 ;      State := hs_HttpSendPost;
 LD   udint 5  ; THttpState#hs_HttpSendPost
 WRX  State
#debug_left usint State
 JMP  fbHttpRequestL_L9
fbHttpRequestL_L41:
 LD   5
 LDY  P0__st__
 EQ  
 JMC  fbHttpRequestL_L42
#srcline 215 ;    hs_HttpSendPost :
#srcline 216 ;      IF BodyLen > 0 THEN
 LDX  BodyLen
#debug uint BodyLen
 LD   uint 0
 GT
 JMC  fbHttpRequestL_L43
#srcline 217 ;        SendTo(rq := 1, chanCode := chanCode, data := void(Data[lPostLen-BodyLen]), lenTx := MIN(512,BodyLen));
 LD   1
 WRX  SendTo~rq
#debug_left bool SendTo~rq
 LDX  chanCode
#debug uint chanCode
 WRX  SendTo~chanCode
#debug_left uint SendTo~chanCode
 LDX  Data
 LDX  lPostLen
#debug uint lPostLen
 LDX  BodyLen
#debug uint BodyLen
 SUB
 AND  $FFFF
 RCHK 1535   ; Range Check
 ADD     ; + offset 
 WRX  SendTo~data
#debug_left pointer SendTo.data
 LD   uint 512
 LDX  BodyLen
#debug uint BodyLen
 MIN
 WRX  SendTo~lenTx
#debug_left uint SendTo~lenTx
 LEAX SendTo
 CAL  fbSendTo_L0
#srcline 218 ;        IF SendTo.mesSent THEN
 LDX  SendTo~mesSent
#debug bool SendTo.mesSent
 JMC  fbHttpRequestL_L45
#srcline 219 ;          BodyLen := BodyLen - MIN(512,BodyLen);
 LDX  BodyLen
#debug uint BodyLen
 LD   uint 512
 LDX  BodyLen
#debug uint BodyLen
 MIN
 SUB
 AND  $FFFF
 WRX  BodyLen
#debug_left uint BodyLen
#srcline 220 ;        END_IF;
fbHttpRequestL_L45:
#srcline 221 ;      ELSE
 JMP  fbHttpRequestL_L44
fbHttpRequestL_L43:
#srcline 222 ;        State := hs_HttpReceivingData;
 LD   udint 4  ; THttpState#hs_HttpReceivingData
 WRX  State
#debug_left usint State
#srcline 223 ;      END_IF;
fbHttpRequestL_L44:
 JMP  fbHttpRequestL_L9
fbHttpRequestL_L42:
 LD   4
 LDY  P0__st__
 EQ  
 JMC  fbHttpRequestL_L47
#srcline 224 ;    hs_HttpReceivingData  :
#srcline 225 ;      RecvFrom(rq := 1, chanCode := chanCode, lenRx := 512, data := void(RecvData));
 LD   1
 WRX  RecvFrom~rq
#debug_left bool RecvFrom~rq
 LDX  chanCode
#debug uint chanCode
 WRX  RecvFrom~chanCode
#debug_left uint RecvFrom~chanCode
 LD   uint 512
 WRX  RecvFrom~lenRx
#debug_left uint RecvFrom~lenRx
 LDX  RecvData
 WRX  RecvFrom~data
#debug_left pointer RecvFrom.data
 LEAX RecvFrom
 CAL  fbRecvFrom_L0
#srcline 226 ;      IF RecvFrom.mesRec THEN                                                   //byla prijata data
 LDX  RecvFrom~mesRec
#debug bool RecvFrom.mesRec
 JMC  fbHttpRequestL_L48
#srcline 227 ;        IF HeaderRecv THEN                                                      //uz byla prijata hlavicka
 LDX  HeaderRecv
#debug bool HeaderRecv
 JMC  fbHttpRequestL_L50
#srcline 228 ;          DataLen := RecvFrom.lenData;                                          //delka dat je rovna delce prijateho paketu
 LDX  RecvFrom~lenData
#debug uint RecvFrom.lenData
 WRX  DataLen
#debug_left uint DataLen
#srcline 229 ;          ContLen := ContLen - UINT_TO_DINT(DataLen);                           //snizit contlen o prijatou delku
 LDX  ContLen
#debug dint ContLen
 LDX  DataLen
#debug uint DataLen
 SUB
 WRX  ContLen
#debug_left dint ContLen
#srcline 230 ;          pUsint  := ADR(RecvData);                                             //nastavit pointer na zacatek dat
 LDX  RecvData
#debug pointer RecvData
 LEAY pUsint
 WRIL 
#debug_left pointer pUsint
#srcline 231 ;        ELSE                                                                    //jeste nebyla prijata hlavicka
 JMP  fbHttpRequestL_L51
fbHttpRequestL_L50:
#srcline 232 ;          i := TO_UINT(MemcpyEx(length := MIN(TO_UDINT(RecvFrom.lenData), 255-TO_UDINT(sOff)),
 NXT
 LDX  RecvFrom~lenData
#debug uint RecvFrom.lenData
 LD   udint 255
 LDX  sOff
#debug uint sOff
 SUB
 MIN
 WR   __Instance__MemcpyEx~length
#debug_left udint __Instance__MemcpyEx~length
#srcline 233 ;               offDest := TO_UDINT(sOff),
 LDX  sOff
#debug uint sOff
 WR   __Instance__MemcpyEx~offDest
#debug_left udint __Instance__MemcpyEx~offDest
#srcline 234 ;               source := RecvData[0], dest := void(helpstring)));
 LDX  RecvData
 WR   __Instance__MemcpyEx~source
#debug_left pointer __Instance__MemcpyEx.source
 LEAX helpstring
 WR   __Instance__MemcpyEx~dest
#debug_left pointer __Instance__MemcpyEx.dest
 LD   0
 WR   __Instance__MemcpyEx~offSource
 PRV
 LEA  __Instance__MemcpyEx
 CAL  MemcpyEx_L0
 WRY  i
#debug_left uint i
#srcline 236 ;          sOff := sOff + i;
 LDX  sOff
#debug uint sOff
 LDY  i
#debug uint i
 ADD
 AND  $FFFF
 WRX  sOff
#debug_left uint sOff
#srcline 237 ;          rLen := RecvFrom.lenData - i;
 LDX  RecvFrom~lenData
#debug uint RecvFrom.lenData
 LDY  i
#debug uint i
 SUB
 AND  $FFFF
 WRX  rLen
#debug_left uint rLen
#srcline 239 ;          pUsint := ADR(helpstring) + TO_UDINT(sOff);
 LEAX helpstring
#debug pointer helpstring
 LDX  sOff
#debug uint sOff
 ADD
 LEAY pUsint
 WRIL 
#debug_left pointer pUsint
#srcline 240 ;          pUsint^ := 0;
 LD   usint 0
 LEAY pUsint
 LDIL    ; dereference 
 WRI 
#debug_left usint pUsint^
#srcline 242 ;          WHILE true DO
fbHttpRequestL_L52:
 LD   bool -1       ; true
 JMC  fbHttpRequestL_L53
 DBG 
#srcline 243 ;            i :=  FIND(IN1 := helpstring, IN2 := '$r$n');
 LEAX helpstring
#debug string helpstring
 LEA  _str_fbHttpRequestL_10
 SFND 
 WRY  i
#debug_left uint i
#srcline 244 ;            IF i = 1 THEN //konec
 LDY  i
#debug uint i
 LD   uint 1
 EQ
 JMC  fbHttpRequestL_L54
#srcline 245 ;              rLen := rLen - 2 + sOff - i + 1;
 LDX  rLen
#debug uint rLen
 LD   uint 2
 SUB
 AND  $FFFF
 LDX  sOff
#debug uint sOff
 ADD
 AND  $FFFF
 LDY  i
#debug uint i
 SUB
 AND  $FFFF
 LD   uint 1
 ADD
 AND  $FFFF
 WRX  rLen
#debug_left uint rLen
#srcline 246 ;              HeaderRecv := true;
 LD   bool -1       ; true
 WRX  HeaderRecv
#debug_left bool HeaderRecv
#srcline 247 ;              EXIT;
 JMP  fbHttpRequestL_L53
#srcline 248 ;            ELSIF i > 1 THEN  //je tam enter
 JMP  fbHttpRequestL_L55
fbHttpRequestL_L54:
 LDY  i
#debug uint i
 LD   uint 1
 GT
 JMC  fbHttpRequestL_L56
#srcline 249 ;              IF NOT ResRecv THEN
 LDX  ResRecv
#debug bool ResRecv
 NEG
 JMC  fbHttpRequestL_L57
#srcline 250 ;                IF FIND(IN1 := helpstring, IN2 := 'HTTP') = 1 THEN      //vyhledani zda je to HTTP hlavicka
 LEAX helpstring
#debug string helpstring
 LEA  _str_fbHttpRequestL_11
 SFND 
 LD   int 1
 EQ
 JMC  fbHttpRequestL_L59
#srcline 251 ;                  ResRecv := true;                                      //prijat zacatek hlavicky
 LD   bool -1       ; true
 WRX  ResRecv
#debug_left bool ResRecv
#srcline 252 ;                  pHelpString := ADR(helpstring) + 9;                   //posunout pointer
 LEAX helpstring
#debug pointer helpstring
 LD   udint 9
 ADD
 LEAY pHelpString
 WRIL 
#debug_left pointer pHelpString
#srcline 253 ;                  Result := STRING_TO_INT(pHelpString^);                //rozkodovat navratovy kod
 LEAY pHelpString
 LDIL    ; dereference 
#debug string pHelpString^
 SCNV $300B;  IEC_STRING _TO_ IEC_INT
 WRX  Result
#debug_left int Result
#srcline 254 ;    //            Debug1       := pHelpString^;
#srcline 255 ;                END_IF;
fbHttpRequestL_L59:
#srcline 256 ;              END_IF;
fbHttpRequestL_L57:
#srcline 257 ;              IF NOT LenRecv THEN                                                   //hledat delku jen kdyz se jeste nenasla 121108
 LDX  LenRecv
#debug bool LenRecv
 NEG
 JMC  fbHttpRequestL_L61
#srcline 258 ;                                                     //012345678901234
#srcline 259 ;                j := FIND(IN1 := helpstring, IN2 := 'Content-Length:');           //hledat delku tela
 LEAX helpstring
#debug string helpstring
 LEA  _str_fbHttpRequestL_12
 SFND 
 WRY  j
#debug_left uint j
#srcline 260 ;                IF j > 0 AND j < i THEN                                            //nasla se delka
 LDY  j
#debug uint j
 LD   uint 0
 GT
 LDY  j
#debug uint j
 LDY  i
#debug uint i
 LT
 AND
 JMC  fbHttpRequestL_L63
#srcline 261 ;                  LenRecv := true;                                                //nastavit priznak ze byla nalezena
 LD   bool -1       ; true
 WRX  LenRecv
#debug_left bool LenRecv
#srcline 262 ;                  pHelpString := ADR(helpstring) + UINT_TO_UDINT(j+15);           //posunout pointer
 LEAX helpstring
#debug pointer helpstring
 LDY  j
#debug uint j
 LD   uint 15
 ADD
 AND  $FFFF
 ADD
 LEAY pHelpString
 WRIL 
#debug_left pointer pHelpString
#srcline 263 ;                  ContLen     := STRING_TO_DINT(pHelpString^);                    //zapsat delku
 LEAY pHelpString
 LDIL    ; dereference 
#debug string pHelpString^
 SCNV $300D;  IEC_STRING _TO_ IEC_DINT
 WRX  ContLen
#debug_left dint ContLen
#srcline 264 ;      //            Debug2       := pHelpString^;
#srcline 265 ;                END_IF;
fbHttpRequestL_L63:
#srcline 266 ;              END_IF;
fbHttpRequestL_L61:
#srcline 267 ;              IF i = FIND(IN1 := helpstring, IN2 := '$r$n$r$n') THEN //konec
 LDY  i
#debug uint i
 LEAX helpstring
#debug string helpstring
 LEA  _str_fbHttpRequestL_13
 SFND 
 EQ
 JMC  fbHttpRequestL_L65
#srcline 268 ;                rLen := rLen - 4 + sOff - i + 1;
 LDX  rLen
#debug uint rLen
 LD   uint 4
 SUB
 AND  $FFFF
 LDX  sOff
#debug uint sOff
 ADD
 AND  $FFFF
 LDY  i
#debug uint i
 SUB
 AND  $FFFF
 LD   uint 1
 ADD
 AND  $FFFF
 WRX  rLen
#debug_left uint rLen
#srcline 269 ;                HeaderRecv := true;
 LD   bool -1       ; true
 WRX  HeaderRecv
#debug_left bool HeaderRecv
#srcline 270 ;                EXIT;
 JMP  fbHttpRequestL_L53
#srcline 271 ;              END_IF;
fbHttpRequestL_L65:
#srcline 272 ;              MemcpyEx(length := TO_UDINT(sOff - i), offSource := TO_UDINT(i) + 1,
 NXT
 LDX  sOff
#debug uint sOff
 LDY  i
#debug uint i
 SUB
 WR   __Instance__MemcpyEx~length
#debug_left udint __Instance__MemcpyEx~length
 LDY  i
#debug uint i
 LD   udint 1
 ADD
 WR   __Instance__MemcpyEx~offSource
#debug_left udint __Instance__MemcpyEx~offSource
#srcline 273 ;                       source := void(helpstring), dest := void(helpstring));
 LEAX helpstring
 WR   __Instance__MemcpyEx~source
#debug_left pointer __Instance__MemcpyEx.source
 LEAX helpstring
 WR   __Instance__MemcpyEx~dest
#debug_left pointer __Instance__MemcpyEx.dest
 LD   0
 WR   __Instance__MemcpyEx~offDest
 PRV
 LEA  __Instance__MemcpyEx
 CAL  MemcpyEx_L0
#srcline 274 ;              sOff := sOff - i - 1;
 LDX  sOff
#debug uint sOff
 LDY  i
#debug uint i
 SUB
 AND  $FFFF
 LD   uint 1
 SUB
 AND  $FFFF
 WRX  sOff
#debug_left uint sOff
#srcline 275 ;            ELSE
 JMP  fbHttpRequestL_L55
fbHttpRequestL_L56:
#srcline 276 ;              IF sOff = 255 THEN //je to bez enteru a plne - zahodit
 LDX  sOff
#debug uint sOff
 LD   uint 255
 EQ
 JMC  fbHttpRequestL_L67
#srcline 277 ;                MemcpyEx(length := 1, offSource := 254,
 NXT
 LD   udint 1
 WR   __Instance__MemcpyEx~length
#debug_left udint __Instance__MemcpyEx~length
 LD   udint 254
 WR   __Instance__MemcpyEx~offSource
#debug_left udint __Instance__MemcpyEx~offSource
#srcline 278 ;                         source := void(helpstring), dest := void(helpstring));
 LEAX helpstring
 WR   __Instance__MemcpyEx~source
#debug_left pointer __Instance__MemcpyEx.source
 LEAX helpstring
 WR   __Instance__MemcpyEx~dest
#debug_left pointer __Instance__MemcpyEx.dest
 LD   0
 WR   __Instance__MemcpyEx~offDest
 PRV
 LEA  __Instance__MemcpyEx
 CAL  MemcpyEx_L0
#srcline 279 ;                sOff := 1;
 LD   uint 1
 WRX  sOff
#debug_left uint sOff
#srcline 280 ;              END_IF;
fbHttpRequestL_L67:
#srcline 281 ;            END_IF;
fbHttpRequestL_L55:
#srcline 283 ;            IF rLen > 0 THEN
 LDX  rLen
#debug uint rLen
 LD   uint 0
 GT
 JMC  fbHttpRequestL_L69
#srcline 284 ;              i := TO_UINT(MemcpyEx(length := MIN(TO_UDINT(rLen), 255-TO_UDINT(sOff)),
 NXT
 LDX  rLen
#debug uint rLen
 LD   udint 255
 LDX  sOff
#debug uint sOff
 SUB
 MIN
 WR   __Instance__MemcpyEx~length
#debug_left udint __Instance__MemcpyEx~length
#srcline 285 ;                   offDest := TO_UDINT(sOff),
 LDX  sOff
#debug uint sOff
 WR   __Instance__MemcpyEx~offDest
#debug_left udint __Instance__MemcpyEx~offDest
#srcline 286 ;                   offSource := TO_UDINT(RecvFrom.lenData) - TO_UDINT(rLen),
 LDX  RecvFrom~lenData
#debug uint RecvFrom.lenData
 LDX  rLen
#debug uint rLen
 SUB
 WR   __Instance__MemcpyEx~offSource
#debug_left udint __Instance__MemcpyEx~offSource
#srcline 287 ;                   source := RecvData[0], dest := void(helpstring)));
 LDX  RecvData
 WR   __Instance__MemcpyEx~source
#debug_left pointer __Instance__MemcpyEx.source
 LEAX helpstring
 WR   __Instance__MemcpyEx~dest
#debug_left pointer __Instance__MemcpyEx.dest
 PRV
 LEA  __Instance__MemcpyEx
 CAL  MemcpyEx_L0
 WRY  i
#debug_left uint i
#srcline 288 ;              sOff := sOff + i;
 LDX  sOff
#debug uint sOff
 LDY  i
#debug uint i
 ADD
 AND  $FFFF
 WRX  sOff
#debug_left uint sOff
#srcline 289 ;              rLen := rLen - i;
 LDX  rLen
#debug uint rLen
 LDY  i
#debug uint i
 SUB
 AND  $FFFF
 WRX  rLen
#debug_left uint rLen
#srcline 290 ;              pUsint := ADR(helpstring) + TO_UDINT(sOff);
 LEAX helpstring
#debug pointer helpstring
 LDX  sOff
#debug uint sOff
 ADD
 LEAY pUsint
 WRIL 
#debug_left pointer pUsint
#srcline 291 ;              pUsint^ := 0;
 LD   usint 0
 LEAY pUsint
 LDIL    ; dereference 
 WRI 
#debug_left usint pUsint^
#srcline 292 ;            ELSIF i = 0 THEN
 JMP  fbHttpRequestL_L70
fbHttpRequestL_L69:
 LDY  i
#debug uint i
 LD   uint 0
 EQ
 JMC  fbHttpRequestL_L71
#srcline 293 ;              EXIT;
 JMP  fbHttpRequestL_L53
#srcline 294 ;            END_IF;
 JMP  fbHttpRequestL_L70
fbHttpRequestL_L71:
fbHttpRequestL_L70:
#srcline 295 ;          END_WHILE;
 JMP  fbHttpRequestL_L52
fbHttpRequestL_L53:
 NOP  -1
#srcline 297 ;          DataLen := 0;
 LD   uint 0
 WRX  DataLen
#debug_left uint DataLen
#srcline 298 ;          IF HeaderRecv THEN
 LDX  HeaderRecv
#debug bool HeaderRecv
 JMC  fbHttpRequestL_L72
#srcline 299 ;            IF rLen > 0 THEN
 LDX  rLen
#debug uint rLen
 LD   uint 0
 GT
 JMC  fbHttpRequestL_L74
#srcline 300 ;              DataLen := rLen;
 LDX  rLen
#debug uint rLen
 WRX  DataLen
#debug_left uint DataLen
#srcline 301 ;              rLen := RecvFrom.lenData - rLen;
 LDX  RecvFrom~lenData
#debug uint RecvFrom.lenData
 LDX  rLen
#debug uint rLen
 SUB
 AND  $FFFF
 WRX  rLen
#debug_left uint rLen
#srcline 302 ;              Memcpy(length := DataLen, source := RecvData[rLen], dest := RecvData[0]);
 NXT
 LDX  DataLen
#debug uint DataLen
 WR   __Instance__Memcpy~length
#debug_left uint __Instance__Memcpy~length
 LDX  RecvData
 LDX  rLen
#debug uint rLen
 RCHK 511   ; Range Check
 ADD     ; + offset 
 WR   __Instance__Memcpy~source
#debug_left pointer __Instance__Memcpy.source
 LDX  RecvData
 WR   __Instance__Memcpy~dest
#debug_left pointer __Instance__Memcpy.dest
 PRV
 LEA  __Instance__Memcpy
 CAL  Memcpy_L0
#srcline 303 ;            END_IF;
fbHttpRequestL_L74:
#srcline 304 ;            WholeLen := ContLen;                                                //zapamatovat si kolik jeste budu prijimat
 LDX  ContLen
#debug dint ContLen
 WRX  WholeLen
#debug_left dint WholeLen
#srcline 305 ;            ContLen  := ContLen - TO_DINT(DataLen);                         //odecist delku od celkove delky k prijmuti
 LDX  ContLen
#debug dint ContLen
 LDX  DataLen
#debug uint DataLen
 SUB
 WRX  ContLen
#debug_left dint ContLen
#srcline 306 ;          END_IF;
fbHttpRequestL_L72:
#srcline 307 ;        END_IF;
fbHttpRequestL_L51:
#srcline 308 ;        DataReady := DataLen > 0;                                               //vydat priznak ze byla prijata data
 LDX  DataLen
#debug uint DataLen
 LD   uint 0
 GT
 WRX  DataReady
#debug_left bool DataReady
#srcline 309 ;      ELSE                                                                      //nic neprislo
 JMP  fbHttpRequestL_L49
fbHttpRequestL_L48:
#srcline 310 ;        DataLen := 0;
 LD   uint 0
 WRX  DataLen
#debug_left uint DataLen
#srcline 311 ;      END_IF;
fbHttpRequestL_L49:
#srcline 313 ;      //bDebug := NOT IsEstabTCPconnection(chanCode := chanCode) & ContLen > 0 & NOT DataReady;
#srcline 315 ;      IF NOT IsEstabTCPconnection(chanCode := chanCode) & NOT DataReady THEN //spojeni se zavrelo a nejsou zadna data
 NXT
 LDX  chanCode
#debug uint chanCode
 WR   __Instance__IsEstabTCPconnection~chanCode
#debug_left uint __Instance__IsEstabTCPconnection~chanCode
 PRV
 LEA  __Instance__IsEstabTCPconnection
 CAL  IsEstabTCPconnection_L0
 NEG
 LDX  DataReady
#debug bool DataReady
 NEG
 AND
 JMC  fbHttpRequestL_L76
#srcline 316 ;        Err    := ContLen > 0;                                               //jeste jsem mel neco prijmout => Error
 LDX  ContLen
#debug dint ContLen
 LD   dint 0
 GTS
 WRX  Err
#debug_left bool Err
#srcline 317 ;        IF Err THEN
 LDX  Err
#debug bool Err
 JMC  fbHttpRequestL_L78
#srcline 318 ;          ErrId := 2;
 LD   usint 2
 WRX  ErrId
#debug_left usint ErrId
#srcline 319 ;        END_IF;
fbHttpRequestL_L78:
#srcline 320 ;//        ErrId  := BOOL_TO_USINT(Err)*2; //Set 2 if error occured
#srcline 321 ;        Done   := NOT Err;                                                   //pokud nebyl error je hotovo
 LDX  Err
#debug bool Err
 NEG
 WRX  Done
#debug_left bool Done
#srcline 322 ;        State  := hs_HttpIdle;                                               //klidovy stav
 LD   udint 0  ; THttpState#hs_HttpIdle
 WRX  State
#debug_left usint State
#srcline 323 ;      END_IF;
fbHttpRequestL_L76:
#srcline 325 ;      IF Close & ContLen = 0 THEN
 LDX  Close
#debug bool Close
 LDX  ContLen
#debug dint ContLen
 LD   dint 0
 EQ
 AND
 JMC  fbHttpRequestL_L80
#srcline 326 ;        CloseTCPconnection(chanCode := chanCode);
 NXT
 LDX  chanCode
#debug uint chanCode
 WR   __Instance__CloseTCPconnection~chanCode
#debug_left uint __Instance__CloseTCPconnection~chanCode
 PRV
 LEA  __Instance__CloseTCPconnection
 CAL  CloseTCPconnection_L0
#srcline 327 ;      END_IF;
fbHttpRequestL_L80:
 JMP  fbHttpRequestL_L9
fbHttpRequestL_L47:
fbHttpRequestL_L9:
#srcline 331 ;  IF Busy THEN
 LDX  Busy
#debug bool Busy
 JMC  fbHttpRequestL_L82
#srcline 332 ;    IF WholeLen > 0 THEN
 LDX  WholeLen
#debug dint WholeLen
 LD   dint 0
 GTS
 JMC  fbHttpRequestL_L84
#srcline 333 ;      Progress := DINT_TO_SINT(((WholeLen - ContLen) * 100 + WholeLen / 2) / WholeLen);
 LDX  WholeLen
#debug dint WholeLen
 LDX  ContLen
#debug dint ContLen
 SUB
 LD   dint 100
 MULS
 LDX  WholeLen
#debug dint WholeLen
 LD   dint 2
 DIVS
 ADD
 LDX  WholeLen
#debug dint WholeLen
 DIVS
 EXTB
 WRX  Progress
#debug_left sint Progress
#srcline 334 ;    ELSE
 JMP  fbHttpRequestL_L85
fbHttpRequestL_L84:
#srcline 335 ;      Progress := -1;
 LD   sint -1
 WRX  Progress
#debug_left sint Progress
#srcline 336 ;    END_IF;
fbHttpRequestL_L85:
#srcline 337 ;  END_IF;
fbHttpRequestL_L82:
#srcline 339 ;END_FUNCTION_BLOCK
fbHttpRequestL_RET:
 ULNK
RET
E     61

; Initialize - variables
P     61
fbHttpRequestL__InstanceInit__:
 LINK 0
 LD   uint 80
 WRX  port
 LEAX RecvFrom
 CAL  fbRecvFrom__InstanceInit__
 LEAX SendTo
 CAL  fbSendTo__InstanceInit__
 ULNK
RET
E     61
; End initialize - variables
#endpou 



 

#srcfile ''
#srcfile 'C:\TECOLIBSRC\INTERNETLIB\INTERNETLIBVCONTROL\FBHTTPREQUESTL2.ST'
#pou fbHttpRequestL2
#srcline 1 ;FUNCTION_BLOCK fbHttpRequestL2

#struct fbHttpRequestL2__temp__
  string[81] lNamePass,
  usint r,
  uint i,
  pointer pHelpString,
  pointer pUint,
  pointer pUsint,
  TUniDesc UniDesc,
  TRemoteEthAdr rea,
  udint l,
  uint authPos,
  uint j,
  usint P0__st__,
  string[257] PS0__st__,
  string[62] PS1__st__,
  string[257] PSC__st__
#data byte _str_fbHttpRequestL2_0 = 
  '@',0
#data byte _str_fbHttpRequestL2_1 = 
  'G','E','T',' ',0
#data byte _str_fbHttpRequestL2_2 = 
  'P','O','S','T',' ',0
#data byte _str_fbHttpRequestL2_3 = 
  ' ','H','T','T','P','/','1','.','0',$0D,$0A,'U','s','e','r','-','A','g','e','n',
  't',':',' ','F','o','x','t','r','o','t','/',0
#data byte _str_fbHttpRequestL2_4 = 
  '.',0
#data byte _str_fbHttpRequestL2_5 = 
  ' ','(','T','e','c','o','m','a','t',';',' ','N',';',' ','e','n','-','U','S',')',
  $0D,$0A,'C','a','c','h','e','-','C','o','n','t','r','o','l',':',' ','m','a','x',
  '-','a','g','e','=','0',$0D,$0A,'C','o','n','t','e','n','t','-','T','y','p','e',
  ':',' ',0
#data byte _str_fbHttpRequestL2_6 = 
  $0D,$0A,'A','c','c','e','p','t',':',' ','*','/','*',$0D,$0A,'H','o','s','t',':',
  ' ',0
#data byte _str_fbHttpRequestL2_7 = 
  ' ','(','T','e','c','o','m','a','t',';',' ','N',';',' ','e','n','-','U','S',')',
  $0D,$0A,'C','a','c','h','e','-','C','o','n','t','r','o','l',':',' ','m','a','x',
  '-','a','g','e','=','0',$0D,$0A,'C','o','n','t','e','n','t','-','T','y','p','e',
  ':',' ','a','p','p','l','i','c','a','t','i','o','n','/','x','-','w','w','w','-',
  'f','o','r','m','-','u','r','l','e','n','c','o','d','e','d',$0D,$0A,'A','c','c',
  'e','p','t',':',' ','*','/','*',$0D,$0A,'H','o','s','t',':',' ',0
#data byte _str_fbHttpRequestL2_8 = 
  ' ','(','T','e','c','o','m','a','t',';',' ','N',';',' ','e','n','-','U','S',')',
  $0D,$0A,'C','a','c','h','e','-','C','o','n','t','r','o','l',':',' ','m','a','x',
  '-','a','g','e','=','0',$0D,$0A,'A','c','c','e','p','t',':',' ','*','/','*',$0D,
  $0A,'H','o','s','t',':',' ',0
#data byte _str_fbHttpRequestL2_9 = 
  $0D,$0A,'A','u','t','h','o','r','i','z','a','t','i','o','n',':',' ','B','a','s',
  'i','c',' ',0
#data byte _str_fbHttpRequestL2_10 = 
  $0D,$0A,'C','o','n','t','e','n','t','-','L','e','n','g','t','h',':',' ',0
#data byte _str_fbHttpRequestL2_11 = 
  $0D,$0A,'C','o','n','n','e','c','t','i','o','n',':',' ','C','l','o','s','e',$0D,
  $0A,$0D,$0A,0
#data byte _str_fbHttpRequestL2_12 = 
  $0D,$0A,'C','o','n','n','e','c','t','i','o','n',':',' ','C','l','o','s','e',$0D,
  $0A,$0D,$0A,0
#data byte _str_fbHttpRequestL2_13 = 
  $0D,$0A,0
#data byte _str_fbHttpRequestL2_14 = 
  'H','T','T','P',0
#data byte _str_fbHttpRequestL2_15 = 
  'C','o','n','t','e','n','t','-','L','e','n','g','t','h',':',0
#data byte _str_fbHttpRequestL2_16 = 
  $0D,$0A,$0D,$0A,0
P     61
fbHttpRequestL2_L0:
 LINK __SizeOf(fbHttpRequestL2__temp__)
; Initialize - dynamic variables
 LD   udint $FFFFFFFF    ; nil
 WRY  pHelpString
 LD   udint $FFFFFFFF    ; nil
 WRY  pUint
 LD   udint $FFFFFFFF    ; nil
 WRY  pUsint
; End initialize - dynamic variables
; R_EDGE, F_EDGE 
 LDX  Post
 LETX __EDGE_R__Post
 WRX  Post
 LDX  Get
 LETX __EDGE_R__Get
 WRX  Get
 LDX  Cancel
 LETX __EDGE_R__Cancel
 WRX  Cancel
#srcline 72 ;  IF GetChanIndex( chanCode) <> -1 THEN
 NXT
 LDX  chanCode
#debug uint chanCode
 WR   __Instance__GetChanIndex~chanCode
#debug_left uint __Instance__GetChanIndex~chanCode
 PRV
 LEA  __Instance__GetChanIndex
 CAL  GetChanIndex_L0
 LD   int -1
 EQ
 NEG
 JMC  fbHttpRequestL2_L1
#srcline 73 ;    // kanal zalozen pomoci #module => kontrola nutna
#srcline 74 ;    UniDesc := GetChanDesc(chanCode := chanCode);
 NXT
 LDX  chanCode
#debug uint chanCode
 WR   __Instance__GetChanDesc~chanCode
#debug_left uint __Instance__GetChanDesc~chanCode
 PRV
 LEA  __Instance__GetChanDesc
 CAL  GetChanDesc_L0
 LEAY UniDesc
#debug_left pointer UniDesc
 LD   26   ;SizeOf() 
 MOV  %IB0
#srcline 75 ;    IF (UniDesc.modeChan <> 5) OR (UniDesc.lenUniIn <> 516) OR (UniDesc.lenUniOut < 516) THEN
 LDY  UniDesc~modeChan
#debug byte UniDesc.modeChan
 LD   byte 5
 EQ
 NEG
 LDY  UniDesc~lenUniIn
#debug uint UniDesc.lenUniIn
 LD   uint 516
 EQ
 NEG
 OR  
 LDY  UniDesc~lenUniOut
#debug uint UniDesc.lenUniOut
 LD   uint 516
 LT
 OR  
 JMC  fbHttpRequestL2_L3
#srcline 76 ;      Err   := true;
 LD   bool -1       ; true
 WRX  Err
#debug_left bool Err
#srcline 77 ;      ErrId := 255;
 LD   usint 255
 WRX  ErrId
#debug_left usint ErrId
#srcline 78 ;      RETURN;
 JMP  fbHttpRequestL2_RET
#srcline 79 ;    END_IF;
fbHttpRequestL2_L3:
#srcline 80 ;  END_IF;
fbHttpRequestL2_L1:
#srcline 82 ;  Busy := State <> hs_HttpIdle;
 LDX  State
#debug usint State
 LD   udint 0  ; THttpState#hs_HttpIdle
 EQ
 NEG
 WRX  Busy
#debug_left bool Busy
#srcline 84 ;  TimeOutTon(IN := Busy & NOT DataReady, PT := T#2m);
 LDX  Busy
#debug bool Busy
 LDX  DataReady
#debug bool DataReady
 NEG
 AND
 WRX  TimeOutTon~IN
#debug_left bool TimeOutTon~IN
 LD   time 120000
 WRX  TimeOutTon~PT
#debug_left time TimeOutTon~PT
 LEAX TimeOutTon
 CAL  TON_L0
#srcline 86 ;  DataReady := false;
 LD   bool 0       ; false
 WRX  DataReady
#debug_left bool DataReady
#srcline 88 ;  IF TimeOutTon.Q THEN
 LDX  TimeOutTon~Q
#debug bool TimeOutTon.Q
 JMC  fbHttpRequestL2_L5
#srcline 89 ;    Err   := true;
 LD   bool -1       ; true
 WRX  Err
#debug_left bool Err
#srcline 90 ;    ErrId := 1;
 LD   usint 1
 WRX  ErrId
#debug_left usint ErrId
#srcline 91 ;    State := hs_HttpIdle;
 LD   udint 0  ; THttpState#hs_HttpIdle
 WRX  State
#debug_left usint State
#srcline 92 ;  END_IF;
fbHttpRequestL2_L5:
#srcline 94 ;  IF Cancel THEN
 LDX  Cancel
#debug bool Cancel
 JMC  fbHttpRequestL2_L7
#srcline 95 ;    State := hs_HttpIdle;
 LD   udint 0  ; THttpState#hs_HttpIdle
 WRX  State
#debug_left usint State
#srcline 96 ;    Err   := ContLen > 0;
 LDX  ContLen
#debug dint ContLen
 LD   dint 0
 GTS
 WRX  Err
#debug_left bool Err
#srcline 97 ;  END_IF;
fbHttpRequestL2_L7:
#srcline 99 ;  CASE State OF
 LDX  State
#debug usint State
 WRY  P0__st__
 LD   0
 LDY  P0__st__
 EQ  
 JMC  fbHttpRequestL2_L10
#srcline 100 ;    hs_HttpIdle   :
#srcline 101 ;      r := CloseTCPconnection(chanCode := chanCode);
 NXT
 LDX  chanCode
#debug uint chanCode
 WR   __Instance__CloseTCPconnection~chanCode
#debug_left uint __Instance__CloseTCPconnection~chanCode
 PRV
 LEA  __Instance__CloseTCPconnection
 CAL  CloseTCPconnection_L0
 WRY  r
#debug_left usint r
#srcline 102 ;      Done := false;
 LD   bool 0       ; false
 WRX  Done
#debug_left bool Done
#srcline 103 ;      IF Post OR Get THEN
 LDX  Post
#debug bool Post
 LDX  Get
#debug bool Get
 OR  
 JMC  fbHttpRequestL2_L11
#srcline 104 ;        sOff := 0;
 LD   uint 0
 WRX  sOff
#debug_left uint sOff
#srcline 105 ;        rLen := 0;
 LD   uint 0
 WRX  rLen
#debug_left uint rLen
#srcline 106 ;        WholeLen := 0;
 LD   dint 0
 WRX  WholeLen
#debug_left dint WholeLen
#srcline 107 ;        Err     := false;
 LD   bool 0       ; false
 WRX  Err
#debug_left bool Err
#srcline 108 ;        ErrId   := 0;
 LD   usint 0
 WRX  ErrId
#debug_left usint ErrId
#srcline 109 ;        Result  := 0;
 LD   int 0
 WRX  Result
#debug_left int Result
#srcline 110 ;        authPos := FIND(IN1 := Host, IN2 := '@');
 LDX  Host
#debug string Host
 LEA  _str_fbHttpRequestL2_0
 SFND 
 WRY  authPos
#debug_left uint authPos
#srcline 111 ;        IF authPos > 0 THEN
 LDY  authPos
#debug uint authPos
 LD   uint 0
 GT
 JMC  fbHttpRequestL2_L13
#srcline 112 ;          lHost := MID(IN := Host, L := 80, P := authPos+1);
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   80
 DST    ; Level 1
 LDX  Host
#debug string Host
 LD   80
 LDY  authPos
#debug uint authPos
 LD   uint 1
 ADD
 AND  $FFFF
 SUB  1
 SMID 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX lHost
 WRI  
 LEAX lHost
 LD   80
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string lHost
 PDST   ; Level 1
#srcline 113 ;          lNamePass := LEFT(IN := Host, L := authPos-1);
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   80
 DST    ; Level 1
 LDX  Host
#debug string Host
 LDY  authPos
#debug uint authPos
 LD   uint 1
 SUB
 AND  $FFFF
 SLFT 
 PDST   ; Level 1
 LD   0   ; null string
 LEAY lNamePass
 WRI  
 LEAY lNamePass
 LD   80
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string lNamePass
 PDST   ; Level 1
#srcline 114 ;        ELSE
 JMP  fbHttpRequestL2_L14
fbHttpRequestL2_L13:
#srcline 115 ;          lHost := Host;
 LD   0   ; null string
 LEAX lHost
 WRI  
 LEAX lHost
 LD   80
 DST    ; Level 1
 LDX  Host
#debug string Host
 SCON 
#debug_left string lHost
 PDST   ; Level 1
#srcline 116 ;        END_IF;
fbHttpRequestL2_L14:
#srcline 117 ;        (*
#srcline 118 ;        pUint := ADR(RecvData);
#srcline 119 ;        pHelpString := pUint;
#srcline 120 ;        *)
#srcline 121 ;        IF Get THEN
 LDX  Get
#debug bool Get
 JMC  fbHttpRequestL2_L15
#srcline 122 ;          BodyLen := 0;
 LD   uint 0
 WRX  BodyLen
#debug_left uint BodyLen
#srcline 123 ;          HelpString := 'GET ' + Action;
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LEA  _str_fbHttpRequestL2_1
 SCON 
 LDX  Action
#debug string Action
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX HelpString
 WRI  
 LEAX HelpString
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string HelpString
 PDST   ; Level 1
#srcline 124 ;        ELSE
 JMP  fbHttpRequestL2_L16
fbHttpRequestL2_L15:
#srcline 125 ;          BodyLen := postLen;
 LDX  postLen
#debug uint postLen
 WRX  BodyLen
#debug_left uint BodyLen
#srcline 126 ;          lPostLen := postLen;
 LDX  postLen
#debug uint postLen
 WRX  lPostLen
#debug_left uint lPostLen
#srcline 127 ;          HelpString := 'POST ' + Action;
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LEA  _str_fbHttpRequestL2_2
 SCON 
 LDX  Action
#debug string Action
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX HelpString
 WRI  
 LEAX HelpString
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string HelpString
 PDST   ; Level 1
#srcline 128 ;        END_IF;
fbHttpRequestL2_L16:
#srcline 129 ;        //TODO: Dodelat kontrolu delky vstupnich dat
#srcline 130 ;        pUint := ADR(RecvData);
 LDX  RecvData
#debug pointer RecvData
 LEAY pUint
 WRIL 
#debug_left pointer pUint
#srcline 131 ;        pUsint := pUint  + MemcpyPtr(length := LEN(helpstring), source := ADR(helpstring), dest := pUint);
 LEAY pUint
 LDIL 
#debug pointer pUint
 NXT
 LEAX helpstring
#debug string helpstring
 SLEN 
 WR   __Instance__MemcpyPtr~length
#debug_left udint __Instance__MemcpyPtr~length
 LEAX helpstring
#debug pointer helpstring
 LEA  __Instance__MemcpyPtr~source
 WRIL 
#debug_left udint __Instance__MemcpyPtr~source
 LEAY pUint
 LDIL 
#debug pointer pUint
 LEA  __Instance__MemcpyPtr~dest
 WRIL 
#debug_left udint __Instance__MemcpyPtr~dest
 PRV
 LEA  __Instance__MemcpyPtr
 CAL  MemcpyPtr_L0
 ADD
 LEAY pUsint
 WRIL 
#debug_left pointer pUsint
#srcline 132 ;        //max len 5+255 = 300
#srcline 133 ;        helpstring := ' HTTP/1.0$r$nUser-Agent: Foxtrot/' + USINT_TO_STRING(%S40) + '.' + USINT_TO_STRING(%S41);
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LEA  _str_fbHttpRequestL2_3
 SCON 
 LD   0   ; null string
 WRY  PSC__st__[0]
 LEAY PSC__st__[0]
 LD   255
 DST    ; Level 2
 LD   %S40
 SCNV $0830;  IEC_USINT _TO_ IEC_STRING
 PDST   ; Level 2
 LEAY PSC__st__[0]

 SCON 
 LEA  _str_fbHttpRequestL2_4
 SCON 
 LD   0   ; null string
 WRY  PSC__st__[0]
 LEAY PSC__st__[0]
 LD   255
 DST    ; Level 2
 LD   %S41
 SCNV $0830;  IEC_USINT _TO_ IEC_STRING
 PDST   ; Level 2
 LEAY PSC__st__[0]

 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX helpstring
 WRI  
 LEAX helpstring
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string helpstring
 PDST   ; Level 1
#srcline 134 ;        pUsint := pUsint + MemcpyPtr(length := LEN(helpstring), source := ADR(helpstring), dest := pUsint);
 LEAY pUsint
 LDIL 
#debug pointer pUsint
 NXT
 LEAX helpstring
#debug string helpstring
 SLEN 
 WR   __Instance__MemcpyPtr~length
#debug_left udint __Instance__MemcpyPtr~length
 LEAX helpstring
#debug pointer helpstring
 LEA  __Instance__MemcpyPtr~source
 WRIL 
#debug_left udint __Instance__MemcpyPtr~source
 LEAY pUsint
 LDIL 
#debug pointer pUsint
 LEA  __Instance__MemcpyPtr~dest
 WRIL 
#debug_left udint __Instance__MemcpyPtr~dest
 PRV
 LEA  __Instance__MemcpyPtr
 CAL  MemcpyPtr_L0
 ADD
 LEAY pUsint
 WRIL 
#debug_left pointer pUsint
#srcline 135 ;        //max len 300+33+1+1+1 = 336
#srcline 137 ;        IF LEN(ContentType) > 0 THEN
 LDX  ContentType
#debug string ContentType
 SLEN 
 LD   int 0
 GTS
 JMC  fbHttpRequestL2_L17
#srcline 138 ;          helpstring := ' (Tecomat; N; en-US)$r$nCache-Control: max-age=0$r$nContent-Type: '+ContentType+'$r$nAccept: */*$r$nHost: ';
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LEA  _str_fbHttpRequestL2_5
 SCON 
 LDX  ContentType
#debug string ContentType
 SCON 
 LEA  _str_fbHttpRequestL2_6
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX helpstring
 WRI  
 LEAX helpstring
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string helpstring
 PDST   ; Level 1
#srcline 139 ;        ELSE
 JMP  fbHttpRequestL2_L18
fbHttpRequestL2_L17:
#srcline 140 ;          IF BodyLen > 0 THEN
 LDX  BodyLen
#debug uint BodyLen
 LD   uint 0
 GT
 JMC  fbHttpRequestL2_L19
#srcline 141 ;            helpstring := ' (Tecomat; N; en-US)$r$nCache-Control: max-age=0$r$nContent-Type: application/x-www-form-urlencoded$r$nAccept: */*$r$nHost: ';
 LD   0   ; null string
 LEAX helpstring
 WRI  
 LEAX helpstring
 LD   255
 DST    ; Level 1
 LEA  _str_fbHttpRequestL2_7
 SCON 
#debug_left string helpstring
 PDST   ; Level 1
#srcline 142 ;          ELSE
 JMP  fbHttpRequestL2_L20
fbHttpRequestL2_L19:
#srcline 143 ;            helpstring := ' (Tecomat; N; en-US)$r$nCache-Control: max-age=0$r$nAccept: */*$r$nHost: ';
 LD   0   ; null string
 LEAX helpstring
 WRI  
 LEAX helpstring
 LD   255
 DST    ; Level 1
 LEA  _str_fbHttpRequestL2_8
 SCON 
#debug_left string helpstring
 PDST   ; Level 1
#srcline 144 ;          END_IF;
fbHttpRequestL2_L20:
#srcline 145 ;        END_IF;
fbHttpRequestL2_L18:
#srcline 147 ;        pUsint := pUsint + MemcpyPtr(length := LEN(helpstring), source := ADR(helpstring), dest := pUsint);
 LEAY pUsint
 LDIL 
#debug pointer pUsint
 NXT
 LEAX helpstring
#debug string helpstring
 SLEN 
 WR   __Instance__MemcpyPtr~length
#debug_left udint __Instance__MemcpyPtr~length
 LEAX helpstring
#debug pointer helpstring
 LEA  __Instance__MemcpyPtr~source
 WRIL 
#debug_left udint __Instance__MemcpyPtr~source
 LEAY pUsint
 LDIL 
#debug pointer pUsint
 LEA  __Instance__MemcpyPtr~dest
 WRIL 
#debug_left udint __Instance__MemcpyPtr~dest
 PRV
 LEA  __Instance__MemcpyPtr
 CAL  MemcpyPtr_L0
 ADD
 LEAY pUsint
 WRIL 
#debug_left pointer pUsint
#srcline 148 ;        //max len 336+140 = 476
#srcline 149 ;        Err := true;
 LD   bool -1       ; true
 WRX  Err
#debug_left bool Err
#srcline 150 ;        REPEAT
fbHttpRequestL2_L21:
 DBG
#srcline 151 ;          l := LEN(lHost);
 LEAX lHost
#debug string lHost
 SLEN 
 WRY  l
#debug_left udint l
#srcline 152 ;          IF PTR_TO_UDINT(pUsint) - PTR_TO_UDINT(pUint) + l > 512 THEN EXIT; END_IF;
 LEAY pUsint
 LDIL 
#debug pointer pUsint
 LEAY pUint
 LDIL 
#debug pointer pUint
 SUB
 LDY  l
#debug udint l
 ADD
 LD   udint 512
 GT
 JMC  fbHttpRequestL2_L23
 JMP  fbHttpRequestL2_L22
fbHttpRequestL2_L23:
#srcline 153 ;          pUsint := pUsint + MemcpyPtr(length := l, source := ADR(lHost), dest := pUsint);
 LEAY pUsint
 LDIL 
#debug pointer pUsint
 NXT
 LDY  l
#debug udint l
 WR   __Instance__MemcpyPtr~length
#debug_left udint __Instance__MemcpyPtr~length
 LEAX lHost
#debug pointer lHost
 LEA  __Instance__MemcpyPtr~source
 WRIL 
#debug_left udint __Instance__MemcpyPtr~source
 LEAY pUsint
 LDIL 
#debug pointer pUsint
 LEA  __Instance__MemcpyPtr~dest
 WRIL 
#debug_left udint __Instance__MemcpyPtr~dest
 PRV
 LEA  __Instance__MemcpyPtr
 CAL  MemcpyPtr_L0
 ADD
 LEAY pUsint
 WRIL 
#debug_left pointer pUsint
#srcline 154 ;          
#srcline 155 ;          IF authPos > 0 THEN
 LDY  authPos
#debug uint authPos
 LD   uint 0
 GT
 JMC  fbHttpRequestL2_L25
#srcline 156 ;            //Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==
#srcline 157 ;            helpstring := '$r$nAuthorization: Basic ' + Base64_encode_string(lNamePass);
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LEA  _str_fbHttpRequestL2_9
 SCON 
 NXT
 LD   0   ; null string
 LEA  __Instance__Base64_encode_string~data
 WRI 
 LEA  __Instance__Base64_encode_string~data
 LD   60
 DST    ; Level 2
 LEAY lNamePass
#debug string lNamePass
 SCON 
#debug_left string __Instance__Base64_encode_string~data
 PDST   ; Level 2
 PRV
 LEA  __Instance__Base64_encode_string
 CAL  Base64_encode_string_L0

 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX helpstring
 WRI  
 LEAX helpstring
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string helpstring
 PDST   ; Level 1
#srcline 158 ;            l := LEN(helpstring);
 LEAX helpstring
#debug string helpstring
 SLEN 
 WRY  l
#debug_left udint l
#srcline 159 ;            IF PTR_TO_UDINT(pUsint) - PTR_TO_UDINT(pUint) + l > 512 THEN EXIT; END_IF;
 LEAY pUsint
 LDIL 
#debug pointer pUsint
 LEAY pUint
 LDIL 
#debug pointer pUint
 SUB
 LDY  l
#debug udint l
 ADD
 LD   udint 512
 GT
 JMC  fbHttpRequestL2_L27
 JMP  fbHttpRequestL2_L22
fbHttpRequestL2_L27:
#srcline 160 ;            pUsint := pUsint + MemcpyPtr(length := l, source := ADR(helpstring), dest := pUsint);
 LEAY pUsint
 LDIL 
#debug pointer pUsint
 NXT
 LDY  l
#debug udint l
 WR   __Instance__MemcpyPtr~length
#debug_left udint __Instance__MemcpyPtr~length
 LEAX helpstring
#debug pointer helpstring
 LEA  __Instance__MemcpyPtr~source
 WRIL 
#debug_left udint __Instance__MemcpyPtr~source
 LEAY pUsint
 LDIL 
#debug pointer pUsint
 LEA  __Instance__MemcpyPtr~dest
 WRIL 
#debug_left udint __Instance__MemcpyPtr~dest
 PRV
 LEA  __Instance__MemcpyPtr
 CAL  MemcpyPtr_L0
 ADD
 LEAY pUsint
 WRIL 
#debug_left pointer pUsint
#srcline 161 ;          END_IF;
fbHttpRequestL2_L25:
#srcline 162 ;          
#srcline 163 ;          //max len 476+80 = 556!!!
#srcline 164 ;          IF BodyLen > 0 THEN
 LDX  BodyLen
#debug uint BodyLen
 LD   uint 0
 GT
 JMC  fbHttpRequestL2_L29
#srcline 165 ;            helpstring := '$r$nContent-Length: ' + UINT_TO_STRING(BodyLen) + '$r$nConnection: Close$r$n$r$n';
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LEA  _str_fbHttpRequestL2_10
 SCON 
 LD   0   ; null string
 WRY  PSC__st__[0]
 LEAY PSC__st__[0]
 LD   255
 DST    ; Level 2
 LDX  BodyLen
#debug uint BodyLen
 SCNV $0A30;  IEC_UINT _TO_ IEC_STRING
 PDST   ; Level 2
 LEAY PSC__st__[0]

 SCON 
 LEA  _str_fbHttpRequestL2_11
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX helpstring
 WRI  
 LEAX helpstring
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string helpstring
 PDST   ; Level 1
#srcline 166 ;          ELSE
 JMP  fbHttpRequestL2_L30
fbHttpRequestL2_L29:
#srcline 167 ;            helpstring := '$r$nConnection: Close$r$n$r$n';
 LD   0   ; null string
 LEAX helpstring
 WRI  
 LEAX helpstring
 LD   255
 DST    ; Level 1
 LEA  _str_fbHttpRequestL2_12
 SCON 
#debug_left string helpstring
 PDST   ; Level 1
#srcline 168 ;          END_IF;
fbHttpRequestL2_L30:
#srcline 169 ;          l := LEN(helpstring);
 LEAX helpstring
#debug string helpstring
 SLEN 
 WRY  l
#debug_left udint l
#srcline 170 ;          IF PTR_TO_UDINT(pUsint) - PTR_TO_UDINT(pUint) + l > 512 THEN EXIT; END_IF;
 LEAY pUsint
 LDIL 
#debug pointer pUsint
 LEAY pUint
 LDIL 
#debug pointer pUint
 SUB
 LDY  l
#debug udint l
 ADD
 LD   udint 512
 GT
 JMC  fbHttpRequestL2_L31
 JMP  fbHttpRequestL2_L22
fbHttpRequestL2_L31:
#srcline 171 ;          pUsint := pUsint + MemcpyPtr(length := l, source := ADR(helpstring), dest := pUsint);
 LEAY pUsint
 LDIL 
#debug pointer pUsint
 NXT
 LDY  l
#debug udint l
 WR   __Instance__MemcpyPtr~length
#debug_left udint __Instance__MemcpyPtr~length
 LEAX helpstring
#debug pointer helpstring
 LEA  __Instance__MemcpyPtr~source
 WRIL 
#debug_left udint __Instance__MemcpyPtr~source
 LEAY pUsint
 LDIL 
#debug pointer pUsint
 LEA  __Instance__MemcpyPtr~dest
 WRIL 
#debug_left udint __Instance__MemcpyPtr~dest
 PRV
 LEA  __Instance__MemcpyPtr
 CAL  MemcpyPtr_L0
 ADD
 LEAY pUsint
 WRIL 
#debug_left pointer pUsint
#srcline 173 ;          
#srcline 174 ;          //max len 556+44=600!!!
#srcline 175 ;          (*
#srcline 176 ;          IF POST THEN //copy data to post
#srcline 177 ;            l := LEN(data);
#srcline 178 ;            IF PTR_TO_UDINT(pUsint) - PTR_TO_UDINT(pUint) + l > 512 THEN EXIT; END_IF;
#srcline 179 ;            pUsint := pUsint + MemcpyPtr(length := LEN(data), source := ADR(data), dest := pUsint);
#srcline 180 ;            //max len 600+80=680!!!
#srcline 181 ;          END_IF;
#srcline 182 ;          *)
#srcline 183 ;          Err := false;
 LD   bool 0       ; false
 WRX  Err
#debug_left bool Err
#srcline 184 ;        UNTIL true END_REPEAT;
 LD   bool -1       ; true
 JMC  fbHttpRequestL2_L21
fbHttpRequestL2_L22:
 NOP  -1
#srcline 185 ;        IF Err THEN
 LDX  Err
#debug bool Err
 JMC  fbHttpRequestL2_L33
#srcline 186 ;          ErrId := 3; //delka hlavicka protokolu presahla 512 bytes
 LD   usint 3
 WRX  ErrId
#debug_left usint ErrId
#srcline 187 ;        ELSE
 JMP  fbHttpRequestL2_L34
fbHttpRequestL2_L33:
#srcline 188 ;          SendTo.lenTx := UDINT_TO_UINT(PTR_TO_UDINT(pUsint) - PTR_TO_UDINT(pUint));
 LEAY pUsint
 LDIL 
#debug pointer pUsint
 LEAY pUint
 LDIL 
#debug pointer pUint
 SUB
 AND  $FFFF
 WRX  SendTo~lenTx
#debug_left uint SendTo.lenTx
#srcline 189 ;          State := hs_HttpSetIP;
 LD   udint 1  ; THttpState#hs_HttpSetIP
 WRX  State
#debug_left usint State
#srcline 190 ;          Busy  := true; //Busy is set in the same cycle when we left idle state!!!
 LD   bool -1       ; true
 WRX  Busy
#debug_left bool Busy
#srcline 191 ;        END_IF;
fbHttpRequestL2_L34:
#srcline 192 ;      END_IF;
fbHttpRequestL2_L11:
 JMP  fbHttpRequestL2_L9
fbHttpRequestL2_L10:
 LD   1
 LDY  P0__st__
 EQ  
 JMC  fbHttpRequestL2_L35
#srcline 193 ;    hs_HttpSetIP:
#srcline 194 ;      IF IPadr = Any_IP THEN
 LEAX IPadr
 LEA  Any_IP
 LD   4   ; SizeOf()
 BCMP 
 EQ   0
 JMC  fbHttpRequestL2_L36
#srcline 195 ;          Err   := true;
 LD   bool -1       ; true
 WRX  Err
#debug_left bool Err
#srcline 196 ;          ErrId := 254;
 LD   usint 254
 WRX  ErrId
#debug_left usint ErrId
#srcline 197 ;          State := hs_HttpIdle;
 LD   udint 0  ; THttpState#hs_HttpIdle
 WRX  State
#debug_left usint State
#srcline 198 ;      ELSE
 JMP  fbHttpRequestL2_L37
fbHttpRequestL2_L36:
#srcline 199 ;        rea.remoteIP   := IPadr;
 LEAX IPadr
#debug pointer IPadr
 SRC  %IB0
 LEAY rea~remoteIP
#debug_left pointer rea.remoteIP
 LD   4   ;SizeOf() 
 MOV  %IB0
#srcline 200 ;        rea.remotePort := port;
 LDX  port
#debug uint port
 WRY  rea~remotePort
#debug_left uint rea.remotePort
#srcline 201 ;/////////nem 21.5.2019
#srcline 202 ;        uniDesc := GetChanDesc( chanCode := chanCode);
 NXT
 LDX  chanCode
#debug uint chanCode
 WR   __Instance__GetChanDesc~chanCode
#debug_left uint __Instance__GetChanDesc~chanCode
 PRV
 LEA  __Instance__GetChanDesc
 CAL  GetChanDesc_L0
 LEAY uniDesc
#debug_left pointer uniDesc
 LD   26   ;SizeOf() 
 MOV  %IB0
#srcline 203 ;        IF uniDesc.res = USINT_TO_BYTE( UNI_SSL_CLIENT) THEN
 LDY  uniDesc~res
#debug byte uniDesc.res
 LD   usint 35
 AND  $FF
 EQ
 JMC  fbHttpRequestL2_L38
#srcline 204 ;          SetUniChanHostName( chanHandle := chanCode, hostName := Host);  // nastavit host name pro SSL socket
 NXT
 LDX  chanCode
#debug uint chanCode
 WR   __Instance__SetUniChanHostName~chanHandle
#debug_left uint __Instance__SetUniChanHostName~chanHandle
 LD   0   ; null string
 LEA  __Instance__SetUniChanHostName~hostName
 WRI 
 LEA  __Instance__SetUniChanHostName~hostName
 LD   80
 DST    ; Level 1
 LDX  Host
#debug string Host
 SCON 
#debug_left string __Instance__SetUniChanHostName~hostName
 PDST   ; Level 1
 PRV
 LEA  __Instance__SetUniChanHostName
 CAL  SetUniChanHostName_L0
#srcline 205 ;        END_IF;
fbHttpRequestL2_L38:
#srcline 206 ;/////////
#srcline 207 ;        IF SetRemoteIPaddress(rq := 1, chanCode := chanCode, ethAdr := rea) THEN
 NXT
 LD   1
 WR   __Instance__SetRemoteIPaddress~rq
#debug_left bool __Instance__SetRemoteIPaddress~rq
 LDX  chanCode
#debug uint chanCode
 WR   __Instance__SetRemoteIPaddress~chanCode
#debug_left uint __Instance__SetRemoteIPaddress~chanCode
 LEAY rea
 WR   __Instance__SetRemoteIPaddress~ethAdr
#debug_left pointer __Instance__SetRemoteIPaddress.ethAdr
 PRV
 LEA  __Instance__SetRemoteIPaddress
 CAL  SetRemoteIPaddress_L0
 JMC  fbHttpRequestL2_L40
#srcline 208 ;          State := hs_HttpConnect;
 LD   udint 2  ; THttpState#hs_HttpConnect
 WRX  State
#debug_left usint State
#srcline 209 ;        END_IF;
fbHttpRequestL2_L40:
#srcline 210 ;      END_IF;
fbHttpRequestL2_L37:
 JMP  fbHttpRequestL2_L9
fbHttpRequestL2_L35:
 LD   2
 LDY  P0__st__
 EQ  
 JMC  fbHttpRequestL2_L42
#srcline 211 ;    hs_HttpConnect:
#srcline 212 ;      r := EstabTCPconnection(chanCode := chanCode);
 NXT
 LDX  chanCode
#debug uint chanCode
 WR   __Instance__EstabTCPconnection~chanCode
#debug_left uint __Instance__EstabTCPconnection~chanCode
 PRV
 LEA  __Instance__EstabTCPconnection
 CAL  EstabTCPconnection_L0
 WRY  r
#debug_left usint r
#srcline 213 ;      IF IsEstabTCPconnection(chanCode := chanCode) THEN
 NXT
 LDX  chanCode
#debug uint chanCode
 WR   __Instance__IsEstabTCPconnection~chanCode
#debug_left uint __Instance__IsEstabTCPconnection~chanCode
 PRV
 LEA  __Instance__IsEstabTCPconnection
 CAL  IsEstabTCPconnection_L0
 JMC  fbHttpRequestL2_L43
#srcline 214 ;        State := hs_HttpSend;
 LD   udint 3  ; THttpState#hs_HttpSend
 WRX  State
#debug_left usint State
#srcline 215 ;      END_IF;
fbHttpRequestL2_L43:
 JMP  fbHttpRequestL2_L9
fbHttpRequestL2_L42:
 LD   3
 LDY  P0__st__
 EQ  
 JMC  fbHttpRequestL2_L45
#srcline 216 ;    hs_HttpSend   :
#srcline 217 ;      SendTo(rq := 1, chanCode := chanCode, data := void(RecvData));
 LD   1
 WRX  SendTo~rq
#debug_left bool SendTo~rq
 LDX  chanCode
#debug uint chanCode
 WRX  SendTo~chanCode
#debug_left uint SendTo~chanCode
 LDX  RecvData
 WRX  SendTo~data
#debug_left pointer SendTo.data
 LEAX SendTo
 CAL  fbSendTo_L0
#srcline 218 ;      ResRecv    := false;
 LD   bool 0       ; false
 WRX  ResRecv
#debug_left bool ResRecv
#srcline 219 ;      LenRecv    := false;
 LD   bool 0       ; false
 WRX  LenRecv
#debug_left bool LenRecv
#srcline 220 ;      HeaderRecv := false;
 LD   bool 0       ; false
 WRX  HeaderRecv
#debug_left bool HeaderRecv
#srcline 221 ;      ContLen    := -1;
 LD   dint -1
 WRX  ContLen
#debug_left dint ContLen
#srcline 222 ;      State := hs_HttpSendPost;
 LD   udint 5  ; THttpState#hs_HttpSendPost
 WRX  State
#debug_left usint State
 JMP  fbHttpRequestL2_L9
fbHttpRequestL2_L45:
 LD   5
 LDY  P0__st__
 EQ  
 JMC  fbHttpRequestL2_L46
#srcline 223 ;    hs_HttpSendPost :
#srcline 224 ;      IF BodyLen > 0 THEN
 LDX  BodyLen
#debug uint BodyLen
 LD   uint 0
 GT
 JMC  fbHttpRequestL2_L47
#srcline 225 ;        SendTo(rq := 1, chanCode := chanCode, data := void(Data[lPostLen-BodyLen]), lenTx := MIN(512,BodyLen));
 LD   1
 WRX  SendTo~rq
#debug_left bool SendTo~rq
 LDX  chanCode
#debug uint chanCode
 WRX  SendTo~chanCode
#debug_left uint SendTo~chanCode
 LDX  Data
 LDX  lPostLen
#debug uint lPostLen
 LDX  BodyLen
#debug uint BodyLen
 SUB
 AND  $FFFF
 RCHK 1535   ; Range Check
 ADD     ; + offset 
 WRX  SendTo~data
#debug_left pointer SendTo.data
 LD   uint 512
 LDX  BodyLen
#debug uint BodyLen
 MIN
 WRX  SendTo~lenTx
#debug_left uint SendTo~lenTx
 LEAX SendTo
 CAL  fbSendTo_L0
#srcline 226 ;        IF SendTo.mesSent THEN
 LDX  SendTo~mesSent
#debug bool SendTo.mesSent
 JMC  fbHttpRequestL2_L49
#srcline 227 ;          BodyLen := BodyLen - MIN(512,BodyLen);
 LDX  BodyLen
#debug uint BodyLen
 LD   uint 512
 LDX  BodyLen
#debug uint BodyLen
 MIN
 SUB
 AND  $FFFF
 WRX  BodyLen
#debug_left uint BodyLen
#srcline 228 ;        END_IF;
fbHttpRequestL2_L49:
#srcline 229 ;      ELSE
 JMP  fbHttpRequestL2_L48
fbHttpRequestL2_L47:
#srcline 230 ;        State := hs_HttpReceivingData;
 LD   udint 4  ; THttpState#hs_HttpReceivingData
 WRX  State
#debug_left usint State
#srcline 231 ;      END_IF;
fbHttpRequestL2_L48:
 JMP  fbHttpRequestL2_L9
fbHttpRequestL2_L46:
 LD   4
 LDY  P0__st__
 EQ  
 JMC  fbHttpRequestL2_L51
#srcline 232 ;    hs_HttpReceivingData  :
#srcline 233 ;      RecvFrom(rq := 1, chanCode := chanCode, lenRx := 512, data := void(RecvData));
 LD   1
 WRX  RecvFrom~rq
#debug_left bool RecvFrom~rq
 LDX  chanCode
#debug uint chanCode
 WRX  RecvFrom~chanCode
#debug_left uint RecvFrom~chanCode
 LD   uint 512
 WRX  RecvFrom~lenRx
#debug_left uint RecvFrom~lenRx
 LDX  RecvData
 WRX  RecvFrom~data
#debug_left pointer RecvFrom.data
 LEAX RecvFrom
 CAL  fbRecvFrom_L0
#srcline 234 ;      IF RecvFrom.mesRec THEN                                                   //byla prijata data
 LDX  RecvFrom~mesRec
#debug bool RecvFrom.mesRec
 JMC  fbHttpRequestL2_L52
#srcline 235 ;        IF HeaderRecv THEN                                                      //uz byla prijata hlavicka
 LDX  HeaderRecv
#debug bool HeaderRecv
 JMC  fbHttpRequestL2_L54
#srcline 236 ;          DataLen := RecvFrom.lenData;                                          //delka dat je rovna delce prijateho paketu
 LDX  RecvFrom~lenData
#debug uint RecvFrom.lenData
 WRX  DataLen
#debug_left uint DataLen
#srcline 237 ;          ContLen := ContLen - UINT_TO_DINT(DataLen);                           //snizit contlen o prijatou delku
 LDX  ContLen
#debug dint ContLen
 LDX  DataLen
#debug uint DataLen
 SUB
 WRX  ContLen
#debug_left dint ContLen
#srcline 238 ;          pUsint  := ADR(RecvData);                                             //nastavit pointer na zacatek dat
 LDX  RecvData
#debug pointer RecvData
 LEAY pUsint
 WRIL 
#debug_left pointer pUsint
#srcline 239 ;        ELSE                                                                    //jeste nebyla prijata hlavicka
 JMP  fbHttpRequestL2_L55
fbHttpRequestL2_L54:
#srcline 240 ;          i := TO_UINT(MemcpyEx(length := MIN(TO_UDINT(RecvFrom.lenData), 255-TO_UDINT(sOff)),
 NXT
 LDX  RecvFrom~lenData
#debug uint RecvFrom.lenData
 LD   udint 255
 LDX  sOff
#debug uint sOff
 SUB
 MIN
 WR   __Instance__MemcpyEx~length
#debug_left udint __Instance__MemcpyEx~length
#srcline 241 ;               offDest := TO_UDINT(sOff),
 LDX  sOff
#debug uint sOff
 WR   __Instance__MemcpyEx~offDest
#debug_left udint __Instance__MemcpyEx~offDest
#srcline 242 ;               source := RecvData[0], dest := void(helpstring)));
 LDX  RecvData
 WR   __Instance__MemcpyEx~source
#debug_left pointer __Instance__MemcpyEx.source
 LEAX helpstring
 WR   __Instance__MemcpyEx~dest
#debug_left pointer __Instance__MemcpyEx.dest
 LD   0
 WR   __Instance__MemcpyEx~offSource
 PRV
 LEA  __Instance__MemcpyEx
 CAL  MemcpyEx_L0
 WRY  i
#debug_left uint i
#srcline 244 ;          sOff := sOff + i;
 LDX  sOff
#debug uint sOff
 LDY  i
#debug uint i
 ADD
 AND  $FFFF
 WRX  sOff
#debug_left uint sOff
#srcline 245 ;          rLen := RecvFrom.lenData - i;
 LDX  RecvFrom~lenData
#debug uint RecvFrom.lenData
 LDY  i
#debug uint i
 SUB
 AND  $FFFF
 WRX  rLen
#debug_left uint rLen
#srcline 247 ;          pUsint := ADR(helpstring) + TO_UDINT(sOff);
 LEAX helpstring
#debug pointer helpstring
 LDX  sOff
#debug uint sOff
 ADD
 LEAY pUsint
 WRIL 
#debug_left pointer pUsint
#srcline 248 ;          pUsint^ := 0;
 LD   usint 0
 LEAY pUsint
 LDIL    ; dereference 
 WRI 
#debug_left usint pUsint^
#srcline 250 ;          WHILE true DO
fbHttpRequestL2_L56:
 LD   bool -1       ; true
 JMC  fbHttpRequestL2_L57
 DBG 
#srcline 251 ;            i :=  FIND(IN1 := helpstring, IN2 := '$r$n');
 LEAX helpstring
#debug string helpstring
 LEA  _str_fbHttpRequestL2_13
 SFND 
 WRY  i
#debug_left uint i
#srcline 252 ;            IF i = 1 THEN //konec
 LDY  i
#debug uint i
 LD   uint 1
 EQ
 JMC  fbHttpRequestL2_L58
#srcline 253 ;              rLen := rLen - 2 + sOff - i + 1;
 LDX  rLen
#debug uint rLen
 LD   uint 2
 SUB
 AND  $FFFF
 LDX  sOff
#debug uint sOff
 ADD
 AND  $FFFF
 LDY  i
#debug uint i
 SUB
 AND  $FFFF
 LD   uint 1
 ADD
 AND  $FFFF
 WRX  rLen
#debug_left uint rLen
#srcline 254 ;              HeaderRecv := true;
 LD   bool -1       ; true
 WRX  HeaderRecv
#debug_left bool HeaderRecv
#srcline 255 ;              EXIT;
 JMP  fbHttpRequestL2_L57
#srcline 256 ;            ELSIF i > 1 THEN  //je tam enter
 JMP  fbHttpRequestL2_L59
fbHttpRequestL2_L58:
 LDY  i
#debug uint i
 LD   uint 1
 GT
 JMC  fbHttpRequestL2_L60
#srcline 257 ;              IF NOT ResRecv THEN
 LDX  ResRecv
#debug bool ResRecv
 NEG
 JMC  fbHttpRequestL2_L61
#srcline 258 ;                IF FIND(IN1 := helpstring, IN2 := 'HTTP') = 1 THEN      //vyhledani zda je to HTTP hlavicka
 LEAX helpstring
#debug string helpstring
 LEA  _str_fbHttpRequestL2_14
 SFND 
 LD   int 1
 EQ
 JMC  fbHttpRequestL2_L63
#srcline 259 ;                  ResRecv := true;                                      //prijat zacatek hlavicky
 LD   bool -1       ; true
 WRX  ResRecv
#debug_left bool ResRecv
#srcline 260 ;                  pHelpString := ADR(helpstring) + 9;                   //posunout pointer
 LEAX helpstring
#debug pointer helpstring
 LD   udint 9
 ADD
 LEAY pHelpString
 WRIL 
#debug_left pointer pHelpString
#srcline 261 ;                  Result := STRING_TO_INT(pHelpString^);                //rozkodovat navratovy kod
 LEAY pHelpString
 LDIL    ; dereference 
#debug string pHelpString^
 SCNV $300B;  IEC_STRING _TO_ IEC_INT
 WRX  Result
#debug_left int Result
#srcline 262 ;    //            Debug1       := pHelpString^;
#srcline 263 ;                END_IF;
fbHttpRequestL2_L63:
#srcline 264 ;              END_IF;
fbHttpRequestL2_L61:
#srcline 265 ;              IF NOT LenRecv THEN                                                   //hledat delku jen kdyz se jeste nenasla 121108
 LDX  LenRecv
#debug bool LenRecv
 NEG
 JMC  fbHttpRequestL2_L65
#srcline 266 ;                                                     //012345678901234
#srcline 267 ;                j := FIND(IN1 := helpstring, IN2 := 'Content-Length:');           //hledat delku tela
 LEAX helpstring
#debug string helpstring
 LEA  _str_fbHttpRequestL2_15
 SFND 
 WRY  j
#debug_left uint j
#srcline 268 ;                IF j > 0 AND j < i THEN                                            //nasla se delka
 LDY  j
#debug uint j
 LD   uint 0
 GT
 LDY  j
#debug uint j
 LDY  i
#debug uint i
 LT
 AND
 JMC  fbHttpRequestL2_L67
#srcline 269 ;                  LenRecv := true;                                                //nastavit priznak ze byla nalezena
 LD   bool -1       ; true
 WRX  LenRecv
#debug_left bool LenRecv
#srcline 270 ;                  pHelpString := ADR(helpstring) + UINT_TO_UDINT(j+15);           //posunout pointer
 LEAX helpstring
#debug pointer helpstring
 LDY  j
#debug uint j
 LD   uint 15
 ADD
 AND  $FFFF
 ADD
 LEAY pHelpString
 WRIL 
#debug_left pointer pHelpString
#srcline 271 ;                  ContLen     := STRING_TO_DINT(pHelpString^);                    //zapsat delku
 LEAY pHelpString
 LDIL    ; dereference 
#debug string pHelpString^
 SCNV $300D;  IEC_STRING _TO_ IEC_DINT
 WRX  ContLen
#debug_left dint ContLen
#srcline 272 ;      //            Debug2       := pHelpString^;
#srcline 273 ;                END_IF;
fbHttpRequestL2_L67:
#srcline 274 ;              END_IF;
fbHttpRequestL2_L65:
#srcline 275 ;              IF i = FIND(IN1 := helpstring, IN2 := '$r$n$r$n') THEN //konec
 LDY  i
#debug uint i
 LEAX helpstring
#debug string helpstring
 LEA  _str_fbHttpRequestL2_16
 SFND 
 EQ
 JMC  fbHttpRequestL2_L69
#srcline 276 ;                rLen := rLen - 4 + sOff - i + 1;
 LDX  rLen
#debug uint rLen
 LD   uint 4
 SUB
 AND  $FFFF
 LDX  sOff
#debug uint sOff
 ADD
 AND  $FFFF
 LDY  i
#debug uint i
 SUB
 AND  $FFFF
 LD   uint 1
 ADD
 AND  $FFFF
 WRX  rLen
#debug_left uint rLen
#srcline 277 ;                HeaderRecv := true;
 LD   bool -1       ; true
 WRX  HeaderRecv
#debug_left bool HeaderRecv
#srcline 278 ;                EXIT;
 JMP  fbHttpRequestL2_L57
#srcline 279 ;              END_IF;
fbHttpRequestL2_L69:
#srcline 280 ;              MemcpyEx(length := TO_UDINT(sOff - i), offSource := TO_UDINT(i) + 1,
 NXT
 LDX  sOff
#debug uint sOff
 LDY  i
#debug uint i
 SUB
 WR   __Instance__MemcpyEx~length
#debug_left udint __Instance__MemcpyEx~length
 LDY  i
#debug uint i
 LD   udint 1
 ADD
 WR   __Instance__MemcpyEx~offSource
#debug_left udint __Instance__MemcpyEx~offSource
#srcline 281 ;                       source := void(helpstring), dest := void(helpstring));
 LEAX helpstring
 WR   __Instance__MemcpyEx~source
#debug_left pointer __Instance__MemcpyEx.source
 LEAX helpstring
 WR   __Instance__MemcpyEx~dest
#debug_left pointer __Instance__MemcpyEx.dest
 LD   0
 WR   __Instance__MemcpyEx~offDest
 PRV
 LEA  __Instance__MemcpyEx
 CAL  MemcpyEx_L0
#srcline 282 ;              sOff := sOff - i - 1;
 LDX  sOff
#debug uint sOff
 LDY  i
#debug uint i
 SUB
 AND  $FFFF
 LD   uint 1
 SUB
 AND  $FFFF
 WRX  sOff
#debug_left uint sOff
#srcline 283 ;            ELSE
 JMP  fbHttpRequestL2_L59
fbHttpRequestL2_L60:
#srcline 284 ;              IF sOff = 255 THEN //je to bez enteru a plne - zahodit
 LDX  sOff
#debug uint sOff
 LD   uint 255
 EQ
 JMC  fbHttpRequestL2_L71
#srcline 285 ;                MemcpyEx(length := 1, offSource := 254,
 NXT
 LD   udint 1
 WR   __Instance__MemcpyEx~length
#debug_left udint __Instance__MemcpyEx~length
 LD   udint 254
 WR   __Instance__MemcpyEx~offSource
#debug_left udint __Instance__MemcpyEx~offSource
#srcline 286 ;                         source := void(helpstring), dest := void(helpstring));
 LEAX helpstring
 WR   __Instance__MemcpyEx~source
#debug_left pointer __Instance__MemcpyEx.source
 LEAX helpstring
 WR   __Instance__MemcpyEx~dest
#debug_left pointer __Instance__MemcpyEx.dest
 LD   0
 WR   __Instance__MemcpyEx~offDest
 PRV
 LEA  __Instance__MemcpyEx
 CAL  MemcpyEx_L0
#srcline 287 ;                sOff := 1;
 LD   uint 1
 WRX  sOff
#debug_left uint sOff
#srcline 288 ;              END_IF;
fbHttpRequestL2_L71:
#srcline 289 ;            END_IF;
fbHttpRequestL2_L59:
#srcline 291 ;            IF rLen > 0 THEN
 LDX  rLen
#debug uint rLen
 LD   uint 0
 GT
 JMC  fbHttpRequestL2_L73
#srcline 292 ;              i := TO_UINT(MemcpyEx(length := MIN(TO_UDINT(rLen), 255-TO_UDINT(sOff)),
 NXT
 LDX  rLen
#debug uint rLen
 LD   udint 255
 LDX  sOff
#debug uint sOff
 SUB
 MIN
 WR   __Instance__MemcpyEx~length
#debug_left udint __Instance__MemcpyEx~length
#srcline 293 ;                   offDest := TO_UDINT(sOff),
 LDX  sOff
#debug uint sOff
 WR   __Instance__MemcpyEx~offDest
#debug_left udint __Instance__MemcpyEx~offDest
#srcline 294 ;                   offSource := TO_UDINT(RecvFrom.lenData) - TO_UDINT(rLen),
 LDX  RecvFrom~lenData
#debug uint RecvFrom.lenData
 LDX  rLen
#debug uint rLen
 SUB
 WR   __Instance__MemcpyEx~offSource
#debug_left udint __Instance__MemcpyEx~offSource
#srcline 295 ;                   source := RecvData[0], dest := void(helpstring)));
 LDX  RecvData
 WR   __Instance__MemcpyEx~source
#debug_left pointer __Instance__MemcpyEx.source
 LEAX helpstring
 WR   __Instance__MemcpyEx~dest
#debug_left pointer __Instance__MemcpyEx.dest
 PRV
 LEA  __Instance__MemcpyEx
 CAL  MemcpyEx_L0
 WRY  i
#debug_left uint i
#srcline 296 ;              sOff := sOff + i;
 LDX  sOff
#debug uint sOff
 LDY  i
#debug uint i
 ADD
 AND  $FFFF
 WRX  sOff
#debug_left uint sOff
#srcline 297 ;              rLen := rLen - i;
 LDX  rLen
#debug uint rLen
 LDY  i
#debug uint i
 SUB
 AND  $FFFF
 WRX  rLen
#debug_left uint rLen
#srcline 298 ;              pUsint := ADR(helpstring) + TO_UDINT(sOff);
 LEAX helpstring
#debug pointer helpstring
 LDX  sOff
#debug uint sOff
 ADD
 LEAY pUsint
 WRIL 
#debug_left pointer pUsint
#srcline 299 ;              pUsint^ := 0;
 LD   usint 0
 LEAY pUsint
 LDIL    ; dereference 
 WRI 
#debug_left usint pUsint^
#srcline 300 ;            ELSIF i = 0 THEN
 JMP  fbHttpRequestL2_L74
fbHttpRequestL2_L73:
 LDY  i
#debug uint i
 LD   uint 0
 EQ
 JMC  fbHttpRequestL2_L75
#srcline 301 ;              EXIT;
 JMP  fbHttpRequestL2_L57
#srcline 302 ;            END_IF;
 JMP  fbHttpRequestL2_L74
fbHttpRequestL2_L75:
fbHttpRequestL2_L74:
#srcline 303 ;          END_WHILE;
 JMP  fbHttpRequestL2_L56
fbHttpRequestL2_L57:
 NOP  -1
#srcline 305 ;          DataLen := 0;
 LD   uint 0
 WRX  DataLen
#debug_left uint DataLen
#srcline 306 ;          IF HeaderRecv THEN
 LDX  HeaderRecv
#debug bool HeaderRecv
 JMC  fbHttpRequestL2_L76
#srcline 307 ;            IF rLen > 0 THEN
 LDX  rLen
#debug uint rLen
 LD   uint 0
 GT
 JMC  fbHttpRequestL2_L78
#srcline 308 ;              DataLen := rLen;
 LDX  rLen
#debug uint rLen
 WRX  DataLen
#debug_left uint DataLen
#srcline 309 ;              rLen := RecvFrom.lenData - rLen;
 LDX  RecvFrom~lenData
#debug uint RecvFrom.lenData
 LDX  rLen
#debug uint rLen
 SUB
 AND  $FFFF
 WRX  rLen
#debug_left uint rLen
#srcline 310 ;              Memcpy(length := DataLen, source := RecvData[rLen], dest := RecvData[0]);
 NXT
 LDX  DataLen
#debug uint DataLen
 WR   __Instance__Memcpy~length
#debug_left uint __Instance__Memcpy~length
 LDX  RecvData
 LDX  rLen
#debug uint rLen
 RCHK 511   ; Range Check
 ADD     ; + offset 
 WR   __Instance__Memcpy~source
#debug_left pointer __Instance__Memcpy.source
 LDX  RecvData
 WR   __Instance__Memcpy~dest
#debug_left pointer __Instance__Memcpy.dest
 PRV
 LEA  __Instance__Memcpy
 CAL  Memcpy_L0
#srcline 311 ;            END_IF;
fbHttpRequestL2_L78:
#srcline 312 ;            WholeLen := ContLen;                                                //zapamatovat si kolik jeste budu prijimat
 LDX  ContLen
#debug dint ContLen
 WRX  WholeLen
#debug_left dint WholeLen
#srcline 313 ;            ContLen  := ContLen - TO_DINT(DataLen);                         //odecist delku od celkove delky k prijmuti
 LDX  ContLen
#debug dint ContLen
 LDX  DataLen
#debug uint DataLen
 SUB
 WRX  ContLen
#debug_left dint ContLen
#srcline 314 ;          END_IF;
fbHttpRequestL2_L76:
#srcline 315 ;        END_IF;
fbHttpRequestL2_L55:
#srcline 316 ;        DataReady := DataLen > 0;                                               //vydat priznak ze byla prijata data
 LDX  DataLen
#debug uint DataLen
 LD   uint 0
 GT
 WRX  DataReady
#debug_left bool DataReady
#srcline 317 ;      ELSE                                                                      //nic neprislo
 JMP  fbHttpRequestL2_L53
fbHttpRequestL2_L52:
#srcline 318 ;        DataLen := 0;
 LD   uint 0
 WRX  DataLen
#debug_left uint DataLen
#srcline 319 ;      END_IF;
fbHttpRequestL2_L53:
#srcline 321 ;      //bDebug := NOT IsEstabTCPconnection(chanCode := chanCode) & ContLen > 0 & NOT DataReady;
#srcline 323 ;      IF NOT IsEstabTCPconnection(chanCode := chanCode) & NOT DataReady THEN //spojeni se zavrelo a nejsou zadna data
 NXT
 LDX  chanCode
#debug uint chanCode
 WR   __Instance__IsEstabTCPconnection~chanCode
#debug_left uint __Instance__IsEstabTCPconnection~chanCode
 PRV
 LEA  __Instance__IsEstabTCPconnection
 CAL  IsEstabTCPconnection_L0
 NEG
 LDX  DataReady
#debug bool DataReady
 NEG
 AND
 JMC  fbHttpRequestL2_L80
#srcline 324 ;        Err    := ContLen > 0;                                               //jeste jsem mel neco prijmout => Error
 LDX  ContLen
#debug dint ContLen
 LD   dint 0
 GTS
 WRX  Err
#debug_left bool Err
#srcline 325 ;        IF Err THEN
 LDX  Err
#debug bool Err
 JMC  fbHttpRequestL2_L82
#srcline 326 ;          ErrId := 2;
 LD   usint 2
 WRX  ErrId
#debug_left usint ErrId
#srcline 327 ;        END_IF;
fbHttpRequestL2_L82:
#srcline 328 ;//        ErrId  := BOOL_TO_USINT(Err)*2; //Set 2 if error occured
#srcline 329 ;        Done   := NOT Err;                                                   //pokud nebyl error je hotovo
 LDX  Err
#debug bool Err
 NEG
 WRX  Done
#debug_left bool Done
#srcline 330 ;        State  := hs_HttpIdle;                                               //klidovy stav
 LD   udint 0  ; THttpState#hs_HttpIdle
 WRX  State
#debug_left usint State
#srcline 331 ;      END_IF;
fbHttpRequestL2_L80:
#srcline 333 ;      IF Close & ContLen = 0 THEN
 LDX  Close
#debug bool Close
 LDX  ContLen
#debug dint ContLen
 LD   dint 0
 EQ
 AND
 JMC  fbHttpRequestL2_L84
#srcline 334 ;        CloseTCPconnection(chanCode := chanCode);
 NXT
 LDX  chanCode
#debug uint chanCode
 WR   __Instance__CloseTCPconnection~chanCode
#debug_left uint __Instance__CloseTCPconnection~chanCode
 PRV
 LEA  __Instance__CloseTCPconnection
 CAL  CloseTCPconnection_L0
#srcline 335 ;      END_IF;
fbHttpRequestL2_L84:
 JMP  fbHttpRequestL2_L9
fbHttpRequestL2_L51:
fbHttpRequestL2_L9:
#srcline 339 ;  IF Busy THEN
 LDX  Busy
#debug bool Busy
 JMC  fbHttpRequestL2_L86
#srcline 340 ;    IF WholeLen > 0 THEN
 LDX  WholeLen
#debug dint WholeLen
 LD   dint 0
 GTS
 JMC  fbHttpRequestL2_L88
#srcline 341 ;      Progress := DINT_TO_SINT(((WholeLen - ContLen) * 100 + WholeLen / 2) / WholeLen);
 LDX  WholeLen
#debug dint WholeLen
 LDX  ContLen
#debug dint ContLen
 SUB
 LD   dint 100
 MULS
 LDX  WholeLen
#debug dint WholeLen
 LD   dint 2
 DIVS
 ADD
 LDX  WholeLen
#debug dint WholeLen
 DIVS
 EXTB
 WRX  Progress
#debug_left sint Progress
#srcline 342 ;    ELSE
 JMP  fbHttpRequestL2_L89
fbHttpRequestL2_L88:
#srcline 343 ;      Progress := -1;
 LD   sint -1
 WRX  Progress
#debug_left sint Progress
#srcline 344 ;    END_IF;
fbHttpRequestL2_L89:
#srcline 345 ;  END_IF;
fbHttpRequestL2_L86:
#srcline 347 ;END_FUNCTION_BLOCK
fbHttpRequestL2_RET:
 ULNK
RET
E     61

; Initialize - variables
P     61
fbHttpRequestL2__InstanceInit__:
 LINK 0
 LD   uint 80
 WRX  port
 LEAX RecvFrom
 CAL  fbRecvFrom__InstanceInit__
 LEAX SendTo
 CAL  fbSendTo__InstanceInit__
 ULNK
RET
E     61
; End initialize - variables
#endpou 



 

#srcfile ''
#srcfile 'C:\TECOLIBSRC\INTERNETLIB\INTERNETLIBVCONTROL\FBSPLITURLADDRESS.ST'
#pou fbSplitUrlAddress
#srcline 1 ;FUNCTION_BLOCK fbSplitUrlAddress

#struct fbSplitUrlAddress__temp__
  bool dnsRequest,
  string[256] tmpStr,
  int pos,
  pointer pStr,
  udint pPos,
  uint tmpPort,
  string[257] PS0__st__
#data byte _str_fbSplitUrlAddress_0 = 
  ':','/','/',0
#data byte _str_fbSplitUrlAddress_1 = 
  'h','t','t','p','s',':','/','/',0
#data byte _str_fbSplitUrlAddress_2 = 
  'w','s','s',':','/','/',0
#data byte _str_fbSplitUrlAddress_3 = 
  '/',0
#data byte _str_fbSplitUrlAddress_4 = 
  '',0
#data byte _str_fbSplitUrlAddress_5 = 
  '@',0
#data byte _str_fbSplitUrlAddress_6 = 
  ':',0
P     61
fbSplitUrlAddress_L0:
 LINK __SizeOf(fbSplitUrlAddress__temp__)
; Initialize - dynamic variables
 LD   udint $FFFFFFFF    ; nil
 WRY  pStr
; End initialize - dynamic variables
; R_EDGE, F_EDGE 
 LDX  split
 LETX __EDGE_R__split
 WRX  split
#srcline 43 ;  Done := false;
 LD   bool 0       ; false
 WRX  Done
#debug_left bool Done
#srcline 44 ;  IF split THEN
 LDX  split
#debug bool split
 JMC  fbSplitUrlAddress_L1
#srcline 45 ;    tmpPort := 80;
 LD   uint 80
 WRY  tmpPort
#debug_left uint tmpPort
#srcline 46 ;    // zpracovat pageName
#srcline 47 ;    pos := FIND( urlAddress, '://');
 LDX  urlAddress
#debug string urlAddress
 LEA  _str_fbSplitUrlAddress_0
 SFND 
 WRY  pos
#debug_left int pos
#srcline 48 ;    IF pos <> 0 THEN
 LDY  pos
#debug int pos
 EXTW 
 LD   int 0
 EQ
 NEG
 JMC  fbSplitUrlAddress_L3
#srcline 49 ;      IF FIND( urlAddress, 'https://') > 0 OR FIND( urlAddress, 'wss://') > 0 THEN
 LDX  urlAddress
#debug string urlAddress
 LEA  _str_fbSplitUrlAddress_1
 SFND 
 LD   int 0
 GTS
 LDX  urlAddress
#debug string urlAddress
 LEA  _str_fbSplitUrlAddress_2
 SFND 
 LD   int 0
 GTS
 OR  
 JMC  fbSplitUrlAddress_L5
#srcline 50 ;        tmpPort := 443;
 LD   uint 443
 WRY  tmpPort
#debug_left uint tmpPort
#srcline 51 ;      END_IF;
fbSplitUrlAddress_L5:
#srcline 52 ;      tmpStr := DELETE( IN := urlAddress, L := pos+2 , P := 1);    // delete '//http://'
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LDX  urlAddress
#debug string urlAddress
 LDY  pos
#debug int pos
 EXTW 
 LD   int 2
 ADD
 EXTW
 LD   1
 SUB  1
 SDEL 
 PDST   ; Level 1
 LD   0   ; null string
 LEAY tmpStr
 WRI  
 LEAY tmpStr
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string tmpStr
 PDST   ; Level 1
#srcline 53 ;    ELSE
 JMP  fbSplitUrlAddress_L4
fbSplitUrlAddress_L3:
#srcline 54 ;      tmpStr := urlAddress;
 LD   0   ; null string
 LEAY tmpStr
 WRI  
 LEAY tmpStr
 LD   255
 DST    ; Level 1
 LDX  urlAddress
#debug string urlAddress
 SCON 
#debug_left string tmpStr
 PDST   ; Level 1
#srcline 55 ;    END_IF;
fbSplitUrlAddress_L4:
#srcline 56 ;    pos := FIND( tmpStr, '/');        // separate domain name and action
 LEAY tmpStr
#debug string tmpStr
 LEA  _str_fbSplitUrlAddress_3
 SFND 
 WRY  pos
#debug_left int pos
#srcline 57 ;    IF pos <> 0 THEN
 LDY  pos
#debug int pos
 EXTW 
 LD   int 0
 EQ
 NEG
 JMC  fbSplitUrlAddress_L7
#srcline 58 ;      host := tmpStr;
 LD   0   ; null string
 LDX  host
 WRI  
 LDX  host
 LD   80
 DST    ; Level 1
 LEAY tmpStr
#debug string tmpStr
 SCON 
#debug_left string host
 PDST   ; Level 1
#srcline 59 ;      host := DELETE( IN := host, L := 255, P := pos);   // domain name
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   80
 DST    ; Level 1
 LDX  host
#debug string host
 LD   255
 LDY  pos
#debug int pos
 EXTW 
 SUB  1
 SDEL 
 PDST   ; Level 1
 LD   0   ; null string
 LDX  host
 WRI  
 LDX  host
 LD   80
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string host
 PDST   ; Level 1
#srcline 60 ;      Action   := DELETE( IN := tmpStr, L := pos-1, P := 1);   // action
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LEAY tmpStr
#debug string tmpStr
 LDY  pos
#debug int pos
 EXTW 
 LD   int 1
 SUB
 EXTW
 LD   1
 SUB  1
 SDEL 
 PDST   ; Level 1
 LD   0   ; null string
 LDX  Action
 WRI  
 LDX  Action
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string Action
 PDST   ; Level 1
#srcline 61 ;    ELSE
 JMP  fbSplitUrlAddress_L8
fbSplitUrlAddress_L7:
#srcline 62 ;      host := tmpStr;
 LD   0   ; null string
 LDX  host
 WRI  
 LDX  host
 LD   80
 DST    ; Level 1
 LEAY tmpStr
#debug string tmpStr
 SCON 
#debug_left string host
 PDST   ; Level 1
#srcline 63 ;      Action := '';
 LD   0   ; null string
 LDX  Action
 WRI  
 LDX  Action
 LD   255
 DST    ; Level 1
 LEA  _str_fbSplitUrlAddress_4
 SCON 
#debug_left string Action
 PDST   ; Level 1
#srcline 64 ;    END_IF;
fbSplitUrlAddress_L8:
#srcline 65 ;    
#srcline 66 ;    pStr := ADR(host);
 LDX  host
#debug pointer host
 LEAY pStr
 WRIL 
#debug_left pointer pStr
#srcline 67 ;    pPos := FIND(host, '@'); //try to find basic autentification
 LDX  host
#debug string host
 LEA  _str_fbSplitUrlAddress_5
 SFND 
 WRY  pPos
#debug_left udint pPos
#srcline 68 ;    IF pPos > 0 THEN
 LDY  pPos
#debug udint pPos
 LD   udint 0
 GT
 JMC  fbSplitUrlAddress_L9
#srcline 69 ;      pStr := pStr + pPos;
 LEAY pStr
 LDIL 
#debug pointer pStr
 LDY  pPos
#debug udint pPos
 ADD
 LEAY pStr
 WRIL 
#debug_left pointer pStr
#srcline 70 ;    END_IF;
fbSplitUrlAddress_L9:
#srcline 71 ;    
#srcline 72 ;    pos := FIND( pStr^, ':');       // try to find port number
 LEAY pStr
 LDIL    ; dereference 
#debug string pStr^
 LEA  _str_fbSplitUrlAddress_6
 SFND 
 WRY  pos
#debug_left int pos
#srcline 73 ;    IF pos <> 0 THEN
 LDY  pos
#debug int pos
 EXTW 
 LD   int 0
 EQ
 NEG
 JMC  fbSplitUrlAddress_L11
#srcline 74 ;      tmpStr := DELETE( IN := pStr^, L := pos, P := 1);
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LEAY pStr
 LDIL    ; dereference 
#debug string pStr^
 LDY  pos
#debug int pos
 EXTW 
 LD   1
 SUB  1
 SDEL 
 PDST   ; Level 1
 LD   0   ; null string
 LEAY tmpStr
 WRI  
 LEAY tmpStr
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string tmpStr
 PDST   ; Level 1
#srcline 75 ;      NsLookUp.Name := DELETE( IN := pStr^, L := 255, P :=INT_TO_UDINT(pos));
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   80
 DST    ; Level 1
 LEAY pStr
 LDIL    ; dereference 
#debug string pStr^
 LD   255
 LDY  pos
#debug int pos
 EXTW 
 SUB  1
 SDEL 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX NsLookUp
 ADD  5  ; + offset 
 WRI  
 LEAX NsLookUp
 ADD  5  ; + offset 
 LD   80
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string NsLookUp.Name
 PDST   ; Level 1
#srcline 76 ;      port   := STRING_TO_UINT( tmpStr);
 LEAY tmpStr
#debug string tmpStr
 SCNV $300A;  IEC_STRING _TO_ IEC_UINT
 LDX  port
 WRIW 
#debug_left uint port
#srcline 77 ;    ELSE
 JMP  fbSplitUrlAddress_L12
fbSplitUrlAddress_L11:
#srcline 78 ;      port := tmpPort;  // 80 nebo 443
 LDY  tmpPort
#debug uint tmpPort
 LDX  port
 WRIW 
#debug_left uint port
#srcline 79 ;      NsLookUp.Name := pStr^;
 LD   0   ; null string
 LEAX NsLookUp
 ADD  5  ; + offset 
 WRI  
 LEAX NsLookUp
 ADD  5  ; + offset 
 LD   80
 DST    ; Level 1
 LEAY pStr
 LDIL    ; dereference 
#debug string pStr^
 SCON 
#debug_left string NsLookUp.Name
 PDST   ; Level 1
#srcline 80 ;    END_IF;
fbSplitUrlAddress_L12:
#srcline 81 ;    dnsRequest := true;
 LD   bool -1       ; true
 WRY  dnsRequest
#debug_left bool dnsRequest
#srcline 82 ;//  NsLookUp.Name := pStr^;
#srcline 83 ;    //code below is alredy solved insinde NsLookUpEx
#srcline 84 ;    // IP address
#srcline 85 ;    (*
#srcline 86 ;    ipAdr := STRING_TO_IPADR(IPAdr := pStr^);
#srcline 87 ;    NsLookUp.Name := pStr^;
#srcline 89 ;    dnsRequest := ipAdr = HTTP_IP_NULL;
#srcline 90 ;    Busy := dnsRequest;
#srcline 91 ;    Done := NOT Busy;
#srcline 92 ;    IF Done THEN
#srcline 93 ;      Err := 0; ErrId := 0;
#srcline 94 ;      RETURN;
#srcline 95 ;    END_IF;
#srcline 96 ;    *)
#srcline 97 ;  END_IF;
fbSplitUrlAddress_L1:
#srcline 99 ;  // prevest domainove jmeno na IP adresu (je-li to potreba)
#srcline 101 ;  IF (16#49 = %S42) OR (16#4A = %S42) THEN
 LD   $49
 LD   %S42
 EQ
 LD   $4A
 LD   %S42
 EQ
 OR  
 JMC  fbSplitUrlAddress_L13
#srcline 102 ;    // CPU rady I nebo J (Foxtrot CP-2xxx)
#srcline 103 ;    NsLookUp( getIP := dnsRequest, dnsIP := HTTP_IP_NULL, IP := ipAdr, Done => Done, Busy => Busy, Err => Err, ErrId => ErrId);
 LDY  dnsRequest
#debug bool dnsRequest
 WRX  NsLookUp~getIP
#debug_left bool NsLookUp~getIP
 LEA  __Const__fbSplitUrlAddress_HTTP_IP_NULL
#debug pointer HTTP_IP_NULL
 SRC  %IB0
 LEAX NsLookUp~dnsIP
 LD   4   ;SizeOf() 
 MOV  %IB0
 LDX  ipAdr
 WRX  NsLookUp~IP
#debug_left pointer NsLookUp.IP
 LEAX NsLookUp
 CAL  fbNsLookUpEx_L0
; output assigment 
 LDX  NsLookUp~Done
#debug bool NsLookUp~Done
 WRX  Done
#debug_left bool Done
 LDX  NsLookUp~Busy
#debug bool NsLookUp~Busy
 WRX  Busy
#debug_left bool Busy
 LDX  NsLookUp~Err
#debug bool NsLookUp~Err
 WRX  Err
#debug_left bool Err
 LDX  NsLookUp~ErrId
#debug usint NsLookUp~ErrId
 WRX  ErrId
#debug_left usint ErrId
#srcline 104 ;  ELSE
 JMP  fbSplitUrlAddress_L14
fbSplitUrlAddress_L13:
#srcline 105 ;    // vsechny ostatni CPU (Foxtrot CP-1xxx)
#srcline 106 ;    NsLookUp( getIP := dnsRequest, dnsIP := GetDNS_IP(ethChan := ETH1), IP := ipAdr, Done => Done, Busy => Busy, Err => Err, ErrId => ErrId);
 LDY  dnsRequest
#debug bool dnsRequest
 WRX  NsLookUp~getIP
#debug_left bool NsLookUp~getIP
 NXT
 LD   usint 225
 WR   __Instance__GetDNS_IP~ethChan
#debug_left usint __Instance__GetDNS_IP~ethChan
 PRV
 LEA  __Instance__GetDNS_IP
 CAL  GetDNS_IP_L0
 LEAX NsLookUp~dnsIP
 LD   4   ;SizeOf() 
 MOV  %IB0
 LDX  ipAdr
 WRX  NsLookUp~IP
#debug_left pointer NsLookUp.IP
 LEAX NsLookUp
 CAL  fbNsLookUpEx_L0
; output assigment 
 LDX  NsLookUp~Done
#debug bool NsLookUp~Done
 WRX  Done
#debug_left bool Done
 LDX  NsLookUp~Busy
#debug bool NsLookUp~Busy
 WRX  Busy
#debug_left bool Busy
 LDX  NsLookUp~Err
#debug bool NsLookUp~Err
 WRX  Err
#debug_left bool Err
 LDX  NsLookUp~ErrId
#debug usint NsLookUp~ErrId
 WRX  ErrId
#debug_left usint ErrId
#srcline 107 ;  END_IF;
fbSplitUrlAddress_L14:
#srcline 109 ;END_FUNCTION_BLOCK
 ULNK
RET
E     61

; Initialize - variables
P     61
fbSplitUrlAddress__InstanceInit__:
 LINK 0
 LEAX NsLookUp
 CAL  fbNsLookUpEx__InstanceInit__
 ULNK
RET
E     61
; End initialize - variables
#endpou 



 

#srcfile ''
#srcfile 'C:\TECOLIBSRC\INTERNETLIB\INTERNETLIBVCONTROL\FBRETRIVEFROMFTP.ST'
#pou fbRetriveFromFtp
#srcline 1 ;FUNCTION_BLOCK fbRetriveFromFtp
#table byte __Init___fbRetriveFromFtp_h = 
      0,  0;

#struct fbRetriveFromFtp__temp__
  TUniDesc UniDescCom,
  uint tmpReplyCode,
  udint tmpud,
  pointer pStr,
  uint iPos,
  uint iIdx,
  string[2] endLocal,
  string[2] endRemot,
  uint ReplyCodeClass,
  pointer pUdint,
  usint P0__st__,
  string[257] PS0__st__
#data byte _str_fbRetriveFromFtp_0 = 
  'U','S','E','R',' ',0
#data byte _str_fbRetriveFromFtp_1 = 
  'P','A','S','S',' ',0
#data byte _str_fbRetriveFromFtp_2 = 
  'T','Y','P','E',' ','I',0
#data byte _str_fbRetriveFromFtp_3 = 
  'P','A','S','V',$0D,$0A,0
#data byte _str_fbRetriveFromFtp_4 = 
  '(',0
#data byte _str_fbRetriveFromFtp_5 = 
  ',',0
#data byte _str_fbRetriveFromFtp_6 = 
  'S','I','Z','E',' ',0
#data byte _str_fbRetriveFromFtp_7 = 
  'R','E','T','R',' ',0
#data byte _str_fbRetriveFromFtp_8 = 
  'Q','U','I','T',0
P     61
fbRetriveFromFtp_L0:
 LINK __SizeOf(fbRetriveFromFtp__temp__)
; Initialize - dynamic variables
 LD   udint $FFFFFFFF    ; nil
 WRY  pStr
 LD   udint $FFFFFFFF    ; nil
 WRY  pUdint
; End initialize - dynamic variables
; R_EDGE, F_EDGE 
 LDX  Retrieve
 LETX __EDGE_R__Retrieve
 WRX  Retrieve
#srcline 77 ;  IF GetChanIndex( chanCodeCom) <> -1 THEN
 NXT
 LDX  chanCodeCom
#debug uint chanCodeCom
 WR   __Instance__GetChanIndex~chanCode
#debug_left uint __Instance__GetChanIndex~chanCode
 PRV
 LEA  __Instance__GetChanIndex
 CAL  GetChanIndex_L0
 LD   int -1
 EQ
 NEG
 JMC  fbRetriveFromFtp_L1
#srcline 78 ;    // kanal zalozen pomoci #module => kontrola nutna
#srcline 79 ;    UniDescCom := GetChanDesc(chanCode := chanCodeCom);
 NXT
 LDX  chanCodeCom
#debug uint chanCodeCom
 WR   __Instance__GetChanDesc~chanCode
#debug_left uint __Instance__GetChanDesc~chanCode
 PRV
 LEA  __Instance__GetChanDesc
 CAL  GetChanDesc_L0
 LEAY UniDescCom
#debug_left pointer UniDescCom
 LD   26   ;SizeOf() 
 MOV  %IB0
#srcline 80 ;    IF (UniDescCom.modeChan <> 5) OR (UniDescCom.lenUniIn <> 259) OR (UniDescCom.lenUniOut < 259) THEN
 LDY  UniDescCom~modeChan
#debug byte UniDescCom.modeChan
 LD   byte 5
 EQ
 NEG
 LDY  UniDescCom~lenUniIn
#debug uint UniDescCom.lenUniIn
 LD   uint 259
 EQ
 NEG
 OR  
 LDY  UniDescCom~lenUniOut
#debug uint UniDescCom.lenUniOut
 LD   uint 259
 LT
 OR  
 JMC  fbRetriveFromFtp_L3
#srcline 81 ;      Err   := true;
 LD   bool -1       ; true
 WRX  Err
#debug_left bool Err
#srcline 82 ;      ErrId := 255;
 LD   usint 255
 WRX  ErrId
#debug_left usint ErrId
#srcline 83 ;      RETURN;
 JMP  fbRetriveFromFtp_RET
#srcline 84 ;    END_IF;
fbRetriveFromFtp_L3:
#srcline 85 ;  END_IF;
fbRetriveFromFtp_L1:
#srcline 87 ;  IF GetChanIndex( chanCodeDat) <> -1 THEN
 NXT
 LDX  chanCodeDat
#debug uint chanCodeDat
 WR   __Instance__GetChanIndex~chanCode
#debug_left uint __Instance__GetChanIndex~chanCode
 PRV
 LEA  __Instance__GetChanIndex
 CAL  GetChanIndex_L0
 LD   int -1
 EQ
 NEG
 JMC  fbRetriveFromFtp_L5
#srcline 88 ;    // kanal zalozen pomoci #module => kontrola nutna
#srcline 89 ;    UniDescCom := GetChanDesc(chanCode := chanCodeDat);
 NXT
 LDX  chanCodeDat
#debug uint chanCodeDat
 WR   __Instance__GetChanDesc~chanCode
#debug_left uint __Instance__GetChanDesc~chanCode
 PRV
 LEA  __Instance__GetChanDesc
 CAL  GetChanDesc_L0
 LEAY UniDescCom
#debug_left pointer UniDescCom
 LD   26   ;SizeOf() 
 MOV  %IB0
#srcline 90 ;    IF (UniDescCom.modeChan <> 5) OR (UniDescCom.lenUniIn <> 259) THEN
 LDY  UniDescCom~modeChan
#debug byte UniDescCom.modeChan
 LD   byte 5
 EQ
 NEG
 LDY  UniDescCom~lenUniIn
#debug uint UniDescCom.lenUniIn
 LD   uint 259
 EQ
 NEG
 OR  
 JMC  fbRetriveFromFtp_L7
#srcline 91 ;      Err   := true;
 LD   bool -1       ; true
 WRX  Err
#debug_left bool Err
#srcline 92 ;      ErrId := 253;
 LD   usint 253
 WRX  ErrId
#debug_left usint ErrId
#srcline 93 ;      RETURN;
 JMP  fbRetriveFromFtp_RET
#srcline 94 ;    END_IF;
fbRetriveFromFtp_L7:
#srcline 95 ;  END_IF;
fbRetriveFromFtp_L5:
#srcline 97 ;  Err   := false;
 LD   bool 0       ; false
 WRX  Err
#debug_left bool Err
#srcline 98 ;  Done  := false;
 LD   bool 0       ; false
 WRX  Done
#debug_left bool Done
#srcline 100 ;  timeoutCom(PT := T#30s); //timeout
 LD   time 30000
 WRX  timeoutCom~PT
#debug_left time timeoutCom~PT
 LEAX timeoutCom
 CAL  TON_L0
#srcline 101 ;  KeepAliveTCP(rq := State = fss_RxData, chanCode := chanCodeCom, PT := T#30s);
 LDX  State
#debug usint State
 LD   udint 28  ; TFtpStoreState#fss_RxData
 EQ
 WRX  KeepAliveTCP~rq
#debug_left bool KeepAliveTCP~rq
 LDX  chanCodeCom
#debug uint chanCodeCom
 WRX  KeepAliveTCP~chanCode
#debug_left uint KeepAliveTCP~chanCode
 LD   time 30000
 WRX  KeepAliveTCP~PT
#debug_left time KeepAliveTCP~PT
 LEAX KeepAliveTCP
 CAL  fbKeepAliveTCP_L0
#srcline 103 ;  IF timeoutCom.Q THEN
 LDX  timeoutCom~Q
#debug bool timeoutCom.Q
 JMC  fbRetriveFromFtp_L9
#srcline 104 ;    state  := fss_Error;
 LD   udint 22  ; TFtpStoreState#fss_Error
 WRX  state
#debug_left usint state
#srcline 105 ;    eErrId := 1;
 LD   usint 1
 WRX  eErrId
#debug_left usint eErrId
#srcline 106 ;  END_IF;
fbRetriveFromFtp_L9:
#srcline 108 ;  IF NOT TRO THEN
 LDX  TRO
#debug bool TRO
 NEG
 JMC  fbRetriveFromFtp_L11
#srcline 109 ;    if mesRec then
 LDX  mesRec
#debug bool mesRec
 JMC  fbRetriveFromFtp_L13
#srcline 110 ;      pUdint := ADR(cmdCom);
 LEAX cmdCom
#debug pointer cmdCom
 LEAY pUdint
 WRIL 
#debug_left pointer pUdint
#srcline 111 ;      if (pUdint^ AND 16#FF000000) = 16#2D000000 then //potlacit multiple lines
 LEAY pUdint
 LDIL    ; dereference 
 LDIL 
#debug dword pUdint^
 LD   dword $FF000000
 AND
 LD   dword $2D000000
 EQ
 JMC  fbRetriveFromFtp_L15
#srcline 112 ;        mesRec := false;
 LD   bool 0       ; false
 WRX  mesRec
#debug_left bool mesRec
#srcline 113 ;      end_if;
fbRetriveFromFtp_L15:
#srcline 114 ;      tmpReplyCode := STRING_TO_UINT(cmdCom);
 LEAX cmdCom
#debug string cmdCom
 SCNV $300A;  IEC_STRING _TO_ IEC_UINT
 WRY  tmpReplyCode
#debug_left uint tmpReplyCode
#srcline 115 ;      ReplyCodeClass := tmpReplyCode / 100;
 LDY  tmpReplyCode
#debug uint tmpReplyCode
 LD   uint 100
 DIVL
 AND  $FFFF
 WRY  ReplyCodeClass
#debug_left uint ReplyCodeClass
#srcline 116 ;      IF Busy AND NOT Err THEN
 LDX  Busy
#debug bool Busy
 LDX  Err
#debug bool Err
 NEG
 AND
 JMC  fbRetriveFromFtp_L17
#srcline 117 ;        ReplyCode := tmpReplyCode;
 LDY  tmpReplyCode
#debug uint tmpReplyCode
 WRX  ReplyCode
#debug_left uint ReplyCode
#srcline 118 ;      END_IF;
fbRetriveFromFtp_L17:
#srcline 119 ;    end_if;
fbRetriveFromFtp_L13:
#srcline 121 ;    CASE state OF
 LDX  state
#debug usint state
 WRY  P0__st__
 LD   0
 LDY  P0__st__
 EQ  
 JMC  fbRetriveFromFtp_L20
#srcline 122 ;      // inicializace ------------------------------------------------------------
#srcline 123 ;      fss_Init :
#srcline 124 ;        busy        := false;
 LD   bool 0       ; false
 WRX  busy
#debug_left bool busy
#srcline 125 ;        state       := fss_Idle;
 LD   udint 1  ; TFtpStoreState#fss_Idle
 WRX  state
#debug_left usint state
#srcline 126 ;        // nenavazovat spojeni
#srcline 127 ;        CloseTCPconnection(chanCodeCom);
 NXT
 LDX  chanCodeCom
#debug uint chanCodeCom
 WR   __Instance__CloseTCPconnection~chanCode
#debug_left uint __Instance__CloseTCPconnection~chanCode
 PRV
 LEA  __Instance__CloseTCPconnection
 CAL  CloseTCPconnection_L0
#srcline 128 ;        CloseTCPconnection(chanCodeDat);
 NXT
 LDX  chanCodeDat
#debug uint chanCodeDat
 WR   __Instance__CloseTCPconnection~chanCode
#debug_left uint __Instance__CloseTCPconnection~chanCode
 PRV
 LEA  __Instance__CloseTCPconnection
 CAL  CloseTCPconnection_L0
#srcline 129 ;        IF h <> INVALID_HANDLE_VALUE THEN
 LDX  h
#debug udint h
 LD   udint 0
 EQ
 NEG
 JMC  fbRetriveFromFtp_L21
#srcline 130 ;          FileClose(hFile := h);
 NXT
 LDX  h
#debug udint h
 WR   __Instance__FileClose~hFile
#debug_left udint __Instance__FileClose~hFile
 PRV
 LEA  __Instance__FileClose
 CAL  FileClose_L0
#srcline 131 ;          h := INVALID_HANDLE_VALUE;
 LD   udint 0
 WRX  h
#debug_left udint h
#srcline 132 ;        END_IF;
fbRetriveFromFtp_L21:
 JMP  fbRetriveFromFtp_L19
fbRetriveFromFtp_L20:
 LD   1
 LDY  P0__st__
 EQ  
 JMC  fbRetriveFromFtp_L23
#srcline 133 ;      // cekani na start ---------------------------------------------------------
#srcline 134 ;      fss_Idle :
#srcline 135 ;        if Retrieve then
 LDX  Retrieve
#debug bool Retrieve
 JMC  fbRetriveFromFtp_L24
#srcline 136 ;          // vycistime prijimaci a vysilaci buffer
#srcline 137 ;          Recv_From_Com.getMes  := 0;
 LD   bool 0       ; false
 WRX  Recv_From_Com~getMes
#debug_left bool Recv_From_Com.getMes
#srcline 138 ;          //Send_To_Com.rq    := 0;
#srcline 139 ;          Send_To_Com.lenTx := 0;
 LD   uint 0
 WRX  Send_To_Com~lenTx
#debug_left uint Send_To_Com.lenTx
#srcline 140 ;          state             := fss_IpCom;
 LD   udint 3  ; TFtpStoreState#fss_IpCom
 WRX  state
#debug_left usint state
#srcline 141 ;          busy              := true;
 LD   bool -1       ; true
 WRX  busy
#debug_left bool busy
#srcline 142 ;          ErrId             := 0;
 LD   usint 0
 WRX  ErrId
#debug_left usint ErrId
#srcline 143 ;          eErrId            := 0;
 LD   usint 0
 WRX  eErrId
#debug_left usint eErrId
#srcline 144 ;          ReplyCode         := 0;
 LD   uint 0
 WRX  ReplyCode
#debug_left uint ReplyCode
#srcline 145 ;          lRemotName        := RemotName;   //ulozit vzdalene jmeno
 LD   0   ; null string
 LEAX lRemotName
 WRI  
 LEAX lRemotName
 LD   80
 DST    ; Level 1
 LDX  RemotName
#debug string RemotName
 SCON 
#debug_left string lRemotName
 PDST   ; Level 1
#srcline 146 ;          idPos             := 0;
 LD   udint 0
 WRX  idPos
#debug_left udint idPos
#srcline 147 ;          //Progress          := 0;
#srcline 148 ;          _FindNextPathSeparator(In := lRemotName, Pos := idPos);
 NXT
 LEAX lRemotName
 WR   __Instance___FindNextPathSeparator~In
#debug_left pointer __Instance___FindNextPathSeparator.In
 LEAX idPos
 WR   __Instance___FindNextPathSeparator~Pos
#debug_left pointer __Instance___FindNextPathSeparator.Pos
 PRV
 LEA  __Instance___FindNextPathSeparator
 CAL  _FindNextPathSeparator_L0
#srcline 149 ;        end_if;
fbRetriveFromFtp_L24:
 JMP  fbRetriveFromFtp_L19
fbRetriveFromFtp_L23:
 LD   3
 LDY  P0__st__
 EQ  
 JMC  fbRetriveFromFtp_L26
#srcline 150 ;      // nastavit IP
#srcline 151 ;      fss_IpCom :
#srcline 152 ;        IF IPadr = Any_IP THEN
 LEAX IPadr
 LEA  Any_IP
 LD   4   ; SizeOf()
 BCMP 
 EQ   0
 JMC  fbRetriveFromFtp_L27
#srcline 153 ;          Err    := 1;
 LD   bool -1      ; true
 WRX  Err
#debug_left bool Err
#srcline 154 ;          ErrId  := 254;
 LD   usint 254
 WRX  ErrId
#debug_left usint ErrId
#srcline 155 ;          state  := fss_Init;
 LD   udint 0  ; TFtpStoreState#fss_Init
 WRX  state
#debug_left usint state
#srcline 156 ;        ELSE
 JMP  fbRetriveFromFtp_L28
fbRetriveFromFtp_L27:
#srcline 157 ;          rea.remoteIP   := IPadr;
 LEAX IPadr
#debug pointer IPadr
 SRC  %IB0
 LEAX rea~remoteIP
#debug_left pointer rea.remoteIP
 LD   4   ;SizeOf() 
 MOV  %IB0
#srcline 158 ;          rea.remotePort := port;
 LDX  port
#debug uint port
 WRX  rea~remotePort
#debug_left uint rea.remotePort
#srcline 159 ;          rea.localPort  := 0;
 LD   uint 0
 WRX  rea~localPort
#debug_left uint rea.localPort
#srcline 160 ;          IF SetRemoteIPaddress(rq := 1, chanCode := chanCodeCom, ethAdr := rea) THEN
 NXT
 LD   1
 WR   __Instance__SetRemoteIPaddress~rq
#debug_left bool __Instance__SetRemoteIPaddress~rq
 LDX  chanCodeCom
#debug uint chanCodeCom
 WR   __Instance__SetRemoteIPaddress~chanCode
#debug_left uint __Instance__SetRemoteIPaddress~chanCode
 LEAX rea
 WR   __Instance__SetRemoteIPaddress~ethAdr
#debug_left pointer __Instance__SetRemoteIPaddress.ethAdr
 PRV
 LEA  __Instance__SetRemoteIPaddress
 CAL  SetRemoteIPaddress_L0
 JMC  fbRetriveFromFtp_L29
#srcline 161 ;            state := fss_Connect;
 LD   udint 4  ; TFtpStoreState#fss_Connect
 WRX  state
#debug_left usint state
#srcline 162 ;          END_IF;
fbRetriveFromFtp_L29:
#srcline 163 ;        END_IF;
fbRetriveFromFtp_L28:
 JMP  fbRetriveFromFtp_L19
fbRetriveFromFtp_L26:
 LD   4
 LDY  P0__st__
 EQ  
 JMC  fbRetriveFromFtp_L31
#srcline 164 ;      fss_Connect :
#srcline 165 ;        EstabTCPconnection(chanCode := chanCodeCom);
 NXT
 LDX  chanCodeCom
#debug uint chanCodeCom
 WR   __Instance__EstabTCPconnection~chanCode
#debug_left uint __Instance__EstabTCPconnection~chanCode
 PRV
 LEA  __Instance__EstabTCPconnection
 CAL  EstabTCPconnection_L0
#srcline 166 ;        Recv_From_Com.getMes := 1;
 LD   bool -1      ; true
 WRX  Recv_From_Com~getMes
#debug_left bool Recv_From_Com.getMes
#srcline 167 ;        IF IsEstabTCPconnection(chanCode := chanCodeCom) THEN
 NXT
 LDX  chanCodeCom
#debug uint chanCodeCom
 WR   __Instance__IsEstabTCPconnection~chanCode
#debug_left uint __Instance__IsEstabTCPconnection~chanCode
 PRV
 LEA  __Instance__IsEstabTCPconnection
 CAL  IsEstabTCPconnection_L0
 JMC  fbRetriveFromFtp_L32
#srcline 168 ;          state := fss_Rx220;
 LD   udint 5  ; TFtpStoreState#fss_Rx220
 WRX  state
#debug_left usint state
#srcline 169 ;        END_IF;
fbRetriveFromFtp_L32:
 JMP  fbRetriveFromFtp_L19
fbRetriveFromFtp_L31:
 LD   5
 LDY  P0__st__
 EQ  
 JMC  fbRetriveFromFtp_L34
#srcline 170 ;      fss_Rx220 :
#srcline 171 ;        IF mesRec THEN
 LDX  mesRec
#debug bool mesRec
 JMC  fbRetriveFromFtp_L35
#srcline 172 ;          Recv_From_Com.getMes := 0;
 LD   bool 0       ; false
 WRX  Recv_From_Com~getMes
#debug_left bool Recv_From_Com.getMes
#srcline 173 ;          IF tmpReplyCode = 220 THEN
 LDY  tmpReplyCode
#debug uint tmpReplyCode
 LD   uint 220
 EQ
 JMC  fbRetriveFromFtp_L37
#srcline 174 ;            state := fss_TxUser;
 LD   udint 6  ; TFtpStoreState#fss_TxUser
 WRX  state
#debug_left usint state
#srcline 175 ;          ELSE
 JMP  fbRetriveFromFtp_L38
fbRetriveFromFtp_L37:
#srcline 176 ;            state := fss_UnexpectedReply;
 LD   udint 23  ; TFtpStoreState#fss_UnexpectedReply
 WRX  state
#debug_left usint state
#srcline 177 ;          END_IF;
fbRetriveFromFtp_L38:
#srcline 178 ;        END_IF;
fbRetriveFromFtp_L35:
 JMP  fbRetriveFromFtp_L19
fbRetriveFromFtp_L34:
 LD   6
 LDY  P0__st__
 EQ  
 JMC  fbRetriveFromFtp_L39
#srcline 179 ;      fss_TxUser:
#srcline 180 ;        Recv_From_Com.getMes := 1;
 LD   bool -1      ; true
 WRX  Recv_From_Com~getMes
#debug_left bool Recv_From_Com.getMes
#srcline 181 ;        Send_To_Com.rq   := 1;
 LD   bool -1      ; true
 WRX  Send_To_Com~rq
#debug_left bool Send_To_Com.rq
#srcline 182 ;        cmdCom := 'USER ' + User + INTERNETLIB_END_OF_LINE_;
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LEA  _str_fbRetriveFromFtp_0
 SCON 
 LDX  User
#debug string User
 SCON 
 LEA  INTERNETLIB_END_OF_LINE_
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX cmdCom
 WRI  
 LEAX cmdCom
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string cmdCom
 PDST   ; Level 1
#srcline 183 ;        state := fss_RxUser;
 LD   udint 7  ; TFtpStoreState#fss_RxUser
 WRX  state
#debug_left usint state
 JMP  fbRetriveFromFtp_L19
fbRetriveFromFtp_L39:
 LD   7
 LDY  P0__st__
 EQ  
 JMC  fbRetriveFromFtp_L40
#srcline 184 ;      fss_RxUser:
#srcline 185 ;        IF mesRec THEN
 LDX  mesRec
#debug bool mesRec
 JMC  fbRetriveFromFtp_L41
#srcline 186 ;          IF tmpReplyCode = 331 THEN
 LDY  tmpReplyCode
#debug uint tmpReplyCode
 LD   uint 331
 EQ
 JMC  fbRetriveFromFtp_L43
#srcline 187 ;            Recv_From_Com.getMes := 0;
 LD   bool 0       ; false
 WRX  Recv_From_Com~getMes
#debug_left bool Recv_From_Com.getMes
#srcline 188 ;            state := fss_TxPass;
 LD   udint 8  ; TFtpStoreState#fss_TxPass
 WRX  state
#debug_left usint state
#srcline 189 ;          ELSIF tmpReplyCode <> 220 THEN
 JMP  fbRetriveFromFtp_L44
fbRetriveFromFtp_L43:
 LDY  tmpReplyCode
#debug uint tmpReplyCode
 LD   uint 220
 EQ
 NEG
 JMC  fbRetriveFromFtp_L45
#srcline 190 ;            Recv_From_Com.getMes := 0;
 LD   bool 0       ; false
 WRX  Recv_From_Com~getMes
#debug_left bool Recv_From_Com.getMes
#srcline 191 ;            state := fss_UnexpectedReply;
 LD   udint 23  ; TFtpStoreState#fss_UnexpectedReply
 WRX  state
#debug_left usint state
#srcline 192 ;          END_IF;
 JMP  fbRetriveFromFtp_L44
fbRetriveFromFtp_L45:
fbRetriveFromFtp_L44:
#srcline 193 ;        END_IF;
fbRetriveFromFtp_L41:
 JMP  fbRetriveFromFtp_L19
fbRetriveFromFtp_L40:
 LD   8
 LDY  P0__st__
 EQ  
 JMC  fbRetriveFromFtp_L46
#srcline 194 ;      fss_TxPass:
#srcline 195 ;        Recv_From_Com.getMes := 1;
 LD   bool -1      ; true
 WRX  Recv_From_Com~getMes
#debug_left bool Recv_From_Com.getMes
#srcline 196 ;        Send_To_Com.rq   := 1;
 LD   bool -1      ; true
 WRX  Send_To_Com~rq
#debug_left bool Send_To_Com.rq
#srcline 197 ;        cmdCom := 'PASS ' + Pass + INTERNETLIB_END_OF_LINE_;
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LEA  _str_fbRetriveFromFtp_1
 SCON 
 LDX  Pass
#debug string Pass
 SCON 
 LEA  INTERNETLIB_END_OF_LINE_
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX cmdCom
 WRI  
 LEAX cmdCom
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string cmdCom
 PDST   ; Level 1
#srcline 198 ;        state := fss_RxPass;
 LD   udint 9  ; TFtpStoreState#fss_RxPass
 WRX  state
#debug_left usint state
 JMP  fbRetriveFromFtp_L19
fbRetriveFromFtp_L46:
 LD   9
 LDY  P0__st__
 EQ  
 JMC  fbRetriveFromFtp_L47
#srcline 199 ;      fss_RxPass:
#srcline 200 ;        IF mesRec THEN
 LDX  mesRec
#debug bool mesRec
 JMC  fbRetriveFromFtp_L48
#srcline 201 ;          Recv_From_Com.getMes := 0;
 LD   bool 0       ; false
 WRX  Recv_From_Com~getMes
#debug_left bool Recv_From_Com.getMes
#srcline 202 ;          IF tmpReplyCode = 230 THEN
 LDY  tmpReplyCode
#debug uint tmpReplyCode
 LD   uint 230
 EQ
 JMC  fbRetriveFromFtp_L50
#srcline 203 ;            state := fss_TxType;
 LD   udint 10  ; TFtpStoreState#fss_TxType
 WRX  state
#debug_left usint state
#srcline 204 ;          ELSE
 JMP  fbRetriveFromFtp_L51
fbRetriveFromFtp_L50:
#srcline 205 ;            state := fss_UnexpectedReply;
 LD   udint 23  ; TFtpStoreState#fss_UnexpectedReply
 WRX  state
#debug_left usint state
#srcline 206 ;          END_IF;
fbRetriveFromFtp_L51:
#srcline 207 ;        END_IF;
fbRetriveFromFtp_L48:
 JMP  fbRetriveFromFtp_L19
fbRetriveFromFtp_L47:
 LD   10
 LDY  P0__st__
 EQ  
 JMC  fbRetriveFromFtp_L52
#srcline 208 ;      fss_TxType:
#srcline 209 ;        Recv_From_Com.getMes := 1;
 LD   bool -1      ; true
 WRX  Recv_From_Com~getMes
#debug_left bool Recv_From_Com.getMes
#srcline 210 ;        Send_To_Com.rq   := 1;
 LD   bool -1      ; true
 WRX  Send_To_Com~rq
#debug_left bool Send_To_Com.rq
#srcline 211 ;        cmdCom := 'TYPE I' + INTERNETLIB_END_OF_LINE_;
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LEA  _str_fbRetriveFromFtp_2
 SCON 
 LEA  INTERNETLIB_END_OF_LINE_
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX cmdCom
 WRI  
 LEAX cmdCom
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string cmdCom
 PDST   ; Level 1
#srcline 212 ;        state := fss_RxType;
 LD   udint 11  ; TFtpStoreState#fss_RxType
 WRX  state
#debug_left usint state
 JMP  fbRetriveFromFtp_L19
fbRetriveFromFtp_L52:
 LD   11
 LDY  P0__st__
 EQ  
 JMC  fbRetriveFromFtp_L53
#srcline 213 ;      fss_RxType:
#srcline 214 ;        IF mesRec THEN
 LDX  mesRec
#debug bool mesRec
 JMC  fbRetriveFromFtp_L54
#srcline 215 ;          Recv_From_Com.getMes := 0;
 LD   bool 0       ; false
 WRX  Recv_From_Com~getMes
#debug_left bool Recv_From_Com.getMes
#srcline 216 ;          IF tmpReplyCode = 200 THEN
 LDY  tmpReplyCode
#debug uint tmpReplyCode
 LD   uint 200
 EQ
 JMC  fbRetriveFromFtp_L56
#srcline 217 ;            state := fss_TxPasv;
 LD   udint 12  ; TFtpStoreState#fss_TxPasv
 WRX  state
#debug_left usint state
#srcline 218 ;          ELSE
 JMP  fbRetriveFromFtp_L57
fbRetriveFromFtp_L56:
#srcline 219 ;            state := fss_UnexpectedReply;
 LD   udint 23  ; TFtpStoreState#fss_UnexpectedReply
 WRX  state
#debug_left usint state
#srcline 220 ;          END_IF;
fbRetriveFromFtp_L57:
#srcline 221 ;        END_IF;
fbRetriveFromFtp_L54:
 JMP  fbRetriveFromFtp_L19
fbRetriveFromFtp_L53:
 LD   12
 LDY  P0__st__
 EQ  
 JMC  fbRetriveFromFtp_L58
#srcline 222 ;      fss_TxPasv:
#srcline 223 ;        Recv_From_Com.getMes := 1;
 LD   bool -1      ; true
 WRX  Recv_From_Com~getMes
#debug_left bool Recv_From_Com.getMes
#srcline 224 ;        Send_To_Com.rq   := 1;
 LD   bool -1      ; true
 WRX  Send_To_Com~rq
#debug_left bool Send_To_Com.rq
#srcline 225 ;        cmdCom := 'PASV$r$l';
 LD   0   ; null string
 LEAX cmdCom
 WRI  
 LEAX cmdCom
 LD   255
 DST    ; Level 1
 LEA  _str_fbRetriveFromFtp_3
 SCON 
#debug_left string cmdCom
 PDST   ; Level 1
#srcline 226 ;        state := fss_RxPasv;
 LD   udint 13  ; TFtpStoreState#fss_RxPasv
 WRX  state
#debug_left usint state
 JMP  fbRetriveFromFtp_L19
fbRetriveFromFtp_L58:
 LD   13
 LDY  P0__st__
 EQ  
 JMC  fbRetriveFromFtp_L59
#srcline 227 ;      fss_RxPasv:
#srcline 228 ;        IF mesRec THEN
 LDX  mesRec
#debug bool mesRec
 JMC  fbRetriveFromFtp_L60
#srcline 229 ;          Recv_From_Com.getMes := 0;
 LD   bool 0       ; false
 WRX  Recv_From_Com~getMes
#debug_left bool Recv_From_Com.getMes
#srcline 230 ;          IF tmpReplyCode = 227 THEN
 LDY  tmpReplyCode
#debug uint tmpReplyCode
 LD   uint 227
 EQ
 JMC  fbRetriveFromFtp_L62
#srcline 231 ;            iPos := FIND(IN1 := cmdCom, IN2 := '(');
 LEAX cmdCom
#debug string cmdCom
 LEA  _str_fbRetriveFromFtp_4
 SFND 
 WRY  iPos
#debug_left uint iPos
#srcline 232 ;            pStr := ADR(cmdCom);
 LEAX cmdCom
#debug pointer cmdCom
 LEAY pStr
 WRIL 
#debug_left pointer pStr
#srcline 233 ;            WHILE iPos > 0 & iIdx < 6 DO
fbRetriveFromFtp_L64:
 LDY  iPos
#debug uint iPos
 LD   uint 0
 GT
 LDY  iIdx
#debug uint iIdx
 LD   uint 6
 LT
 AND
 JMC  fbRetriveFromFtp_L65
 DBG 
#srcline 234 ;              pStr := pStr + UINT_TO_UDINT(iPos);
 LEAY pStr
 LDIL 
#debug pointer pStr
 LDY  iPos
#debug uint iPos
 ADD
 LEAY pStr
 WRIL 
#debug_left pointer pStr
#srcline 235 ;              pasvDat[iIdx] := STRING_TO_USINT(pStr^);
 LEAY pStr
 LDIL    ; dereference 
#debug string pStr^
 SCNV $3008;  IEC_STRING _TO_ IEC_USINT
 LEAX pasvDat
 LDY  iIdx
#debug uint iIdx
 RCHK 5   ; Range Check
 ADD     ; + offset 
 WRI 
#debug_left usint pasvDat[iIdx]
#srcline 236 ;              iIdx := iIdx + 1;
 LDY  iIdx
#debug uint iIdx
 LD   uint 1
 ADD
 AND  $FFFF
 WRY  iIdx
#debug_left uint iIdx
#srcline 237 ;              iPos := FIND(IN1 := pStr^, IN2 := ',');
 LEAY pStr
 LDIL    ; dereference 
#debug string pStr^
 LEA  _str_fbRetriveFromFtp_5
 SFND 
 WRY  iPos
#debug_left uint iPos
#srcline 238 ;            END_WHILE;
 JMP  fbRetriveFromFtp_L64
fbRetriveFromFtp_L65:
 NOP  -1
#srcline 239 ;            state := fss_TxSize;
 LD   udint 29  ; TFtpStoreState#fss_TxSize
 WRX  state
#debug_left usint state
#srcline 240 ;          ELSE
 JMP  fbRetriveFromFtp_L63
fbRetriveFromFtp_L62:
#srcline 241 ;            state := fss_UnexpectedReply;
 LD   udint 23  ; TFtpStoreState#fss_UnexpectedReply
 WRX  state
#debug_left usint state
#srcline 242 ;          END_IF;
fbRetriveFromFtp_L63:
#srcline 243 ;        END_IF;
fbRetriveFromFtp_L60:
 JMP  fbRetriveFromFtp_L19
fbRetriveFromFtp_L59:
 LD   29
 LDY  P0__st__
 EQ  
 JMC  fbRetriveFromFtp_L66
#srcline 244 ;      fss_TxSize:
#srcline 245 ;        Recv_From_Com.getMes := 1;
 LD   bool -1      ; true
 WRX  Recv_From_Com~getMes
#debug_left bool Recv_From_Com.getMes
#srcline 246 ;        Send_To_Com.rq   := 1;
 LD   bool -1      ; true
 WRX  Send_To_Com~rq
#debug_left bool Send_To_Com.rq
#srcline 247 ;        cmdCom := 'SIZE ' + lRemotName + INTERNETLIB_END_OF_LINE_;
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LEA  _str_fbRetriveFromFtp_6
 SCON 
 LEAX lRemotName
#debug string lRemotName
 SCON 
 LEA  INTERNETLIB_END_OF_LINE_
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX cmdCom
 WRI  
 LEAX cmdCom
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string cmdCom
 PDST   ; Level 1
#srcline 248 ;        state := fss_RxSize;
 LD   udint 30  ; TFtpStoreState#fss_RxSize
 WRX  state
#debug_left usint state
 JMP  fbRetriveFromFtp_L19
fbRetriveFromFtp_L66:
 LD   30
 LDY  P0__st__
 EQ  
 JMC  fbRetriveFromFtp_L67
#srcline 249 ;      fss_RxSize:
#srcline 250 ;        lSize := 0;
 LD   udint 0
 WRX  lSize
#debug_left udint lSize
#srcline 251 ;        IF mesRec THEN
 LDX  mesRec
#debug bool mesRec
 JMC  fbRetriveFromFtp_L68
#srcline 252 ;          Recv_From_Com.getMes := 0;
 LD   bool 0       ; false
 WRX  Recv_From_Com~getMes
#debug_left bool Recv_From_Com.getMes
#srcline 253 ;          IF tmpReplyCode = 213 THEN
 LDY  tmpReplyCode
#debug uint tmpReplyCode
 LD   uint 213
 EQ
 JMC  fbRetriveFromFtp_L70
#srcline 254 ;            pStr := ADR(cmdCom) + 4;
 LEAX cmdCom
#debug pointer cmdCom
 LD   udint 4
 ADD
 LEAY pStr
 WRIL 
#debug_left pointer pStr
#srcline 255 ;            lSize := STRING_TO_UDINT(pStr^);
 LEAY pStr
 LDIL    ; dereference 
#debug string pStr^
 SCNV $300C;  IEC_STRING _TO_ IEC_UDINT
 WRX  lSize
#debug_left udint lSize
#srcline 256 ;(*          ELSE                              //kdyz to nevyjde budeme to ignorovat?
#srcline 257 ;            state := fss_UnexpectedReply;*)
#srcline 258 ;          END_IF;
fbRetriveFromFtp_L70:
#srcline 259 ;          state := fss_TxRetr;
 LD   udint 27  ; TFtpStoreState#fss_TxRetr
 WRX  state
#debug_left usint state
#srcline 260 ;        END_IF;
fbRetriveFromFtp_L68:
 JMP  fbRetriveFromFtp_L19
fbRetriveFromFtp_L67:
 LD   27
 LDY  P0__st__
 EQ  
 JMC  fbRetriveFromFtp_L72
#srcline 261 ;      fss_TxRetr:
#srcline 262 ;        Recv_From_Com.getMes := 1;
 LD   bool -1      ; true
 WRX  Recv_From_Com~getMes
#debug_left bool Recv_From_Com.getMes
#srcline 263 ;        Send_To_Com.rq   := 1;
 LD   bool -1      ; true
 WRX  Send_To_Com~rq
#debug_left bool Send_To_Com.rq
#srcline 264 ;        cmdCom := 'RETR ' + lRemotName + INTERNETLIB_END_OF_LINE_;
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LEA  _str_fbRetriveFromFtp_7
 SCON 
 LEAX lRemotName
#debug string lRemotName
 SCON 
 LEA  INTERNETLIB_END_OF_LINE_
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX cmdCom
 WRI  
 LEAX cmdCom
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string cmdCom
 PDST   ; Level 1
#srcline 265 ;        data   := 0;
 LD   udint 0
 WRX  data
#debug_left udint data
#srcline 266 ;        state  := fss_IpDat;
 LD   udint 15  ; TFtpStoreState#fss_IpDat
 WRX  state
#debug_left usint state
 JMP  fbRetriveFromFtp_L19
fbRetriveFromFtp_L72:
 LD   15
 LDY  P0__st__
 EQ  
 JMC  fbRetriveFromFtp_L73
#srcline 267 ;      fss_IpDat:
#srcline 268 ;        rea.remoteIP[0]   := pasvDat[0];
 LDX  pasvDat[0]
#debug usint pasvDat[0]
 WRX  rea~remoteIP[0]
#debug_left usint rea.remoteIP[0]
#srcline 269 ;        rea.remoteIP[1]   := pasvDat[1];
 LDX  pasvDat[1]
#debug usint pasvDat[1]
 WRX  rea~remoteIP[1]
#debug_left usint rea.remoteIP[1]
#srcline 270 ;        rea.remoteIP[2]   := pasvDat[2];
 LDX  pasvDat[2]
#debug usint pasvDat[2]
 WRX  rea~remoteIP[2]
#debug_left usint rea.remoteIP[2]
#srcline 271 ;        rea.remoteIP[3]   := pasvDat[3];
 LDX  pasvDat[3]
#debug usint pasvDat[3]
 WRX  rea~remoteIP[3]
#debug_left usint rea.remoteIP[3]
#srcline 272 ;        rea.remotePort    := USINT_TO_UINT(pasvDat[4])*256+USINT_TO_UINT(pasvDat[5]);
 LDX  pasvDat[4]
#debug usint pasvDat[4]
 AND  $FFFF
 LD   uint 256
 MUL
 AND  $FFFF
 LDX  pasvDat[5]
#debug usint pasvDat[5]
 AND  $FFFF
 ADD
 AND  $FFFF
 WRX  rea~remotePort
#debug_left uint rea.remotePort
#srcline 273 ;        rea.localPort  := 0;
 LD   uint 0
 WRX  rea~localPort
#debug_left uint rea.localPort
#srcline 274 ;        IF SetRemoteIPaddress(rq := 1, chanCode := chanCodeDat, ethAdr := rea) THEN
 NXT
 LD   1
 WR   __Instance__SetRemoteIPaddress~rq
#debug_left bool __Instance__SetRemoteIPaddress~rq
 LDX  chanCodeDat
#debug uint chanCodeDat
 WR   __Instance__SetRemoteIPaddress~chanCode
#debug_left uint __Instance__SetRemoteIPaddress~chanCode
 LEAX rea
 WR   __Instance__SetRemoteIPaddress~ethAdr
#debug_left pointer __Instance__SetRemoteIPaddress.ethAdr
 PRV
 LEA  __Instance__SetRemoteIPaddress
 CAL  SetRemoteIPaddress_L0
 JMC  fbRetriveFromFtp_L74
#srcline 275 ;          EstabTCPconnection(chanCode := chanCodeDat);
 NXT
 LDX  chanCodeDat
#debug uint chanCodeDat
 WR   __Instance__EstabTCPconnection~chanCode
#debug_left uint __Instance__EstabTCPconnection~chanCode
 PRV
 LEA  __Instance__EstabTCPconnection
 CAL  EstabTCPconnection_L0
#srcline 276 ;          Recv_From_Dat.rq   := 1;
 LD   bool -1      ; true
 WRX  Recv_From_Dat~rq
#debug_left bool Recv_From_Dat.rq
#srcline 277 ;          lTrans := 0;
 LD   udint 0
 WRX  lTrans
#debug_left udint lTrans
#srcline 278 ;          state := fss_RxData;
 LD   udint 28  ; TFtpStoreState#fss_RxData
 WRX  state
#debug_left usint state
#srcline 279 ;        END_IF;
fbRetriveFromFtp_L74:
 JMP  fbRetriveFromFtp_L19
fbRetriveFromFtp_L73:
 LD   28
 LDY  P0__st__
 EQ  
 JMC  fbRetriveFromFtp_L76
#srcline 280 ;      (*
#srcline 281 ;      fss_WaitForOpen:
#srcline 282 ;        EstabTCPconnection(chanCode := chanCodeDat);
#srcline 283 ;        Recv_From_Dat.rq   := 1;
#srcline 284 ;        IF mesRec THEN
#srcline 285 ;          IF ReplyCode = 150 OR ReplyCode = 125 THEN
#srcline 286 ;            lTrans := 0;
#srcline 287 ;            state := fss_RxData;
#srcline 288 ;          ELSE
#srcline 289 ;            state := fss_UnexpectedReply;
#srcline 290 ;          END_IF;
#srcline 291 ;        END_IF;
#srcline 292 ;      *)
#srcline 293 ;      fss_RxData:
#srcline 294 ;        IF mesRec THEN //prijmout info o connection
 LDX  mesRec
#debug bool mesRec
 JMC  fbRetriveFromFtp_L77
#srcline 295 ;          IF ReplyCode <> 150 AND ReplyCode <> 125 AND ReplyCode <> 226 THEN
 LDX  ReplyCode
#debug uint ReplyCode
 LD   uint 150
 EQ
 NEG
 LDX  ReplyCode
#debug uint ReplyCode
 LD   uint 125
 EQ
 NEG
 AND
 LDX  ReplyCode
#debug uint ReplyCode
 LD   uint 226
 EQ
 NEG
 AND
 JMC  fbRetriveFromFtp_L79
#srcline 296 ;            state := fss_UnexpectedReply;
 LD   udint 23  ; TFtpStoreState#fss_UnexpectedReply
 WRX  state
#debug_left usint state
#srcline 297 ;            CloseTCPconnection(chanCodeDat); //nastala chyba zavreme
 NXT
 LDX  chanCodeDat
#debug uint chanCodeDat
 WR   __Instance__CloseTCPconnection~chanCode
#debug_left uint __Instance__CloseTCPconnection~chanCode
 PRV
 LEA  __Instance__CloseTCPconnection
 CAL  CloseTCPconnection_L0
#srcline 298 ;          END_IF;
fbRetriveFromFtp_L79:
#srcline 299 ;        END_IF;
fbRetriveFromFtp_L77:
#srcline 300 ;        IF lSize > 0 THEN Progress := REAL_TO_USINT(UDINT_TO_REAL(lTrans)*100.0/UDINT_TO_REAL(lSize)); END_IF;
 LDX  lSize
#debug udint lSize
 LD   udint 0
 GT
 JMC  fbRetriveFromFtp_L81
 LDX  lTrans
#debug udint lTrans
 ULF
 LD   real 100.0
 MUF
 LDX  lSize
#debug udint lSize
 ULF
 DIF
 RND
 UFW
 AND  $FF
 WRX  Progress
#debug_left usint Progress
fbRetriveFromFtp_L81:
#srcline 301 ;        IF ReplyCode = 226 AND NOT Recv_From_Dat.mesRec AND NOT IsEstabTCPconnection(chanCode := chanCodeDat) THEN
 LDX  ReplyCode
#debug uint ReplyCode
 LD   uint 226
 EQ
 LDX  Recv_From_Dat~mesRec
#debug bool Recv_From_Dat.mesRec
 NEG
 AND
 NXT
 LDX  chanCodeDat
#debug uint chanCodeDat
 WR   __Instance__IsEstabTCPconnection~chanCode
#debug_left uint __Instance__IsEstabTCPconnection~chanCode
 PRV
 LEA  __Instance__IsEstabTCPconnection
 CAL  IsEstabTCPconnection_L0
 NEG
 AND
 JMC  fbRetriveFromFtp_L83
#srcline 302 ;          state := fss_TxQuit;
 LD   udint 19  ; TFtpStoreState#fss_TxQuit
 WRX  state
#debug_left usint state
#srcline 303 ;          Recv_From_Dat.rq := 0;
 LD   bool 0       ; false
 WRX  Recv_From_Dat~rq
#debug_left bool Recv_From_Dat.rq
#srcline 304 ;          CloseTCPconnection(chanCodeDat); //aby se zbytecne neotevrelo znovu
 NXT
 LDX  chanCodeDat
#debug uint chanCodeDat
 WR   __Instance__CloseTCPconnection~chanCode
#debug_left uint __Instance__CloseTCPconnection~chanCode
 PRV
 LEA  __Instance__CloseTCPconnection
 CAL  CloseTCPconnection_L0
#srcline 305 ;        END_IF;
fbRetriveFromFtp_L83:
 JMP  fbRetriveFromFtp_L19
fbRetriveFromFtp_L76:
 LD   19
 LDY  P0__st__
 EQ  
 JMC  fbRetriveFromFtp_L85
#srcline 306 ;      fss_TxQuit:
#srcline 307 ;        Recv_From_Com.getMes := 1;
 LD   bool -1      ; true
 WRX  Recv_From_Com~getMes
#debug_left bool Recv_From_Com.getMes
#srcline 308 ;        Send_To_Com.rq   := 1;
 LD   bool -1      ; true
 WRX  Send_To_Com~rq
#debug_left bool Send_To_Com.rq
#srcline 309 ;        cmdCom := 'QUIT' + INTERNETLIB_END_OF_LINE_;
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LEA  _str_fbRetriveFromFtp_8
 SCON 
 LEA  INTERNETLIB_END_OF_LINE_
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX cmdCom
 WRI  
 LEAX cmdCom
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string cmdCom
 PDST   ; Level 1
#srcline 310 ;        state := fss_RxQuit;
 LD   udint 20  ; TFtpStoreState#fss_RxQuit
 WRX  state
#debug_left usint state
 JMP  fbRetriveFromFtp_L19
fbRetriveFromFtp_L85:
 LD   20
 LDY  P0__st__
 EQ  
 JMC  fbRetriveFromFtp_L86
#srcline 311 ;      fss_RxQuit:
#srcline 312 ;        IF mesRec THEN
 LDX  mesRec
#debug bool mesRec
 JMC  fbRetriveFromFtp_L87
#srcline 313 ;          Recv_From_Com.getMes := 0;
 LD   bool 0       ; false
 WRX  Recv_From_Com~getMes
#debug_left bool Recv_From_Com.getMes
#srcline 314 ;          IF tmpReplyCode = 221 THEN
 LDY  tmpReplyCode
#debug uint tmpReplyCode
 LD   uint 221
 EQ
 JMC  fbRetriveFromFtp_L89
#srcline 315 ;            state := fss_Close;
 LD   udint 21  ; TFtpStoreState#fss_Close
 WRX  state
#debug_left usint state
#srcline 316 ;          ELSE
 JMP  fbRetriveFromFtp_L90
fbRetriveFromFtp_L89:
#srcline 317 ;            state := fss_UnexpectedReply;
 LD   udint 23  ; TFtpStoreState#fss_UnexpectedReply
 WRX  state
#debug_left usint state
#srcline 318 ;          END_IF;
fbRetriveFromFtp_L90:
#srcline 319 ;        END_IF;
fbRetriveFromFtp_L87:
 JMP  fbRetriveFromFtp_L19
fbRetriveFromFtp_L86:
 LD   21
 LDY  P0__st__
 EQ  
 JMC  fbRetriveFromFtp_L91
#srcline 320 ;      fss_Close:
#srcline 321 ;        CloseTCPconnection(chanCode := chanCodeCom);
 NXT
 LDX  chanCodeCom
#debug uint chanCodeCom
 WR   __Instance__CloseTCPconnection~chanCode
#debug_left uint __Instance__CloseTCPconnection~chanCode
 PRV
 LEA  __Instance__CloseTCPconnection
 CAL  CloseTCPconnection_L0
#srcline 322 ;        IF IsEstabTCPconnection(chanCode := chanCodeCom) = false THEN
 NXT
 LDX  chanCodeCom
#debug uint chanCodeCom
 WR   __Instance__IsEstabTCPconnection~chanCode
#debug_left uint __Instance__IsEstabTCPconnection~chanCode
 PRV
 LEA  __Instance__IsEstabTCPconnection
 CAL  IsEstabTCPconnection_L0
 LD   bool 0       ; false
 XOR
 NEG
 JMC  fbRetriveFromFtp_L92
#srcline 323 ;          Done := true;
 LD   bool -1       ; true
 WRX  Done
#debug_left bool Done
#srcline 324 ;          state := fss_Init;
 LD   udint 0  ; TFtpStoreState#fss_Init
 WRX  state
#debug_left usint state
#srcline 325 ;        END_IF;
fbRetriveFromFtp_L92:
 JMP  fbRetriveFromFtp_L19
fbRetriveFromFtp_L91:
 LD   23
 LDY  P0__st__
 EQ  
 JMC  fbRetriveFromFtp_L94
#srcline 326 ;      fss_UnexpectedReply:
#srcline 327 ;        eErrId := 2;
 LD   usint 2
 WRX  eErrId
#debug_left usint eErrId
#srcline 328 ;        state := fss_Error;
 LD   udint 22  ; TFtpStoreState#fss_Error
 WRX  state
#debug_left usint state
 JMP  fbRetriveFromFtp_L19
fbRetriveFromFtp_L94:
 LD   22
 LDY  P0__st__
 EQ  
 JMC  fbRetriveFromFtp_L95
#srcline 329 ;      fss_Error :
#srcline 330 ;        Recv_From_Dat.rq := 0; //tohle zavre prijem pro pripad kdyz nastane chyba
 LD   bool 0       ; false
 WRX  Recv_From_Dat~rq
#debug_left bool Recv_From_Dat.rq
#srcline 331 ;        Err := 1;
 LD   bool -1      ; true
 WRX  Err
#debug_left bool Err
#srcline 332 ;        ErrId := eErrId;
 LDX  eErrId
#debug usint eErrId
 WRX  ErrId
#debug_left usint ErrId
#srcline 333 ;        Recv_From_Com.getMes  := 0;
 LD   bool 0       ; false
 WRX  Recv_From_Com~getMes
#debug_left bool Recv_From_Com.getMes
#srcline 334 ;        state := fss_Init;
 LD   udint 0  ; TFtpStoreState#fss_Init
 WRX  state
#debug_left usint state
 JMP  fbRetriveFromFtp_L19
fbRetriveFromFtp_L95:
fbRetriveFromFtp_L19:
#srcline 336 ;  END_IF;
fbRetriveFromFtp_L11:
#srcline 338 ;  timeoutCom.IN := Recv_From_Com.getMes & NOT Recv_From_Dat.mesRec; //timeout se prerusi v pripade ze prijde neco z datoveho spojeni
 LDX  Recv_From_Com~getMes
#debug bool Recv_From_Com.getMes
 LDX  Recv_From_Dat~mesRec
#debug bool Recv_From_Dat.mesRec
 NEG
 AND
 WRX  timeoutCom~IN
#debug_left bool timeoutCom.IN
#srcline 340 ;  Send_To_Com   (lenTx := len(cmdCom), chanCode := chanCodeCom, data := void(cmdCom));
 LEAX cmdCom
#debug string cmdCom
 SLEN 
 WRX  Send_To_Com~lenTx
#debug_left uint Send_To_Com~lenTx
 LDX  chanCodeCom
#debug uint chanCodeCom
 WRX  Send_To_Com~chanCode
#debug_left uint Send_To_Com~chanCode
 LEAX cmdCom
 WRX  Send_To_Com~data
#debug_left pointer Send_To_Com.data
 LEAX Send_To_Com
 CAL  fbSendTo_L0
#srcline 342 ;  //Recv_From_Com (lenRx := 255, chanCode := chanCodeCom, data := void(cmdCom), mesRec => mesRec);
#srcline 343 ;  Recv_From_Com(chanCode := chanCodeCom, lenBuf := 255, lenTxt := 255, buffer := void(cmdBuffer), txtMes := void(cmdCom));
 LDX  chanCodeCom
#debug uint chanCodeCom
 WRX  Recv_From_Com~chanCode
#debug_left uint Recv_From_Com~chanCode
 LD   uint 255
 WRX  Recv_From_Com~lenBuf
#debug_left uint Recv_From_Com~lenBuf
 LD   uint 255
 WRX  Recv_From_Com~lenTxt
#debug_left uint Recv_From_Com~lenTxt
 LEAX cmdBuffer
 WRX  Recv_From_Com~buffer
#debug_left pointer Recv_From_Com.buffer
 LEAX cmdCom
 WRX  Recv_From_Com~txtMes
#debug_left pointer Recv_From_Com.txtMes
 LEAX Recv_From_Com
 CAL  fbRecvTxt_L0
#srcline 344 ;  mesRec := Recv_From_Com.lenMes > 0;
 LDX  Recv_From_Com~lenMes
#debug uint Recv_From_Com.lenMes
 LD   uint 0
 GT
 WRX  mesRec
#debug_left bool mesRec
#srcline 345 ;  
#srcline 346 ;  Recv_From_Dat(lenRx := 255, chanCode := chanCodeDat, data := void(cmdDat));
 LD   uint 255
 WRX  Recv_From_Dat~lenRx
#debug_left uint Recv_From_Dat~lenRx
 LDX  chanCodeDat
#debug uint chanCodeDat
 WRX  Recv_From_Dat~chanCode
#debug_left uint Recv_From_Dat~chanCode
 LEAX cmdDat
 WRX  Recv_From_Dat~data
#debug_left pointer Recv_From_Dat.data
 LEAX Recv_From_Dat
 CAL  fbRecvFrom_L0
#srcline 347 ;  
#srcline 348 ;  lTrans := lTrans + UINT_TO_UDINT(Recv_From_Dat.lenData);
 LDX  lTrans
#debug udint lTrans
 LDX  Recv_From_Dat~lenData
#debug uint Recv_From_Dat.lenData
 ADD
 WRX  lTrans
#debug_left udint lTrans
#srcline 349 ;  WTFS(fileName := LocalName, srcVar := void(cmdDat), write := Recv_From_Dat.mesRec, close := NOT Recv_From_Dat.rq, size := UINT_TO_UDINT(Recv_From_Dat.lenData));
 LDX  LocalName
 WRX  WTFS~fileName
#debug_left pointer WTFS.fileName
 LEAX cmdDat
 WRX  WTFS~srcVar
#debug_left pointer WTFS.srcVar
 LDX  Recv_From_Dat~mesRec
#debug bool Recv_From_Dat.mesRec
 WRX  WTFS~write
#debug_left bool WTFS~write
 LDX  Recv_From_Dat~rq
#debug bool Recv_From_Dat.rq
 NEG
 WRX  WTFS~close
#debug_left bool WTFS~close
 LDX  Recv_From_Dat~lenData
#debug uint Recv_From_Dat.lenData
 WRX  WTFS~size
#debug_left udint WTFS~size
 LEAX WTFS
 CAL  WriteToFileSeq_L0
#srcline 350 ;  IF WTFS.err AND WTFS.write THEN
 LDX  WTFS~err
#debug bool WTFS.err
 LDX  WTFS~write
#debug bool WTFS.write
 AND
 JMC  fbRetriveFromFtp_L96
#srcline 351 ;    state  := fss_Error;
 LD   udint 22  ; TFtpStoreState#fss_Error
 WRX  state
#debug_left usint state
#srcline 352 ;    eErrId := 3; //chyba souboru
 LD   usint 3
 WRX  eErrId
#debug_left usint eErrId
#srcline 353 ;  END_IF;
fbRetriveFromFtp_L96:
#srcline 354 ;//  TRO_dat := Send_To_Dat.error = 5; //buffer is full wait
#srcline 355 ;  TRO_com := Send_To_Com.error = 5;
 LDX  Send_To_Com~error
#debug usint Send_To_Com.error
 LD   usint 5
 EQ
 WRX  TRO_com
#debug_left bool TRO_com
#srcline 356 ;  TRO := TRO_com OR TRO_dat;
 LDX  TRO_com
#debug bool TRO_com
 LDX  TRO_dat
#debug bool TRO_dat
 OR  
 WRX  TRO
#debug_left bool TRO
#srcline 358 ;  Send_To_Com.rq := Send_To_Com.rq AND TRO_com;
 LDX  Send_To_Com~rq
#debug bool Send_To_Com.rq
 LDX  TRO_com
#debug bool TRO_com
 AND
 WRX  Send_To_Com~rq
#debug_left bool Send_To_Com.rq
#srcline 359 ;//  Send_To_Dat.rq := Send_To_Dat.rq  AND TRO_dat;
#srcline 361 ;END_FUNCTION_BLOCK
fbRetriveFromFtp_RET:
 ULNK
RET
E     61

; Initialize - variables
P     61
fbRetriveFromFtp__InstanceInit__:
 LINK 0
 LD   uint 21
 WRX  port
 LEAX Send_To_Com
 CAL  fbSendTo__InstanceInit__
 LEAX Recv_From_Com
 CAL  fbRecvTxt__InstanceInit__
 LEAX Recv_From_Dat
 CAL  fbRecvFrom__InstanceInit__
 LD   0
 SRC  byte __Init___fbRetriveFromFtp_h
 LEAX byte h
 LD   4
 MOV  %X0
 ULNK
RET
E     61
; End initialize - variables
#endpou 



 

#srcfile ''
#srcfile 'C:\TECOLIBSRC\INTERNETLIB\INTERNETLIBVCONTROL\FBSENDPING.ST'
#pou fbPingIP
#srcline 14 ;FUNCTION_BLOCK fbPingIP

#struct fbPingIP__temp__
  dint tmp,
  dword[4] myEthAdr,  ; TLocalEthAdr ... myEthAdr[0] = myIP, myEthAdr[1] = myIM, myEthAdr[2] = myGW
  dword hisIP,
  string[82] PS0__st__
#data byte _str_fbPingIP_0 = 
  'C','a','n','n','o','t',' ','r','e','s','o','l','v','e',' ','h','o','s','t',$27,
  's',' ','h','a','r','d','w','a','r','e',' ','a','d','d','r','e','s','s','!',0
#data byte _str_fbPingIP_1 = 
  'I','P',' ','a','d','d','r','e','s','s',' ','o','f',' ','g','a','t','e','w','a',
  'y',' ','i','n',' ','P','L','C',' ','i','s',' ','w','r','o','n','g','!',0
#data byte _str_fbPingIP_2 = 
  'N','o',' ','a','n','s','w','e','r','!',0
#data byte _str_fbPingIP_3 = 
  'N','o',' ','a','n','s','w','e','r','!',0
P     61
fbPingIP_L0:
 LINK __SizeOf(fbPingIP__temp__)
; Initialize - dynamic variables
; End initialize - dynamic variables
; R_EDGE, F_EDGE 
 LDX  rqPing
 LETX __EDGE_R__rqPing
 WRX  rqPing
#srcline 44 ;  Done := 0;
 LD   bool 0       ; false
 WRX  Done
#debug_left bool Done
#srcline 45 ;  timeout( PT := MAX( timeLimit, T#1s));
 LDX  timeLimit
#debug time timeLimit
 LD   time 1000
 MAXS
 WRX  timeout~PT
#debug_left time timeout~PT
 LEAX timeout
 CAL  TON_L0
#srcline 47 ;  IF ( System_S.S42 <> 16#49 ) and ( System_S.S42 <> 16#4A ) THEN  // neni to CPU rady I nebo J => Foxtrot CP-1xxx nebo TC-700 ----
 LD   System_S~S42
#debug byte System_S.S42
 LD   byte $49
 EQ
 NEG
 LD   System_S~S42
#debug byte System_S.S42
 LD   byte $4A
 EQ
 NEG
 AND
 JMC  fbPingIP_L1
#srcline 48 ;    IF (rqPing AND NOT busy) OR waitArp THEN
 LDX  rqPing
#debug bool rqPing
 LDX  busy
#debug bool busy
 NEG
 AND
 LDX  waitArp
#debug bool waitArp
 OR  
 JMC  fbPingIP_L3
#srcline 49 ;      busy := 1; err := 0;
 LD   bool -1      ; true
 WRX  busy
#debug_left bool busy
 LD   bool 0       ; false
 WRX  err
#debug_left bool err
#srcline 50 ;      timeout.IN := 1;
 LD   bool -1      ; true
 WRX  timeout~IN
#debug_left bool timeout.IN
#srcline 51 ;      IF rqPing THEN
 LDX  rqPing
#debug bool rqPing
 JMC  fbPingIP_L5
#srcline 52 ;        waitArp := 0;
 LD   bool 0       ; false
 WRX  waitArp
#debug_left bool waitArp
#srcline 53 ;      END_IF;
fbPingIP_L5:
#srcline 54 ;      {asm}
#srcline 55
        LDX    long hostIP ; IP address of host
#srcline 56
        LDX    ttl         ; time to live
#srcline 57
        LDX    timeLimit   ; timeout
#srcline 58
        LDX    dataLen     ; length of data
#srcline 59
        LDX    pingInfo    ; struct for result
#srcline 60
        LD     1           ; subcode 1 ... send_ping
#srcline 61
        SYS    88          ; internet service
#srcline 62
        WRY    tmp
#srcline 63 ;      {end_asm}
#srcline 64 ;      IF tmp = -2 THEN      // nedopadla sluzba _arp_resolve
 LDY  tmp
#debug dint tmp
 LD   dint -2
 EQ
 JMC  fbPingIP_L7
#srcline 65 ;        IF timeout.Q  THEN
 LDX  timeout~Q
#debug bool timeout.Q
 JMC  fbPingIP_L9
#srcline 66 ;          waitArp := 0;
 LD   bool 0       ; false
 WRX  waitArp
#debug_left bool waitArp
#srcline 67 ;          pingInfo.result := -1;
 LD   dint -1
 LDX  pingInfo
 WRIL 
#debug_left dint pingInfo.result
#srcline 68 ;          pingInfo.hostIP := hostIP;
 LEAX hostIP
#debug pointer hostIP
 SRC  %IB0
 LDX  pingInfo
 ADD  4  ; + offset 
#debug_left pointer pingInfo.hostIP
 LD   4   ;SizeOf() 
 MOV  %IB0
#srcline 69 ;          // zkontrolovat, jestli je dobre nastavena brana site
#srcline 70 ;          IF CheckGatewayIP( ethChan := ETH1) THEN
 NXT
 LD   usint 225
 WR   __Instance__CheckGatewayIP~ethChan
#debug_left usint __Instance__CheckGatewayIP~ethChan
 PRV
 LEA  __Instance__CheckGatewayIP
 CAL  CheckGatewayIP_L0
 JMC  fbPingIP_L11
#srcline 71 ;            pingInfo.errMsg := 'Cannot resolve host$'s hardware address!';   // neni odezva na ARP dotaz
 LD   0   ; null string
 LDX  pingInfo
 ADD  21  ; + offset 
 WRI  
 LDX  pingInfo
 ADD  21  ; + offset 
 LD   80
 DST    ; Level 1
 LEA  _str_fbPingIP_0
 SCON 
#debug_left string pingInfo.errMsg
 PDST   ; Level 1
#srcline 72 ;          ELSE
 JMP  fbPingIP_L12
fbPingIP_L11:
#srcline 73 ;            pingInfo.errMsg := 'IP address of gateway in PLC is wrong!';     // chybne nastavena brana site
 LD   0   ; null string
 LDX  pingInfo
 ADD  21  ; + offset 
 WRI  
 LDX  pingInfo
 ADD  21  ; + offset 
 LD   80
 DST    ; Level 1
 LEA  _str_fbPingIP_1
 SCON 
#debug_left string pingInfo.errMsg
 PDST   ; Level 1
#srcline 74 ;          END_IF;
fbPingIP_L12:
#srcline 75 ;        ELSE
 JMP  fbPingIP_L10
fbPingIP_L9:
#srcline 76 ;          waitArp := 1;
 LD   bool -1      ; true
 WRX  waitArp
#debug_left bool waitArp
#srcline 77 ;          return;          // cekat na vyrizeni ARP dotazu
 JMP  fbPingIP_RET
#srcline 78 ;        END_IF;
fbPingIP_L10:
#srcline 79 ;      ELSE
 JMP  fbPingIP_L8
fbPingIP_L7:
#srcline 80 ;        waitArp := 0;
 LD   bool 0       ; false
 WRX  waitArp
#debug_left bool waitArp
#srcline 81 ;      END_IF;
fbPingIP_L8:
#srcline 82 ;    END_IF;
fbPingIP_L3:
#srcline 83 ;    IF busy THEN
 LDX  busy
#debug bool busy
 JMC  fbPingIP_L13
#srcline 84 ;      IF pingInfo.result = 1 THEN
 LDX  pingInfo
 LDIL 
#debug dint pingInfo.result
 LD   dint 1
 EQ
 JMC  fbPingIP_L15
#srcline 85 ;        done := 1; busy := 0; err := 0; timeout.IN := 0;
 LD   bool -1      ; true
 WRX  done
#debug_left bool done
 LD   bool 0       ; false
 WRX  busy
#debug_left bool busy
 LD   bool 0       ; false
 WRX  err
#debug_left bool err
 LD   bool 0       ; false
 WRX  timeout~IN
#debug_left bool timeout.IN
#srcline 86 ;      ELSIF pingInfo.result < 0 THEN
 JMP  fbPingIP_L16
fbPingIP_L15:
 LDX  pingInfo
 LDIL 
#debug dint pingInfo.result
 LD   dint 0
 LTS
 JMC  fbPingIP_L17
#srcline 87 ;        done := 0; busy := 0; err := 1; timeout.IN := 0;
 LD   bool 0       ; false
 WRX  done
#debug_left bool done
 LD   bool 0       ; false
 WRX  busy
#debug_left bool busy
 LD   bool -1      ; true
 WRX  err
#debug_left bool err
 LD   bool 0       ; false
 WRX  timeout~IN
#debug_left bool timeout.IN
#srcline 88 ;      ELSE
 JMP  fbPingIP_L16
fbPingIP_L17:
#srcline 89 ;        // kontrolni casovac
#srcline 90 ;        IF timeout.Q THEN
 LDX  timeout~Q
#debug bool timeout.Q
 JMC  fbPingIP_L18
#srcline 91 ;          busy := 0; err := 1; timeout.IN := 0;
 LD   bool 0       ; false
 WRX  busy
#debug_left bool busy
 LD   bool -1      ; true
 WRX  err
#debug_left bool err
 LD   bool 0       ; false
 WRX  timeout~IN
#debug_left bool timeout.IN
#srcline 92 ;          pingInfo.result := -1;
 LD   dint -1
 LDX  pingInfo
 WRIL 
#debug_left dint pingInfo.result
#srcline 93 ;          pingInfo.hostIP := hostIP;
 LEAX hostIP
#debug pointer hostIP
 SRC  %IB0
 LDX  pingInfo
 ADD  4  ; + offset 
#debug_left pointer pingInfo.hostIP
 LD   4   ;SizeOf() 
 MOV  %IB0
#srcline 94 ;          pingInfo.errMsg := 'No answer!';
 LD   0   ; null string
 LDX  pingInfo
 ADD  21  ; + offset 
 WRI  
 LDX  pingInfo
 ADD  21  ; + offset 
 LD   80
 DST    ; Level 1
 LEA  _str_fbPingIP_2
 SCON 
#debug_left string pingInfo.errMsg
 PDST   ; Level 1
#srcline 95 ;        END_IF;
fbPingIP_L18:
#srcline 96 ;      END_IF;
fbPingIP_L16:
#srcline 97 ;    END_IF;
fbPingIP_L13:
#srcline 99 ;  ELSE  // je to CPU rady I nebo J => Foxtrot CP-2xxx -----------------------------------------------------------------------------
 JMP  fbPingIP_L2
fbPingIP_L1:
#srcline 100 ;    IF (rqPing AND NOT busy) THEN
 LDX  rqPing
#debug bool rqPing
 LDX  busy
#debug bool busy
 NEG
 AND
 JMC  fbPingIP_L20
#srcline 101 ;      busy := 1; err := 0;
 LD   bool -1      ; true
 WRX  busy
#debug_left bool busy
 LD   bool 0       ; false
 WRX  err
#debug_left bool err
#srcline 102 ;      timeout.IN := 1;
 LD   bool -1      ; true
 WRX  timeout~IN
#debug_left bool timeout.IN
#srcline 103 ;      Memset(dest := void( pingInfo), val := 0, length := sizeof( pingInfo));  // nutne pro spusteni PING prikazu
 NXT
 LDX  pingInfo
 WR   __Instance__Memset~dest
#debug_left pointer __Instance__Memset.dest
 LD   udint 0
 WR   __Instance__Memset~val
#debug_left udint __Instance__Memset~val
 LD   102  ; SizeOf()
 WR   __Instance__Memset~length
#debug_left uint __Instance__Memset~length
 PRV
 LEA  __Instance__Memset
 CAL  Memset_L0
#srcline 104 ;      {asm}
#srcline 105
        LDX    long hostIP ; IP address of host
#srcline 106
        LDX    ttl         ; time to live
#srcline 107
        LDX    timeLimit   ; timeout
#srcline 108
        LDX    dataLen     ; length of data
#srcline 109
        LDX    pingInfo    ; struct for result
#srcline 110
        LD     31          ; subcode 31 ... send_ping
#srcline 111
        SYS    88          ; internet service
#srcline 112
        WRY    tmp
#srcline 113 ;      {end_asm}
#srcline 114 ;      RETURN;
 JMP  fbPingIP_RET
#srcline 115 ;    END_IF;
fbPingIP_L20:
#srcline 116 ;    IF busy THEN
 LDX  busy
#debug bool busy
 JMC  fbPingIP_L22
#srcline 117 ;      {asm}
#srcline 118
        LDX    pingInfo    ; struct for result
#srcline 119
        LD     32          ; subcode 32 ... test_ping
#srcline 120
        SYS    88          ; internet service
#srcline 121
        WRY    tmp
#srcline 122 ;      {end_asm}
#srcline 124 ;      IF pingInfo.result = 1 THEN
 LDX  pingInfo
 LDIL 
#debug dint pingInfo.result
 LD   dint 1
 EQ
 JMC  fbPingIP_L24
#srcline 125 ;        done := 1; busy := 0; err := 0; timeout.IN := 0;
 LD   bool -1      ; true
 WRX  done
#debug_left bool done
 LD   bool 0       ; false
 WRX  busy
#debug_left bool busy
 LD   bool 0       ; false
 WRX  err
#debug_left bool err
 LD   bool 0       ; false
 WRX  timeout~IN
#debug_left bool timeout.IN
#srcline 126 ;      ELSIF pingInfo.result < 0 THEN
 JMP  fbPingIP_L25
fbPingIP_L24:
 LDX  pingInfo
 LDIL 
#debug dint pingInfo.result
 LD   dint 0
 LTS
 JMC  fbPingIP_L26
#srcline 127 ;        done := 0; busy := 0; err := 1; timeout.IN := 0;
 LD   bool 0       ; false
 WRX  done
#debug_left bool done
 LD   bool 0       ; false
 WRX  busy
#debug_left bool busy
 LD   bool -1      ; true
 WRX  err
#debug_left bool err
 LD   bool 0       ; false
 WRX  timeout~IN
#debug_left bool timeout.IN
#srcline 128 ;      ELSE
 JMP  fbPingIP_L25
fbPingIP_L26:
#srcline 129 ;        // kontrolni casovac
#srcline 130 ;        IF timeout.Q THEN
 LDX  timeout~Q
#debug bool timeout.Q
 JMC  fbPingIP_L27
#srcline 131 ;          busy := 0; err := 1; timeout.IN := 0;
 LD   bool 0       ; false
 WRX  busy
#debug_left bool busy
 LD   bool -1      ; true
 WRX  err
#debug_left bool err
 LD   bool 0       ; false
 WRX  timeout~IN
#debug_left bool timeout.IN
#srcline 132 ;          pingInfo.result := -1;
 LD   dint -1
 LDX  pingInfo
 WRIL 
#debug_left dint pingInfo.result
#srcline 133 ;          pingInfo.errMsg := 'No answer!';
 LD   0   ; null string
 LDX  pingInfo
 ADD  21  ; + offset 
 WRI  
 LDX  pingInfo
 ADD  21  ; + offset 
 LD   80
 DST    ; Level 1
 LEA  _str_fbPingIP_3
 SCON 
#debug_left string pingInfo.errMsg
 PDST   ; Level 1
#srcline 134 ;        END_IF;
fbPingIP_L27:
#srcline 135 ;      END_IF;
fbPingIP_L25:
#srcline 136 ;    END_IF;
fbPingIP_L22:
#srcline 138 ;  END_IF;
fbPingIP_L2:
#srcline 139 ;END_FUNCTION_BLOCK
fbPingIP_RET:
 ULNK
RET
E     61
#endpou 

#pou fbPing
#srcline 142 ;FUNCTION_BLOCK fbPing

#struct fbPing__temp__
  udint P0__st__,
  udint P1__st__,
  string[82] PS0__st__,
  string[257] PSC__st__
#data byte _str_fbPing_0 = 
  'D','N','S',' ','s','e','r','v','e','r',' ','f','a','i','l','u','r','e','!',0
#data byte _str_fbPing_1 = 
  'H','o','s','t',' ','n','a','m','e',' ','f','a','i','l','e','d',' ','t','o',' ',
  'f','i','n','d','!',0
#data byte _str_fbPing_2 = 
  'H','o','s','t',' ','n','a','m','e',' ','i','s',' ','e','m','p','t','y',' ','o',
  'r',' ','i','n','v','a','l','i','d','!',0
#data byte _str_fbPing_3 = 
  'f','b','N','s','L','o','o','k','U','p','E','x',' ','e','r','r','o','r',':',' ',0
#data byte _str_fbPing_4 = 
  'I','P',' ','a','d','d','r','e','s','s',' ','o','f',' ','g','a','t','e','w','a',
  'y',' ','i','n',' ','P','L','C',' ','i','s',' ','w','r','o','n','g','!',0
#data byte _str_fbPing_5 = 
  'D','N','S',' ','s','e','r','v','e','r',' ','f','a','i','l','u','r','e','!',0
#data byte _str_fbPing_6 = 
  'H','o','s','t',' ','n','a','m','e',' ','f','a','i','l','e','d',' ','t','o',' ',
  'f','i','n','d','!',0
#data byte _str_fbPing_7 = 
  'H','o','s','t',' ','n','a','m','e',' ','i','s',' ','e','m','p','t','y',' ','o',
  'r',' ','i','n','v','a','l','i','d','!',0
#data byte _str_fbPing_8 = 
  'f','b','N','s','L','o','o','k','U','p','E','x',' ','e','r','r','o','r',':',' ',0
P     61
fbPing_L0:
 LINK __SizeOf(fbPing__temp__)
; Initialize - dynamic variables
; End initialize - dynamic variables
; R_EDGE, F_EDGE 
 LDX  rqPing
 LETX __EDGE_R__rqPing
 WRX  rqPing
#srcline 167 ;  done := 0;
 LD   bool 0       ; false
 WRX  done
#debug_left bool done
#srcline 168 ;  IF rqPing THEN
 LDX  rqPing
#debug bool rqPing
 JMC  fbPing_L1
#srcline 169 ;    busy := 1; err := 0; rqSplit := 1;
 LD   bool -1      ; true
 WRX  busy
#debug_left bool busy
 LD   bool 0       ; false
 WRX  err
#debug_left bool err
 LD   bool -1      ; true
 WRX  rqSplit
#debug_left bool rqSplit
#srcline 170 ;    Memset( val := 0, length := sizeof(T_PING_INFO), dest := void( pingInfo));
 NXT
 LD   udint 0
 WR   __Instance__Memset~val
#debug_left udint __Instance__Memset~val
 LD   102  ; SizeOf()
 WR   __Instance__Memset~length
#debug_left uint __Instance__Memset~length
 LEAX pingInfo
 WR   __Instance__Memset~dest
#debug_left pointer __Instance__Memset.dest
 PRV
 LEA  __Instance__Memset
 CAL  Memset_L0
#srcline 171 ;  END_IF;
fbPing_L1:
#srcline 173 ;  SplitUrlAdr( split := rqSplit, urlAddress := hostName, host := host, action := action, ipAdr := ipAdr, port := port);
 LDX  rqSplit
#debug bool rqSplit
 WRX  SplitUrlAdr~split
#debug_left bool SplitUrlAdr~split
 LEAX hostName
 WRX  SplitUrlAdr~urlAddress
#debug_left pointer SplitUrlAdr.urlAddress
 LEAX host
 WRX  SplitUrlAdr~host
#debug_left pointer SplitUrlAdr.host
 LEAX action
 WRX  SplitUrlAdr~action
#debug_left pointer SplitUrlAdr.action
 LEAX ipAdr
 WRX  SplitUrlAdr~ipAdr
#debug_left pointer SplitUrlAdr.ipAdr
 LEAX port
 WRX  SplitUrlAdr~port
#debug_left pointer SplitUrlAdr.port
 LEAX SplitUrlAdr
 CAL  fbSplitUrlAddress_L0
#srcline 174 ;  IF rqSplit AND SplitUrlAdr.err THEN
 LDX  rqSplit
#debug bool rqSplit
 LDX  SplitUrlAdr~err
#debug bool SplitUrlAdr.err
 AND
 JMC  fbPing_L3
#srcline 175 ;    err := 1; busy := 0; rqSplit := 0;
 LD   bool -1      ; true
 WRX  err
#debug_left bool err
 LD   bool 0       ; false
 WRX  busy
#debug_left bool busy
 LD   bool 0       ; false
 WRX  rqSplit
#debug_left bool rqSplit
#srcline 176 ;    pingInfo.result := -1;
 LD   dint -1
 WRX  pingInfo~result
#debug_left dint pingInfo.result
#srcline 178 ;    IF ( System_S.S42 <> 16#49 ) and ( System_S.S42 <> 16#4A ) THEN  // neni to CPU rady I nebo J => Foxtrot CP-1xxx nebo TC-700 ----
 LD   System_S~S42
#debug byte System_S.S42
 LD   byte $49
 EQ
 NEG
 LD   System_S~S42
#debug byte System_S.S42
 LD   byte $4A
 EQ
 NEG
 AND
 JMC  fbPing_L5
#srcline 179 ;      // zkontrolovat, jestli je dobre nastavena brana site
#srcline 180 ;      IF CheckGatewayIP(ethChan := ETH1) THEN
 NXT
 LD   usint 225
 WR   __Instance__CheckGatewayIP~ethChan
#debug_left usint __Instance__CheckGatewayIP~ethChan
 PRV
 LEA  __Instance__CheckGatewayIP
 CAL  CheckGatewayIP_L0
 JMC  fbPing_L7
#srcline 181 ;        CASE SplitUrlAdr.errId OF
 LDX  SplitUrlAdr~errId
#debug usint SplitUrlAdr.errId
 WRY  P0__st__
 LD   3
 LDY  P0__st__
 EQ  
 JMC  fbPing_L10
#srcline 182 ;          3  : pingInfo.errMsg := 'DNS server failure!';
 LD   0   ; null string
 LEAX pingInfo
 ADD  21  ; + offset 
 WRI  
 LEAX pingInfo
 ADD  21  ; + offset 
 LD   80
 DST    ; Level 1
 LEA  _str_fbPing_0
 SCON 
#debug_left string pingInfo.errMsg
 PDST   ; Level 1
 JMP  fbPing_L9
fbPing_L10:
 LD   4
 LDY  P0__st__
 EQ  
 JMC  fbPing_L11
#srcline 183 ;          4  : pingInfo.errMsg := 'Host name failed to find!';
 LD   0   ; null string
 LEAX pingInfo
 ADD  21  ; + offset 
 WRI  
 LEAX pingInfo
 ADD  21  ; + offset 
 LD   80
 DST    ; Level 1
 LEA  _str_fbPing_1
 SCON 
#debug_left string pingInfo.errMsg
 PDST   ; Level 1
 JMP  fbPing_L9
fbPing_L11:
 LD   17
 LDY  P0__st__
 EQ  
 JMC  fbPing_L12
#srcline 184 ;          17 : pingInfo.errMsg := 'Host name is empty or invalid!';
 LD   0   ; null string
 LEAX pingInfo
 ADD  21  ; + offset 
 WRI  
 LEAX pingInfo
 ADD  21  ; + offset 
 LD   80
 DST    ; Level 1
 LEA  _str_fbPing_2
 SCON 
#debug_left string pingInfo.errMsg
 PDST   ; Level 1
 JMP  fbPing_L9
fbPing_L12:
#srcline 185 ;        ELSE
#srcline 186 ;          pingInfo.errMsg := 'fbNsLookUpEx error: ' + USINT_TO_STRING( SplitUrlAdr.errId);  // chyba v NsLookUpEx
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   80
 DST    ; Level 1
 LEA  _str_fbPing_3
 SCON 
 LD   0   ; null string
 WRY  PSC__st__[0]
 LEAY PSC__st__[0]
 LD   80
 DST    ; Level 2
 LDX  SplitUrlAdr~errId
#debug usint SplitUrlAdr.errId
 SCNV $0830;  IEC_USINT _TO_ IEC_STRING
 PDST   ; Level 2
 LEAY PSC__st__[0]

 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX pingInfo
 ADD  21  ; + offset 
 WRI  
 LEAX pingInfo
 ADD  21  ; + offset 
 LD   80
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string pingInfo.errMsg
 PDST   ; Level 1
#srcline 187 ;        END_CASE;
fbPing_L9:
#srcline 188 ;      ELSE
 JMP  fbPing_L8
fbPing_L7:
#srcline 189 ;        pingInfo.errMsg := 'IP address of gateway in PLC is wrong!'; // chybne nastavena brana site
 LD   0   ; null string
 LEAX pingInfo
 ADD  21  ; + offset 
 WRI  
 LEAX pingInfo
 ADD  21  ; + offset 
 LD   80
 DST    ; Level 1
 LEA  _str_fbPing_4
 SCON 
#debug_left string pingInfo.errMsg
 PDST   ; Level 1
#srcline 190 ;      END_IF;
fbPing_L8:
#srcline 191 ;    ELSE                                                             // je to CPU rady I nebo J => Foxtrot CP-2xxx ------------------
 JMP  fbPing_L6
fbPing_L5:
#srcline 192 ;      CASE SplitUrlAdr.errId OF
 LDX  SplitUrlAdr~errId
#debug usint SplitUrlAdr.errId
 WRY  P1__st__
 LD   3
 LDY  P1__st__
 EQ  
 JMC  fbPing_L14
#srcline 193 ;        3  : pingInfo.errMsg := 'DNS server failure!';
 LD   0   ; null string
 LEAX pingInfo
 ADD  21  ; + offset 
 WRI  
 LEAX pingInfo
 ADD  21  ; + offset 
 LD   80
 DST    ; Level 1
 LEA  _str_fbPing_5
 SCON 
#debug_left string pingInfo.errMsg
 PDST   ; Level 1
 JMP  fbPing_L13
fbPing_L14:
 LD   4
 LDY  P1__st__
 EQ  
 JMC  fbPing_L15
#srcline 194 ;        4  : pingInfo.errMsg := 'Host name failed to find!';
 LD   0   ; null string
 LEAX pingInfo
 ADD  21  ; + offset 
 WRI  
 LEAX pingInfo
 ADD  21  ; + offset 
 LD   80
 DST    ; Level 1
 LEA  _str_fbPing_6
 SCON 
#debug_left string pingInfo.errMsg
 PDST   ; Level 1
 JMP  fbPing_L13
fbPing_L15:
 LD   17
 LDY  P1__st__
 EQ  
 JMC  fbPing_L16
#srcline 195 ;        17 : pingInfo.errMsg := 'Host name is empty or invalid!';
 LD   0   ; null string
 LEAX pingInfo
 ADD  21  ; + offset 
 WRI  
 LEAX pingInfo
 ADD  21  ; + offset 
 LD   80
 DST    ; Level 1
 LEA  _str_fbPing_7
 SCON 
#debug_left string pingInfo.errMsg
 PDST   ; Level 1
 JMP  fbPing_L13
fbPing_L16:
#srcline 196 ;      ELSE
#srcline 197 ;        pingInfo.errMsg := 'fbNsLookUpEx error: ' + USINT_TO_STRING( SplitUrlAdr.errId);  // chyba v NsLookUpEx
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   80
 DST    ; Level 1
 LEA  _str_fbPing_8
 SCON 
 LD   0   ; null string
 WRY  PSC__st__[0]
 LEAY PSC__st__[0]
 LD   80
 DST    ; Level 2
 LDX  SplitUrlAdr~errId
#debug usint SplitUrlAdr.errId
 SCNV $0830;  IEC_USINT _TO_ IEC_STRING
 PDST   ; Level 2
 LEAY PSC__st__[0]

 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX pingInfo
 ADD  21  ; + offset 
 WRI  
 LEAX pingInfo
 ADD  21  ; + offset 
 LD   80
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string pingInfo.errMsg
 PDST   ; Level 1
#srcline 198 ;      END_CASE;
fbPing_L13:
#srcline 199 ;    END_IF;
fbPing_L6:
#srcline 201 ;  ELSIF SplitUrlAdr.done THEN
 JMP  fbPing_L4
fbPing_L3:
 LDX  SplitUrlAdr~done
#debug bool SplitUrlAdr.done
 JMC  fbPing_L17
#srcline 202 ;    rqSplit := 0;
 LD   bool 0       ; false
 WRX  rqSplit
#debug_left bool rqSplit
#srcline 203 ;  END_IF;
 JMP  fbPing_L4
fbPing_L17:
fbPing_L4:
#srcline 205 ;  PingIP( rqPing := SplitUrlAdr.Done, hostIP := ipAdr, ttl := 60, timeLimit := T#3s, dataLen := 32, pingInfo := pingInfo);
 LDX  SplitUrlAdr~Done
#debug bool SplitUrlAdr.Done
 WRX  PingIP~rqPing
#debug_left bool PingIP~rqPing
 LEAX ipAdr
#debug pointer ipAdr
 SRC  %IB0
 LEAX PingIP~hostIP
 LD   4   ;SizeOf() 
 MOV  %IB0
 LD   usint 60
 WRX  PingIP~ttl
#debug_left usint PingIP~ttl
 LD   time 3000
 WRX  PingIP~timeLimit
#debug_left time PingIP~timeLimit
 LD   uint 32
 WRX  PingIP~dataLen
#debug_left uint PingIP~dataLen
 LEAX pingInfo
 WRX  PingIP~pingInfo
#debug_left pointer PingIP.pingInfo
 LEAX PingIP
 CAL  fbPingIP_L0
#srcline 206 ;  IF PingIP.done THEN
 LDX  PingIP~done
#debug bool PingIP.done
 JMC  fbPing_L18
#srcline 207 ;    busy := 0; done := 1; err := 0;
 LD   bool 0       ; false
 WRX  busy
#debug_left bool busy
 LD   bool -1      ; true
 WRX  done
#debug_left bool done
 LD   bool 0       ; false
 WRX  err
#debug_left bool err
#srcline 208 ;  ELSIF busy AND PingIP.err THEN
 JMP  fbPing_L19
fbPing_L18:
 LDX  busy
#debug bool busy
 LDX  PingIP~err
#debug bool PingIP.err
 AND
 JMC  fbPing_L20
#srcline 209 ;    busy := 0; err := 1;
 LD   bool 0       ; false
 WRX  busy
#debug_left bool busy
 LD   bool -1      ; true
 WRX  err
#debug_left bool err
#srcline 210 ;  END_IF;
 JMP  fbPing_L19
fbPing_L20:
fbPing_L19:
#srcline 211 ;END_FUNCTION_BLOCK
 ULNK
RET
E     61

; Initialize - variables
P     61
fbPing__InstanceInit__:
 LINK 0
 LEAX SplitUrlAdr
 CAL  fbSplitUrlAddress__InstanceInit__
 ULNK
RET
E     61
; End initialize - variables
#endpou 



 

#srcfile ''
#srcfile 'C:\TECOLIBSRC\INTERNETLIB\INTERNETLIBVCONTROL\FBSMTPDBX.ST'
#pou fbSmtpDbx
#srcline 1 ;FUNCTION_BLOCK fbSmtpDbx

#struct fbSmtpDbx__temp__
  pointer ptrUsint,
  TMacAdr mac,  ;MAC adresa
  udint tmpud,
  int pos,
  TRemoteEthAdr rea,
  uint tmpReplyCode,
  TUniDesc UniDesc,
  bool timeout_elapsed,  ; true pokud nastal timeout
  usint P0__st__,
  string[257] PS0__st__,
  string[82] PS1__st__
#data byte _str_fbSmtpDbx_0 = 
  '-',0
#data byte _str_fbSmtpDbx_1 = 
  ' ',$0D,$0A,0
#data byte _str_fbSmtpDbx_2 = 
  'E','H','L','O',' ','t','e','c','o','m','a','t','.','P','L','C',$0D,$0A,0
#data byte _str_fbSmtpDbx_3 = 
  'H','E','L','O',' ','t','e','c','o','m','a','t','.','P','L','C',$0D,$0A,0
#data byte _str_fbSmtpDbx_4 = 
  'A','U','T','H',' ','L','O','G','I','N',$0D,$0A,0
#data byte _str_fbSmtpDbx_5 = 
  'M','A','I','L',' ','F','R','O','M',':',' ','<',0
#data byte _str_fbSmtpDbx_6 = 
  ';',0
#data byte _str_fbSmtpDbx_7 = 
  '<',0
#data byte _str_fbSmtpDbx_8 = 
  '>',0
#data byte _str_fbSmtpDbx_9 = 
  ',','<',0
#data byte _str_fbSmtpDbx_10 = 
  '>',0
#data byte _str_fbSmtpDbx_11 = 
  'R','C','P','T',' ','T','O',':','<',0
#data byte _str_fbSmtpDbx_12 = 
  'D','A','T','A',$0D,$0A,0
#data byte _str_fbSmtpDbx_13 = 
  'D','A','T','E',':',' ',0
#data byte _str_fbSmtpDbx_14 = 
  'F','R','O','M',':',' ','"',0
#data byte _str_fbSmtpDbx_15 = 
  '"',' ','<',0
#data byte _str_fbSmtpDbx_16 = 
  'T','O',':',' ',0
#data byte _str_fbSmtpDbx_17 = 
  '@',0
#data byte _str_fbSmtpDbx_18 = 
  'M','e','s','s','a','g','e','-','I','D',':',' ','<',0
#data byte _str_fbSmtpDbx_19 = 
  '%','T','Y','Y','M','M','D','D','h','h','m','m','s','s','z','z','z',0
#data byte _str_fbSmtpDbx_20 = 
  'S','U','B','J','E','C','T',':',' ','=','?',0
#data byte _str_fbSmtpDbx_21 = 
  '?','B','?',0
#data byte _str_fbSmtpDbx_22 = 
  '?','=',$0D,$0A,0
#data byte _str_fbSmtpDbx_23 = 
  'S','U','B','J','E','C','T',':',' ',0
#data byte _str_fbSmtpDbx_24 = 
  'M','I','M','E','-','V','e','r','s','i','o','n',':',' ','1','.','0',$0D,$0A,'C',
  'o','n','t','e','n','t','-','T','y','p','e',':',' ','m','u','l','t','i','p','a',
  'r','t','/','m','i','x','e','d',';',$0D,$0A,' ','b','o','u','n','d','a','r','y',
  '=','"','-','-','-','-','=','_','N','e','x','t','P','a','r','t','_','0','0','0',
  '_','0','0','0','D','_','6','6','6','F','7','8','7','4','.','7','4','6','5','6',
  '3','6','F','"',$0D,$0A,$0D,$0A,'T','h','i','s',' ','i','s',' ','a',' ','m','e',
  's','s','a','g','e',' ','w','i','t','h',' ','m','u','l','t','i','p','l','e',' ',
  'p','a','r','t','s',' ','i','n',' ','M','I','M','E',' ','f','o','r','m','a','t',
  '.',$0D,$0A,$0D,$0A,'-','-','-','-','-','-','=','_','N','e','x','t','P','a','r',
  't','_','0','0','0','_','0','0','0','D','_','6','6','6','F','7','8','7','4','.',
  '7','4','6','5','6','3','6','F',$0D,$0A,0
#data byte _str_fbSmtpDbx_25 = 
  'C','o','n','t','e','n','t','-','T','y','p','e',':',' ','t','e','x','t','/','p',
  'l','a','i','n',';',' ','c','h','a','r','s','e','t','=',0
#data byte _str_fbSmtpDbx_26 = 
  $0D,$0A,$0D,$0A,0
#data byte _str_fbSmtpDbx_27 = 
  'C','o','n','t','e','n','t','-','T','y','p','e',':',' ','t','e','x','t','/','p',
  'l','a','i','n',';',$0D,$0A,$0D,$0A,0
#data byte _str_fbSmtpDbx_28 = 
  '',0
#data byte _str_fbSmtpDbx_29 = 
  'a','p','p','l','i','c','a','t','i','o','n','/','o','c','t','e','t','-','s','t',
  'r','e','a','m',0
#data byte _str_fbSmtpDbx_30 = 
  '-','-','-','-','-','-','=','_','N','e','x','t','P','a','r','t','_','0','0','0',
  '_','0','0','0','D','_','6','6','6','F','7','8','7','4','.','7','4','6','5','6',
  '3','6','F',$0D,$0A,'C','o','n','t','e','n','t','-','T','y','p','e',':',' ',0
#data byte _str_fbSmtpDbx_31 = 
  ';',' ','n','a','m','e','=','"',0
#data byte _str_fbSmtpDbx_32 = 
  '"',$0D,$0A,0
#data byte _str_fbSmtpDbx_33 = 
  'C','o','n','t','e','n','t','-','T','r','a','n','s','f','e','r','-','E','n','c',
  'o','d','i','n','g',':',' ','b','a','s','e','6','4',$0D,$0A,'C','o','n','t','e',
  'n','t','-','D','i','s','p','o','s','i','t','i','o','n',':',' ','a','t','t','a',
  'c','h','m','e','n','t',';',' ','f','i','l','e','n','a','m','e','=','"',0
#data byte _str_fbSmtpDbx_34 = 
  '"',$0D,$0A,$0D,$0A,0
#data byte _str_fbSmtpDbx_35 = 
  $0D,$0A,0
#data byte _str_fbSmtpDbx_36 = 
  $0D,$0A,0
#data byte _str_fbSmtpDbx_37 = 
  $0D,$0A,0
#data byte _str_fbSmtpDbx_38 = 
  '-','-','-','-','-','-','=','_','N','e','x','t','P','a','r','t','_','0','0','0',
  '_','0','0','0','D','_','6','6','6','F','7','8','7','4','.','7','4','6','5','6',
  '3','6','F','-','-',$0D,$0A,'.',$0D,$0A,0
#data byte _str_fbSmtpDbx_39 = 
  'Q','U','I','T',$0D,$0A,0
P     61
fbSmtpDbx_L0:
 LINK __SizeOf(fbSmtpDbx__temp__)
; Initialize - dynamic variables
 LD   udint $FFFFFFFF    ; nil
 WRY  ptrUsint
; End initialize - dynamic variables
; R_EDGE, F_EDGE 
 LDX  Send
 LETX __EDGE_R__Send
 WRX  Send
 LDX  Cancel
 LETX __EDGE_R__Cancel
 WRX  Cancel
#srcline 83 ;  mesRec := Recv_from.lenMes > 0;
 LDX  Recv_from~lenMes
#debug uint Recv_from.lenMes
 LD   uint 0
 GT
 WRX  mesRec
#debug_left bool mesRec
#srcline 85 ;  IF GetChanIndex( chanCode) <> -1 THEN
 NXT
 LDX  chanCode
#debug uint chanCode
 WR   __Instance__GetChanIndex~chanCode
#debug_left uint __Instance__GetChanIndex~chanCode
 PRV
 LEA  __Instance__GetChanIndex
 CAL  GetChanIndex_L0
 LD   int -1
 EQ
 NEG
 JMC  fbSmtpDbx_L1
#srcline 86 ;    // kanal zalozen pomoci #module => kontrola nutna
#srcline 87 ;    UniDesc := GetChanDesc(chanCode := chanCode);
 NXT
 LDX  chanCode
#debug uint chanCode
 WR   __Instance__GetChanDesc~chanCode
#debug_left uint __Instance__GetChanDesc~chanCode
 PRV
 LEA  __Instance__GetChanDesc
 CAL  GetChanDesc_L0
 LEAY UniDesc
#debug_left pointer UniDesc
 LD   26   ;SizeOf() 
 MOV  %IB0
#srcline 88 ;    IF (UniDesc.modeChan <> 5) OR (UniDesc.lenUniIn <> 259) OR (UniDesc.lenUniOut < 259) THEN
 LDY  UniDesc~modeChan
#debug byte UniDesc.modeChan
 LD   byte 5
 EQ
 NEG
 LDY  UniDesc~lenUniIn
#debug uint UniDesc.lenUniIn
 LD   uint 259
 EQ
 NEG
 OR  
 LDY  UniDesc~lenUniOut
#debug uint UniDesc.lenUniOut
 LD   uint 259
 LT
 OR  
 JMC  fbSmtpDbx_L3
#srcline 89 ;      Err   := true;
 LD   bool -1       ; true
 WRX  Err
#debug_left bool Err
#srcline 90 ;      ErrId := 255;
 LD   usint 255
 WRX  ErrId
#debug_left usint ErrId
#srcline 91 ;      RETURN;
 JMP  fbSmtpDbx_RET
#srcline 92 ;    END_IF;
fbSmtpDbx_L3:
#srcline 93 ;  END_IF;
fbSmtpDbx_L1:
#srcline 95 ;  IF Cancel THEN
 LDX  Cancel
#debug bool Cancel
 JMC  fbSmtpDbx_L5
#srcline 96 ;    state := ss_SmtpInit;
 LD   udint 0  ; TSmtpState#ss_SmtpInit
 WRX  state
#debug_left usint state
#srcline 97 ;  END_IF;
fbSmtpDbx_L5:
#srcline 98 ;  (*
#srcline 99 ;  IF state <> ss_Smtptxattachementbody & state <> ss_Smtptxattachement THEN
#srcline 100 ;    IF h <> INVALID_HANDLE_VALUE THEN
#srcline 101 ;      FileClose(h);
#srcline 102 ;      h := INVALID_HANDLE_VALUE;
#srcline 103 ;    END_IF;
#srcline 104 ;  END_IF;
#srcline 105 ;  *)
#srcline 106 ;  timeout_cntr( IN := Recv_from.getMes & NOT Send_to.rq, PT := T#1m50s, Q => timeout_elapsed); // timeout
 LDX  Recv_from~getMes
#debug bool Recv_from.getMes
 LDX  Send_to~rq
#debug bool Send_to.rq
 NEG
 AND
 WRX  timeout_cntr~IN
#debug_left bool timeout_cntr~IN
 LD   time 110000
 WRX  timeout_cntr~PT
#debug_left time timeout_cntr~PT
 LEAX timeout_cntr
 CAL  TON_L0
; output assigment 
 LDX  timeout_cntr~Q
#debug bool timeout_cntr~Q
 WRY  timeout_elapsed
#debug_left bool timeout_elapsed
#srcline 108 ;  IF NOT TRO THEN
 LDX  TRO
#debug bool TRO
 NEG
 JMC  fbSmtpDbx_L7
#srcline 109 ;    if mesRec then
 LDX  mesRec
#debug bool mesRec
 JMC  fbSmtpDbx_L9
#srcline 110 ;      tmpReplyCode := STRING_TO_UINT(cmd);
 LEAX cmd
#debug string cmd
 SCNV $300A;  IEC_STRING _TO_ IEC_UINT
 WRY  tmpReplyCode
#debug_left uint tmpReplyCode
#srcline 111 ;      IF Busy AND NOT Err THEN
 LDX  Busy
#debug bool Busy
 LDX  Err
#debug bool Err
 NEG
 AND
 JMC  fbSmtpDbx_L11
#srcline 112 ;        ReplyCode := tmpReplyCode;
 LDY  tmpReplyCode
#debug uint tmpReplyCode
 WRX  ReplyCode
#debug_left uint ReplyCode
#srcline 113 ;      END_IF;
fbSmtpDbx_L11:
#srcline 114 ;      IF FIND(IN1 := cmd, IN2 := '-') = 4 THEN //pokracuje na dalsim radku
 LEAX cmd
#debug string cmd
 LEA  _str_fbSmtpDbx_0
 SFND 
 LD   int 4
 EQ
 JMC  fbSmtpDbx_L13
#srcline 115 ;        mesRec := 0;
 LD   bool 0       ; false
 WRX  mesRec
#debug_left bool mesRec
#srcline 116 ;      END_IF;
fbSmtpDbx_L13:
#srcline 117 ;    end_if;
fbSmtpDbx_L9:
#srcline 119 ;    CASE state OF
 LDX  state
#debug usint state
 WRY  P0__st__
 LD   0
 LDY  P0__st__
 EQ  
 JMC  fbSmtpDbx_L16
#srcline 120 ;      // inicializace ------------------------------------------------------------
#srcline 121 ;      ss_Smtpinit :
#srcline 122 ;        busy        := false;
 LD   bool 0       ; false
 WRX  busy
#debug_left bool busy
#srcline 123 ;        Done        := false;
 LD   bool 0       ; false
 WRX  Done
#debug_left bool Done
#srcline 124 ;        lSend       := Send;
 LDX  Send
#debug bool Send
 WRX  lSend
#debug_left bool lSend
#srcline 125 ;        state       := ss_Smtpidle;
 LD   udint 1  ; TSmtpState#ss_SmtpIdle
 WRX  state
#debug_left usint state
#srcline 126 ;        // nenavazovat spojeni : r0_p0_Control_ETH1_UNI0.CONTROL.0 := 1;
#srcline 127 ;        CloseTCPconnection( chanCode);
 NXT
 LDX  chanCode
#debug uint chanCode
 WR   __Instance__CloseTCPconnection~chanCode
#debug_left uint __Instance__CloseTCPconnection~chanCode
 PRV
 LEA  __Instance__CloseTCPconnection
 CAL  CloseTCPconnection_L0
 JMP  fbSmtpDbx_L15
fbSmtpDbx_L16:
 LD   1
 LDY  P0__st__
 EQ  
 JMC  fbSmtpDbx_L17
#srcline 129 ;      // cekani na start ---------------------------------------------------------
#srcline 130 ;      ss_Smtpidle :
#srcline 131 ;        if Send OR lSend then
 LDX  Send
#debug bool Send
 LDX  lSend
#debug bool lSend
 OR  
 JMC  fbSmtpDbx_L18
#srcline 132 ;          lSend := false;
 LD   bool 0       ; false
 WRX  lSend
#debug_left bool lSend
#srcline 133 ;          lAuth := Auth;
 LDX  Auth
#debug bool Auth
 WRX  lAuth
#debug_left bool lAuth
#srcline 134 ;          // vycistime prijimaci a vysilaci buffer
#srcline 135 ;          Recv_from.getMes := FALSE;
 LD   bool 0       ; false
 WRX  Recv_from~getMes
#debug_left bool Recv_from.getMes
#srcline 136 ;          Send_to.rq   := FALSE;   Send_to.lenTx := 1;
 LD   bool 0       ; false
 WRX  Send_to~rq
#debug_left bool Send_to.rq
 LD   uint 1
 WRX  Send_to~lenTx
#debug_left uint Send_to.lenTx
#srcline 137 ;          state := ss_SmtpSetIp;
 LD   udint 2  ; TSmtpState#ss_SmtpSetIP
 WRX  state
#debug_left usint state
#srcline 138 ;          busy  := true; body_lines := USINT_TO_SINT(lines);
 LD   bool -1       ; true
 WRX  busy
#debug_left bool busy
 LDX  lines
#debug usint lines
 EXTB
 WRX  body_lines
#debug_left sint body_lines
#srcline 139 ;          Err   := false;
 LD   bool 0       ; false
 WRX  Err
#debug_left bool Err
#srcline 140 ;          ErrId := 0;
 LD   usint 0
 WRX  ErrId
#debug_left usint ErrId
#srcline 141 ;          ReplyCode := 0;
 LD   uint 0
 WRX  ReplyCode
#debug_left uint ReplyCode
#srcline 142 ;        end_if;
fbSmtpDbx_L18:
 JMP  fbSmtpDbx_L15
fbSmtpDbx_L17:
 LD   2
 LDY  P0__st__
 EQ  
 JMC  fbSmtpDbx_L20
#srcline 143 ;      // nastaveni IP adresy
#srcline 144 ;      ss_SmtpSetIp:
#srcline 145 ;        IF IPadr = Any_IP THEN
 LEAX IPadr
 LEA  Any_IP
 LD   4   ; SizeOf()
 BCMP 
 EQ   0
 JMC  fbSmtpDbx_L21
#srcline 146 ;          Err    := 1;
 LD   bool -1      ; true
 WRX  Err
#debug_left bool Err
#srcline 147 ;          ErrId  := 254;
 LD   usint 254
 WRX  ErrId
#debug_left usint ErrId
#srcline 148 ;          state  := ss_Smtpidle;
 LD   udint 1  ; TSmtpState#ss_SmtpIdle
 WRX  state
#debug_left usint state
#srcline 149 ;        ELSE
 JMP  fbSmtpDbx_L22
fbSmtpDbx_L21:
#srcline 150 ;          rea.remoteIP   := IPadr;
 LEAX IPadr
#debug pointer IPadr
 SRC  %IB0
 LEAY rea~remoteIP
#debug_left pointer rea.remoteIP
 LD   4   ;SizeOf() 
 MOV  %IB0
#srcline 151 ;          rea.remotePort := port;
 LDX  port
#debug uint port
 WRY  rea~remotePort
#debug_left uint rea.remotePort
#srcline 152 ;          IF SetRemoteIPaddress(rq := 1, chanCode := chanCode, ethAdr := rea) THEN
 NXT
 LD   1
 WR   __Instance__SetRemoteIPaddress~rq
#debug_left bool __Instance__SetRemoteIPaddress~rq
 LDX  chanCode
#debug uint chanCode
 WR   __Instance__SetRemoteIPaddress~chanCode
#debug_left uint __Instance__SetRemoteIPaddress~chanCode
 LEAY rea
 WR   __Instance__SetRemoteIPaddress~ethAdr
#debug_left pointer __Instance__SetRemoteIPaddress.ethAdr
 PRV
 LEA  __Instance__SetRemoteIPaddress
 CAL  SetRemoteIPaddress_L0
 JMC  fbSmtpDbx_L23
#srcline 153 ;            //EstabTCPconnection( chanCode);
#srcline 154 ;            state := ss_Smtprxconnect; //ss_Smtptxconnect;
 LD   udint 4  ; TSmtpState#ss_SmtpRxConnect
 WRX  state
#debug_left usint state
#srcline 155 ;          END_IF;
fbSmtpDbx_L23:
#srcline 156 ;        END_IF;
fbSmtpDbx_L22:
 JMP  fbSmtpDbx_L15
fbSmtpDbx_L20:
 LD   3
 LDY  P0__st__
 EQ  
 JMC  fbSmtpDbx_L25
#srcline 157 ;      // kontaktujeme server -----------------------------------------------------
#srcline 158 ;      ss_Smtptxconnect :
#srcline 159 ;        // navazat spojeni se serverem : r0_p0_Control_ETH1_UNI0.CONTROL.0 := 0;
#srcline 160 ;        cmd := ' $r$l';
 LD   0   ; null string
 LEAX cmd
 WRI  
 LEAX cmd
 LD   255
 DST    ; Level 1
 LEA  _str_fbSmtpDbx_1
 SCON 
#debug_left string cmd
 PDST   ; Level 1
#srcline 161 ;        Send_to.rq := TRUE;
 LD   bool -1       ; true
 WRX  Send_to~rq
#debug_left bool Send_to.rq
#srcline 162 ;        state := ss_Smtprxconnect;
 LD   udint 4  ; TSmtpState#ss_SmtpRxConnect
 WRX  state
#debug_left usint state
 JMP  fbSmtpDbx_L15
fbSmtpDbx_L25:
 LD   4
 LDY  P0__st__
 EQ  
 JMC  fbSmtpDbx_L26
#srcline 163 ;      // cekani na odezvu --------------------------------------------------------
#srcline 164 ;      ss_Smtprxconnect :
#srcline 165 ;        EstabTCPconnection( chanCode);
 NXT
 LDX  chanCode
#debug uint chanCode
 WR   __Instance__EstabTCPconnection~chanCode
#debug_left uint __Instance__EstabTCPconnection~chanCode
 PRV
 LEA  __Instance__EstabTCPconnection
 CAL  EstabTCPconnection_L0
#srcline 166 ;        Send_to.rq   := FALSE;
 LD   bool 0       ; false
 WRX  Send_to~rq
#debug_left bool Send_to.rq
#srcline 167 ;        Recv_from.getMes := TRUE;
 LD   bool -1       ; true
 WRX  Recv_from~getMes
#debug_left bool Recv_from.getMes
#srcline 168 ;        if mesRec then
 LDX  mesRec
#debug bool mesRec
 JMC  fbSmtpDbx_L27
#srcline 169 ;          {$IFDEF _DEBUG} dbg1 := cmd; {$END_IF}
#srcline 170 ;          if tmpReplyCode = 220 then //je to odezva typu '220 proxy.tecomat.cz ESMTP ready'?
 LDY  tmpReplyCode
#debug uint tmpReplyCode
 LD   uint 220
 EQ
 JMC  fbSmtpDbx_L29
#srcline 171 ;            state := ss_Smtptxhelo;
 LD   udint 5  ; TSmtpState#ss_SmtpTxHelo
 WRX  state
#debug_left usint state
#srcline 172 ;          else
 JMP  fbSmtpDbx_L30
fbSmtpDbx_L29:
#srcline 173 ;            state := ss_Smtprxerror;        //chybna odezva
 LD   udint 31  ; TSmtpState#ss_SmtpRxError
 WRX  state
#debug_left usint state
#srcline 174 ;          end_if;
fbSmtpDbx_L30:
#srcline 175 ;        else
 JMP  fbSmtpDbx_L28
fbSmtpDbx_L27:
#srcline 176 ;          if timeout_elapsed then    //server neodpovida
 LDY  timeout_elapsed
#debug bool timeout_elapsed
 JMC  fbSmtpDbx_L31
#srcline 177 ;            state := ss_Smtprxtimeout;
 LD   udint 30  ; TSmtpState#ss_SmtpRxTimeout
 WRX  state
#debug_left usint state
#srcline 178 ;          end_if;
fbSmtpDbx_L31:
#srcline 179 ;        end_if;
fbSmtpDbx_L28:
 JMP  fbSmtpDbx_L15
fbSmtpDbx_L26:
 LD   5
 LDY  P0__st__
 EQ  
 JMC  fbSmtpDbx_L33
#srcline 182 ;      // posleme prikaz helo -----------------------------------------------------
#srcline 183 ;      ss_Smtptxhelo :
#srcline 184 ;        IF lAuth THEN
 LDX  lAuth
#debug bool lAuth
 JMC  fbSmtpDbx_L34
#srcline 185 ;          cmd := 'EHLO tecomat.PLC$r$l'; //ESMTP
 LD   0   ; null string
 LEAX cmd
 WRI  
 LEAX cmd
 LD   255
 DST    ; Level 1
 LEA  _str_fbSmtpDbx_2
 SCON 
#debug_left string cmd
 PDST   ; Level 1
#srcline 186 ;        ELSE
 JMP  fbSmtpDbx_L35
fbSmtpDbx_L34:
#srcline 187 ;          cmd := 'HELO tecomat.PLC$r$l';
 LD   0   ; null string
 LEAX cmd
 WRI  
 LEAX cmd
 LD   255
 DST    ; Level 1
 LEA  _str_fbSmtpDbx_3
 SCON 
#debug_left string cmd
 PDST   ; Level 1
#srcline 188 ;        END_IF;
fbSmtpDbx_L35:
#srcline 189 ;        Send_to.rq  := TRUE;
 LD   bool -1       ; true
 WRX  Send_to~rq
#debug_left bool Send_to.rq
#srcline 190 ;        state := ss_Smtprxhelo;
 LD   udint 6  ; TSmtpState#ss_SmtpRxHelo
 WRX  state
#debug_left usint state
 JMP  fbSmtpDbx_L15
fbSmtpDbx_L33:
 LD   6
 LDY  P0__st__
 EQ  
 JMC  fbSmtpDbx_L36
#srcline 192 ;      // cekani na odezvu --------------------------------------------------------
#srcline 193 ;      ss_Smtprxhelo :
#srcline 194 ;        Send_to.rq   := FALSE;
 LD   bool 0       ; false
 WRX  Send_to~rq
#debug_left bool Send_to.rq
#srcline 195 ;        if mesRec then
 LDX  mesRec
#debug bool mesRec
 JMC  fbSmtpDbx_L37
#srcline 196 ;          {$IFDEF _DEBUG} dbg2 := cmd; {$END_IF}
#srcline 197 ;          if tmpReplyCode = 250 then //je to odezva typu '250'?
 LDY  tmpReplyCode
#debug uint tmpReplyCode
 LD   uint 250
 EQ
 JMC  fbSmtpDbx_L39
#srcline 198 ;            if lAuth then
 LDX  lAuth
#debug bool lAuth
 JMC  fbSmtpDbx_L41
#srcline 199 ;              state := ss_Smtptxauthlogin;
 LD   udint 7  ; TSmtpState#ss_SmtpTxAuthlogin
 WRX  state
#debug_left usint state
#srcline 200 ;            else
 JMP  fbSmtpDbx_L42
fbSmtpDbx_L41:
#srcline 201 ;              state := ss_Smtptxmailfrom;
 LD   udint 13  ; TSmtpState#ss_SmtpTxMailFrom
 WRX  state
#debug_left usint state
#srcline 202 ;            end_if;
fbSmtpDbx_L42:
#srcline 203 ;          else
 JMP  fbSmtpDbx_L40
fbSmtpDbx_L39:
#srcline 204 ;            state := ss_Smtprxerror;        //chybna odezva
 LD   udint 31  ; TSmtpState#ss_SmtpRxError
 WRX  state
#debug_left usint state
#srcline 205 ;          end_if;
fbSmtpDbx_L40:
#srcline 206 ;        elsif timeout_elapsed then   //server neodpovida
 JMP  fbSmtpDbx_L38
fbSmtpDbx_L37:
 LDY  timeout_elapsed
#debug bool timeout_elapsed
 JMC  fbSmtpDbx_L43
#srcline 207 ;          state := ss_Smtprxtimeout;
 LD   udint 30  ; TSmtpState#ss_SmtpRxTimeout
 WRX  state
#debug_left usint state
#srcline 208 ;        end_if;
 JMP  fbSmtpDbx_L38
fbSmtpDbx_L43:
fbSmtpDbx_L38:
 JMP  fbSmtpDbx_L15
fbSmtpDbx_L36:
 LD   7
 LDY  P0__st__
 EQ  
 JMC  fbSmtpDbx_L44
#srcline 210 ;      // AUTH LOGIN
#srcline 211 ;      ss_Smtptxauthlogin:
#srcline 212 ;        cmd := 'AUTH LOGIN$r$l';
 LD   0   ; null string
 LEAX cmd
 WRI  
 LEAX cmd
 LD   255
 DST    ; Level 1
 LEA  _str_fbSmtpDbx_4
 SCON 
#debug_left string cmd
 PDST   ; Level 1
#srcline 213 ;        Send_to.rq   := TRUE;
 LD   bool -1       ; true
 WRX  Send_to~rq
#debug_left bool Send_to.rq
#srcline 214 ;        state := ss_Smtprxauthlogin;
 LD   udint 8  ; TSmtpState#ss_SmtpRxAuthlogin
 WRX  state
#debug_left usint state
 JMP  fbSmtpDbx_L15
fbSmtpDbx_L44:
 LD   8
 LDY  P0__st__
 EQ  
 JMC  fbSmtpDbx_L45
#srcline 216 ;      // 334
#srcline 217 ;      ss_Smtprxauthlogin:
#srcline 218 ;        Send_to.rq  := FALSE;
 LD   bool 0       ; false
 WRX  Send_to~rq
#debug_left bool Send_to.rq
#srcline 219 ;        if mesRec then
 LDX  mesRec
#debug bool mesRec
 JMC  fbSmtpDbx_L46
#srcline 220 ;          {$IFDEF _DEBUG} dbg2 := cmd; {$END_IF}
#srcline 221 ;          if tmpReplyCode = 334 then //je to odezva typu '334'?
 LDY  tmpReplyCode
#debug uint tmpReplyCode
 LD   uint 334
 EQ
 JMC  fbSmtpDbx_L48
#srcline 222 ;            state := ss_Smtptxusername;
 LD   udint 9  ; TSmtpState#ss_SmtpTxUserName
 WRX  state
#debug_left usint state
#srcline 223 ;          else
 JMP  fbSmtpDbx_L49
fbSmtpDbx_L48:
#srcline 224 ;            state := ss_Smtprxerror;        //chybna odezva
 LD   udint 31  ; TSmtpState#ss_SmtpRxError
 WRX  state
#debug_left usint state
#srcline 225 ;          end_if;
fbSmtpDbx_L49:
#srcline 226 ;        elsif timeout_elapsed then   // server neodpovida
 JMP  fbSmtpDbx_L47
fbSmtpDbx_L46:
 LDY  timeout_elapsed
#debug bool timeout_elapsed
 JMC  fbSmtpDbx_L50
#srcline 227 ;          state := ss_Smtptxusername;
 LD   udint 9  ; TSmtpState#ss_SmtpTxUserName
 WRX  state
#debug_left usint state
#srcline 228 ;        end_if;
 JMP  fbSmtpDbx_L47
fbSmtpDbx_L50:
fbSmtpDbx_L47:
 JMP  fbSmtpDbx_L15
fbSmtpDbx_L45:
 LD   9
 LDY  P0__st__
 EQ  
 JMC  fbSmtpDbx_L51
#srcline 230 ;      // Username:
#srcline 231 ;      ss_Smtptxusername:
#srcline 232 ;        cmd := Base64_encode_string(username) + INTERNETLIB_END_OF_LINE_;
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 NXT
 LD   0   ; null string
 LEA  __Instance__Base64_encode_string~data
 WRI 
 LEA  __Instance__Base64_encode_string~data
 LD   60
 DST    ; Level 2
 LDX  username
#debug string username
 SCON 
#debug_left string __Instance__Base64_encode_string~data
 PDST   ; Level 2
 PRV
 LEA  __Instance__Base64_encode_string
 CAL  Base64_encode_string_L0

 SCON 
 LEA  INTERNETLIB_END_OF_LINE_
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX cmd
 WRI  
 LEAX cmd
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string cmd
 PDST   ; Level 1
#srcline 233 ;        Send_to.rq  := TRUE;
 LD   bool -1       ; true
 WRX  Send_to~rq
#debug_left bool Send_to.rq
#srcline 234 ;        state := ss_Smtprxusername;
 LD   udint 10  ; TSmtpState#ss_SmtpRxUserName
 WRX  state
#debug_left usint state
 JMP  fbSmtpDbx_L15
fbSmtpDbx_L51:
 LD   10
 LDY  P0__st__
 EQ  
 JMC  fbSmtpDbx_L52
#srcline 236 ;      // 334
#srcline 237 ;      ss_Smtprxusername:
#srcline 238 ;        Send_to.rq   := FALSE;
 LD   bool 0       ; false
 WRX  Send_to~rq
#debug_left bool Send_to.rq
#srcline 239 ;        if mesRec then
 LDX  mesRec
#debug bool mesRec
 JMC  fbSmtpDbx_L53
#srcline 240 ;          {$IFDEF _DEBUG} dbg2 := cmd; {$END_IF}
#srcline 241 ;          if tmpReplyCode = 334 then //je to odezva typu '334'?
 LDY  tmpReplyCode
#debug uint tmpReplyCode
 LD   uint 334
 EQ
 JMC  fbSmtpDbx_L55
#srcline 242 ;            state := ss_Smtptxpassword;
 LD   udint 11  ; TSmtpState#ss_SmtpTxPassword
 WRX  state
#debug_left usint state
#srcline 243 ;          else
 JMP  fbSmtpDbx_L56
fbSmtpDbx_L55:
#srcline 244 ;            state := ss_Smtprxerror;          //chybna odezva
 LD   udint 31  ; TSmtpState#ss_SmtpRxError
 WRX  state
#debug_left usint state
#srcline 245 ;          end_if;
fbSmtpDbx_L56:
#srcline 246 ;        elsif timeout_elapsed then     //server neodpovida
 JMP  fbSmtpDbx_L54
fbSmtpDbx_L53:
 LDY  timeout_elapsed
#debug bool timeout_elapsed
 JMC  fbSmtpDbx_L57
#srcline 247 ;          state := ss_Smtprxtimeout;
 LD   udint 30  ; TSmtpState#ss_SmtpRxTimeout
 WRX  state
#debug_left usint state
#srcline 248 ;        end_if;
 JMP  fbSmtpDbx_L54
fbSmtpDbx_L57:
fbSmtpDbx_L54:
 JMP  fbSmtpDbx_L15
fbSmtpDbx_L52:
 LD   11
 LDY  P0__st__
 EQ  
 JMC  fbSmtpDbx_L58
#srcline 250 ;      // Password:
#srcline 251 ;      ss_Smtptxpassword:
#srcline 252 ;        cmd := Base64_encode_string(password) + INTERNETLIB_END_OF_LINE_;
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 NXT
 LD   0   ; null string
 LEA  __Instance__Base64_encode_string~data
 WRI 
 LEA  __Instance__Base64_encode_string~data
 LD   60
 DST    ; Level 2
 LDX  password
#debug string password
 SCON 
#debug_left string __Instance__Base64_encode_string~data
 PDST   ; Level 2
 PRV
 LEA  __Instance__Base64_encode_string
 CAL  Base64_encode_string_L0

 SCON 
 LEA  INTERNETLIB_END_OF_LINE_
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX cmd
 WRI  
 LEAX cmd
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string cmd
 PDST   ; Level 1
#srcline 253 ;        Send_to.rq  := TRUE;
 LD   bool -1       ; true
 WRX  Send_to~rq
#debug_left bool Send_to.rq
#srcline 254 ;        state := ss_Smtprxpassword;
 LD   udint 12  ; TSmtpState#ss_SmtpRxPassword
 WRX  state
#debug_left usint state
 JMP  fbSmtpDbx_L15
fbSmtpDbx_L58:
 LD   12
 LDY  P0__st__
 EQ  
 JMC  fbSmtpDbx_L59
#srcline 256 ;      // 235
#srcline 257 ;      ss_Smtprxpassword:
#srcline 258 ;        Send_to.rq  := FALSE;
 LD   bool 0       ; false
 WRX  Send_to~rq
#debug_left bool Send_to.rq
#srcline 259 ;        if mesRec then
 LDX  mesRec
#debug bool mesRec
 JMC  fbSmtpDbx_L60
#srcline 260 ;          {$IFDEF _DEBUG} dbg2 := cmd; {$END_IF}
#srcline 261 ;          if tmpReplyCode = 235 then   //je to odezva typu '235'?
 LDY  tmpReplyCode
#debug uint tmpReplyCode
 LD   uint 235
 EQ
 JMC  fbSmtpDbx_L62
#srcline 262 ;            state := ss_Smtptxmailfrom;
 LD   udint 13  ; TSmtpState#ss_SmtpTxMailFrom
 WRX  state
#debug_left usint state
#srcline 263 ;          else
 JMP  fbSmtpDbx_L63
fbSmtpDbx_L62:
#srcline 264 ;            state := ss_Smtprxerror;          //chybna odezva
 LD   udint 31  ; TSmtpState#ss_SmtpRxError
 WRX  state
#debug_left usint state
#srcline 265 ;          end_if;
fbSmtpDbx_L63:
#srcline 266 ;        elsif timeout_elapsed then     //server neodpovida
 JMP  fbSmtpDbx_L61
fbSmtpDbx_L60:
 LDY  timeout_elapsed
#debug bool timeout_elapsed
 JMC  fbSmtpDbx_L64
#srcline 267 ;          state := ss_Smtprxtimeout;
 LD   udint 30  ; TSmtpState#ss_SmtpRxTimeout
 WRX  state
#debug_left usint state
#srcline 268 ;        end_if;
 JMP  fbSmtpDbx_L61
fbSmtpDbx_L64:
fbSmtpDbx_L61:
 JMP  fbSmtpDbx_L15
fbSmtpDbx_L59:
 LD   13
 LDY  P0__st__
 EQ  
 JMC  fbSmtpDbx_L65
#srcline 271 ;      // posleme adresu odesilatele ----------------------------------------------
#srcline 272 ;      ss_Smtptxmailfrom :
#srcline 273 ;        cmd := 'MAIL FROM: <'+sender+SMTP_END_OF_LINE_2_;
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LEA  _str_fbSmtpDbx_5
 SCON 
 LDX  sender
#debug string sender
 SCON 
 LEA  SMTP_END_OF_LINE_2_
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX cmd
 WRI  
 LEAX cmd
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string cmd
 PDST   ; Level 1
#srcline 274 ;        Send_to.rq  := TRUE;
 LD   bool -1       ; true
 WRX  Send_to~rq
#debug_left bool Send_to.rq
#srcline 275 ;        state := ss_Smtprxmailfrom;
 LD   udint 14  ; TSmtpState#ss_SmtpRxMailFrom
 WRX  state
#debug_left usint state
 JMP  fbSmtpDbx_L15
fbSmtpDbx_L65:
 LD   14
 LDY  P0__st__
 EQ  
 JMC  fbSmtpDbx_L66
#srcline 277 ;      // cekani na odezvu --------------------------------------------------------
#srcline 278 ;      ss_Smtprxmailfrom :
#srcline 279 ;        Send_to.rq  := FALSE;
 LD   bool 0       ; false
 WRX  Send_to~rq
#debug_left bool Send_to.rq
#srcline 280 ;        if mesRec then
 LDX  mesRec
#debug bool mesRec
 JMC  fbSmtpDbx_L67
#srcline 281 ;          {$IFDEF _DEBUG} dbg3 := cmd; {$END_IF}
#srcline 282 ;          if tmpReplyCode = 250 then //je to odezva typu '250'?
 LDY  tmpReplyCode
#debug uint tmpReplyCode
 LD   uint 250
 EQ
 JMC  fbSmtpDbx_L69
#srcline 283 ;            state := ss_Smtptxrcptto;
 LD   udint 15  ; TSmtpState#ss_SmtpTxRcptTo
 WRX  state
#debug_left usint state
#srcline 284 ;            copy_rcpt := rcpt;
 LD   0   ; null string
 LEAX copy_rcpt
 WRI  
 LEAX copy_rcpt
 LD   255
 DST    ; Level 1
 LDX  rcpt
#debug string rcpt
 SCON 
#debug_left string copy_rcpt
 PDST   ; Level 1
#srcline 285 ;            body_rcpt := INTERNETLIB_EMPTY_STRING_;
 LD   0   ; null string
 LEAX body_rcpt
 WRI  
 LEAX body_rcpt
 LD   80
 DST    ; Level 1
 LEA  INTERNETLIB_EMPTY_STRING_
 SCON 
#debug_left string body_rcpt
 PDST   ; Level 1
#srcline 286 ;          else
 JMP  fbSmtpDbx_L70
fbSmtpDbx_L69:
#srcline 287 ;            state := ss_Smtprxerror;        //chybna odezva
 LD   udint 31  ; TSmtpState#ss_SmtpRxError
 WRX  state
#debug_left usint state
#srcline 288 ;          end_if;
fbSmtpDbx_L70:
#srcline 289 ;        elsif timeout_elapsed then   //server neodpovida
 JMP  fbSmtpDbx_L68
fbSmtpDbx_L67:
 LDY  timeout_elapsed
#debug bool timeout_elapsed
 JMC  fbSmtpDbx_L71
#srcline 290 ;          state := ss_Smtprxtimeout;
 LD   udint 30  ; TSmtpState#ss_SmtpRxTimeout
 WRX  state
#debug_left usint state
#srcline 291 ;        end_if;
 JMP  fbSmtpDbx_L68
fbSmtpDbx_L71:
fbSmtpDbx_L68:
 JMP  fbSmtpDbx_L15
fbSmtpDbx_L66:
 LD   15
 LDY  P0__st__
 EQ  
 JMC  fbSmtpDbx_L72
#srcline 293 ;      // posleme adresu prijemce -------------------------------------------------
#srcline 294 ;      ss_Smtptxrcptto :
#srcline 295 ;        Send_to.rq  := TRUE;
 LD   bool -1       ; true
 WRX  Send_to~rq
#debug_left bool Send_to.rq
#srcline 296 ;        pos := find( copy_rcpt, ';');
 LEAX copy_rcpt
#debug string copy_rcpt
 LEA  _str_fbSmtpDbx_6
 SFND 
 WRY  pos
#debug_left int pos
#srcline 297 ;        ptrUsint := ADR(temp_rcpt);
 LEAX temp_rcpt
#debug pointer temp_rcpt
 LEAY ptrUsint
 WRIL 
#debug_left pointer ptrUsint
#srcline 298 ;        if pos <> 0 then
 LDY  pos
#debug int pos
 EXTW 
 LD   int 0
 EQ
 NEG
 JMC  fbSmtpDbx_L73
#srcline 299 ;          temp_rcpt := left( copy_rcpt, pos-1);
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   180
 DST    ; Level 1
 LEAX copy_rcpt
#debug string copy_rcpt
 LDY  pos
#debug int pos
 EXTW 
 LD   int 1
 SUB
 EXTW
 SLFT 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX temp_rcpt
 WRI  
 LEAX temp_rcpt
 LD   180
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string temp_rcpt
 PDST   ; Level 1
#srcline 300 ;          copy_rcpt := delete(IN := copy_rcpt, L := pos, P := 1);
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LEAX copy_rcpt
#debug string copy_rcpt
 LDY  pos
#debug int pos
 EXTW 
 LD   1
 SUB  1
 SDEL 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX copy_rcpt
 WRI  
 LEAX copy_rcpt
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string copy_rcpt
 PDST   ; Level 1
#srcline 301 ;        else
 JMP  fbSmtpDbx_L74
fbSmtpDbx_L73:
#srcline 302 ;          temp_rcpt := copy_rcpt;
 LD   0   ; null string
 LEAX temp_rcpt
 WRI  
 LEAX temp_rcpt
 LD   180
 DST    ; Level 1
 LEAX copy_rcpt
#debug string copy_rcpt
 SCON 
#debug_left string temp_rcpt
 PDST   ; Level 1
#srcline 303 ;          copy_rcpt := INTERNETLIB_EMPTY_STRING_;
 LD   0   ; null string
 LEAX copy_rcpt
 WRI  
 LEAX copy_rcpt
 LD   255
 DST    ; Level 1
 LEA  INTERNETLIB_EMPTY_STRING_
 SCON 
#debug_left string copy_rcpt
 PDST   ; Level 1
#srcline 304 ;        end_if;
fbSmtpDbx_L74:
#srcline 305 ;        if ptrUsint^ = 46 then
 LEAY ptrUsint
 LDIL    ; dereference 
 LDI  
#debug usint ptrUsint^
 LD   usint 46
 EQ
 JMC  fbSmtpDbx_L75
#srcline 306 ;           temp_rcpt := delete(IN := temp_rcpt, L := 1, P := 1); //vymazat prvni znak ktery urcil ze je to hidden
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   180
 DST    ; Level 1
 LEAX temp_rcpt
#debug string temp_rcpt
 LD   1
 LD   1
 SUB  1
 SDEL 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX temp_rcpt
 WRI  
 LEAX temp_rcpt
 LD   180
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string temp_rcpt
 PDST   ; Level 1
#srcline 307 ;        else
 JMP  fbSmtpDbx_L76
fbSmtpDbx_L75:
#srcline 308 ;          ptrUsint := ADR(body_rcpt);
 LEAX body_rcpt
#debug pointer body_rcpt
 LEAY ptrUsint
 WRIL 
#debug_left pointer ptrUsint
#srcline 309 ;          if ptrUsint^ = 0 then
 LEAY ptrUsint
 LDIL    ; dereference 
 LDI  
#debug usint ptrUsint^
 LD   usint 0
 EQ
 JMC  fbSmtpDbx_L77
#srcline 310 ;            body_rcpt := '<'+temp_rcpt+'>';    //priprava pro telo zpravy
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   80
 DST    ; Level 1
 LEA  _str_fbSmtpDbx_7
 SCON 
 LEAX temp_rcpt
#debug string temp_rcpt
 SCON 
 LEA  _str_fbSmtpDbx_8
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX body_rcpt
 WRI  
 LEAX body_rcpt
 LD   80
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string body_rcpt
 PDST   ; Level 1
#srcline 311 ;          else
 JMP  fbSmtpDbx_L78
fbSmtpDbx_L77:
#srcline 312 ;            body_rcpt := body_rcpt+',<'+temp_rcpt+'>';    //priprava pro telo zpravy
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   80
 DST    ; Level 1
 LEAX body_rcpt
#debug string body_rcpt
 SCON 
 LEA  _str_fbSmtpDbx_9
 SCON 
 LEAX temp_rcpt
#debug string temp_rcpt
 SCON 
 LEA  _str_fbSmtpDbx_10
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX body_rcpt
 WRI  
 LEAX body_rcpt
 LD   80
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string body_rcpt
 PDST   ; Level 1
#srcline 313 ;          end_if;
fbSmtpDbx_L78:
#srcline 314 ;        end_if;
fbSmtpDbx_L76:
#srcline 315 ;//        body_rcpt := body_rcpt+'<'+temp_rcpt+'>';    //priprava pro telo zpravy
#srcline 316 ;        cmd := 'RCPT TO:<'+temp_rcpt+SMTP_END_OF_LINE_2_;
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LEA  _str_fbSmtpDbx_11
 SCON 
 LEAX temp_rcpt
#debug string temp_rcpt
 SCON 
 LEA  SMTP_END_OF_LINE_2_
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX cmd
 WRI  
 LEAX cmd
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string cmd
 PDST   ; Level 1
#srcline 317 ;        state := ss_Smtprxrcptto;
 LD   udint 16  ; TSmtpState#ss_SmtpRxRcptTo
 WRX  state
#debug_left usint state
 JMP  fbSmtpDbx_L15
fbSmtpDbx_L72:
 LD   16
 LDY  P0__st__
 EQ  
 JMC  fbSmtpDbx_L79
#srcline 319 ;      // cekani na odezvu --------------------------------------------------------
#srcline 320 ;      ss_Smtprxrcptto :
#srcline 321 ;        Send_to.rq  := FALSE;
 LD   bool 0       ; false
 WRX  Send_to~rq
#debug_left bool Send_to.rq
#srcline 322 ;        if mesRec then
 LDX  mesRec
#debug bool mesRec
 JMC  fbSmtpDbx_L80
#srcline 323 ;          {$IFDEF _DEBUG} dbg4 := cmd; {$END_IF}
#srcline 324 ;          if tmpReplyCode = 250 or tmpReplyCode = 251 then //je to odezva typu '250' nebo '251'?
 LDY  tmpReplyCode
#debug uint tmpReplyCode
 LD   uint 250
 EQ
 LDY  tmpReplyCode
#debug uint tmpReplyCode
 LD   uint 251
 EQ
 OR  
 JMC  fbSmtpDbx_L82
#srcline 325 ;            if len(copy_rcpt) = 0 then
 LEAX copy_rcpt
#debug string copy_rcpt
 SLEN 
 LD   int 0
 EQ
 JMC  fbSmtpDbx_L84
#srcline 326 ;              state := ss_Smtptxdata;         //telo zpravy
 LD   udint 17  ; TSmtpState#ss_SmtpTxData
 WRX  state
#debug_left usint state
#srcline 327 ;            else
 JMP  fbSmtpDbx_L85
fbSmtpDbx_L84:
#srcline 328 ;              state := ss_Smtptxrcptto;       //dalsi prijemce
 LD   udint 15  ; TSmtpState#ss_SmtpTxRcptTo
 WRX  state
#debug_left usint state
#srcline 329 ;//              body_rcpt := body_rcpt+',';
#srcline 330 ;            end_if;
fbSmtpDbx_L85:
#srcline 331 ;          else
 JMP  fbSmtpDbx_L83
fbSmtpDbx_L82:
#srcline 332 ;            state := ss_Smtprxerror;          //chybna odezva
 LD   udint 31  ; TSmtpState#ss_SmtpRxError
 WRX  state
#debug_left usint state
#srcline 333 ;          end_if;
fbSmtpDbx_L83:
#srcline 334 ;        elsif timeout_elapsed then   //server neodpovida
 JMP  fbSmtpDbx_L81
fbSmtpDbx_L80:
 LDY  timeout_elapsed
#debug bool timeout_elapsed
 JMC  fbSmtpDbx_L86
#srcline 335 ;          state := ss_Smtprxtimeout;
 LD   udint 30  ; TSmtpState#ss_SmtpRxTimeout
 WRX  state
#debug_left usint state
#srcline 336 ;        end_if;
 JMP  fbSmtpDbx_L81
fbSmtpDbx_L86:
fbSmtpDbx_L81:
 JMP  fbSmtpDbx_L15
fbSmtpDbx_L79:
 LD   17
 LDY  P0__st__
 EQ  
 JMC  fbSmtpDbx_L87
#srcline 337 ;      // posleme telo zpravy -----------------------------------------------------
#srcline 338 ;      ss_Smtptxdata :
#srcline 339 ;        cmd := 'DATA$r$l';
 LD   0   ; null string
 LEAX cmd
 WRI  
 LEAX cmd
 LD   255
 DST    ; Level 1
 LEA  _str_fbSmtpDbx_12
 SCON 
#debug_left string cmd
 PDST   ; Level 1
#srcline 340 ;        Send_to.rq  := TRUE;
 LD   bool -1       ; true
 WRX  Send_to~rq
#debug_left bool Send_to.rq
#srcline 341 ;        state := ss_Smtprxdata;
 LD   udint 18  ; TSmtpState#ss_SmtpRxData
 WRX  state
#debug_left usint state
 JMP  fbSmtpDbx_L15
fbSmtpDbx_L87:
 LD   18
 LDY  P0__st__
 EQ  
 JMC  fbSmtpDbx_L88
#srcline 343 ;      // cekani na odezvu --------------------------------------------------------
#srcline 344 ;      ss_Smtprxdata :
#srcline 345 ;        Send_to.rq  := FALSE;
 LD   bool 0       ; false
 WRX  Send_to~rq
#debug_left bool Send_to.rq
#srcline 346 ;        if mesRec then
 LDX  mesRec
#debug bool mesRec
 JMC  fbSmtpDbx_L89
#srcline 347 ;          {$IFDEF _DEBUG} dbg5 := cmd; {$END_IF}
#srcline 348 ;          if tmpReplyCode = 354 then //je to odezva typu '354'?
 LDY  tmpReplyCode
#debug uint tmpReplyCode
 LD   uint 354
 EQ
 JMC  fbSmtpDbx_L91
#srcline 349 ;            state := ss_Smtptxdate;
 LD   udint 32  ; TSmtpState#ss_SmtpTxDate
 WRX  state
#debug_left usint state
#srcline 350 ;          else
 JMP  fbSmtpDbx_L92
fbSmtpDbx_L91:
#srcline 351 ;            state := ss_Smtprxerror;        //chybna odezva
 LD   udint 31  ; TSmtpState#ss_SmtpRxError
 WRX  state
#debug_left usint state
#srcline 352 ;          end_if;
fbSmtpDbx_L92:
#srcline 353 ;        elsif timeout_elapsed then   //server neodpovida
 JMP  fbSmtpDbx_L90
fbSmtpDbx_L89:
 LDY  timeout_elapsed
#debug bool timeout_elapsed
 JMC  fbSmtpDbx_L93
#srcline 354 ;          state := ss_Smtprxtimeout;
 LD   udint 30  ; TSmtpState#ss_SmtpRxTimeout
 WRX  state
#debug_left usint state
#srcline 355 ;        end_if;
 JMP  fbSmtpDbx_L90
fbSmtpDbx_L93:
fbSmtpDbx_L90:
 JMP  fbSmtpDbx_L15
fbSmtpDbx_L88:
 LD   32
 LDY  P0__st__
 EQ  
 JMC  fbSmtpDbx_L94
#srcline 357 ;      // posleme datum kdy jsme zpravu poslali -----------------------------------
#srcline 358 ;      ss_Smtptxdate :
#srcline 359 ;        cmd := 'DATE: ' + GetDateAndTime_RFC2822(UtcOff := UtcOff)+INTERNETLIB_END_OF_LINE_;
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LEA  _str_fbSmtpDbx_13
 SCON 
 NXT
 LDX  UtcOff
#debug int UtcOff
 EXTW 
 WR   __Instance__GetDateAndTime_RFC2822~UtcOff
#debug_left int __Instance__GetDateAndTime_RFC2822~UtcOff
 PRV
 LEA  __Instance__GetDateAndTime_RFC2822
 CAL  GetDateAndTime_RFC2822_L0

 SCON 
 LEA  INTERNETLIB_END_OF_LINE_
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX cmd
 WRI  
 LEAX cmd
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string cmd
 PDST   ; Level 1
#srcline 360 ;        Send_to.rq  := TRUE;
 LD   bool -1       ; true
 WRX  Send_to~rq
#debug_left bool Send_to.rq
#srcline 361 ;        state := ss_Smtptxdatafrom;
 LD   udint 19  ; TSmtpState#ss_SmtpTxDataFrom
 WRX  state
#debug_left usint state
 JMP  fbSmtpDbx_L15
fbSmtpDbx_L94:
 LD   19
 LDY  P0__st__
 EQ  
 JMC  fbSmtpDbx_L95
#srcline 363 ;      // posleme telo zpravy - odesilatel ----------------------------------------
#srcline 364 ;      ss_Smtptxdatafrom :
#srcline 365 ;        cmd := 'FROM: "'+SendName+'" <'+sender+SMTP_END_OF_LINE_2_;
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LEA  _str_fbSmtpDbx_14
 SCON 
 LDX  SendName
#debug string SendName
 SCON 
 LEA  _str_fbSmtpDbx_15
 SCON 
 LDX  sender
#debug string sender
 SCON 
 LEA  SMTP_END_OF_LINE_2_
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX cmd
 WRI  
 LEAX cmd
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string cmd
 PDST   ; Level 1
#srcline 366 ;        Send_to.rq  := TRUE;
 LD   bool -1       ; true
 WRX  Send_to~rq
#debug_left bool Send_to.rq
#srcline 367 ;        state := ss_Smtptxdatato;
 LD   udint 20  ; TSmtpState#ss_SmtpTxDataTo
 WRX  state
#debug_left usint state
 JMP  fbSmtpDbx_L15
fbSmtpDbx_L95:
 LD   20
 LDY  P0__st__
 EQ  
 JMC  fbSmtpDbx_L96
#srcline 369 ;      // posleme telo zpravy - prijemce ------------------------------------------
#srcline 370 ;      ss_Smtptxdatato :
#srcline 371 ;        cmd := 'TO: '+body_rcpt+INTERNETLIB_END_OF_LINE_;
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LEA  _str_fbSmtpDbx_16
 SCON 
 LEAX body_rcpt
#debug string body_rcpt
 SCON 
 LEA  INTERNETLIB_END_OF_LINE_
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX cmd
 WRI  
 LEAX cmd
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string cmd
 PDST   ; Level 1
#srcline 372 ;        IF genMessageID THEN
 LDX  genMessageID
#debug bool genMessageID
 JMC  fbSmtpDbx_L97
#srcline 373 ;          state := ss_SmtpTxMessageId;
 LD   udint 34  ; TSmtpState#ss_SmtpTxMessageId
 WRX  state
#debug_left usint state
#srcline 374 ;        ELSE
 JMP  fbSmtpDbx_L98
fbSmtpDbx_L97:
#srcline 375 ;          state := ss_Smtptxdatasubject;
 LD   udint 21  ; TSmtpState#ss_SmtpTxDataSubject
 WRX  state
#debug_left usint state
#srcline 376 ;        END_IF;
fbSmtpDbx_L98:
 JMP  fbSmtpDbx_L15
fbSmtpDbx_L96:
 LD   34
 LDY  P0__st__
 EQ  
 JMC  fbSmtpDbx_L99
#srcline 378 ;      //pokus o vygenerovani Message-ID
#srcline 379 ;      ss_SmtpTxMessageId:
#srcline 380 ;        pos := FIND(Sender, '@');
 LDX  Sender
#debug string Sender
 LEA  _str_fbSmtpDbx_17
 SFND 
 WRY  pos
#debug_left int pos
#srcline 381 ;        ptrText := ADR(Sender) + INT_TO_UDINT(pos) - 1;
 LDX  Sender
#debug pointer Sender
 LDY  pos
#debug int pos
 EXTW 
 ADD
 LD   udint 1
 SUB
 LEAX ptrText
 WRIL 
#debug_left pointer ptrText
#srcline 382 ;        IF pos > 0 THEN
 LDY  pos
#debug int pos
 EXTW 
 LD   int 0
 GTS
 JMC  fbSmtpDbx_L100
#srcline 383 ;          GetMACaddress(ethChan := ETH1, MacAdr := mac);
 NXT
 LD   usint 225
 WR   __Instance__GetMACaddress~ethChan
#debug_left usint __Instance__GetMACaddress~ethChan
 LEAY mac
 WR   __Instance__GetMACaddress~MacAdr
#debug_left pointer __Instance__GetMACaddress.MacAdr
 PRV
 LEA  __Instance__GetMACaddress
 CAL  GetMACaddress_L0
#srcline 384 ;          {ASM}
#srcline 385
             LDY word mac[0]
#srcline 386
             BAS
#srcline 387
             WRX dword cmd[0]
#srcline 388
             LDY word mac[2]
#srcline 389
             BAS
#srcline 390
             WRX dword cmd[4]
#srcline 391
             LDY word mac[4]
#srcline 392
             BAS
#srcline 393
             WRX dword cmd[8]
#srcline 394
             LD  0
#srcline 395
             WRX cmd[12]
#srcline 396 ;          {END_ASM}
#srcline 397 ;          cmd := 'Message-ID: <' + DT_TO_STRINGF(in := GetRTC(), format := '%TYYMMDDhhmmsszzz') +
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LEA  _str_fbSmtpDbx_18
 SCON 
 NXT
 LEA  __Instance__GetRTC
 CAL  GetRTC_L0
 WR   __Instance__DT_TO_STRINGF~in
#debug_left dt __Instance__DT_TO_STRINGF~in
 LD   0   ; null string
 LEA  __Instance__DT_TO_STRINGF~format
 WRI 
 LEA  __Instance__DT_TO_STRINGF~format
 LD   80
 DST    ; Level 2
 LEA  _str_fbSmtpDbx_19
 SCON 
#debug_left string __Instance__DT_TO_STRINGF~format
 PDST   ; Level 2
 PRV
 LEA  __Instance__DT_TO_STRINGF
 CAL  DT_TO_STRINGF_L0

 SCON 
#srcline 398 ;                  cmd +
 LEAX cmd
#debug string cmd
 SCON 
#srcline 399 ;                  ptrText^ +
 LEAX ptrText
 LDIL    ; dereference 
#debug string ptrText^
 SCON 
#srcline 400 ;                  SMTP_END_OF_LINE_2_;
 LEA  SMTP_END_OF_LINE_2_
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX cmd
 WRI  
 LEAX cmd
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string cmd
 PDST   ; Level 1
#srcline 401 ;        END_IF;
fbSmtpDbx_L100:
#srcline 402 ;        state := ss_Smtptxdatasubject;
 LD   udint 21  ; TSmtpState#ss_SmtpTxDataSubject
 WRX  state
#debug_left usint state
 JMP  fbSmtpDbx_L15
fbSmtpDbx_L99:
 LD   21
 LDY  P0__st__
 EQ  
 JMC  fbSmtpDbx_L102
#srcline 403 ;      // posleme telo zpravy - predmet -------------------------------------------
#srcline 404 ;      ss_Smtptxdatasubject :
#srcline 405 ;        IF LEN(charset) > 0 THEN
 LEAX charset
#debug string charset
 SLEN 
 LD   int 0
 GTS
 JMC  fbSmtpDbx_L103
#srcline 406 ;          cmd := 'SUBJECT: =?'+charset+'?B?'+Base64_encode_string(subject)+'?=$r$l';
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LEA  _str_fbSmtpDbx_20
 SCON 
 LEAX charset
#debug string charset
 SCON 
 LEA  _str_fbSmtpDbx_21
 SCON 
 NXT
 LD   0   ; null string
 LEA  __Instance__Base64_encode_string~data
 WRI 
 LEA  __Instance__Base64_encode_string~data
 LD   60
 DST    ; Level 2
 LDX  subject
#debug string subject
 SCON 
#debug_left string __Instance__Base64_encode_string~data
 PDST   ; Level 2
 PRV
 LEA  __Instance__Base64_encode_string
 CAL  Base64_encode_string_L0

 SCON 
 LEA  _str_fbSmtpDbx_22
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX cmd
 WRI  
 LEAX cmd
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string cmd
 PDST   ; Level 1
#srcline 407 ;        ELSE
 JMP  fbSmtpDbx_L104
fbSmtpDbx_L103:
#srcline 408 ;          cmd := 'SUBJECT: '+subject+INTERNETLIB_END_OF_LINE_;
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LEA  _str_fbSmtpDbx_23
 SCON 
 LDX  subject
#debug string subject
 SCON 
 LEA  INTERNETLIB_END_OF_LINE_
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX cmd
 WRI  
 LEAX cmd
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string cmd
 PDST   ; Level 1
#srcline 409 ;        END_IF;
fbSmtpDbx_L104:
#srcline 410 ;        state := ss_Smtptxmultipart;
 LD   udint 22  ; TSmtpState#ss_SmtpTxMultipart
 WRX  state
#debug_left usint state
 JMP  fbSmtpDbx_L15
fbSmtpDbx_L102:
 LD   22
 LDY  P0__st__
 EQ  
 JMC  fbSmtpDbx_L105
#srcline 411 ;      // posleme odelovac casti --------------------------------------------------
#srcline 412 ;     // posleme odelovac casti v2 --------------------------------------------------
#srcline 413 ;      ss_Smtptxmultipart :
#srcline 414 ;        cmd := 'MIME-Version: 1.0$r$lContent-Type: multipart/mixed;$r$l boundary="----=_NextPart_000_000D_666F7874.7465636F"$r$l$r$lThis is a message with multiple parts in MIME format.$r$l$r$l------=_NextPart_000_000D_666F7874.7465636F$r$l';
 LD   0   ; null string
 LEAX cmd
 WRI  
 LEAX cmd
 LD   255
 DST    ; Level 1
 LEA  _str_fbSmtpDbx_24
 SCON 
#debug_left string cmd
 PDST   ; Level 1
#srcline 415 ;        state := ss_SmtptxContentType;
 LD   udint 33  ; TSmtpState#ss_SmtpTxContentType
 WRX  state
#debug_left usint state
 JMP  fbSmtpDbx_L15
fbSmtpDbx_L105:
 LD   33
 LDY  P0__st__
 EQ  
 JMC  fbSmtpDbx_L106
#srcline 416 ;     // posleme kodovani tela textu-------------------------------------------------
#srcline 417 ;      ss_SmtptxContentType :
#srcline 418 ;        IF LEN(charset) > 0 THEN
 LEAX charset
#debug string charset
 SLEN 
 LD   int 0
 GTS
 JMC  fbSmtpDbx_L107
#srcline 419 ;          cmd := 'Content-Type: text/plain; charset='+charset+'$r$l$r$l';
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LEA  _str_fbSmtpDbx_25
 SCON 
 LEAX charset
#debug string charset
 SCON 
 LEA  _str_fbSmtpDbx_26
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX cmd
 WRI  
 LEAX cmd
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string cmd
 PDST   ; Level 1
#srcline 420 ;        ELSE
 JMP  fbSmtpDbx_L108
fbSmtpDbx_L107:
#srcline 421 ;          cmd := 'Content-Type: text/plain;$r$l$r$l';
 LD   0   ; null string
 LEAX cmd
 WRI  
 LEAX cmd
 LD   255
 DST    ; Level 1
 LEA  _str_fbSmtpDbx_27
 SCON 
#debug_left string cmd
 PDST   ; Level 1
#srcline 422 ;        END_IF;
fbSmtpDbx_L108:
#srcline 423 ;        ptrText := ADR(text);
 LDX  text
#debug pointer text
 LEAX ptrText
 WRIL 
#debug_left pointer ptrText
#srcline 424 ;        state := ss_Smtptxdatatext;
 LD   udint 23  ; TSmtpState#ss_SmtpTxDataText
 WRX  state
#debug_left usint state
 JMP  fbSmtpDbx_L15
fbSmtpDbx_L106:
 LD   23
 LDY  P0__st__
 EQ  
 JMC  fbSmtpDbx_L109
#srcline 425 ;      // posleme telo zpravy - text zpravy ---------------------------------------
#srcline 426 ;      ss_Smtptxdatatext :
#srcline 427 ;        IF body_lines < 1 THEN
 LDX  body_lines
#debug sint body_lines
 EXTB 
 LD   sint 1
 LTS
 JMC  fbSmtpDbx_L110
#srcline 428 ;          cmd := INTERNETLIB_END_OF_LINE_;   //nedavat nic kdyz je pocet radek mensi nez 1
 LD   0   ; null string
 LEAX cmd
 WRI  
 LEAX cmd
 LD   255
 DST    ; Level 1
 LEA  INTERNETLIB_END_OF_LINE_
 SCON 
#debug_left string cmd
 PDST   ; Level 1
#srcline 429 ;        ELSE
 JMP  fbSmtpDbx_L111
fbSmtpDbx_L110:
#srcline 430 ;          cmd := ptrText^+INTERNETLIB_END_OF_LINE_;
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LEAX ptrText
 LDIL    ; dereference 
#debug string ptrText^
 SCON 
 LEA  INTERNETLIB_END_OF_LINE_
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX cmd
 WRI  
 LEAX cmd
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string cmd
 PDST   ; Level 1
#srcline 431 ;        END_IF;
fbSmtpDbx_L111:
#srcline 432 ;        body_lines := body_lines - 1; ptrText := ptrText + 81; // sizeof(string)
 LDX  body_lines
#debug sint body_lines
 EXTB 
 LD   sint 1
 SUB
 EXTB
 WRX  body_lines
#debug_left sint body_lines
 LEAX ptrText
 LDIL 
#debug pointer ptrText
 LD   udint 81
 ADD
 LEAX ptrText
 WRIL 
#debug_left pointer ptrText
#srcline 434 ;        if body_lines < 1 then
 LDX  body_lines
#debug sint body_lines
 EXTB 
 LD   sint 1
 LTS
 JMC  fbSmtpDbx_L112
#srcline 435 ;          IF Attachement AND AttachLen > 0 THEN
 LDX  Attachement
#debug bool Attachement
 LDX  AttachLen
#debug udint AttachLen
 LD   udint 0
 GT
 AND
 JMC  fbSmtpDbx_L114
#srcline 436 ;            //h := FileOpen(fileName := Attach, mode := F_READ);
#srcline 437 ;            lAttachLen := AttachLen;
 LDX  AttachLen
#debug udint AttachLen
 WRX  lAttachLen
#debug_left udint lAttachLen
#srcline 438 ;            oAttachLen := lAttachLen;
 LDX  lAttachLen
#debug udint lAttachLen
 WRX  oAttachLen
#debug_left udint oAttachLen
#srcline 439 ;            state := ss_Smtptxattachement;
 LD   udint 24  ; TSmtpState#ss_SmtpTxAttachement
 WRX  state
#debug_left usint state
#srcline 440 ;          ELSE
 JMP  fbSmtpDbx_L115
fbSmtpDbx_L114:
#srcline 441 ;            state := ss_Smtptxendofmail;
 LD   udint 26  ; TSmtpState#ss_SmtpTxEndOfMail
 WRX  state
#debug_left usint state
#srcline 442 ;          END_IF;
fbSmtpDbx_L115:
#srcline 443 ;          (*
#srcline 444 ;          IF state = ss_Smtptxattachement & h = INVALID_HANDLE_VALUE THEN
#srcline 445 ;            Err   := 1;
#srcline 446 ;            ErrId := 3; //cannot open file
#srcline 447 ;            state := ss_Smtptxendofmail;
#srcline 448 ;          END_IF;
#srcline 449 ;          *)
#srcline 450 ;        END_IF;
fbSmtpDbx_L112:
 JMP  fbSmtpDbx_L15
fbSmtpDbx_L109:
 LD   24
 LDY  P0__st__
 EQ  
 JMC  fbSmtpDbx_L116
#srcline 451 ;      // priloha zacatek----------------------------------------------------------
#srcline 452 ;      ss_Smtptxattachement:
#srcline 453 ;        //najit posledni lomitko
#srcline 454 ;        ptrUsint := ADR(Attach);
 LDX  Attach
#debug pointer Attach
 LEAY ptrUsint
 WRIL 
#debug_left pointer ptrUsint
#srcline 455 ;        ptrText  := ptrUsint;
 LEAY ptrUsint
 LDIL 
#debug pointer ptrUsint
 LEAX ptrText
 WRIL 
#debug_left pointer ptrText
#srcline 456 ;        WHILE ptrUsint^ <> 0 DO
fbSmtpDbx_L117:
 LEAY ptrUsint
 LDIL    ; dereference 
 LDI  
#debug usint ptrUsint^
 LD   usint 0
 EQ
 NEG
 JMC  fbSmtpDbx_L118
 DBG 
#srcline 457 ;          IF ptrUsint^ = 16#2F THEN //'/'
 LEAY ptrUsint
 LDIL    ; dereference 
 LDI  
#debug usint ptrUsint^
 LD   usint $2F
 EQ
 JMC  fbSmtpDbx_L119
#srcline 458 ;            ptrText  := ptrUsint+1;
 LEAY ptrUsint
 LDIL 
#debug pointer ptrUsint
 LD   udint 1
 ADD
 LEAX ptrText
 WRIL 
#debug_left pointer ptrText
#srcline 459 ;          END_IF;
fbSmtpDbx_L119:
#srcline 460 ;          ptrUsint := ptrUsint + 1;
 LEAY ptrUsint
 LDIL 
#debug pointer ptrUsint
 LD   udint 1
 ADD
 LEAY ptrUsint
 WRIL 
#debug_left pointer ptrUsint
#srcline 461 ;        END_WHILE;
 JMP  fbSmtpDbx_L117
fbSmtpDbx_L118:
 NOP  -1
#srcline 463 ;        IF attachementType = '' THEN
 LEAX attachementType
#debug string attachementType
 LEA  _str_fbSmtpDbx_28
 SCMP 
 EQ   0
 JMC  fbSmtpDbx_L121
#srcline 464 ;          attachementType := 'application/octet-stream';
 LD   0   ; null string
 LEAX attachementType
 WRI  
 LEAX attachementType
 LD   32
 DST    ; Level 1
 LEA  _str_fbSmtpDbx_29
 SCON 
#debug_left string attachementType
 PDST   ; Level 1
#srcline 465 ;        END_IF;
fbSmtpDbx_L121:
#srcline 467 ;        cmd := '------=_NextPart_000_000D_666F7874.7465636F$r$lContent-Type: '+attachementType+'; name="'+ptrText^+'"$r$l'+
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LEA  _str_fbSmtpDbx_30
 SCON 
 LEAX attachementType
#debug string attachementType
 SCON 
 LEA  _str_fbSmtpDbx_31
 SCON 
 LEAX ptrText
 LDIL    ; dereference 
#debug string ptrText^
 SCON 
 LEA  _str_fbSmtpDbx_32
 SCON 
#srcline 468 ;               'Content-Transfer-Encoding: base64$r$lContent-Disposition: attachment; filename="'+ptrText^+'"$r$l$r$l';
 LEA  _str_fbSmtpDbx_33
 SCON 
 LEAX ptrText
 LDIL    ; dereference 
#debug string ptrText^
 SCON 
 LEA  _str_fbSmtpDbx_34
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX cmd
 WRI  
 LEAX cmd
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string cmd
 PDST   ; Level 1
#srcline 470 ;        state := ss_Smtptxattachementbody;
 LD   udint 25  ; TSmtpState#ss_SmtpTxAttachementBody
 WRX  state
#debug_left usint state
 JMP  fbSmtpDbx_L15
fbSmtpDbx_L116:
 LD   25
 LDY  P0__st__
 EQ  
 JMC  fbSmtpDbx_L123
#srcline 471 ;      // priloha telo----------------------------------------------------------
#srcline 472 ;      ss_Smtptxattachementbody:
#srcline 473 ;        tmpud := USINT_TO_UDINT(ReadBlockFromDBx(dataBoxAddress := AttachAdr + oAttachLen - lAttachLen, length := UDINT_TO_USINT(MIN(lAttachLen,SMTP_MAXIMUM_FILE_LINE_LENGTH_)), variable := void(temp_rcpt)));////FileRead(h, PTR_TO_UDINT(ADR(temp_rcpt)), SMTP_MAXIMUM_FILE_LINE_LENGTH_);
 NXT
 LDX  AttachAdr
#debug udint AttachAdr
 LDX  oAttachLen
#debug udint oAttachLen
 ADD
 LDX  lAttachLen
#debug udint lAttachLen
 SUB
 WR   __Instance__ReadBlockFromDBx~dataBoxAddress
#debug_left udint __Instance__ReadBlockFromDBx~dataBoxAddress
 LDX  lAttachLen
#debug udint lAttachLen
 LD   udint 171
 MIN
 AND  $FF
 WR   __Instance__ReadBlockFromDBx~length
#debug_left usint __Instance__ReadBlockFromDBx~length
 LEAX temp_rcpt
 WR   __Instance__ReadBlockFromDBx~variable
#debug_left pointer __Instance__ReadBlockFromDBx.variable
 PRV
 LEA  __Instance__ReadBlockFromDBx
 CAL  ReadBlockFromDBx_L0
 WRY  tmpud
#debug_left udint tmpud
#srcline 474 ;        lAttachLen := lAttachLen - tmpud;
 LDX  lAttachLen
#debug udint lAttachLen
 LDY  tmpud
#debug udint tmpud
 SUB
 WRX  lAttachLen
#debug_left udint lAttachLen
#srcline 475 ;        cmd := Base64_encode_ptr_string(ADR(temp_rcpt), UDINT_TO_UINT(min(SMTP_BASE64_LEN_,tmpud))) + '$r$l';
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 NXT
 LEAX temp_rcpt
#debug pointer temp_rcpt
 LEA  __Instance__Base64_encode_ptr_string~data
 WRIL 
#debug_left udint __Instance__Base64_encode_ptr_string~data
 LD   udint 57
 LDY  tmpud
#debug udint tmpud
 MIN
 AND  $FFFF
 WR   __Instance__Base64_encode_ptr_string~dataLen
#debug_left uint __Instance__Base64_encode_ptr_string~dataLen
 PRV
 LEA  __Instance__Base64_encode_ptr_string
 CAL  Base64_encode_ptr_string_L0

 SCON 
 LEA  _str_fbSmtpDbx_35
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX cmd
 WRI  
 LEAX cmd
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string cmd
 PDST   ; Level 1
#srcline 476 ;        IF tmpud > SMTP_BASE64_LEN_ THEN
 LDY  tmpud
#debug udint tmpud
 LD   udint 57
 GT
 JMC  fbSmtpDbx_L124
#srcline 477 ;           cmd := cmd + Base64_encode_ptr_string(ADR(temp_rcpt)+SMTP_BASE64_LEN_, UDINT_TO_UINT(min(SMTP_BASE64_LEN_,tmpud-SMTP_BASE64_LEN_))) + '$r$l';
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LEAX cmd
#debug string cmd
 SCON 
 NXT
 LEAX temp_rcpt
#debug pointer temp_rcpt
 LD   udint 57
 ADD
 LEA  __Instance__Base64_encode_ptr_string~data
 WRIL 
#debug_left udint __Instance__Base64_encode_ptr_string~data
 LD   udint 57
 LDY  tmpud
#debug udint tmpud
 LD   udint 57
 SUB
 MIN
 AND  $FFFF
 WR   __Instance__Base64_encode_ptr_string~dataLen
#debug_left uint __Instance__Base64_encode_ptr_string~dataLen
 PRV
 LEA  __Instance__Base64_encode_ptr_string
 CAL  Base64_encode_ptr_string_L0

 SCON 
 LEA  _str_fbSmtpDbx_36
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX cmd
 WRI  
 LEAX cmd
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string cmd
 PDST   ; Level 1
#srcline 478 ;        END_IF;
fbSmtpDbx_L124:
#srcline 479 ;        IF tmpud > SMTP_BASE64_LEN2_ THEN
 LDY  tmpud
#debug udint tmpud
 LD   udint 114
 GT
 JMC  fbSmtpDbx_L126
#srcline 480 ;           cmd := cmd + Base64_encode_ptr_string(ADR(temp_rcpt)+SMTP_BASE64_LEN2_, UDINT_TO_UINT(tmpud-SMTP_BASE64_LEN2_)) + '$r$l';
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LEAX cmd
#debug string cmd
 SCON 
 NXT
 LEAX temp_rcpt
#debug pointer temp_rcpt
 LD   udint 114
 ADD
 LEA  __Instance__Base64_encode_ptr_string~data
 WRIL 
#debug_left udint __Instance__Base64_encode_ptr_string~data
 LDY  tmpud
#debug udint tmpud
 LD   udint 114
 SUB
 AND  $FFFF
 WR   __Instance__Base64_encode_ptr_string~dataLen
#debug_left uint __Instance__Base64_encode_ptr_string~dataLen
 PRV
 LEA  __Instance__Base64_encode_ptr_string
 CAL  Base64_encode_ptr_string_L0

 SCON 
 LEA  _str_fbSmtpDbx_37
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX cmd
 WRI  
 LEAX cmd
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string cmd
 PDST   ; Level 1
#srcline 481 ;        END_IF;
fbSmtpDbx_L126:
#srcline 482 ;        //Send_to.rq  := TRUE;
#srcline 483 ;        IF tmpud < SMTP_MAXIMUM_FILE_LINE_LENGTH_ THEN
 LDY  tmpud
#debug udint tmpud
 LD   udint 171
 LT
 JMC  fbSmtpDbx_L128
#srcline 484 ;          state := ss_Smtptxendofmail;
 LD   udint 26  ; TSmtpState#ss_SmtpTxEndOfMail
 WRX  state
#debug_left usint state
#srcline 485 ;        END_IF;
fbSmtpDbx_L128:
 JMP  fbSmtpDbx_L15
fbSmtpDbx_L123:
 LD   26
 LDY  P0__st__
 EQ  
 JMC  fbSmtpDbx_L130
#srcline 486 ;      // konec emailu ------------------------------------------------------------
#srcline 487 ;      (*
#srcline 488 ;      ss_SmtpPause:
#srcline 489 ;        IF timpause - %SL52 <= T#0s THEN
#srcline 490 ;          state := ss_Smtptxattachementbody;
#srcline 491 ;        END_IF;
#srcline 492 ;        return;
#srcline 493 ;      *)
#srcline 494 ;      ss_Smtptxendofmail:
#srcline 495 ;        cmd := '------=_NextPart_000_000D_666F7874.7465636F--$r$l.$r$l';
 LD   0   ; null string
 LEAX cmd
 WRI  
 LEAX cmd
 LD   255
 DST    ; Level 1
 LEA  _str_fbSmtpDbx_38
 SCON 
#debug_left string cmd
 PDST   ; Level 1
#srcline 496 ;        state := ss_Smtprxack;
 LD   udint 27  ; TSmtpState#ss_SmtpRxAck
 WRX  state
#debug_left usint state
 JMP  fbSmtpDbx_L15
fbSmtpDbx_L130:
 LD   27
 LDY  P0__st__
 EQ  
 JMC  fbSmtpDbx_L131
#srcline 497 ;      // cekani na odezvu --------------------------------------------------------
#srcline 498 ;      ss_Smtprxack :
#srcline 499 ;        Send_to.rq  := FALSE;
 LD   bool 0       ; false
 WRX  Send_to~rq
#debug_left bool Send_to.rq
#srcline 500 ;        if mesRec then
 LDX  mesRec
#debug bool mesRec
 JMC  fbSmtpDbx_L132
#srcline 501 ;          {$IFDEF _DEBUG} dbg6 := cmd; {$END_IF}
#srcline 502 ;          if tmpReplyCode = 250 then //je to odezva typu '250'?
 LDY  tmpReplyCode
#debug uint tmpReplyCode
 LD   uint 250
 EQ
 JMC  fbSmtpDbx_L134
#srcline 503 ;            state := ss_Smtptxquit;
 LD   udint 28  ; TSmtpState#ss_SmtpTxQuit
 WRX  state
#debug_left usint state
#srcline 504 ;          else
 JMP  fbSmtpDbx_L135
fbSmtpDbx_L134:
#srcline 505 ;            state := ss_Smtprxerror;          //chybna odezva
 LD   udint 31  ; TSmtpState#ss_SmtpRxError
 WRX  state
#debug_left usint state
#srcline 506 ;          end_if;
fbSmtpDbx_L135:
#srcline 507 ;        elsif timeout_elapsed then     //server neodpovida
 JMP  fbSmtpDbx_L133
fbSmtpDbx_L132:
 LDY  timeout_elapsed
#debug bool timeout_elapsed
 JMC  fbSmtpDbx_L136
#srcline 508 ;          state := ss_Smtprxtimeout;
 LD   udint 30  ; TSmtpState#ss_SmtpRxTimeout
 WRX  state
#debug_left usint state
#srcline 509 ;        end_if;
 JMP  fbSmtpDbx_L133
fbSmtpDbx_L136:
fbSmtpDbx_L133:
 JMP  fbSmtpDbx_L15
fbSmtpDbx_L131:
 LD   28
 LDY  P0__st__
 EQ  
 JMC  fbSmtpDbx_L137
#srcline 511 ;      // ukonceni spojeni --------------------------------------------------------
#srcline 512 ;      ss_Smtptxquit :
#srcline 513 ;        cmd := 'QUIT$r$l';
 LD   0   ; null string
 LEAX cmd
 WRI  
 LEAX cmd
 LD   255
 DST    ; Level 1
 LEA  _str_fbSmtpDbx_39
 SCON 
#debug_left string cmd
 PDST   ; Level 1
#srcline 514 ;        Send_to.rq  := TRUE;
 LD   bool -1       ; true
 WRX  Send_to~rq
#debug_left bool Send_to.rq
#srcline 515 ;        state := ss_Smtprxclose;
 LD   udint 29  ; TSmtpState#ss_SmtpRxClose
 WRX  state
#debug_left usint state
 JMP  fbSmtpDbx_L15
fbSmtpDbx_L137:
 LD   29
 LDY  P0__st__
 EQ  
 JMC  fbSmtpDbx_L138
#srcline 517 ;      // cekani na ukonceni spojeni ----------------------------------------------
#srcline 518 ;      ss_Smtprxclose :
#srcline 519 ;        Send_to.rq  := FALSE;
 LD   bool 0       ; false
 WRX  Send_to~rq
#debug_left bool Send_to.rq
#srcline 520 ;        if IsEstabTCPconnection(chanCode := chanCode) = false then  // spojeni ukonceno
 NXT
 LDX  chanCode
#debug uint chanCode
 WR   __Instance__IsEstabTCPconnection~chanCode
#debug_left uint __Instance__IsEstabTCPconnection~chanCode
 PRV
 LEA  __Instance__IsEstabTCPconnection
 CAL  IsEstabTCPconnection_L0
 LD   bool 0       ; false
 XOR
 NEG
 JMC  fbSmtpDbx_L139
#srcline 521 ;          Done := NOT Err;
 LDX  Err
#debug bool Err
 NEG
 WRX  Done
#debug_left bool Done
#srcline 522 ;          state  := ss_Smtpinit;
 LD   udint 0  ; TSmtpState#ss_SmtpInit
 WRX  state
#debug_left usint state
#srcline 523 ;        elsif mesRec then            //prijata odezva
 JMP  fbSmtpDbx_L140
fbSmtpDbx_L139:
 LDX  mesRec
#debug bool mesRec
 JMC  fbSmtpDbx_L141
#srcline 524 ;          {$IFDEF _DEBUG} dbg7 := cmd; {$END_IF}
#srcline 525 ;          if tmpReplyCode = 221 then //je to odezva typu '221'?
 LDY  tmpReplyCode
#debug uint tmpReplyCode
 LD   uint 221
 EQ
 JMC  fbSmtpDbx_L142
#srcline 526 ;            Done := NOT Err;
 LDX  Err
#debug bool Err
 NEG
 WRX  Done
#debug_left bool Done
#srcline 527 ;            state  := ss_Smtpinit;
 LD   udint 0  ; TSmtpState#ss_SmtpInit
 WRX  state
#debug_left usint state
#srcline 528 ;          elsif tmpReplyCode = 250 then //je to odezva typu '250'?
 JMP  fbSmtpDbx_L143
fbSmtpDbx_L142:
 LDY  tmpReplyCode
#debug uint tmpReplyCode
 LD   uint 250
 EQ
 JMC  fbSmtpDbx_L144
#srcline 529 ;            state := ss_Smtptxquit;  //nechce nas pustit posleme jeste jednou
 LD   udint 28  ; TSmtpState#ss_SmtpTxQuit
 WRX  state
#debug_left usint state
#srcline 530 ;          else
 JMP  fbSmtpDbx_L143
fbSmtpDbx_L144:
#srcline 531 ;            state := ss_Smtprxerror;          //chybna odezva
 LD   udint 31  ; TSmtpState#ss_SmtpRxError
 WRX  state
#debug_left usint state
#srcline 532 ;          end_if;
fbSmtpDbx_L143:
#srcline 533 ;        elsif timeout_elapsed then     //server neodpovida
 JMP  fbSmtpDbx_L140
fbSmtpDbx_L141:
 LDY  timeout_elapsed
#debug bool timeout_elapsed
 JMC  fbSmtpDbx_L145
#srcline 534 ;          state := ss_Smtpinit;
 LD   udint 0  ; TSmtpState#ss_SmtpInit
 WRX  state
#debug_left usint state
#srcline 535 ;        end_if;
 JMP  fbSmtpDbx_L140
fbSmtpDbx_L145:
fbSmtpDbx_L140:
 JMP  fbSmtpDbx_L15
fbSmtpDbx_L138:
 LD   30
 LDY  P0__st__
 EQ  
 JMC  fbSmtpDbx_L146
#srcline 537 ;      // osetreni kdyz je timeout prijmu -----------------------------------------
#srcline 538 ;      ss_Smtprxtimeout :
#srcline 539 ;        state := ss_Smtpinit;
 LD   udint 0  ; TSmtpState#ss_SmtpInit
 WRX  state
#debug_left usint state
#srcline 540 ;        Err   := true;
 LD   bool -1       ; true
 WRX  Err
#debug_left bool Err
#srcline 541 ;        ErrId := 1; //timeout
 LD   usint 1
 WRX  ErrId
#debug_left usint ErrId
 JMP  fbSmtpDbx_L15
fbSmtpDbx_L146:
 LD   31
 LDY  P0__st__
 EQ  
 JMC  fbSmtpDbx_L147
#srcline 543 ;      // osetreni kdyz je chybna odezva ------------------------------------------
#srcline 544 ;      ss_Smtprxerror :
#srcline 545 ;        state := ss_Smtptxquit;
 LD   udint 28  ; TSmtpState#ss_SmtpTxQuit
 WRX  state
#debug_left usint state
#srcline 546 ;        Err   := true;
 LD   bool -1       ; true
 WRX  Err
#debug_left bool Err
#srcline 547 ;        ErrId := 2; //unexpected reply
 LD   usint 2
 WRX  ErrId
#debug_left usint ErrId
 JMP  fbSmtpDbx_L15
fbSmtpDbx_L147:
#srcline 549 ;    // ilegalni stav, provedeme restart stavoveho automatu -----------------------
#srcline 550 ;    ELSE
#srcline 551 ;      state := ss_Smtpinit;
 LD   udint 0  ; TSmtpState#ss_SmtpInit
 WRX  state
#debug_left usint state
#srcline 552 ;    END_CASE;
fbSmtpDbx_L15:
#srcline 553 ;  END_IF;
fbSmtpDbx_L7:
#srcline 555 ;  Send_to   (lenTx := len(cmd), chanCode := chanCode, data := void(cmd));
 LEAX cmd
#debug string cmd
 SLEN 
 WRX  Send_to~lenTx
#debug_left uint Send_to~lenTx
 LDX  chanCode
#debug uint chanCode
 WRX  Send_to~chanCode
#debug_left uint Send_to~chanCode
 LEAX cmd
 WRX  Send_to~data
#debug_left pointer Send_to.data
 LEAX Send_to
 CAL  fbSendTo_L0
#srcline 556 ;  TRO := Send_to.error = COM_ERR5; //buffer is full wait
 LDX  Send_to~error
#debug usint Send_to.error
 LD   usint 5
 EQ
 WRX  TRO
#debug_left bool TRO
#srcline 557 ;//  Recv_from (lenRx := 255, chanCode := chanCode,      data := void(cmd));
#srcline 558 ;  IF NOT TRO THEN //pokud je TRO nesmim to volat, jinak mi to prepise moje data
 LDX  TRO
#debug bool TRO
 NEG
 JMC  fbSmtpDbx_L148
#srcline 559 ;    Recv_from(chanCode := chanCode, lenBuf := 512, lenTxt := 255, buffer := buff[0], txtMes := void(cmd));
 LDX  chanCode
#debug uint chanCode
 WRX  Recv_from~chanCode
#debug_left uint Recv_from~chanCode
 LD   uint 512
 WRX  Recv_from~lenBuf
#debug_left uint Recv_from~lenBuf
 LD   uint 255
 WRX  Recv_from~lenTxt
#debug_left uint Recv_from~lenTxt
 LEAX buff
 WRX  Recv_from~buffer
#debug_left pointer Recv_from.buffer
 LEAX cmd
 WRX  Recv_from~txtMes
#debug_left pointer Recv_from.txtMes
 LEAX Recv_from
 CAL  fbRecvTxt_L0
#srcline 560 ;  END_IF;
fbSmtpDbx_L148:
#srcline 562 ;END_FUNCTION_BLOCK
fbSmtpDbx_RET:
 ULNK
RET
E     61

; Initialize - variables
P     61
fbSmtpDbx__InstanceInit__:
 LINK 0
 LD   uint 25
 WRX  port
 LD   udint $FFFFFFFF    ; nil
 WRX  ptrText
 LEAX Recv_from
 CAL  fbRecvTxt__InstanceInit__
 LEAX Send_to
 CAL  fbSendTo__InstanceInit__
 ULNK
RET
E     61
; End initialize - variables
#endpou 



 

#srcfile ''
#srcfile 'C:\TECOLIBSRC\INTERNETLIB\INTERNETLIBVCONTROL\FBHTTPREQUESTL3.ST'
#pou fbHttpRequestL3
#srcline 1 ;FUNCTION_BLOCK fbHttpRequestL3

#struct fbHttpRequestL3__temp__
  string[81] lNamePass,
  usint r,
  uint i,
  pointer pHelpString,
  pointer pUint,
  pointer pUsint,
  TUniDesc UniDesc,
  TRemoteEthAdr rea,
  udint l,
  uint authPos,
  uint j,
  usint P0__st__,
  string[257] PS0__st__,
  string[62] PS1__st__,
  string[257] PSC__st__
#data byte _str_fbHttpRequestL3_0 = 
  '@',0
#data byte _str_fbHttpRequestL3_1 = 
  'G','E','T',' ',0
#data byte _str_fbHttpRequestL3_2 = 
  'P','O','S','T',' ',0
#data byte _str_fbHttpRequestL3_3 = 
  'P','U','T',' ',0
#data byte _str_fbHttpRequestL3_4 = 
  ' ','H','T','T','P','/','1','.','0',$0D,$0A,'U','s','e','r','-','A','g','e','n',
  't',':',' ','F','o','x','t','r','o','t','/',0
#data byte _str_fbHttpRequestL3_5 = 
  '.',0
#data byte _str_fbHttpRequestL3_6 = 
  ' ','(','T','e','c','o','m','a','t',';',' ','N',';',' ','e','n','-','U','S',')',
  $0D,$0A,'C','a','c','h','e','-','C','o','n','t','r','o','l',':',' ','m','a','x',
  '-','a','g','e','=','0',$0D,$0A,'C','o','n','t','e','n','t','-','T','y','p','e',
  ':',' ',0
#data byte _str_fbHttpRequestL3_7 = 
  $0D,$0A,'A','c','c','e','p','t',':',' ','*','/','*',$0D,$0A,'H','o','s','t',':',
  ' ',0
#data byte _str_fbHttpRequestL3_8 = 
  ' ','(','T','e','c','o','m','a','t',';',' ','N',';',' ','e','n','-','U','S',')',
  $0D,$0A,'C','a','c','h','e','-','C','o','n','t','r','o','l',':',' ','m','a','x',
  '-','a','g','e','=','0',$0D,$0A,'C','o','n','t','e','n','t','-','T','y','p','e',
  ':',' ','a','p','p','l','i','c','a','t','i','o','n','/','x','-','w','w','w','-',
  'f','o','r','m','-','u','r','l','e','n','c','o','d','e','d',$0D,$0A,'A','c','c',
  'e','p','t',':',' ','*','/','*',$0D,$0A,'H','o','s','t',':',' ',0
#data byte _str_fbHttpRequestL3_9 = 
  ' ','(','T','e','c','o','m','a','t',';',' ','N',';',' ','e','n','-','U','S',')',
  $0D,$0A,'C','a','c','h','e','-','C','o','n','t','r','o','l',':',' ','m','a','x',
  '-','a','g','e','=','0',$0D,$0A,'A','c','c','e','p','t',':',' ','*','/','*',$0D,
  $0A,'H','o','s','t',':',' ',0
#data byte _str_fbHttpRequestL3_10 = 
  $0D,$0A,'A','u','t','h','o','r','i','z','a','t','i','o','n',':',' ','B','a','s',
  'i','c',' ',0
#data byte _str_fbHttpRequestL3_11 = 
  $0D,$0A,'C','o','n','t','e','n','t','-','L','e','n','g','t','h',':',' ',0
#data byte _str_fbHttpRequestL3_12 = 
  $0D,$0A,'C','o','n','n','e','c','t','i','o','n',':',' ','C','l','o','s','e',$0D,
  $0A,$0D,$0A,0
#data byte _str_fbHttpRequestL3_13 = 
  $0D,$0A,'C','o','n','n','e','c','t','i','o','n',':',' ','C','l','o','s','e',$0D,
  $0A,$0D,$0A,0
#data byte _str_fbHttpRequestL3_14 = 
  $0D,$0A,0
#data byte _str_fbHttpRequestL3_15 = 
  'H','T','T','P',0
#data byte _str_fbHttpRequestL3_16 = 
  'C','o','n','t','e','n','t','-','L','e','n','g','t','h',':',0
#data byte _str_fbHttpRequestL3_17 = 
  $0D,$0A,$0D,$0A,0
P     61
fbHttpRequestL3_L0:
 LINK __SizeOf(fbHttpRequestL3__temp__)
; Initialize - dynamic variables
 LD   udint $FFFFFFFF    ; nil
 WRY  pHelpString
 LD   udint $FFFFFFFF    ; nil
 WRY  pUint
 LD   udint $FFFFFFFF    ; nil
 WRY  pUsint
; End initialize - dynamic variables
; R_EDGE, F_EDGE 
 LDX  Post
 LETX __EDGE_R__Post
 WRX  Post
 LDX  Put
 LETX __EDGE_R__Put
 WRX  Put
 LDX  Get
 LETX __EDGE_R__Get
 WRX  Get
 LDX  Cancel
 LETX __EDGE_R__Cancel
 WRX  Cancel
#srcline 73 ;  IF GetChanIndex( chanCode) <> -1 THEN
 NXT
 LDX  chanCode
#debug uint chanCode
 WR   __Instance__GetChanIndex~chanCode
#debug_left uint __Instance__GetChanIndex~chanCode
 PRV
 LEA  __Instance__GetChanIndex
 CAL  GetChanIndex_L0
 LD   int -1
 EQ
 NEG
 JMC  fbHttpRequestL3_L1
#srcline 74 ;    // kanal zalozen pomoci #module => kontrola nutna
#srcline 75 ;    UniDesc := GetChanDesc(chanCode := chanCode);
 NXT
 LDX  chanCode
#debug uint chanCode
 WR   __Instance__GetChanDesc~chanCode
#debug_left uint __Instance__GetChanDesc~chanCode
 PRV
 LEA  __Instance__GetChanDesc
 CAL  GetChanDesc_L0
 LEAY UniDesc
#debug_left pointer UniDesc
 LD   26   ;SizeOf() 
 MOV  %IB0
#srcline 76 ;    IF (UniDesc.modeChan <> 5) OR (UniDesc.lenUniIn <> 516) OR (UniDesc.lenUniOut < 516) THEN
 LDY  UniDesc~modeChan
#debug byte UniDesc.modeChan
 LD   byte 5
 EQ
 NEG
 LDY  UniDesc~lenUniIn
#debug uint UniDesc.lenUniIn
 LD   uint 516
 EQ
 NEG
 OR  
 LDY  UniDesc~lenUniOut
#debug uint UniDesc.lenUniOut
 LD   uint 516
 LT
 OR  
 JMC  fbHttpRequestL3_L3
#srcline 77 ;      Err   := true;
 LD   bool -1       ; true
 WRX  Err
#debug_left bool Err
#srcline 78 ;      ErrId := 255;
 LD   usint 255
 WRX  ErrId
#debug_left usint ErrId
#srcline 79 ;      RETURN;
 JMP  fbHttpRequestL3_RET
#srcline 80 ;    END_IF;
fbHttpRequestL3_L3:
#srcline 81 ;  END_IF;
fbHttpRequestL3_L1:
#srcline 83 ;  Busy := State <> hs_HttpIdle;
 LDX  State
#debug usint State
 LD   udint 0  ; THttpState#hs_HttpIdle
 EQ
 NEG
 WRX  Busy
#debug_left bool Busy
#srcline 85 ;  TimeOutTon(IN := Busy & NOT DataReady, PT := T#2m);
 LDX  Busy
#debug bool Busy
 LDX  DataReady
#debug bool DataReady
 NEG
 AND
 WRX  TimeOutTon~IN
#debug_left bool TimeOutTon~IN
 LD   time 120000
 WRX  TimeOutTon~PT
#debug_left time TimeOutTon~PT
 LEAX TimeOutTon
 CAL  TON_L0
#srcline 87 ;  DataReady := false;
 LD   bool 0       ; false
 WRX  DataReady
#debug_left bool DataReady
#srcline 89 ;  IF TimeOutTon.Q THEN
 LDX  TimeOutTon~Q
#debug bool TimeOutTon.Q
 JMC  fbHttpRequestL3_L5
#srcline 90 ;    Err   := true;
 LD   bool -1       ; true
 WRX  Err
#debug_left bool Err
#srcline 91 ;    ErrId := 1;
 LD   usint 1
 WRX  ErrId
#debug_left usint ErrId
#srcline 92 ;    State := hs_HttpIdle;
 LD   udint 0  ; THttpState#hs_HttpIdle
 WRX  State
#debug_left usint State
#srcline 93 ;  END_IF;
fbHttpRequestL3_L5:
#srcline 95 ;  IF Cancel THEN
 LDX  Cancel
#debug bool Cancel
 JMC  fbHttpRequestL3_L7
#srcline 96 ;    State := hs_HttpIdle;
 LD   udint 0  ; THttpState#hs_HttpIdle
 WRX  State
#debug_left usint State
#srcline 97 ;    Err   := ContLen > 0;
 LDX  ContLen
#debug dint ContLen
 LD   dint 0
 GTS
 WRX  Err
#debug_left bool Err
#srcline 98 ;  END_IF;
fbHttpRequestL3_L7:
#srcline 100 ;  CASE State OF
 LDX  State
#debug usint State
 WRY  P0__st__
 LD   0
 LDY  P0__st__
 EQ  
 JMC  fbHttpRequestL3_L10
#srcline 101 ;    hs_HttpIdle   :
#srcline 102 ;      r := CloseTCPconnection(chanCode := chanCode);
 NXT
 LDX  chanCode
#debug uint chanCode
 WR   __Instance__CloseTCPconnection~chanCode
#debug_left uint __Instance__CloseTCPconnection~chanCode
 PRV
 LEA  __Instance__CloseTCPconnection
 CAL  CloseTCPconnection_L0
 WRY  r
#debug_left usint r
#srcline 103 ;      Done := false;
 LD   bool 0       ; false
 WRX  Done
#debug_left bool Done
#srcline 104 ;      IF Post OR Get OR Put THEN
 LDX  Post
#debug bool Post
 LDX  Get
#debug bool Get
 OR  
 LDX  Put
#debug bool Put
 OR  
 JMC  fbHttpRequestL3_L11
#srcline 105 ;        sOff := 0;
 LD   uint 0
 WRX  sOff
#debug_left uint sOff
#srcline 106 ;        rLen := 0;
 LD   uint 0
 WRX  rLen
#debug_left uint rLen
#srcline 107 ;        WholeLen := 0;
 LD   dint 0
 WRX  WholeLen
#debug_left dint WholeLen
#srcline 108 ;        Err     := false;
 LD   bool 0       ; false
 WRX  Err
#debug_left bool Err
#srcline 109 ;        ErrId   := 0;
 LD   usint 0
 WRX  ErrId
#debug_left usint ErrId
#srcline 110 ;        Result  := 0;
 LD   int 0
 WRX  Result
#debug_left int Result
#srcline 111 ;        authPos := FIND(IN1 := Host, IN2 := '@');
 LDX  Host
#debug string Host
 LEA  _str_fbHttpRequestL3_0
 SFND 
 WRY  authPos
#debug_left uint authPos
#srcline 112 ;        IF authPos > 0 THEN
 LDY  authPos
#debug uint authPos
 LD   uint 0
 GT
 JMC  fbHttpRequestL3_L13
#srcline 113 ;          lHost := MID(IN := Host, L := 80, P := authPos+1);
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   80
 DST    ; Level 1
 LDX  Host
#debug string Host
 LD   80
 LDY  authPos
#debug uint authPos
 LD   uint 1
 ADD
 AND  $FFFF
 SUB  1
 SMID 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX lHost
 WRI  
 LEAX lHost
 LD   80
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string lHost
 PDST   ; Level 1
#srcline 114 ;          lNamePass := LEFT(IN := Host, L := authPos-1);
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   80
 DST    ; Level 1
 LDX  Host
#debug string Host
 LDY  authPos
#debug uint authPos
 LD   uint 1
 SUB
 AND  $FFFF
 SLFT 
 PDST   ; Level 1
 LD   0   ; null string
 LEAY lNamePass
 WRI  
 LEAY lNamePass
 LD   80
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string lNamePass
 PDST   ; Level 1
#srcline 115 ;        ELSE
 JMP  fbHttpRequestL3_L14
fbHttpRequestL3_L13:
#srcline 116 ;          lHost := Host;
 LD   0   ; null string
 LEAX lHost
 WRI  
 LEAX lHost
 LD   80
 DST    ; Level 1
 LDX  Host
#debug string Host
 SCON 
#debug_left string lHost
 PDST   ; Level 1
#srcline 117 ;        END_IF;
fbHttpRequestL3_L14:
#srcline 118 ;        (*
#srcline 119 ;        pUint := ADR(RecvData);
#srcline 120 ;        pHelpString := pUint;
#srcline 121 ;        *)
#srcline 122 ;        IF Get THEN
 LDX  Get
#debug bool Get
 JMC  fbHttpRequestL3_L15
#srcline 123 ;          BodyLen := 0;
 LD   uint 0
 WRX  BodyLen
#debug_left uint BodyLen
#srcline 124 ;          HelpString := 'GET ' + Action;
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LEA  _str_fbHttpRequestL3_1
 SCON 
 LDX  Action
#debug string Action
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX HelpString
 WRI  
 LEAX HelpString
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string HelpString
 PDST   ; Level 1
#srcline 125 ;        ELSE
 JMP  fbHttpRequestL3_L16
fbHttpRequestL3_L15:
#srcline 126 ;          BodyLen := postLen;
 LDX  postLen
#debug uint postLen
 WRX  BodyLen
#debug_left uint BodyLen
#srcline 127 ;          lPostLen := postLen;
 LDX  postLen
#debug uint postLen
 WRX  lPostLen
#debug_left uint lPostLen
#srcline 128 ;          IF Post THEN
 LDX  Post
#debug bool Post
 JMC  fbHttpRequestL3_L17
#srcline 129 ;            HelpString := 'POST ' + Action;
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LEA  _str_fbHttpRequestL3_2
 SCON 
 LDX  Action
#debug string Action
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX HelpString
 WRI  
 LEAX HelpString
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string HelpString
 PDST   ; Level 1
#srcline 130 ;          ELSE
 JMP  fbHttpRequestL3_L18
fbHttpRequestL3_L17:
#srcline 131 ;            HelpString := 'PUT ' + Action;
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LEA  _str_fbHttpRequestL3_3
 SCON 
 LDX  Action
#debug string Action
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX HelpString
 WRI  
 LEAX HelpString
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string HelpString
 PDST   ; Level 1
#srcline 132 ;          END_IF;
fbHttpRequestL3_L18:
#srcline 133 ;        END_IF;
fbHttpRequestL3_L16:
#srcline 134 ;        //TODO: Dodelat kontrolu delky vstupnich dat
#srcline 135 ;        pUint := ADR(RecvData);
 LDX  RecvData
#debug pointer RecvData
 LEAY pUint
 WRIL 
#debug_left pointer pUint
#srcline 136 ;        pUsint := pUint  + MemcpyPtr(length := LEN(helpstring), source := ADR(helpstring), dest := pUint);
 LEAY pUint
 LDIL 
#debug pointer pUint
 NXT
 LEAX helpstring
#debug string helpstring
 SLEN 
 WR   __Instance__MemcpyPtr~length
#debug_left udint __Instance__MemcpyPtr~length
 LEAX helpstring
#debug pointer helpstring
 LEA  __Instance__MemcpyPtr~source
 WRIL 
#debug_left udint __Instance__MemcpyPtr~source
 LEAY pUint
 LDIL 
#debug pointer pUint
 LEA  __Instance__MemcpyPtr~dest
 WRIL 
#debug_left udint __Instance__MemcpyPtr~dest
 PRV
 LEA  __Instance__MemcpyPtr
 CAL  MemcpyPtr_L0
 ADD
 LEAY pUsint
 WRIL 
#debug_left pointer pUsint
#srcline 137 ;        //max len 5+255 = 300
#srcline 138 ;        helpstring := ' HTTP/1.0$r$nUser-Agent: Foxtrot/' + USINT_TO_STRING(%S40) + '.' + USINT_TO_STRING(%S41);
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LEA  _str_fbHttpRequestL3_4
 SCON 
 LD   0   ; null string
 WRY  PSC__st__[0]
 LEAY PSC__st__[0]
 LD   255
 DST    ; Level 2
 LD   %S40
 SCNV $0830;  IEC_USINT _TO_ IEC_STRING
 PDST   ; Level 2
 LEAY PSC__st__[0]

 SCON 
 LEA  _str_fbHttpRequestL3_5
 SCON 
 LD   0   ; null string
 WRY  PSC__st__[0]
 LEAY PSC__st__[0]
 LD   255
 DST    ; Level 2
 LD   %S41
 SCNV $0830;  IEC_USINT _TO_ IEC_STRING
 PDST   ; Level 2
 LEAY PSC__st__[0]

 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX helpstring
 WRI  
 LEAX helpstring
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string helpstring
 PDST   ; Level 1
#srcline 139 ;        pUsint := pUsint + MemcpyPtr(length := LEN(helpstring), source := ADR(helpstring), dest := pUsint);
 LEAY pUsint
 LDIL 
#debug pointer pUsint
 NXT
 LEAX helpstring
#debug string helpstring
 SLEN 
 WR   __Instance__MemcpyPtr~length
#debug_left udint __Instance__MemcpyPtr~length
 LEAX helpstring
#debug pointer helpstring
 LEA  __Instance__MemcpyPtr~source
 WRIL 
#debug_left udint __Instance__MemcpyPtr~source
 LEAY pUsint
 LDIL 
#debug pointer pUsint
 LEA  __Instance__MemcpyPtr~dest
 WRIL 
#debug_left udint __Instance__MemcpyPtr~dest
 PRV
 LEA  __Instance__MemcpyPtr
 CAL  MemcpyPtr_L0
 ADD
 LEAY pUsint
 WRIL 
#debug_left pointer pUsint
#srcline 140 ;        //max len 300+33+1+1+1 = 336
#srcline 142 ;        IF LEN(ContentType) > 0 THEN
 LDX  ContentType
#debug string ContentType
 SLEN 
 LD   int 0
 GTS
 JMC  fbHttpRequestL3_L19
#srcline 143 ;          helpstring := ' (Tecomat; N; en-US)$r$nCache-Control: max-age=0$r$nContent-Type: '+ContentType+'$r$nAccept: */*$r$nHost: ';
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LEA  _str_fbHttpRequestL3_6
 SCON 
 LDX  ContentType
#debug string ContentType
 SCON 
 LEA  _str_fbHttpRequestL3_7
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX helpstring
 WRI  
 LEAX helpstring
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string helpstring
 PDST   ; Level 1
#srcline 144 ;        ELSE
 JMP  fbHttpRequestL3_L20
fbHttpRequestL3_L19:
#srcline 145 ;          IF BodyLen > 0 THEN
 LDX  BodyLen
#debug uint BodyLen
 LD   uint 0
 GT
 JMC  fbHttpRequestL3_L21
#srcline 146 ;            helpstring := ' (Tecomat; N; en-US)$r$nCache-Control: max-age=0$r$nContent-Type: application/x-www-form-urlencoded$r$nAccept: */*$r$nHost: ';
 LD   0   ; null string
 LEAX helpstring
 WRI  
 LEAX helpstring
 LD   255
 DST    ; Level 1
 LEA  _str_fbHttpRequestL3_8
 SCON 
#debug_left string helpstring
 PDST   ; Level 1
#srcline 147 ;          ELSE
 JMP  fbHttpRequestL3_L22
fbHttpRequestL3_L21:
#srcline 148 ;            helpstring := ' (Tecomat; N; en-US)$r$nCache-Control: max-age=0$r$nAccept: */*$r$nHost: ';
 LD   0   ; null string
 LEAX helpstring
 WRI  
 LEAX helpstring
 LD   255
 DST    ; Level 1
 LEA  _str_fbHttpRequestL3_9
 SCON 
#debug_left string helpstring
 PDST   ; Level 1
#srcline 149 ;          END_IF;
fbHttpRequestL3_L22:
#srcline 150 ;        END_IF;
fbHttpRequestL3_L20:
#srcline 152 ;        pUsint := pUsint + MemcpyPtr(length := LEN(helpstring), source := ADR(helpstring), dest := pUsint);
 LEAY pUsint
 LDIL 
#debug pointer pUsint
 NXT
 LEAX helpstring
#debug string helpstring
 SLEN 
 WR   __Instance__MemcpyPtr~length
#debug_left udint __Instance__MemcpyPtr~length
 LEAX helpstring
#debug pointer helpstring
 LEA  __Instance__MemcpyPtr~source
 WRIL 
#debug_left udint __Instance__MemcpyPtr~source
 LEAY pUsint
 LDIL 
#debug pointer pUsint
 LEA  __Instance__MemcpyPtr~dest
 WRIL 
#debug_left udint __Instance__MemcpyPtr~dest
 PRV
 LEA  __Instance__MemcpyPtr
 CAL  MemcpyPtr_L0
 ADD
 LEAY pUsint
 WRIL 
#debug_left pointer pUsint
#srcline 153 ;        //max len 336+140 = 476
#srcline 154 ;        Err := true;
 LD   bool -1       ; true
 WRX  Err
#debug_left bool Err
#srcline 155 ;        REPEAT
fbHttpRequestL3_L23:
 DBG
#srcline 156 ;          l := LEN(lHost);
 LEAX lHost
#debug string lHost
 SLEN 
 WRY  l
#debug_left udint l
#srcline 157 ;          IF PTR_TO_UDINT(pUsint) - PTR_TO_UDINT(pUint) + l > 512 THEN EXIT; END_IF;
 LEAY pUsint
 LDIL 
#debug pointer pUsint
 LEAY pUint
 LDIL 
#debug pointer pUint
 SUB
 LDY  l
#debug udint l
 ADD
 LD   udint 512
 GT
 JMC  fbHttpRequestL3_L25
 JMP  fbHttpRequestL3_L24
fbHttpRequestL3_L25:
#srcline 158 ;          pUsint := pUsint + MemcpyPtr(length := l, source := ADR(lHost), dest := pUsint);
 LEAY pUsint
 LDIL 
#debug pointer pUsint
 NXT
 LDY  l
#debug udint l
 WR   __Instance__MemcpyPtr~length
#debug_left udint __Instance__MemcpyPtr~length
 LEAX lHost
#debug pointer lHost
 LEA  __Instance__MemcpyPtr~source
 WRIL 
#debug_left udint __Instance__MemcpyPtr~source
 LEAY pUsint
 LDIL 
#debug pointer pUsint
 LEA  __Instance__MemcpyPtr~dest
 WRIL 
#debug_left udint __Instance__MemcpyPtr~dest
 PRV
 LEA  __Instance__MemcpyPtr
 CAL  MemcpyPtr_L0
 ADD
 LEAY pUsint
 WRIL 
#debug_left pointer pUsint
#srcline 160 ;          IF authPos > 0 THEN
 LDY  authPos
#debug uint authPos
 LD   uint 0
 GT
 JMC  fbHttpRequestL3_L27
#srcline 161 ;            //Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==
#srcline 162 ;            helpstring := '$r$nAuthorization: Basic ' + Base64_encode_string(lNamePass);
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LEA  _str_fbHttpRequestL3_10
 SCON 
 NXT
 LD   0   ; null string
 LEA  __Instance__Base64_encode_string~data
 WRI 
 LEA  __Instance__Base64_encode_string~data
 LD   60
 DST    ; Level 2
 LEAY lNamePass
#debug string lNamePass
 SCON 
#debug_left string __Instance__Base64_encode_string~data
 PDST   ; Level 2
 PRV
 LEA  __Instance__Base64_encode_string
 CAL  Base64_encode_string_L0

 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX helpstring
 WRI  
 LEAX helpstring
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string helpstring
 PDST   ; Level 1
#srcline 163 ;            l := LEN(helpstring);
 LEAX helpstring
#debug string helpstring
 SLEN 
 WRY  l
#debug_left udint l
#srcline 164 ;            IF PTR_TO_UDINT(pUsint) - PTR_TO_UDINT(pUint) + l > 512 THEN EXIT; END_IF;
 LEAY pUsint
 LDIL 
#debug pointer pUsint
 LEAY pUint
 LDIL 
#debug pointer pUint
 SUB
 LDY  l
#debug udint l
 ADD
 LD   udint 512
 GT
 JMC  fbHttpRequestL3_L29
 JMP  fbHttpRequestL3_L24
fbHttpRequestL3_L29:
#srcline 165 ;            pUsint := pUsint + MemcpyPtr(length := l, source := ADR(helpstring), dest := pUsint);
 LEAY pUsint
 LDIL 
#debug pointer pUsint
 NXT
 LDY  l
#debug udint l
 WR   __Instance__MemcpyPtr~length
#debug_left udint __Instance__MemcpyPtr~length
 LEAX helpstring
#debug pointer helpstring
 LEA  __Instance__MemcpyPtr~source
 WRIL 
#debug_left udint __Instance__MemcpyPtr~source
 LEAY pUsint
 LDIL 
#debug pointer pUsint
 LEA  __Instance__MemcpyPtr~dest
 WRIL 
#debug_left udint __Instance__MemcpyPtr~dest
 PRV
 LEA  __Instance__MemcpyPtr
 CAL  MemcpyPtr_L0
 ADD
 LEAY pUsint
 WRIL 
#debug_left pointer pUsint
#srcline 166 ;          END_IF;
fbHttpRequestL3_L27:
#srcline 168 ;          //max len 476+80 = 556!!!
#srcline 169 ;          IF BodyLen > 0 THEN
 LDX  BodyLen
#debug uint BodyLen
 LD   uint 0
 GT
 JMC  fbHttpRequestL3_L31
#srcline 170 ;            helpstring := '$r$nContent-Length: ' + UINT_TO_STRING(BodyLen) + '$r$nConnection: Close$r$n$r$n';
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LEA  _str_fbHttpRequestL3_11
 SCON 
 LD   0   ; null string
 WRY  PSC__st__[0]
 LEAY PSC__st__[0]
 LD   255
 DST    ; Level 2
 LDX  BodyLen
#debug uint BodyLen
 SCNV $0A30;  IEC_UINT _TO_ IEC_STRING
 PDST   ; Level 2
 LEAY PSC__st__[0]

 SCON 
 LEA  _str_fbHttpRequestL3_12
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX helpstring
 WRI  
 LEAX helpstring
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string helpstring
 PDST   ; Level 1
#srcline 171 ;          ELSE
 JMP  fbHttpRequestL3_L32
fbHttpRequestL3_L31:
#srcline 172 ;            helpstring := '$r$nConnection: Close$r$n$r$n';
 LD   0   ; null string
 LEAX helpstring
 WRI  
 LEAX helpstring
 LD   255
 DST    ; Level 1
 LEA  _str_fbHttpRequestL3_13
 SCON 
#debug_left string helpstring
 PDST   ; Level 1
#srcline 173 ;          END_IF;
fbHttpRequestL3_L32:
#srcline 174 ;          l := LEN(helpstring);
 LEAX helpstring
#debug string helpstring
 SLEN 
 WRY  l
#debug_left udint l
#srcline 175 ;          IF PTR_TO_UDINT(pUsint) - PTR_TO_UDINT(pUint) + l > 512 THEN EXIT; END_IF;
 LEAY pUsint
 LDIL 
#debug pointer pUsint
 LEAY pUint
 LDIL 
#debug pointer pUint
 SUB
 LDY  l
#debug udint l
 ADD
 LD   udint 512
 GT
 JMC  fbHttpRequestL3_L33
 JMP  fbHttpRequestL3_L24
fbHttpRequestL3_L33:
#srcline 176 ;          pUsint := pUsint + MemcpyPtr(length := l, source := ADR(helpstring), dest := pUsint);
 LEAY pUsint
 LDIL 
#debug pointer pUsint
 NXT
 LDY  l
#debug udint l
 WR   __Instance__MemcpyPtr~length
#debug_left udint __Instance__MemcpyPtr~length
 LEAX helpstring
#debug pointer helpstring
 LEA  __Instance__MemcpyPtr~source
 WRIL 
#debug_left udint __Instance__MemcpyPtr~source
 LEAY pUsint
 LDIL 
#debug pointer pUsint
 LEA  __Instance__MemcpyPtr~dest
 WRIL 
#debug_left udint __Instance__MemcpyPtr~dest
 PRV
 LEA  __Instance__MemcpyPtr
 CAL  MemcpyPtr_L0
 ADD
 LEAY pUsint
 WRIL 
#debug_left pointer pUsint
#srcline 179 ;          //max len 556+44=600!!!
#srcline 180 ;          (*
#srcline 181 ;          IF POST THEN //copy data to post
#srcline 182 ;            l := LEN(data);
#srcline 183 ;            IF PTR_TO_UDINT(pUsint) - PTR_TO_UDINT(pUint) + l > 512 THEN EXIT; END_IF;
#srcline 184 ;            pUsint := pUsint + MemcpyPtr(length := LEN(data), source := ADR(data), dest := pUsint);
#srcline 185 ;            //max len 600+80=680!!!
#srcline 186 ;          END_IF;
#srcline 187 ;          *)
#srcline 188 ;          Err := false;
 LD   bool 0       ; false
 WRX  Err
#debug_left bool Err
#srcline 189 ;        UNTIL true END_REPEAT;
 LD   bool -1       ; true
 JMC  fbHttpRequestL3_L23
fbHttpRequestL3_L24:
 NOP  -1
#srcline 190 ;        IF Err THEN
 LDX  Err
#debug bool Err
 JMC  fbHttpRequestL3_L35
#srcline 191 ;          ErrId := 3; //delka hlavicka protokolu presahla 512 bytes
 LD   usint 3
 WRX  ErrId
#debug_left usint ErrId
#srcline 192 ;        ELSE
 JMP  fbHttpRequestL3_L36
fbHttpRequestL3_L35:
#srcline 193 ;          SendTo.lenTx := UDINT_TO_UINT(PTR_TO_UDINT(pUsint) - PTR_TO_UDINT(pUint));
 LEAY pUsint
 LDIL 
#debug pointer pUsint
 LEAY pUint
 LDIL 
#debug pointer pUint
 SUB
 AND  $FFFF
 WRX  SendTo~lenTx
#debug_left uint SendTo.lenTx
#srcline 194 ;          State := hs_HttpSetIP;
 LD   udint 1  ; THttpState#hs_HttpSetIP
 WRX  State
#debug_left usint State
#srcline 195 ;          Busy  := true; //Busy is set in the same cycle when we left idle state!!!
 LD   bool -1       ; true
 WRX  Busy
#debug_left bool Busy
#srcline 196 ;        END_IF;
fbHttpRequestL3_L36:
#srcline 197 ;      END_IF;
fbHttpRequestL3_L11:
 JMP  fbHttpRequestL3_L9
fbHttpRequestL3_L10:
 LD   1
 LDY  P0__st__
 EQ  
 JMC  fbHttpRequestL3_L37
#srcline 198 ;    hs_HttpSetIP:
#srcline 199 ;      IF IPadr = Any_IP THEN
 LEAX IPadr
 LEA  Any_IP
 LD   4   ; SizeOf()
 BCMP 
 EQ   0
 JMC  fbHttpRequestL3_L38
#srcline 200 ;          Err   := true;
 LD   bool -1       ; true
 WRX  Err
#debug_left bool Err
#srcline 201 ;          ErrId := 254;
 LD   usint 254
 WRX  ErrId
#debug_left usint ErrId
#srcline 202 ;          State := hs_HttpIdle;
 LD   udint 0  ; THttpState#hs_HttpIdle
 WRX  State
#debug_left usint State
#srcline 203 ;      ELSE
 JMP  fbHttpRequestL3_L39
fbHttpRequestL3_L38:
#srcline 204 ;        rea.remoteIP   := IPadr;
 LEAX IPadr
#debug pointer IPadr
 SRC  %IB0
 LEAY rea~remoteIP
#debug_left pointer rea.remoteIP
 LD   4   ;SizeOf() 
 MOV  %IB0
#srcline 205 ;        rea.remotePort := port;
 LDX  port
#debug uint port
 WRY  rea~remotePort
#debug_left uint rea.remotePort
#srcline 206 ;/////////nem 21.5.2019
#srcline 207 ;        uniDesc := GetChanDesc( chanCode := chanCode);
 NXT
 LDX  chanCode
#debug uint chanCode
 WR   __Instance__GetChanDesc~chanCode
#debug_left uint __Instance__GetChanDesc~chanCode
 PRV
 LEA  __Instance__GetChanDesc
 CAL  GetChanDesc_L0
 LEAY uniDesc
#debug_left pointer uniDesc
 LD   26   ;SizeOf() 
 MOV  %IB0
#srcline 208 ;        IF uniDesc.res = USINT_TO_BYTE( UNI_SSL_CLIENT) THEN
 LDY  uniDesc~res
#debug byte uniDesc.res
 LD   usint 35
 AND  $FF
 EQ
 JMC  fbHttpRequestL3_L40
#srcline 209 ;          SetUniChanHostName( chanHandle := chanCode, hostName := Host);  // nastavit host name pro SSL socket
 NXT
 LDX  chanCode
#debug uint chanCode
 WR   __Instance__SetUniChanHostName~chanHandle
#debug_left uint __Instance__SetUniChanHostName~chanHandle
 LD   0   ; null string
 LEA  __Instance__SetUniChanHostName~hostName
 WRI 
 LEA  __Instance__SetUniChanHostName~hostName
 LD   80
 DST    ; Level 1
 LDX  Host
#debug string Host
 SCON 
#debug_left string __Instance__SetUniChanHostName~hostName
 PDST   ; Level 1
 PRV
 LEA  __Instance__SetUniChanHostName
 CAL  SetUniChanHostName_L0
#srcline 210 ;        END_IF;
fbHttpRequestL3_L40:
#srcline 211 ;/////////
#srcline 212 ;        IF SetRemoteIPaddress(rq := 1, chanCode := chanCode, ethAdr := rea) THEN
 NXT
 LD   1
 WR   __Instance__SetRemoteIPaddress~rq
#debug_left bool __Instance__SetRemoteIPaddress~rq
 LDX  chanCode
#debug uint chanCode
 WR   __Instance__SetRemoteIPaddress~chanCode
#debug_left uint __Instance__SetRemoteIPaddress~chanCode
 LEAY rea
 WR   __Instance__SetRemoteIPaddress~ethAdr
#debug_left pointer __Instance__SetRemoteIPaddress.ethAdr
 PRV
 LEA  __Instance__SetRemoteIPaddress
 CAL  SetRemoteIPaddress_L0
 JMC  fbHttpRequestL3_L42
#srcline 213 ;          State := hs_HttpConnect;
 LD   udint 2  ; THttpState#hs_HttpConnect
 WRX  State
#debug_left usint State
#srcline 214 ;        END_IF;
fbHttpRequestL3_L42:
#srcline 215 ;      END_IF;
fbHttpRequestL3_L39:
 JMP  fbHttpRequestL3_L9
fbHttpRequestL3_L37:
 LD   2
 LDY  P0__st__
 EQ  
 JMC  fbHttpRequestL3_L44
#srcline 216 ;    hs_HttpConnect:
#srcline 217 ;      r := EstabTCPconnection(chanCode := chanCode);
 NXT
 LDX  chanCode
#debug uint chanCode
 WR   __Instance__EstabTCPconnection~chanCode
#debug_left uint __Instance__EstabTCPconnection~chanCode
 PRV
 LEA  __Instance__EstabTCPconnection
 CAL  EstabTCPconnection_L0
 WRY  r
#debug_left usint r
#srcline 218 ;      IF IsEstabTCPconnection(chanCode := chanCode) THEN
 NXT
 LDX  chanCode
#debug uint chanCode
 WR   __Instance__IsEstabTCPconnection~chanCode
#debug_left uint __Instance__IsEstabTCPconnection~chanCode
 PRV
 LEA  __Instance__IsEstabTCPconnection
 CAL  IsEstabTCPconnection_L0
 JMC  fbHttpRequestL3_L45
#srcline 219 ;        State := hs_HttpSend;
 LD   udint 3  ; THttpState#hs_HttpSend
 WRX  State
#debug_left usint State
#srcline 220 ;      END_IF;
fbHttpRequestL3_L45:
 JMP  fbHttpRequestL3_L9
fbHttpRequestL3_L44:
 LD   3
 LDY  P0__st__
 EQ  
 JMC  fbHttpRequestL3_L47
#srcline 221 ;    hs_HttpSend   :
#srcline 222 ;      SendTo(rq := 1, chanCode := chanCode, data := void(RecvData));
 LD   1
 WRX  SendTo~rq
#debug_left bool SendTo~rq
 LDX  chanCode
#debug uint chanCode
 WRX  SendTo~chanCode
#debug_left uint SendTo~chanCode
 LDX  RecvData
 WRX  SendTo~data
#debug_left pointer SendTo.data
 LEAX SendTo
 CAL  fbSendTo_L0
#srcline 223 ;      ResRecv    := false;
 LD   bool 0       ; false
 WRX  ResRecv
#debug_left bool ResRecv
#srcline 224 ;      LenRecv    := false;
 LD   bool 0       ; false
 WRX  LenRecv
#debug_left bool LenRecv
#srcline 225 ;      HeaderRecv := false;
 LD   bool 0       ; false
 WRX  HeaderRecv
#debug_left bool HeaderRecv
#srcline 226 ;      ContLen    := -1;
 LD   dint -1
 WRX  ContLen
#debug_left dint ContLen
#srcline 227 ;      State := hs_HttpSendPost;
 LD   udint 5  ; THttpState#hs_HttpSendPost
 WRX  State
#debug_left usint State
 JMP  fbHttpRequestL3_L9
fbHttpRequestL3_L47:
 LD   5
 LDY  P0__st__
 EQ  
 JMC  fbHttpRequestL3_L48
#srcline 228 ;    hs_HttpSendPost :
#srcline 229 ;      IF BodyLen > 0 THEN
 LDX  BodyLen
#debug uint BodyLen
 LD   uint 0
 GT
 JMC  fbHttpRequestL3_L49
#srcline 230 ;        SendTo(rq := 1, chanCode := chanCode, data := void(Data[lPostLen-BodyLen]), lenTx := MIN(512,BodyLen));
 LD   1
 WRX  SendTo~rq
#debug_left bool SendTo~rq
 LDX  chanCode
#debug uint chanCode
 WRX  SendTo~chanCode
#debug_left uint SendTo~chanCode
 LDX  Data
 LDX  lPostLen
#debug uint lPostLen
 LDX  BodyLen
#debug uint BodyLen
 SUB
 AND  $FFFF
 RCHK 1535   ; Range Check
 ADD     ; + offset 
 WRX  SendTo~data
#debug_left pointer SendTo.data
 LD   uint 512
 LDX  BodyLen
#debug uint BodyLen
 MIN
 WRX  SendTo~lenTx
#debug_left uint SendTo~lenTx
 LEAX SendTo
 CAL  fbSendTo_L0
#srcline 231 ;        IF SendTo.mesSent THEN
 LDX  SendTo~mesSent
#debug bool SendTo.mesSent
 JMC  fbHttpRequestL3_L51
#srcline 232 ;          BodyLen := BodyLen - MIN(512,BodyLen);
 LDX  BodyLen
#debug uint BodyLen
 LD   uint 512
 LDX  BodyLen
#debug uint BodyLen
 MIN
 SUB
 AND  $FFFF
 WRX  BodyLen
#debug_left uint BodyLen
#srcline 233 ;        END_IF;
fbHttpRequestL3_L51:
#srcline 234 ;      ELSE
 JMP  fbHttpRequestL3_L50
fbHttpRequestL3_L49:
#srcline 235 ;        State := hs_HttpReceivingData;
 LD   udint 4  ; THttpState#hs_HttpReceivingData
 WRX  State
#debug_left usint State
#srcline 236 ;      END_IF;
fbHttpRequestL3_L50:
 JMP  fbHttpRequestL3_L9
fbHttpRequestL3_L48:
 LD   4
 LDY  P0__st__
 EQ  
 JMC  fbHttpRequestL3_L53
#srcline 237 ;    hs_HttpReceivingData  :
#srcline 238 ;      RecvFrom(rq := 1, chanCode := chanCode, lenRx := 512, data := void(RecvData));
 LD   1
 WRX  RecvFrom~rq
#debug_left bool RecvFrom~rq
 LDX  chanCode
#debug uint chanCode
 WRX  RecvFrom~chanCode
#debug_left uint RecvFrom~chanCode
 LD   uint 512
 WRX  RecvFrom~lenRx
#debug_left uint RecvFrom~lenRx
 LDX  RecvData
 WRX  RecvFrom~data
#debug_left pointer RecvFrom.data
 LEAX RecvFrom
 CAL  fbRecvFrom_L0
#srcline 239 ;      IF RecvFrom.mesRec THEN                                                   //byla prijata data
 LDX  RecvFrom~mesRec
#debug bool RecvFrom.mesRec
 JMC  fbHttpRequestL3_L54
#srcline 240 ;        IF HeaderRecv THEN                                                      //uz byla prijata hlavicka
 LDX  HeaderRecv
#debug bool HeaderRecv
 JMC  fbHttpRequestL3_L56
#srcline 241 ;          DataLen := RecvFrom.lenData;                                          //delka dat je rovna delce prijateho paketu
 LDX  RecvFrom~lenData
#debug uint RecvFrom.lenData
 WRX  DataLen
#debug_left uint DataLen
#srcline 242 ;          ContLen := ContLen - UINT_TO_DINT(DataLen);                           //snizit contlen o prijatou delku
 LDX  ContLen
#debug dint ContLen
 LDX  DataLen
#debug uint DataLen
 SUB
 WRX  ContLen
#debug_left dint ContLen
#srcline 243 ;          pUsint  := ADR(RecvData);                                             //nastavit pointer na zacatek dat
 LDX  RecvData
#debug pointer RecvData
 LEAY pUsint
 WRIL 
#debug_left pointer pUsint
#srcline 244 ;        ELSE                                                                    //jeste nebyla prijata hlavicka
 JMP  fbHttpRequestL3_L57
fbHttpRequestL3_L56:
#srcline 245 ;          i := TO_UINT(MemcpyEx(length := MIN(TO_UDINT(RecvFrom.lenData), 255-TO_UDINT(sOff)),
 NXT
 LDX  RecvFrom~lenData
#debug uint RecvFrom.lenData
 LD   udint 255
 LDX  sOff
#debug uint sOff
 SUB
 MIN
 WR   __Instance__MemcpyEx~length
#debug_left udint __Instance__MemcpyEx~length
#srcline 246 ;               offDest := TO_UDINT(sOff),
 LDX  sOff
#debug uint sOff
 WR   __Instance__MemcpyEx~offDest
#debug_left udint __Instance__MemcpyEx~offDest
#srcline 247 ;               source := RecvData[0], dest := void(helpstring)));
 LDX  RecvData
 WR   __Instance__MemcpyEx~source
#debug_left pointer __Instance__MemcpyEx.source
 LEAX helpstring
 WR   __Instance__MemcpyEx~dest
#debug_left pointer __Instance__MemcpyEx.dest
 LD   0
 WR   __Instance__MemcpyEx~offSource
 PRV
 LEA  __Instance__MemcpyEx
 CAL  MemcpyEx_L0
 WRY  i
#debug_left uint i
#srcline 249 ;          sOff := sOff + i;
 LDX  sOff
#debug uint sOff
 LDY  i
#debug uint i
 ADD
 AND  $FFFF
 WRX  sOff
#debug_left uint sOff
#srcline 250 ;          rLen := RecvFrom.lenData - i;
 LDX  RecvFrom~lenData
#debug uint RecvFrom.lenData
 LDY  i
#debug uint i
 SUB
 AND  $FFFF
 WRX  rLen
#debug_left uint rLen
#srcline 252 ;          pUsint := ADR(helpstring) + TO_UDINT(sOff);
 LEAX helpstring
#debug pointer helpstring
 LDX  sOff
#debug uint sOff
 ADD
 LEAY pUsint
 WRIL 
#debug_left pointer pUsint
#srcline 253 ;          pUsint^ := 0;
 LD   usint 0
 LEAY pUsint
 LDIL    ; dereference 
 WRI 
#debug_left usint pUsint^
#srcline 255 ;          WHILE true DO
fbHttpRequestL3_L58:
 LD   bool -1       ; true
 JMC  fbHttpRequestL3_L59
 DBG 
#srcline 256 ;            i :=  FIND(IN1 := helpstring, IN2 := '$r$n');
 LEAX helpstring
#debug string helpstring
 LEA  _str_fbHttpRequestL3_14
 SFND 
 WRY  i
#debug_left uint i
#srcline 257 ;            IF i = 1 THEN //konec
 LDY  i
#debug uint i
 LD   uint 1
 EQ
 JMC  fbHttpRequestL3_L60
#srcline 258 ;              rLen := rLen - 2 + sOff - i + 1;
 LDX  rLen
#debug uint rLen
 LD   uint 2
 SUB
 AND  $FFFF
 LDX  sOff
#debug uint sOff
 ADD
 AND  $FFFF
 LDY  i
#debug uint i
 SUB
 AND  $FFFF
 LD   uint 1
 ADD
 AND  $FFFF
 WRX  rLen
#debug_left uint rLen
#srcline 259 ;              HeaderRecv := true;
 LD   bool -1       ; true
 WRX  HeaderRecv
#debug_left bool HeaderRecv
#srcline 260 ;              EXIT;
 JMP  fbHttpRequestL3_L59
#srcline 261 ;            ELSIF i > 1 THEN  //je tam enter
 JMP  fbHttpRequestL3_L61
fbHttpRequestL3_L60:
 LDY  i
#debug uint i
 LD   uint 1
 GT
 JMC  fbHttpRequestL3_L62
#srcline 262 ;              IF NOT ResRecv THEN
 LDX  ResRecv
#debug bool ResRecv
 NEG
 JMC  fbHttpRequestL3_L63
#srcline 263 ;                IF FIND(IN1 := helpstring, IN2 := 'HTTP') = 1 THEN      //vyhledani zda je to HTTP hlavicka
 LEAX helpstring
#debug string helpstring
 LEA  _str_fbHttpRequestL3_15
 SFND 
 LD   int 1
 EQ
 JMC  fbHttpRequestL3_L65
#srcline 264 ;                  ResRecv := true;                                      //prijat zacatek hlavicky
 LD   bool -1       ; true
 WRX  ResRecv
#debug_left bool ResRecv
#srcline 265 ;                  pHelpString := ADR(helpstring) + 9;                   //posunout pointer
 LEAX helpstring
#debug pointer helpstring
 LD   udint 9
 ADD
 LEAY pHelpString
 WRIL 
#debug_left pointer pHelpString
#srcline 266 ;                  Result := STRING_TO_INT(pHelpString^);                //rozkodovat navratovy kod
 LEAY pHelpString
 LDIL    ; dereference 
#debug string pHelpString^
 SCNV $300B;  IEC_STRING _TO_ IEC_INT
 WRX  Result
#debug_left int Result
#srcline 267 ;    //            Debug1       := pHelpString^;
#srcline 268 ;                END_IF;
fbHttpRequestL3_L65:
#srcline 269 ;              END_IF;
fbHttpRequestL3_L63:
#srcline 270 ;              IF NOT LenRecv THEN                                                   //hledat delku jen kdyz se jeste nenasla 121108
 LDX  LenRecv
#debug bool LenRecv
 NEG
 JMC  fbHttpRequestL3_L67
#srcline 271 ;                                                     //012345678901234
#srcline 272 ;                j := FIND(IN1 := helpstring, IN2 := 'Content-Length:');           //hledat delku tela
 LEAX helpstring
#debug string helpstring
 LEA  _str_fbHttpRequestL3_16
 SFND 
 WRY  j
#debug_left uint j
#srcline 273 ;                IF j > 0 AND j < i THEN                                            //nasla se delka
 LDY  j
#debug uint j
 LD   uint 0
 GT
 LDY  j
#debug uint j
 LDY  i
#debug uint i
 LT
 AND
 JMC  fbHttpRequestL3_L69
#srcline 274 ;                  LenRecv := true;                                                //nastavit priznak ze byla nalezena
 LD   bool -1       ; true
 WRX  LenRecv
#debug_left bool LenRecv
#srcline 275 ;                  pHelpString := ADR(helpstring) + UINT_TO_UDINT(j+15);           //posunout pointer
 LEAX helpstring
#debug pointer helpstring
 LDY  j
#debug uint j
 LD   uint 15
 ADD
 AND  $FFFF
 ADD
 LEAY pHelpString
 WRIL 
#debug_left pointer pHelpString
#srcline 276 ;                  ContLen     := STRING_TO_DINT(pHelpString^);                    //zapsat delku
 LEAY pHelpString
 LDIL    ; dereference 
#debug string pHelpString^
 SCNV $300D;  IEC_STRING _TO_ IEC_DINT
 WRX  ContLen
#debug_left dint ContLen
#srcline 277 ;      //            Debug2       := pHelpString^;
#srcline 278 ;                END_IF;
fbHttpRequestL3_L69:
#srcline 279 ;              END_IF;
fbHttpRequestL3_L67:
#srcline 280 ;              IF i = FIND(IN1 := helpstring, IN2 := '$r$n$r$n') THEN //konec
 LDY  i
#debug uint i
 LEAX helpstring
#debug string helpstring
 LEA  _str_fbHttpRequestL3_17
 SFND 
 EQ
 JMC  fbHttpRequestL3_L71
#srcline 281 ;                rLen := rLen - 4 + sOff - i + 1;
 LDX  rLen
#debug uint rLen
 LD   uint 4
 SUB
 AND  $FFFF
 LDX  sOff
#debug uint sOff
 ADD
 AND  $FFFF
 LDY  i
#debug uint i
 SUB
 AND  $FFFF
 LD   uint 1
 ADD
 AND  $FFFF
 WRX  rLen
#debug_left uint rLen
#srcline 282 ;                HeaderRecv := true;
 LD   bool -1       ; true
 WRX  HeaderRecv
#debug_left bool HeaderRecv
#srcline 283 ;                EXIT;
 JMP  fbHttpRequestL3_L59
#srcline 284 ;              END_IF;
fbHttpRequestL3_L71:
#srcline 285 ;              MemcpyEx(length := TO_UDINT(sOff - i), offSource := TO_UDINT(i) + 1,
 NXT
 LDX  sOff
#debug uint sOff
 LDY  i
#debug uint i
 SUB
 WR   __Instance__MemcpyEx~length
#debug_left udint __Instance__MemcpyEx~length
 LDY  i
#debug uint i
 LD   udint 1
 ADD
 WR   __Instance__MemcpyEx~offSource
#debug_left udint __Instance__MemcpyEx~offSource
#srcline 286 ;                       source := void(helpstring), dest := void(helpstring));
 LEAX helpstring
 WR   __Instance__MemcpyEx~source
#debug_left pointer __Instance__MemcpyEx.source
 LEAX helpstring
 WR   __Instance__MemcpyEx~dest
#debug_left pointer __Instance__MemcpyEx.dest
 LD   0
 WR   __Instance__MemcpyEx~offDest
 PRV
 LEA  __Instance__MemcpyEx
 CAL  MemcpyEx_L0
#srcline 287 ;              sOff := sOff - i - 1;
 LDX  sOff
#debug uint sOff
 LDY  i
#debug uint i
 SUB
 AND  $FFFF
 LD   uint 1
 SUB
 AND  $FFFF
 WRX  sOff
#debug_left uint sOff
#srcline 288 ;            ELSE
 JMP  fbHttpRequestL3_L61
fbHttpRequestL3_L62:
#srcline 289 ;              IF sOff = 255 THEN //je to bez enteru a plne - zahodit
 LDX  sOff
#debug uint sOff
 LD   uint 255
 EQ
 JMC  fbHttpRequestL3_L73
#srcline 290 ;                MemcpyEx(length := 1, offSource := 254,
 NXT
 LD   udint 1
 WR   __Instance__MemcpyEx~length
#debug_left udint __Instance__MemcpyEx~length
 LD   udint 254
 WR   __Instance__MemcpyEx~offSource
#debug_left udint __Instance__MemcpyEx~offSource
#srcline 291 ;                         source := void(helpstring), dest := void(helpstring));
 LEAX helpstring
 WR   __Instance__MemcpyEx~source
#debug_left pointer __Instance__MemcpyEx.source
 LEAX helpstring
 WR   __Instance__MemcpyEx~dest
#debug_left pointer __Instance__MemcpyEx.dest
 LD   0
 WR   __Instance__MemcpyEx~offDest
 PRV
 LEA  __Instance__MemcpyEx
 CAL  MemcpyEx_L0
#srcline 292 ;                sOff := 1;
 LD   uint 1
 WRX  sOff
#debug_left uint sOff
#srcline 293 ;              END_IF;
fbHttpRequestL3_L73:
#srcline 294 ;            END_IF;
fbHttpRequestL3_L61:
#srcline 296 ;            IF rLen > 0 THEN
 LDX  rLen
#debug uint rLen
 LD   uint 0
 GT
 JMC  fbHttpRequestL3_L75
#srcline 297 ;              i := TO_UINT(MemcpyEx(length := MIN(TO_UDINT(rLen), 255-TO_UDINT(sOff)),
 NXT
 LDX  rLen
#debug uint rLen
 LD   udint 255
 LDX  sOff
#debug uint sOff
 SUB
 MIN
 WR   __Instance__MemcpyEx~length
#debug_left udint __Instance__MemcpyEx~length
#srcline 298 ;                   offDest := TO_UDINT(sOff),
 LDX  sOff
#debug uint sOff
 WR   __Instance__MemcpyEx~offDest
#debug_left udint __Instance__MemcpyEx~offDest
#srcline 299 ;                   offSource := TO_UDINT(RecvFrom.lenData) - TO_UDINT(rLen),
 LDX  RecvFrom~lenData
#debug uint RecvFrom.lenData
 LDX  rLen
#debug uint rLen
 SUB
 WR   __Instance__MemcpyEx~offSource
#debug_left udint __Instance__MemcpyEx~offSource
#srcline 300 ;                   source := RecvData[0], dest := void(helpstring)));
 LDX  RecvData
 WR   __Instance__MemcpyEx~source
#debug_left pointer __Instance__MemcpyEx.source
 LEAX helpstring
 WR   __Instance__MemcpyEx~dest
#debug_left pointer __Instance__MemcpyEx.dest
 PRV
 LEA  __Instance__MemcpyEx
 CAL  MemcpyEx_L0
 WRY  i
#debug_left uint i
#srcline 301 ;              sOff := sOff + i;
 LDX  sOff
#debug uint sOff
 LDY  i
#debug uint i
 ADD
 AND  $FFFF
 WRX  sOff
#debug_left uint sOff
#srcline 302 ;              rLen := rLen - i;
 LDX  rLen
#debug uint rLen
 LDY  i
#debug uint i
 SUB
 AND  $FFFF
 WRX  rLen
#debug_left uint rLen
#srcline 303 ;              pUsint := ADR(helpstring) + TO_UDINT(sOff);
 LEAX helpstring
#debug pointer helpstring
 LDX  sOff
#debug uint sOff
 ADD
 LEAY pUsint
 WRIL 
#debug_left pointer pUsint
#srcline 304 ;              pUsint^ := 0;
 LD   usint 0
 LEAY pUsint
 LDIL    ; dereference 
 WRI 
#debug_left usint pUsint^
#srcline 305 ;            ELSIF i = 0 THEN
 JMP  fbHttpRequestL3_L76
fbHttpRequestL3_L75:
 LDY  i
#debug uint i
 LD   uint 0
 EQ
 JMC  fbHttpRequestL3_L77
#srcline 306 ;              EXIT;
 JMP  fbHttpRequestL3_L59
#srcline 307 ;            END_IF;
 JMP  fbHttpRequestL3_L76
fbHttpRequestL3_L77:
fbHttpRequestL3_L76:
#srcline 308 ;          END_WHILE;
 JMP  fbHttpRequestL3_L58
fbHttpRequestL3_L59:
 NOP  -1
#srcline 310 ;          DataLen := 0;
 LD   uint 0
 WRX  DataLen
#debug_left uint DataLen
#srcline 311 ;          IF HeaderRecv THEN
 LDX  HeaderRecv
#debug bool HeaderRecv
 JMC  fbHttpRequestL3_L78
#srcline 312 ;            IF rLen > 0 THEN
 LDX  rLen
#debug uint rLen
 LD   uint 0
 GT
 JMC  fbHttpRequestL3_L80
#srcline 313 ;              DataLen := rLen;
 LDX  rLen
#debug uint rLen
 WRX  DataLen
#debug_left uint DataLen
#srcline 314 ;              rLen := RecvFrom.lenData - rLen;
 LDX  RecvFrom~lenData
#debug uint RecvFrom.lenData
 LDX  rLen
#debug uint rLen
 SUB
 AND  $FFFF
 WRX  rLen
#debug_left uint rLen
#srcline 315 ;              Memcpy(length := DataLen, source := RecvData[rLen], dest := RecvData[0]);
 NXT
 LDX  DataLen
#debug uint DataLen
 WR   __Instance__Memcpy~length
#debug_left uint __Instance__Memcpy~length
 LDX  RecvData
 LDX  rLen
#debug uint rLen
 RCHK 511   ; Range Check
 ADD     ; + offset 
 WR   __Instance__Memcpy~source
#debug_left pointer __Instance__Memcpy.source
 LDX  RecvData
 WR   __Instance__Memcpy~dest
#debug_left pointer __Instance__Memcpy.dest
 PRV
 LEA  __Instance__Memcpy
 CAL  Memcpy_L0
#srcline 316 ;            END_IF;
fbHttpRequestL3_L80:
#srcline 317 ;            WholeLen := ContLen;                                                //zapamatovat si kolik jeste budu prijimat
 LDX  ContLen
#debug dint ContLen
 WRX  WholeLen
#debug_left dint WholeLen
#srcline 318 ;            ContLen  := ContLen - TO_DINT(DataLen);                         //odecist delku od celkove delky k prijmuti
 LDX  ContLen
#debug dint ContLen
 LDX  DataLen
#debug uint DataLen
 SUB
 WRX  ContLen
#debug_left dint ContLen
#srcline 319 ;          END_IF;
fbHttpRequestL3_L78:
#srcline 320 ;        END_IF;
fbHttpRequestL3_L57:
#srcline 321 ;        DataReady := DataLen > 0;                                               //vydat priznak ze byla prijata data
 LDX  DataLen
#debug uint DataLen
 LD   uint 0
 GT
 WRX  DataReady
#debug_left bool DataReady
#srcline 322 ;      ELSE                                                                      //nic neprislo
 JMP  fbHttpRequestL3_L55
fbHttpRequestL3_L54:
#srcline 323 ;        DataLen := 0;
 LD   uint 0
 WRX  DataLen
#debug_left uint DataLen
#srcline 324 ;      END_IF;
fbHttpRequestL3_L55:
#srcline 326 ;      //bDebug := NOT IsEstabTCPconnection(chanCode := chanCode) & ContLen > 0 & NOT DataReady;
#srcline 328 ;      IF NOT IsEstabTCPconnection(chanCode := chanCode) & NOT DataReady THEN //spojeni se zavrelo a nejsou zadna data
 NXT
 LDX  chanCode
#debug uint chanCode
 WR   __Instance__IsEstabTCPconnection~chanCode
#debug_left uint __Instance__IsEstabTCPconnection~chanCode
 PRV
 LEA  __Instance__IsEstabTCPconnection
 CAL  IsEstabTCPconnection_L0
 NEG
 LDX  DataReady
#debug bool DataReady
 NEG
 AND
 JMC  fbHttpRequestL3_L82
#srcline 329 ;        Err    := ContLen > 0;                                               //jeste jsem mel neco prijmout => Error
 LDX  ContLen
#debug dint ContLen
 LD   dint 0
 GTS
 WRX  Err
#debug_left bool Err
#srcline 330 ;        IF Err THEN
 LDX  Err
#debug bool Err
 JMC  fbHttpRequestL3_L84
#srcline 331 ;          ErrId := 2;
 LD   usint 2
 WRX  ErrId
#debug_left usint ErrId
#srcline 332 ;        END_IF;
fbHttpRequestL3_L84:
#srcline 333 ;//        ErrId  := BOOL_TO_USINT(Err)*2; //Set 2 if error occured
#srcline 334 ;        Done   := NOT Err;                                                   //pokud nebyl error je hotovo
 LDX  Err
#debug bool Err
 NEG
 WRX  Done
#debug_left bool Done
#srcline 335 ;        State  := hs_HttpIdle;                                               //klidovy stav
 LD   udint 0  ; THttpState#hs_HttpIdle
 WRX  State
#debug_left usint State
#srcline 336 ;      END_IF;
fbHttpRequestL3_L82:
#srcline 338 ;      IF Close & ContLen = 0 THEN
 LDX  Close
#debug bool Close
 LDX  ContLen
#debug dint ContLen
 LD   dint 0
 EQ
 AND
 JMC  fbHttpRequestL3_L86
#srcline 339 ;        CloseTCPconnection(chanCode := chanCode);
 NXT
 LDX  chanCode
#debug uint chanCode
 WR   __Instance__CloseTCPconnection~chanCode
#debug_left uint __Instance__CloseTCPconnection~chanCode
 PRV
 LEA  __Instance__CloseTCPconnection
 CAL  CloseTCPconnection_L0
#srcline 340 ;      END_IF;
fbHttpRequestL3_L86:
 JMP  fbHttpRequestL3_L9
fbHttpRequestL3_L53:
fbHttpRequestL3_L9:
#srcline 344 ;  IF Busy THEN
 LDX  Busy
#debug bool Busy
 JMC  fbHttpRequestL3_L88
#srcline 345 ;    IF WholeLen > 0 THEN
 LDX  WholeLen
#debug dint WholeLen
 LD   dint 0
 GTS
 JMC  fbHttpRequestL3_L90
#srcline 346 ;      Progress := DINT_TO_SINT(((WholeLen - ContLen) * 100 + WholeLen / 2) / WholeLen);
 LDX  WholeLen
#debug dint WholeLen
 LDX  ContLen
#debug dint ContLen
 SUB
 LD   dint 100
 MULS
 LDX  WholeLen
#debug dint WholeLen
 LD   dint 2
 DIVS
 ADD
 LDX  WholeLen
#debug dint WholeLen
 DIVS
 EXTB
 WRX  Progress
#debug_left sint Progress
#srcline 347 ;    ELSE
 JMP  fbHttpRequestL3_L91
fbHttpRequestL3_L90:
#srcline 348 ;      Progress := -1;
 LD   sint -1
 WRX  Progress
#debug_left sint Progress
#srcline 349 ;    END_IF;
fbHttpRequestL3_L91:
#srcline 350 ;  END_IF;
fbHttpRequestL3_L88:
#srcline 352 ;END_FUNCTION_BLOCK
fbHttpRequestL3_RET:
 ULNK
RET
E     61

; Initialize - variables
P     61
fbHttpRequestL3__InstanceInit__:
 LINK 0
 LD   uint 80
 WRX  port
 LEAX RecvFrom
 CAL  fbRecvFrom__InstanceInit__
 LEAX SendTo
 CAL  fbSendTo__InstanceInit__
 ULNK
RET
E     61
; End initialize - variables
#endpou 



 

#srcfile ''
#srcfile 'C:\TECOLIBSRC\INTERNETLIB\INTERNETLIBVCONTROL\FBWEBSOCKETCLIENT.ST'
#pou _internetlib_SwpUint
#srcline 25 ;FUNCTION _internetlib_SwpUint {HIDDEN} : UINT
P     61
_internetlib_SwpUint_L0:
 LINK 0
 NXT
#srcline 33 ;begin
#srcline 34 ;  {asm}
#srcline 35
	  ldx    in
#srcline 36
    swp				                ;prohodit spodni horni byte
#srcline 37
	  wrx    __fc___internetlib_SwpUint
#srcline 38 ;  {end_asm}
#srcline 39 ;END_FUNCTION
 PRV  
 LDX  __fc___internetlib_SwpUint
 ULNK
RET
E     61
#endpou 

#pou _internetlib_fbRandUdint
#srcline 41 ;FUNCTION_BLOCK _internetlib_fbRandUdint {HIDDEN}
P     61
_internetlib_fbRandUdint_L0:
 LINK 0
#srcline 61 ;  if seed = 0 then
 LDX  seed
#debug dint seed
 LD   dint 0
 EQ
 JMC  _internetlib_fbRandUdint_L1
#srcline 62 ;    seed := %SL52 + %SL5;  // init
 LD   %SL52
 LD   %SL5
 ADD
 WRX  seed
#debug_left dint seed
#srcline 63 ;  end_if;
_internetlib_fbRandUdint_L1:
#srcline 65 ;  k := seed / 127773;
 LDX  seed
#debug dint seed
 LD   dint 127773
 DIVS
 WRX  k
#debug_left dint k
#srcline 67 ;  seed := 16807 * ( seed - k * 127773 ) - k * 2836;
 LD   dint 16807
 LDX  seed
#debug dint seed
 LDX  k
#debug dint k
 LD   dint 127773
 MULS
 SUB
 MULS
 LDX  k
#debug dint k
 LD   dint 2836
 MULS
 SUB
 WRX  seed
#debug_left dint seed
#srcline 69 ;  IF  seed < 0 THEN
 LDX  seed
#debug dint seed
 LD   dint 0
 LTS
 JMC  _internetlib_fbRandUdint_L3
#srcline 70 ;    seed := seed + 2147483647;
 LDX  seed
#debug dint seed
 LD   dint 2147483647
 ADD
 WRX  seed
#debug_left dint seed
#srcline 71 ;  END_IF;
_internetlib_fbRandUdint_L3:
#srcline 73 ;  out := DINT_TO_UDINT( seed);
 LDX  seed
#debug dint seed
 LDX  out
 WRIL 
#debug_left udint out
#srcline 74 ;END_FUNCTION_BLOCK
 ULNK
RET
E     61
#endpou 

#pou fbWebSocketClient
#srcline 77 ;FUNCTION_BLOCK fbWebSocketClient

#struct fbWebSocketClient__temp__
  pointer pUint,
  int pos,
  uint i,
  udint[4] wsKey,
  pointer ptrAnswer,
  string[256] wsHeader,
  string[256] wsHeader_,  ; pro jistotu (kdyby vysla delsi hlavicka)
  uint P0__st__,
  uint P1__st__,
  uint P2__st__,
  byte P3__st__,
  string[257] PS0__st__,
  string[82] PS1__st__,
  string[257] PSC__st__
#data byte _str_fbWebSocketClient_0 = 
  'f','b','W','e','b','S','o','c','k','e','t','C','l','i','e','n','t',' ','i','s',
  ' ','n','o','t',' ','s','u','p','p','o','r','t','e','d',' ','o','n',' ','t','h',
  'i','s',' ','P','L','C','!',0
#data byte _str_fbWebSocketClient_1 = 
  '',0
#data byte _str_fbWebSocketClient_2 = 
  'f','b','N','s','L','o','o','k','U','p','E','x',' ','e','r','r','o','r',':',' ',0
#data byte _str_fbWebSocketClient_3 = 
  'w','s','s',':',0
#data byte _str_fbWebSocketClient_4 = 
  'O','p','e','n','U','n','i','S','o','c','k','e','t',' ','f','a','i','l','e','d',
  '!',0
#data byte _str_fbWebSocketClient_5 = 
  '/',0
#data byte _str_fbWebSocketClient_6 = 
  $0D,$0A,$0D,$0A,0
#data byte _str_fbWebSocketClient_7 = 
  'H','T','T','P','/','1','.','1',' ','1','0','1',0
#data byte _str_fbWebSocketClient_8 = 
  'u','p','g','r','a','d','e',':',' ','w','e','b','s','o','c','k','e','t',0
#data byte _str_fbWebSocketClient_9 = 
  'c','o','n','n','e','c','t','i','o','n',':',' ','u','p','g','r','a','d','e',0
#data byte _str_fbWebSocketClient_10 = 
  's','e','c','-','w','e','b','s','o','c','k','e','t','-','a','c','c','e','p','t',
  ':',0
#data byte _str_fbWebSocketClient_11 = 
  $0D,$0A,0
#data byte _str_fbWebSocketClient_12 = 
  'C','o','n','n','e','c','t','i','o','n',' ','w','i','t','h',' ','s','e','r','v',
  'e','r',' ','w','a','s',' ','l','o','s','t','!',0
#data byte _str_fbWebSocketClient_13 = 
  'S','e','n','d','i','n','g',' ','m','e','s','s','a','g','e',' ','i','s',' ','l',
  'o','n','g','e','r',' ','t','h','e','n',' ','%','d',' ','b','y','t','e','s','!',0
#data byte _str_fbWebSocketClient_14 = 
  'S','e','n','d','i','n','g',' ','e','r','r','o','r',':',' ',0
#data byte _str_fbWebSocketClient_15 = 
  'R','e','c','e','i','v','i','n','g',' ','e','r','r','o','r',':',' ',0
#data byte _str_fbWebSocketClient_16 = 
  'R','e','c','e','i','v','i','n','g',' ','m','e','s','s','a','g','e',' ','i','s',
  ' ','l','o','n','g','e','r',' ','t','h','e','n',' ','%','d',' ','b','y','t','e',
  's','!',0
#data byte _str_fbWebSocketClient_17 = 
  'U','n','s','u','p','p','o','r','t','e','d',' ','l','e','n','g','t','h',' ','o',
  'f',' ','r','e','c','e','i','v','e','d',' ','w','e','b','s','o','c','k','e','t',
  ' ','m','e','s','s','a','g','e','!',0
#data byte _str_fbWebSocketClient_18 = 
  'W','e','b',' ','S','o','c','k','e','t',' ','f','r','a','g','m','e','n','t','a',
  't','i','o','n',' ','i','s',' ','n','o','t',' ','s','u','p','p','o','r','t','e',
  'd','!',0
#data byte _str_fbWebSocketClient_19 = 
  'W','e','b',' ','S','o','c','k','e','t',' ','f','r','a','g','m','e','n','t','a',
  't','i','o','n',' ','i','s',' ','n','o','t',' ','s','u','p','p','o','r','t','e',
  'd','!',0
#data byte _str_fbWebSocketClient_20 = 
  'T','h','e',' ','s','e','r','v','e','r',' ','r','e','q','u','e','s','t','s',' ',
  't','o',' ','c','l','o','s','e',' ','t','h','e',' ','c','o','n','n','e','c','t',
  'i','o','n','!',0
#data byte _str_fbWebSocketClient_21 = 
  'C','o','n','n','e','c','t','i','o','n',' ','w','a','s',' ','c','l','o','s','e',
  'd',' ','b','y',' ','t','h','e',' ','s','e','r','v','e','r','!',0
#data byte _str_fbWebSocketClient_22 = 
  '',0
#data byte _str_fbWebSocketClient_23 = 
  'U','n','a','b','l','e',' ','t','o',' ','g','e','t',' ','s','e','r','v','e','r',
  ' ','I','P',' ','a','d','d','r','e','s','s','!',0
P     61
fbWebSocketClient_L0:
 LINK __SizeOf(fbWebSocketClient__temp__)
; Initialize - dynamic variables
 LD   udint $FFFFFFFF    ; nil
 WRY  pUint
 LD   udint $FFFFFFFF    ; nil
 WRY  ptrAnswer
; End initialize - dynamic variables
#srcline 152 ;  IF ( System_S.S42 <> 16#49 ) and ( System_S.S42 <> 16#4A ) THEN
 LD   System_S~S42
#debug byte System_S.S42
 LD   byte $49
 EQ
 NEG
 LD   System_S~S42
#debug byte System_S.S42
 LD   byte $4A
 EQ
 NEG
 AND
 JMC  fbWebSocketClient_L1
#srcline 153 ;    isError := 1; lastErrDesc := 'fbWebSocketClient is not supported on this PLC!';  // chyba, neni to CPU rady I nebo J
 LD   bool -1      ; true
 WRX  isError
#debug_left bool isError
 LD   0   ; null string
 LEAX lastErrDesc
 WRI  
 LEAX lastErrDesc
 LD   80
 DST    ; Level 1
 LEA  _str_fbWebSocketClient_0
 SCON 
#debug_left string lastErrDesc
 PDST   ; Level 1
#srcline 154 ;    return;
 JMP  fbWebSocketClient_RET
#srcline 155 ;  END_IF;
fbWebSocketClient_L1:
#srcline 157 ;  isError := 0; ConnectTrg(CLK := rqConnect);
 LD   bool 0       ; false
 WRX  isError
#debug_left bool isError
 LDX  rqConnect
#debug bool rqConnect
 WRX  ConnectTrg~CLK
#debug_left bool ConnectTrg~CLK
 LEAX ConnectTrg
 CAL  R_TRIG_L0
#srcline 158 ;  IF ConnectTrg.Q THEN
 LDX  ConnectTrg~Q
#debug bool ConnectTrg.Q
 JMC  fbWebSocketClient_L3
#srcline 159 ;    lastErrDesc := '';
 LD   0   ; null string
 LEAX lastErrDesc
 WRI  
 LEAX lastErrDesc
 LD   80
 DST    ; Level 1
 LEA  _str_fbWebSocketClient_1
 SCON 
#debug_left string lastErrDesc
 PDST   ; Level 1
#srcline 160 ;    Memset(val := 0, length := sizeof(recvData), dest := void(recvData));
 NXT
 LD   udint 0
 WR   __Instance__Memset~val
#debug_left udint __Instance__Memset~val
 LD   1445  ; SizeOf()
 WR   __Instance__Memset~length
#debug_left uint __Instance__Memset~length
 LEAX recvData
 WR   __Instance__Memset~dest
#debug_left pointer __Instance__Memset.dest
 PRV
 LEA  __Instance__Memset
 CAL  Memset_L0
#srcline 161 ;    Memset(val := 0, length := sizeof(sendData), dest := void(sendData));
 NXT
 LD   udint 0
 WR   __Instance__Memset~val
#debug_left udint __Instance__Memset~val
 LD   1449  ; SizeOf()
 WR   __Instance__Memset~length
#debug_left uint __Instance__Memset~length
 LEAX sendData
 WR   __Instance__Memset~dest
#debug_left pointer __Instance__Memset.dest
 PRV
 LEA  __Instance__Memset
 CAL  Memset_L0
#srcline 162 ;    sumaSend := 0; sumaRecv := 0;
 LD   udint 0
 WRX  sumaSend
#debug_left udint sumaSend
 LD   udint 0
 WRX  sumaRecv
#debug_left udint sumaRecv
#srcline 163 ;  END_IF;
fbWebSocketClient_L3:
#srcline 165 ;  // zjistit IP adresu serveru
#srcline 166 ;  Split(split := rqConnect, urlAddress := serverUrl, host := HttpName, action := Action, ipAdr := serverAdr.remoteIP, port := serverAdr.remotePort);
 LDX  rqConnect
#debug bool rqConnect
 WRX  Split~split
#debug_left bool Split~split
 LEAX serverUrl
 WRX  Split~urlAddress
#debug_left pointer Split.urlAddress
 LEAX HttpName
 WRX  Split~host
#debug_left pointer Split.host
 LEAX Action
 WRX  Split~action
#debug_left pointer Split.action
 LEAX serverAdr
 WRX  Split~ipAdr
#debug_left pointer Split.ipAdr
 LEAX serverAdr
 ADD  4  ; + offset 
 WRX  Split~port
#debug_left pointer Split.port
 LEAX Split
 CAL  fbSplitUrlAddress_L0
#srcline 167 ;  IF Split.err THEN
 LDX  Split~err
#debug bool Split.err
 JMC  fbWebSocketClient_L5
#srcline 168 ;    isError := 1; lastErrDesc := 'fbNsLookUpEx error: ' + USINT_TO_STRING(Split.errId);
 LD   bool -1      ; true
 WRX  isError
#debug_left bool isError
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   80
 DST    ; Level 1
 LEA  _str_fbWebSocketClient_2
 SCON 
 LD   0   ; null string
 WRY  PSC__st__[0]
 LEAY PSC__st__[0]
 LD   80
 DST    ; Level 2
 LDX  Split~errId
#debug usint Split.errId
 SCNV $0830;  IEC_USINT _TO_ IEC_STRING
 PDST   ; Level 2
 LEAY PSC__st__[0]

 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX lastErrDesc
 WRI  
 LEAX lastErrDesc
 LD   80
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string lastErrDesc
 PDST   ; Level 1
#srcline 169 ;  END_IF;
fbWebSocketClient_L5:
#srcline 171 ;  // nastavit pozadavek na web socket komunikaci
#srcline 172 ;  IF Split.done THEN
 LDX  Split~done
#debug bool Split.done
 JMC  fbWebSocketClient_L7
#srcline 173 ;    rqWebSocket := 1;      // byl pozadavek na connect a byla zjistena IP adresa serveru
 LD   bool -1      ; true
 WRX  rqWebSocket
#debug_left bool rqWebSocket
#srcline 174 ;  END_IF;
fbWebSocketClient_L7:
#srcline 175 ;  IF NOT rqConnect THEN
 LDX  rqConnect
#debug bool rqConnect
 NEG
 JMC  fbWebSocketClient_L9
#srcline 176 ;    rqWebSocket := 0;      // neni pozadavek na connect
 LD   bool 0       ; false
 WRX  rqWebSocket
#debug_left bool rqWebSocket
#srcline 177 ;  END_IF;
fbWebSocketClient_L9:
#srcline 179 ;  // otevrit TCP socket
#srcline 180 ;  IF (hSocket = 0) AND rqWebSocket THEN
 LDX  hSocket
#debug uint hSocket
 LD   uint 0
 EQ
 LDX  rqWebSocket
#debug bool rqWebSocket
 AND
 JMC  fbWebSocketClient_L11
#srcline 181 ;    protocol := UNI_TCP_CLIENT;
 LD   usint 33
 WRX  protocol
#debug_left usint protocol
#srcline 182 ;    IF FIND(IN1 := serverUrl, IN2 := 'wss:') = 1 THEN
 LEAX serverUrl
#debug string serverUrl
 LEA  _str_fbWebSocketClient_3
 SFND 
 LD   int 1
 EQ
 JMC  fbWebSocketClient_L13
#srcline 183 ;      protocol := UNI_SSL_CLIENT;
 LD   usint 35
 WRX  protocol
#debug_left usint protocol
#srcline 184 ;    END_IF;
fbWebSocketClient_L13:
#srcline 185 ;    hSocket := OpenUniSocket( myIP  := ANY_IP, myPort  := 0, hisIP := ANY_IP, hisPort := 0, protocol := protocol);
 NXT
 LEA  ANY_IP
#debug pointer ANY_IP
 SRC  %IB0
 LEA  __Instance__OpenUniSocket~myIP
#debug_left pointer __Instance__OpenUniSocket~myIP
 LD   4   ;SizeOf() 
 MOV  %IB0
 LD   uint 0
 WR   __Instance__OpenUniSocket~myPort
#debug_left uint __Instance__OpenUniSocket~myPort
 LEA  ANY_IP
#debug pointer ANY_IP
 SRC  %IB0
 LEA  __Instance__OpenUniSocket~hisIP
#debug_left pointer __Instance__OpenUniSocket~hisIP
 LD   4   ;SizeOf() 
 MOV  %IB0
 LD   uint 0
 WR   __Instance__OpenUniSocket~hisPort
#debug_left uint __Instance__OpenUniSocket~hisPort
 LDX  protocol
#debug usint protocol
 WR   __Instance__OpenUniSocket~protocol
#debug_left usint __Instance__OpenUniSocket~protocol
 PRV
 LEA  __Instance__OpenUniSocket
 CAL  OpenUniSocket_L0
 WRX  hSocket
#debug_left uint hSocket
#srcline 186 ;    IF hSocket = 0 THEN
 LDX  hSocket
#debug uint hSocket
 LD   uint 0
 EQ
 JMC  fbWebSocketClient_L15
#srcline 187 ;      isError := 1; lastErrDesc := 'OpenUniSocket failed!';
 LD   bool -1      ; true
 WRX  isError
#debug_left bool isError
 LD   0   ; null string
 LEAX lastErrDesc
 WRI  
 LEAX lastErrDesc
 LD   80
 DST    ; Level 1
 LEA  _str_fbWebSocketClient_4
 SCON 
#debug_left string lastErrDesc
 PDST   ; Level 1
#srcline 188 ;    END_IF;
fbWebSocketClient_L15:
#srcline 189 ;    IF logSizeKB > 0 THEN
 LDX  logSizeKB
#debug uint logSizeKB
 LD   uint 0
 GT
 JMC  fbWebSocketClient_L17
#srcline 190 ;      SetUniLog( chanHandle := hSocket, logMode := logMode, logSizeKB := UINT_TO_UDINT( logSizeKB), logName := logFileName);  // log pro kontrolu komunikace
 NXT
 LDX  hSocket
#debug uint hSocket
 WR   __Instance__SetUniLog~chanHandle
#debug_left uint __Instance__SetUniLog~chanHandle
 LDX  logMode
#debug uint logMode
 WR   __Instance__SetUniLog~logMode
#debug_left uint __Instance__SetUniLog~logMode
 LDX  logSizeKB
#debug uint logSizeKB
 WR   __Instance__SetUniLog~logSizeKB
#debug_left udint __Instance__SetUniLog~logSizeKB
 LD   0   ; null string
 LEA  __Instance__SetUniLog~logName
 WRI 
 LEA  __Instance__SetUniLog~logName
 LD   80
 DST    ; Level 1
 LEAX logFileName
#debug string logFileName
 SCON 
#debug_left string __Instance__SetUniLog~logName
 PDST   ; Level 1
 PRV
 LEA  __Instance__SetUniLog
 CAL  SetUniLog_L0
#srcline 191 ;    END_IF;
fbWebSocketClient_L17:
#srcline 192 ;  END_IF;
fbWebSocketClient_L11:
#srcline 194 ;  // nastavit IP adresu serveru
#srcline 195 ;  setAdr := SetRemoteIPaddress(rq := rqWebSocket AND (serverAdr.remoteIP <> ANY_IP), chanCode := hSocket, ethAdr :=  serverAdr);
 NXT
 LDX  rqWebSocket
#debug bool rqWebSocket
 LEAX serverAdr~remoteIP
 LEA  ANY_IP
 LD   4   ; SizeOf()
 BCMP 
 EQ   0
 NEG
 AND
 WR   __Instance__SetRemoteIPaddress~rq
#debug_left bool __Instance__SetRemoteIPaddress~rq
 LDX  hSocket
#debug uint hSocket
 WR   __Instance__SetRemoteIPaddress~chanCode
#debug_left uint __Instance__SetRemoteIPaddress~chanCode
 LEAX serverAdr
 WR   __Instance__SetRemoteIPaddress~ethAdr
#debug_left pointer __Instance__SetRemoteIPaddress.ethAdr
 PRV
 LEA  __Instance__SetRemoteIPaddress
 CAL  SetRemoteIPaddress_L0
 WRX  setAdr
#debug_left bool setAdr
#srcline 197 ;  // navazat spojeni se serverem
#srcline 198 ;  IF setAdr THEN
 LDX  setAdr
#debug bool setAdr
 JMC  fbWebSocketClient_L19
#srcline 199 ;    EstabTCPconnection(chanCode := hSocket); rqSendHeader := 1;
 NXT
 LDX  hSocket
#debug uint hSocket
 WR   __Instance__EstabTCPconnection~chanCode
#debug_left uint __Instance__EstabTCPconnection~chanCode
 PRV
 LEA  __Instance__EstabTCPconnection
 CAL  EstabTCPconnection_L0
 LD   bool -1      ; true
 WRX  rqSendHeader
#debug_left bool rqSendHeader
#srcline 200 ;  END_IF;
fbWebSocketClient_L19:
#srcline 202 ;  IF IsEstabTCPconnection(chanCode := hSocket) THEN             // spojeni je navazane
 NXT
 LDX  hSocket
#debug uint hSocket
 WR   __Instance__IsEstabTCPconnection~chanCode
#debug_left uint __Instance__IsEstabTCPconnection~chanCode
 PRV
 LEA  __Instance__IsEstabTCPconnection
 CAL  IsEstabTCPconnection_L0
 JMC  fbWebSocketClient_L21
#srcline 203 ;    IF NOT isConnected THEN                                     // jeste neni web socket komunikace
 LDX  isConnected
#debug bool isConnected
 NEG
 JMC  fbWebSocketClient_L23
#srcline 204 ;      IF rqSendHeader THEN                                      // sestavit web socket header
 LDX  rqSendHeader
#debug bool rqSendHeader
 JMC  fbWebSocketClient_L25
#srcline 205 ;        IF LEN( Action) = 0 THEN Action := '/'; END_IF;
 LEAX Action
#debug string Action
 SLEN 
 LD   int 0
 EQ
 JMC  fbWebSocketClient_L27
 LD   0   ; null string
 LEAX Action
 WRI  
 LEAX Action
 LD   80
 DST    ; Level 1
 LEA  _str_fbWebSocketClient_5
 SCON 
#debug_left string Action
 PDST   ; Level 1
fbWebSocketClient_L27:
#srcline 206 ;        wsHeader := wsHeader0 + Action + wsHeader1 + HttpName + wsHeader2;
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LEA  __Const__fbWebSocketClient_wsHeader0
 SCON 
 LEAX Action
#debug string Action
 SCON 
 LEA  __Const__fbWebSocketClient_wsHeader1
 SCON 
 LEAX HttpName
#debug string HttpName
 SCON 
 LEA  __Const__fbWebSocketClient_wsHeader2
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAY wsHeader
 WRI  
 LEAY wsHeader
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string wsHeader
 PDST   ; Level 1
#srcline 207 ;        FOR i := 0 TO 3 DO                                      // celkem 16 nahodnych bytu
 LD   uint 0
 WRY  i
 LD   uint 3
 WRY  P0__st__
fbWebSocketClient_L29:
 LDY  i
 LDY  P0__st__
 GT   
 JMD  fbWebSocketClient_L30
 DBG  
#srcline 208 ;          RandomNum(out := wsKey[i]);
 LEAY wsKey
 LDY  i
#debug uint i
 RCHK 3   ; Range Check
 MUL  4   ; SizeOf(...)
 ADD     ; + offset 
 WRX  RandomNum~out
#debug_left pointer RandomNum.out
 LEAX RandomNum
 CAL  _internetlib_fbRandUdint_L0
#srcline 209 ;        END_FOR;
 LDY  i
 LD   1
 ADD  
 WRY  i
 JMP  fbWebSocketClient_L29
fbWebSocketClient_L30:
 NOP  -1
#srcline 210 ;        Base64_encode(dataLen := sizeof(wsKey), bufferLen := sizeof(wsKey64), data := void(wsKey), out := void(wsKey64));
 NXT
 LD   16  ; SizeOf()
 WR   __Instance__Base64_encode~dataLen
#debug_left uint __Instance__Base64_encode~dataLen
 LD   33  ; SizeOf()
 WR   __Instance__Base64_encode~bufferLen
#debug_left uint __Instance__Base64_encode~bufferLen
 LEAY wsKey
 WR   __Instance__Base64_encode~data
#debug_left pointer __Instance__Base64_encode.data
 LEAX wsKey64
 WR   __Instance__Base64_encode~out
#debug_left pointer __Instance__Base64_encode.out
 PRV
 LEA  __Instance__Base64_encode
 CAL  Base64_encode_L0
#srcline 211 ;        wsHeader := wsHeader + wsKey64 + wsHeader3;
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LEAY wsHeader
#debug string wsHeader
 SCON 
 LEAX wsKey64
#debug string wsKey64
 SCON 
 LEA  __Const__fbWebSocketClient_wsHeader3
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAY wsHeader
 WRI  
 LEAY wsHeader
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string wsHeader
 PDST   ; Level 1
#srcline 212 ;        IF LEN(wsOptHeader) > 0 THEN
 LEAX wsOptHeader
#debug string wsOptHeader
 SLEN 
 LD   int 0
 GTS
 JMC  fbWebSocketClient_L31
#srcline 213 ;          wsHeader := wsHeader + wsOptHeader + wsHeader4;
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LEAY wsHeader
#debug string wsHeader
 SCON 
 LEAX wsOptHeader
#debug string wsOptHeader
 SCON 
 LEA  __Const__fbWebSocketClient_wsHeader4
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAY wsHeader
 WRI  
 LEAY wsHeader
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string wsHeader
 PDST   ; Level 1
#srcline 214 ;        ELSE
 JMP  fbWebSocketClient_L32
fbWebSocketClient_L31:
#srcline 215 ;          wsHeader := wsHeader + wsHeader4;
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LEAY wsHeader
#debug string wsHeader
 SCON 
 LEA  __Const__fbWebSocketClient_wsHeader4
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAY wsHeader
 WRI  
 LEAY wsHeader
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string wsHeader
 PDST   ; Level 1
#srcline 216 ;        END_IF;
fbWebSocketClient_L32:
#srcline 217 ;      END_IF;
fbWebSocketClient_L25:
#srcline 219 ;      // web socket handshake
#srcline 220 ;      SendTo(rq := rqSendHeader, chanCode := hSocket, lenTx := LEN(wsHeader), data := void(wsHeader));  // vyslat zadost o web socket handshake
 LDX  rqSendHeader
#debug bool rqSendHeader
 WRX  SendTo~rq
#debug_left bool SendTo~rq
 LDX  hSocket
#debug uint hSocket
 WRX  SendTo~chanCode
#debug_left uint SendTo~chanCode
 LEAY wsHeader
#debug string wsHeader
 SLEN 
 WRX  SendTo~lenTx
#debug_left uint SendTo~lenTx
 LEAY wsHeader
 WRX  SendTo~data
#debug_left pointer SendTo.data
 LEAX SendTo
 CAL  fbSendTo_L0
#srcline 221 ;      IF SendTo.mesSent THEN
 LDX  SendTo~mesSent
#debug bool SendTo.mesSent
 JMC  fbWebSocketClient_L33
#srcline 222 ;        rqSendHeader := 0; indRecv := 0;
 LD   bool 0       ; false
 WRX  rqSendHeader
#debug_left bool rqSendHeader
 LD   uint 0
 WRX  indRecv
#debug_left uint indRecv
#srcline 223 ;      END_IF;
fbWebSocketClient_L33:
#srcline 224 ;      IF SendTo.error <> 0 THEN
 LDX  SendTo~error
#debug usint SendTo.error
 LD   usint 0
 EQ
 NEG
 JMC  fbWebSocketClient_L35
#srcline 225 ;        isError := 1; lastErrDesc := handshakeErr + GetLastComErrTxt( errCode := SendTo.error);  // 'Handshake failed! '
 LD   bool -1      ; true
 WRX  isError
#debug_left bool isError
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   80
 DST    ; Level 1
 LEA  __Const__fbWebSocketClient_handshakeErr
 SCON 
 NXT
 LDX  SendTo~error
#debug usint SendTo.error
 WR   __Instance__GetLastComErrTxt~errCode
#debug_left usint __Instance__GetLastComErrTxt~errCode
 PRV
 LEA  __Instance__GetLastComErrTxt
 CAL  GetLastComErrTxt_L0

 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX lastErrDesc
 WRI  
 LEAX lastErrDesc
 LD   80
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string lastErrDesc
 PDST   ; Level 1
#srcline 226 ;      END_IF;
fbWebSocketClient_L35:
#srcline 228 ;      RecvFrom(rq := 1, chanCode := hSocket, lenRx := sizeof(recvData.data), data := void(recvData.data[indRecv])); // prijem odpovedi
 LD   1
 WRX  RecvFrom~rq
#debug_left bool RecvFrom~rq
 LDX  hSocket
#debug uint hSocket
 WRX  RecvFrom~chanCode
#debug_left uint RecvFrom~chanCode
 LD   1441  ; SizeOf()
 WRX  RecvFrom~lenRx
#debug_left uint RecvFrom~lenRx
 LEAX recvData
 ADD  4  ; + offset 
 LDX  indRecv
#debug uint indRecv
 RCHK 1440   ; Range Check
 ADD     ; + offset 
 WRX  RecvFrom~data
#debug_left pointer RecvFrom.data
 LEAX RecvFrom
 CAL  fbRecvFrom_L0
#srcline 229 ;      IF RecvFrom.mesRec THEN
 LDX  RecvFrom~mesRec
#debug bool RecvFrom.mesRec
 JMC  fbWebSocketClient_L37
#srcline 230 ;        IF RecvFrom.error = 0 THEN
 LDX  RecvFrom~error
#debug usint RecvFrom.error
 LD   usint 0
 EQ
 JMC  fbWebSocketClient_L39
#srcline 231 ;          ptrAnswer := ADR(recvData.data);
 LEAX recvData
 ADD  4  ; + offset 
#debug pointer recvData.data
 LEAY ptrAnswer
 WRIL 
#debug_left pointer ptrAnswer
#srcline 232 ;          IF FIND( ptrAnswer^, '$0D$0A$0D$0A') <> 0 THEN          // prisla cela odpoved
 LEAY ptrAnswer
 LDIL    ; dereference 
#debug string ptrAnswer^
 LEA  _str_fbWebSocketClient_6
 SFND 
 LD   int 0
 EQ
 NEG
 JMC  fbWebSocketClient_L41
#srcline 233 ;            IF FIND( ptrAnswer^, 'HTTP/1.1 101') = 1 THEN         // a je to 101
 LEAY ptrAnswer
 LDIL    ; dereference 
#debug string ptrAnswer^
 LEA  _str_fbWebSocketClient_7
 SFND 
 LD   int 1
 EQ
 JMC  fbWebSocketClient_L43
#srcline 234 ;              STRING_TO_LOWER( input := void(recvData.data));
 NXT
 LEAX recvData
 ADD  4  ; + offset 
 WR   __Instance__STRING_TO_LOWER~input
#debug_left pointer __Instance__STRING_TO_LOWER.input
 PRV
 LEA  __Instance__STRING_TO_LOWER
 CAL  STRING_TO_LOWER_L0
#srcline 235 ;              IF FIND( ptrAnswer^, 'upgrade: websocket') <> 0 THEN
 LEAY ptrAnswer
 LDIL    ; dereference 
#debug string ptrAnswer^
 LEA  _str_fbWebSocketClient_8
 SFND 
 LD   int 0
 EQ
 NEG
 JMC  fbWebSocketClient_L45
#srcline 236 ;                IF FIND( ptrAnswer^, 'connection: upgrade') <> 0 THEN
 LEAY ptrAnswer
 LDIL    ; dereference 
#debug string ptrAnswer^
 LEA  _str_fbWebSocketClient_9
 SFND 
 LD   int 0
 EQ
 NEG
 JMC  fbWebSocketClient_L47
#srcline 237 ;                  IF FIND( ptrAnswer^, 'sec-websocket-accept:') <> 0 THEN
 LEAY ptrAnswer
 LDIL    ; dereference 
#debug string ptrAnswer^
 LEA  _str_fbWebSocketClient_10
 SFND 
 LD   int 0
 EQ
 NEG
 JMC  fbWebSocketClient_L49
#srcline 238 ;                    isConnected := 1;                             // zadost o handshake potvrzena
 LD   bool -1      ; true
 WRX  isConnected
#debug_left bool isConnected
#srcline 239 ;                    indRecv := 0; reqRecv := 0; lenRecv := 0;     // priprava na prijem
 LD   uint 0
 WRX  indRecv
#debug_left uint indRecv
 LD   uint 0
 WRX  reqRecv
#debug_left uint reqRecv
 LD   uint 0
 WRX  lenRecv
#debug_left uint lenRecv
#srcline 240 ;                  END_IF;
fbWebSocketClient_L49:
#srcline 241 ;                END_IF;
fbWebSocketClient_L47:
#srcline 242 ;              END_IF;
fbWebSocketClient_L45:
#srcline 243 ;            ELSE
 JMP  fbWebSocketClient_L44
fbWebSocketClient_L43:
#srcline 244 ;              isError := 1; lastErrDesc := handshakeErr;          // 'Handshake failed! '
 LD   bool -1      ; true
 WRX  isError
#debug_left bool isError
 LD   0   ; null string
 LEAX lastErrDesc
 WRI  
 LEAX lastErrDesc
 LD   80
 DST    ; Level 1
 LEA  __Const__fbWebSocketClient_handshakeErr
 SCON 
#debug_left string lastErrDesc
 PDST   ; Level 1
#srcline 245 ;              pos := FIND( ptrAnswer^, '$0D$0A');
 LEAY ptrAnswer
 LDIL    ; dereference 
#debug string ptrAnswer^
 LEA  _str_fbWebSocketClient_11
 SFND 
 WRY  pos
#debug_left int pos
#srcline 246 ;              IF pos > 0 THEN
 LDY  pos
#debug int pos
 EXTW 
 LD   int 0
 GTS
 JMC  fbWebSocketClient_L51
#srcline 247 ;                 ptrAnswer := ptrAnswer + INT_TO_UDINT(pos); ptrAnswer^ := 0; ptrAnswer := ptrAnswer - INT_TO_UDINT(pos);
 LEAY ptrAnswer
 LDIL 
#debug pointer ptrAnswer
 LDY  pos
#debug int pos
 EXTW 
 ADD
 LEAY ptrAnswer
 WRIL 
#debug_left pointer ptrAnswer
 LD   0   ; null string
 LEAY ptrAnswer
 LDIL    ; dereference 
 WRI  
 LEAY ptrAnswer
 LDIL    ; dereference 
 LD   255
 DST    ; Level 1
 LD   string 0
 SCON 
#debug_left string ptrAnswer^
 PDST   ; Level 1
 LEAY ptrAnswer
 LDIL 
#debug pointer ptrAnswer
 LDY  pos
#debug int pos
 EXTW 
 SUB
 LEAY ptrAnswer
 WRIL 
#debug_left pointer ptrAnswer
#srcline 248 ;                 lastErrDesc := lastErrDesc + ptrAnswer^;
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   80
 DST    ; Level 1
 LEAX lastErrDesc
#debug string lastErrDesc
 SCON 
 LEAY ptrAnswer
 LDIL    ; dereference 
#debug string ptrAnswer^
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX lastErrDesc
 WRI  
 LEAX lastErrDesc
 LD   80
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string lastErrDesc
 PDST   ; Level 1
#srcline 249 ;              END_IF;
fbWebSocketClient_L51:
#srcline 250 ;            END_IF;
fbWebSocketClient_L44:
#srcline 251 ;          ELSE
 JMP  fbWebSocketClient_L42
fbWebSocketClient_L41:
#srcline 252 ;            indRecv := indRecv + RecvFrom.lenData;                // odpoved jeste neni cela, pockat
 LDX  indRecv
#debug uint indRecv
 LDX  RecvFrom~lenData
#debug uint RecvFrom.lenData
 ADD
 AND  $FFFF
 WRX  indRecv
#debug_left uint indRecv
#srcline 253 ;          END_IF;
fbWebSocketClient_L42:
#srcline 254 ;        ELSE
 JMP  fbWebSocketClient_L40
fbWebSocketClient_L39:
#srcline 255 ;          isError := 1; lastErrDesc := handshakeErr + GetLastComErrTxt( errCode := RecvFrom.error);  // // 'Handshake failed! '
 LD   bool -1      ; true
 WRX  isError
#debug_left bool isError
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   80
 DST    ; Level 1
 LEA  __Const__fbWebSocketClient_handshakeErr
 SCON 
 NXT
 LDX  RecvFrom~error
#debug usint RecvFrom.error
 WR   __Instance__GetLastComErrTxt~errCode
#debug_left usint __Instance__GetLastComErrTxt~errCode
 PRV
 LEA  __Instance__GetLastComErrTxt
 CAL  GetLastComErrTxt_L0

 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX lastErrDesc
 WRI  
 LEAX lastErrDesc
 LD   80
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string lastErrDesc
 PDST   ; Level 1
#srcline 256 ;        END_IF;
fbWebSocketClient_L40:
#srcline 257 ;      END_IF;
fbWebSocketClient_L37:
#srcline 259 ;      // cekat na odpoved na handshake max. 10 sec
#srcline 260 ;      TimerWs(IN := NOT RecvFrom.mesRec, PT := T#10s);
 LDX  RecvFrom~mesRec
#debug bool RecvFrom.mesRec
 NEG
 WRX  TimerWs~IN
#debug_left bool TimerWs~IN
 LD   time 10000
 WRX  TimerWs~PT
#debug_left time TimerWs~PT
 LEAX TimerWs
 CAL  TON_L0
#srcline 261 ;      IF TimerWs.Q THEN
 LDX  TimerWs~Q
#debug bool TimerWs.Q
 JMC  fbWebSocketClient_L53
#srcline 262 ;        TimerWs(IN := 0);                                       // handshake se nepodaril
 LD   bool 0       ; false
 WRX  TimerWs~IN
#debug_left bool TimerWs~IN
 LEAX TimerWs
 CAL  TON_L0
#srcline 263 ;        isError := 1; lastErrDesc := handshakeErr;              //'Handshake failed! ';
 LD   bool -1      ; true
 WRX  isError
#debug_left bool isError
 LD   0   ; null string
 LEAX lastErrDesc
 WRI  
 LEAX lastErrDesc
 LD   80
 DST    ; Level 1
 LEA  __Const__fbWebSocketClient_handshakeErr
 SCON 
#debug_left string lastErrDesc
 PDST   ; Level 1
#srcline 264 ;      END_IF;
fbWebSocketClient_L53:
#srcline 266 ;    ELSE                                                        // uz probiha web socket komunikace
 JMP  fbWebSocketClient_L24
fbWebSocketClient_L23:
#srcline 267 ;      // casovac pro udrzbu spojeni
#srcline 268 ;      TimerWs(IN := NOT newPacket AND (indRecv = 0) AND (pingTime <> T#0s), PT := pingTime);
 LDX  newPacket
#debug bool newPacket
 NEG
 LDX  indRecv
#debug uint indRecv
 LD   uint 0
 EQ
 AND
 LDX  pingTime
#debug time pingTime
 LD   time 0
 EQ
 NEG
 AND
 WRX  TimerWs~IN
#debug_left bool TimerWs~IN
 LDX  pingTime
#debug time pingTime
 WRX  TimerWs~PT
#debug_left time TimerWs~PT
 LEAX TimerWs
 CAL  TON_L0
#srcline 269 ;      IF TimerWs.Q THEN
 LDX  TimerWs~Q
#debug bool TimerWs.Q
 JMC  fbWebSocketClient_L55
#srcline 270 ;        TimerWs(IN := 0); rqPing := 1; cntPing := cntPing + 1;  // kdyz dobehne casovac tak odeslat ping
 LD   bool 0       ; false
 WRX  TimerWs~IN
#debug_left bool TimerWs~IN
 LEAX TimerWs
 CAL  TON_L0
 LD   bool -1      ; true
 WRX  rqPing
#debug_left bool rqPing
 LDX  cntPing
#debug usint cntPing
 LD   usint 1
 ADD
 AND  $FF
 WRX  cntPing
#debug_left usint cntPing
#srcline 271 ;        IF cntPing > 3 THEN
 LDX  cntPing
#debug usint cntPing
 LD   usint 3
 GT
 JMC  fbWebSocketClient_L57
#srcline 272 ;          isError := 1; lastErrDesc := 'Connection with server was lost!';
 LD   bool -1      ; true
 WRX  isError
#debug_left bool isError
 LD   0   ; null string
 LEAX lastErrDesc
 WRI  
 LEAX lastErrDesc
 LD   80
 DST    ; Level 1
 LEA  _str_fbWebSocketClient_12
 SCON 
#debug_left string lastErrDesc
 PDST   ; Level 1
#srcline 273 ;        END_IF;
fbWebSocketClient_L57:
#srcline 274 ;      END_IF;
fbWebSocketClient_L55:
#srcline 276 ;      // priprava dat pro vysilani web socketem
#srcline 277 ;      SendTo.rq := 0;
 LD   bool 0       ; false
 WRX  SendTo~rq
#debug_left bool SendTo.rq
#srcline 278 ;      IF rqSend AND (lenSend > 0) THEN                           // zadost o vysilani
 LDX  rqSend
#debug bool rqSend
 LDX  lenSend
#debug uint lenSend
 LD   uint 0
 GT
 AND
 JMC  fbWebSocketClient_L59
#srcline 279 ;        IF lenSend < MAX_LEN_WS_BUFFER THEN
 LDX  lenSend
#debug uint lenSend
 LD   uint 1440
 LT
 JMC  fbWebSocketClient_L61
#srcline 280 ;          Memcpy( length := lenSend, source := void(sendBuf), dest := void(sendData.data));
 NXT
 LDX  lenSend
#debug uint lenSend
 WR   __Instance__Memcpy~length
#debug_left uint __Instance__Memcpy~length
 LDX  sendBuf
 WR   __Instance__Memcpy~source
#debug_left pointer __Instance__Memcpy.source
 LEAX sendData
 ADD  8  ; + offset 
 WR   __Instance__Memcpy~dest
#debug_left pointer __Instance__Memcpy.dest
 PRV
 LEA  __Instance__Memcpy
 CAL  Memcpy_L0
#srcline 281 ;          sendData.opcode := SEL( G := textMode, IN0 := 16#82, IN1 := 16#81);  // // FIN flag + frame type (binary/text)
 LDX  textMode
#debug bool textMode
 JMD  fbWebSocketClient_L63
 POP  1
 LD   byte $82
 JMP  fbWebSocketClient_L64
fbWebSocketClient_L63:
 POP  1
 LD   byte $81
fbWebSocketClient_L64:
 WRX  sendData~opcode
#debug_left byte sendData.opcode
#srcline 283 ;          IF lenSend < 126 THEN
 LDX  lenSend
#debug uint lenSend
 LD   uint 126
 LT
 JMC  fbWebSocketClient_L65
#srcline 284 ;            sendData.payloadLen := 128 + UINT_TO_USINT(lenSend);  // MASK flag + len
 LD   usint 128
 LDX  lenSend
#debug uint lenSend
 AND  $FF
 ADD
 AND  $FF
 WRX  sendData~payloadLen
#debug_left usint sendData.payloadLen
#srcline 285 ;            SendTo.lenTx := lenSend+6;                            // kolik budeme vysilat
 LDX  lenSend
#debug uint lenSend
 LD   uint 6
 ADD
 AND  $FFFF
 WRX  SendTo~lenTx
#debug_left uint SendTo.lenTx
#srcline 286 ;            SendTo.rq := 1;
 LD   bool -1      ; true
 WRX  SendTo~rq
#debug_left bool SendTo.rq
#srcline 287 ;          ELSE
 JMP  fbWebSocketClient_L66
fbWebSocketClient_L65:
#srcline 288 ;            sendData.payloadLen := 128 + 126;                     // MASK flag + 126
 LD   usint 128
 LD   usint 126
 ADD
 AND  $FF
 WRX  sendData~payloadLen
#debug_left usint sendData.payloadLen
#srcline 289 ;            sendData.extPayLen := _internetlib_SwpUint(lenSend);
 NXT
 LDX  lenSend
#debug uint lenSend
 WR   __Instance___internetlib_SwpUint~in
#debug_left uint __Instance___internetlib_SwpUint~in
 PRV
 LEA  __Instance___internetlib_SwpUint
 CAL  _internetlib_SwpUint_L0
 WRX  sendData~extPayLen
#debug_left uint sendData.extPayLen
#srcline 290 ;            SendTo.lenTx := lenSend+8;                            // kolik se bude vysilat
 LDX  lenSend
#debug uint lenSend
 LD   uint 8
 ADD
 AND  $FFFF
 WRX  SendTo~lenTx
#debug_left uint SendTo.lenTx
#srcline 291 ;            SendTo.rq := 1;
 LD   bool -1      ; true
 WRX  SendTo~rq
#debug_left bool SendTo.rq
#srcline 292 ;          END_IF;
fbWebSocketClient_L66:
#srcline 294 ;          RandomNum(out := void(sendData.maskingKey));            // masking key
 LEAX sendData
 ADD  4  ; + offset 
 WRX  RandomNum~out
#debug_left pointer RandomNum.out
 LEAX RandomNum
 CAL  _internetlib_fbRandUdint_L0
#srcline 296 ;          // kodovat vysilana data
#srcline 297 ;          FOR i := 0 TO lenSend-1 DO
 LD   uint 0
 WRY  i
 LDX  lenSend
#debug uint lenSend
 LD   uint 1
 SUB
 AND  $FFFF
 WRY  P1__st__
fbWebSocketClient_L67:
 LDY  i
 LDY  P1__st__
 GT   
 JMD  fbWebSocketClient_L68
 DBG  
#srcline 298 ;            sendData.data[i] := sendData.data[i] XOR sendData.maskingKey[i mod 4];
 LEAX sendData
 ADD  8  ; + offset 
 LDY  i
#debug uint i
 RCHK 1440   ; Range Check
 ADD     ; + offset 
 LDI  
#debug byte sendData.data[i]
 LEAX sendData
 ADD  4  ; + offset 
 LDY  i
#debug uint i
 LD   uint 4
 MOD
 AND  $FFFF
 RCHK 3   ; Range Check
 ADD     ; + offset 
 LDI  
#debug byte sendData.maskingKey[imod4]
 XOR 
 LEAX sendData
 ADD  8  ; + offset 
 LDY  i
#debug uint i
 RCHK 1440   ; Range Check
 ADD     ; + offset 
 WRI 
#debug_left byte sendData.data[i]
#srcline 299 ;          END_FOR;
 LDY  i
 LD   1
 ADD  
 WRY  i
 JMP  fbWebSocketClient_L67
fbWebSocketClient_L68:
 NOP  -1
#srcline 300 ;          // kratke zpravy posunout (vynechat extPayLen)
#srcline 301 ;          IF rqSend AND (lenSend < 126) THEN
 LDX  rqSend
#debug bool rqSend
 LDX  lenSend
#debug uint lenSend
 LD   uint 126
 LT
 AND
 JMC  fbWebSocketClient_L69
#srcline 302 ;            memcpy( length := lenSend+4, source := void(sendData.maskingKey), dest := void(sendData.extPayLen));
 NXT
 LDX  lenSend
#debug uint lenSend
 LD   uint 4
 ADD
 AND  $FFFF
 WR   __Instance__Memcpy~length
#debug_left uint __Instance__Memcpy~length
 LEAX sendData
 ADD  4  ; + offset 
 WR   __Instance__Memcpy~source
#debug_left pointer __Instance__Memcpy.source
 LEAX sendData
 ADD  2  ; + offset 
 WR   __Instance__Memcpy~dest
#debug_left pointer __Instance__Memcpy.dest
 PRV
 LEA  __Instance__Memcpy
 CAL  Memcpy_L0
#srcline 303 ;          END_IF;
fbWebSocketClient_L69:
#srcline 304 ;        ELSE
 JMP  fbWebSocketClient_L62
fbWebSocketClient_L61:
#srcline 305 ;          isError := 1; lastErrDesc := UINT_TO_STRINGF( MAX_LEN_WS_BUFFER, 'Sending message is longer then %d bytes!');
 LD   bool -1      ; true
 WRX  isError
#debug_left bool isError
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   80
 DST    ; Level 1
 NXT
 LD   uint 1440
 WR   __Instance__UINT_TO_STRINGF~in
#debug_left uint __Instance__UINT_TO_STRINGF~in
 LD   0   ; null string
 LEA  __Instance__UINT_TO_STRINGF~format
 WRI 
 LEA  __Instance__UINT_TO_STRINGF~format
 LD   80
 DST    ; Level 2
 LEA  _str_fbWebSocketClient_13
 SCON 
#debug_left string __Instance__UINT_TO_STRINGF~format
 PDST   ; Level 2
 PRV
 LEA  __Instance__UINT_TO_STRINGF
 CAL  UINT_TO_STRINGF_L0

 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX lastErrDesc
 WRI  
 LEAX lastErrDesc
 LD   80
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string lastErrDesc
 PDST   ; Level 1
#srcline 306 ;        END_IF;
fbWebSocketClient_L62:
#srcline 308 ;      ELSIF rqPong THEN
 JMP  fbWebSocketClient_L60
fbWebSocketClient_L59:
 LDX  rqPong
#debug bool rqPong
 JMC  fbWebSocketClient_L71
#srcline 309 ;        rqPong := 0;
 LD   bool 0       ; false
 WRX  rqPong
#debug_left bool rqPong
#srcline 310 ;        sendData.opcode := 16#8A;                               // FIN flag + pong
 LD   byte $8A
 WRX  sendData~opcode
#debug_left byte sendData.opcode
#srcline 311 ;        sendData.payloadLen := 128 + UINT_TO_USINT( lenPong);   // MASK + lenPong (delka payloadu v pong musi odpovidat payloadu prijatem v ping)
 LD   usint 128
 LDX  lenPong
#debug uint lenPong
 AND  $FF
 ADD
 AND  $FF
 WRX  sendData~payloadLen
#debug_left usint sendData.payloadLen
#srcline 312 ;        IF lenPong > 0 THEN
 LDX  lenPong
#debug uint lenPong
 LD   uint 0
 GT
 JMC  fbWebSocketClient_L72
#srcline 313 ;          RandomNum(out := void(sendData.maskingKey));          // masking key
 LEAX sendData
 ADD  4  ; + offset 
 WRX  RandomNum~out
#debug_left pointer RandomNum.out
 LEAX RandomNum
 CAL  _internetlib_fbRandUdint_L0
#srcline 314 ;          FOR i := 0 TO lenPong-1 DO
 LD   uint 0
 WRY  i
 LDX  lenPong
#debug uint lenPong
 LD   uint 1
 SUB
 AND  $FFFF
 WRY  P2__st__
fbWebSocketClient_L74:
 LDY  i
 LDY  P2__st__
 GT   
 JMD  fbWebSocketClient_L75
 DBG  
#srcline 315 ;            sendData.data[i] := dataPong[i] XOR sendData.maskingKey[i mod 4];
 LEAX dataPong
 LDY  i
#debug uint i
 RCHK 127   ; Range Check
 ADD     ; + offset 
 LDI  
#debug byte dataPong[i]
 LEAX sendData
 ADD  4  ; + offset 
 LDY  i
#debug uint i
 LD   uint 4
 MOD
 AND  $FFFF
 RCHK 3   ; Range Check
 ADD     ; + offset 
 LDI  
#debug byte sendData.maskingKey[imod4]
 XOR 
 LEAX sendData
 ADD  8  ; + offset 
 LDY  i
#debug uint i
 RCHK 1440   ; Range Check
 ADD     ; + offset 
 WRI 
#debug_left byte sendData.data[i]
#srcline 316 ;          END_FOR;
 LDY  i
 LD   1
 ADD  
 WRY  i
 JMP  fbWebSocketClient_L74
fbWebSocketClient_L75:
 NOP  -1
#srcline 317 ;          memcpy( length := lenPong+4, source := void(sendData.maskingKey), dest := void(sendData.extPayLen));
 NXT
 LDX  lenPong
#debug uint lenPong
 LD   uint 4
 ADD
 AND  $FFFF
 WR   __Instance__Memcpy~length
#debug_left uint __Instance__Memcpy~length
 LEAX sendData
 ADD  4  ; + offset 
 WR   __Instance__Memcpy~source
#debug_left pointer __Instance__Memcpy.source
 LEAX sendData
 ADD  2  ; + offset 
 WR   __Instance__Memcpy~dest
#debug_left pointer __Instance__Memcpy.dest
 PRV
 LEA  __Instance__Memcpy
 CAL  Memcpy_L0
#srcline 318 ;        ELSE
 JMP  fbWebSocketClient_L73
fbWebSocketClient_L72:
#srcline 319 ;          RandomNum(out := void(sendData.extPayLen));           // pouze masking key (zadny payload)
 LEAX sendData
 ADD  2  ; + offset 
 WRX  RandomNum~out
#debug_left pointer RandomNum.out
 LEAX RandomNum
 CAL  _internetlib_fbRandUdint_L0
#srcline 320 ;        END_IF;
fbWebSocketClient_L73:
#srcline 321 ;        SendTo.lenTx := lenPong+6;                              // kolik se bude vysilat
 LDX  lenPong
#debug uint lenPong
 LD   uint 6
 ADD
 AND  $FFFF
 WRX  SendTo~lenTx
#debug_left uint SendTo.lenTx
#srcline 322 ;        SendTo.rq := 1;
 LD   bool -1      ; true
 WRX  SendTo~rq
#debug_left bool SendTo.rq
#srcline 324 ;      ELSIF rqPing THEN
 JMP  fbWebSocketClient_L60
fbWebSocketClient_L71:
 LDX  rqPing
#debug bool rqPing
 JMC  fbWebSocketClient_L76
#srcline 325 ;        rqPing := 0;
 LD   bool 0       ; false
 WRX  rqPing
#debug_left bool rqPing
#srcline 326 ;        sendData.opcode := 16#89;                               // FIN flag + ping
 LD   byte $89
 WRX  sendData~opcode
#debug_left byte sendData.opcode
#srcline 327 ;        sendData.payloadLen := 128 + 0;                         // MASK + len = 0
 LD   usint 128
 LD   usint 0
 ADD
 AND  $FF
 WRX  sendData~payloadLen
#debug_left usint sendData.payloadLen
#srcline 328 ;        RandomNum(out := void(sendData.extPayLen));             // masking key
 LEAX sendData
 ADD  2  ; + offset 
 WRX  RandomNum~out
#debug_left pointer RandomNum.out
 LEAX RandomNum
 CAL  _internetlib_fbRandUdint_L0
#srcline 329 ;        SendTo.lenTx := 6;                                      // kolik se bude vysilat
 LD   uint 6
 WRX  SendTo~lenTx
#debug_left uint SendTo.lenTx
#srcline 330 ;        SendTo.rq := 1;
 LD   bool -1      ; true
 WRX  SendTo~rq
#debug_left bool SendTo.rq
#srcline 331 ;      END_IF;
 JMP  fbWebSocketClient_L60
fbWebSocketClient_L76:
fbWebSocketClient_L60:
#srcline 333 ;      // vysilani dat web socketem
#srcline 334 ;      SendTo( chanCode := hSocket, data := void(sendData));     // vysilani dat
 LDX  hSocket
#debug uint hSocket
 WRX  SendTo~chanCode
#debug_left uint SendTo~chanCode
 LEAX sendData
 WRX  SendTo~data
#debug_left pointer SendTo.data
 LEAX SendTo
 CAL  fbSendTo_L0
#srcline 335 ;      IF SendTo.error = 0 THEN
 LDX  SendTo~error
#debug usint SendTo.error
 LD   usint 0
 EQ
 JMC  fbWebSocketClient_L77
#srcline 336 ;        IF SendTo.mesSent THEN
 LDX  SendTo~mesSent
#debug bool SendTo.mesSent
 JMC  fbWebSocketClient_L79
#srcline 337 ;          IF rqSend THEN
 LDX  rqSend
#debug bool rqSend
 JMC  fbWebSocketClient_L81
#srcline 338 ;            sumaSend := sumaSend + UINT_TO_UDINT(lenSend);
 LDX  sumaSend
#debug udint sumaSend
 LDX  lenSend
#debug uint lenSend
 ADD
 WRX  sumaSend
#debug_left udint sumaSend
#srcline 339 ;            rqSend := 0; lenSend := 0;
 LD   bool 0       ; false
 WRX  rqSend
#debug_left bool rqSend
 LD   uint 0
 WRX  lenSend
#debug_left uint lenSend
#srcline 340 ;          END_IF;
fbWebSocketClient_L81:
#srcline 341 ;        END_IF;
fbWebSocketClient_L79:
#srcline 342 ;      ELSE
 JMP  fbWebSocketClient_L78
fbWebSocketClient_L77:
#srcline 343 ;        isError := 1; lastErrDesc := 'Sending error: ' + GetLastComErrTxt( SendTo.error);
 LD   bool -1      ; true
 WRX  isError
#debug_left bool isError
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   80
 DST    ; Level 1
 LEA  _str_fbWebSocketClient_14
 SCON 
 NXT
 LDX  SendTo~error
#debug usint SendTo.error
 WR   __Instance__GetLastComErrTxt~errCode
#debug_left usint __Instance__GetLastComErrTxt~errCode
 PRV
 LEA  __Instance__GetLastComErrTxt
 CAL  GetLastComErrTxt_L0

 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX lastErrDesc
 WRI  
 LEAX lastErrDesc
 LD   80
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string lastErrDesc
 PDST   ; Level 1
#srcline 344 ;      END_IF;
fbWebSocketClient_L78:
#srcline 346 ;      // prijem dat web socketem
#srcline 347 ;      newPacket := 0; isRecv := 0; lenRecv := 0;
 LD   bool 0       ; false
 WRX  newPacket
#debug_left bool newPacket
 LD   bool 0       ; false
 WRX  isRecv
#debug_left bool isRecv
 LD   uint 0
 WRX  lenRecv
#debug_left uint lenRecv
#srcline 348 ;      RecvFrom(rq := 1, chanCode := hSocket, lenRx := sizeof(recvData.data) - indRecv, data := void(recvData.data[indRecv]));  // pokracovani prijmu dat (kdyz neprijde cela zprava najednou)
 LD   1
 WRX  RecvFrom~rq
#debug_left bool RecvFrom~rq
 LDX  hSocket
#debug uint hSocket
 WRX  RecvFrom~chanCode
#debug_left uint RecvFrom~chanCode
 LD   1441  ; SizeOf()
 LDX  indRecv
#debug uint indRecv
 SUB
 AND  $FFFF
 WRX  RecvFrom~lenRx
#debug_left uint RecvFrom~lenRx
 LEAX recvData
 ADD  4  ; + offset 
 LDX  indRecv
#debug uint indRecv
 RCHK 1440   ; Range Check
 ADD     ; + offset 
 WRX  RecvFrom~data
#debug_left pointer RecvFrom.data
 LEAX RecvFrom
 CAL  fbRecvFrom_L0
#srcline 349 ;      // vyhodnotit jestli mame jednu celou zpravu
#srcline 350 ;      IF RecvFrom.mesRec THEN                                            // zpracovat prijata data
 LDX  RecvFrom~mesRec
#debug bool RecvFrom.mesRec
 JMC  fbWebSocketClient_L83
#srcline 351 ;        IF RecvFrom.error <> 0 THEN
 LDX  RecvFrom~error
#debug usint RecvFrom.error
 LD   usint 0
 EQ
 NEG
 JMC  fbWebSocketClient_L85
#srcline 352 ;          isError := 1; lastErrDesc := 'Receiving error: ' + GetLastComErrTxt( RecvFrom.error);
 LD   bool -1      ; true
 WRX  isError
#debug_left bool isError
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   80
 DST    ; Level 1
 LEA  _str_fbWebSocketClient_15
 SCON 
 NXT
 LDX  RecvFrom~error
#debug usint RecvFrom.error
 WR   __Instance__GetLastComErrTxt~errCode
#debug_left usint __Instance__GetLastComErrTxt~errCode
 PRV
 LEA  __Instance__GetLastComErrTxt
 CAL  GetLastComErrTxt_L0

 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX lastErrDesc
 WRI  
 LEAX lastErrDesc
 LD   80
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string lastErrDesc
 PDST   ; Level 1
#srcline 353 ;        ELSE
 JMP  fbWebSocketClient_L86
fbWebSocketClient_L85:
#srcline 354 ;          indRecv := indRecv + RecvFrom.lenData;                         // index := pocet dosud nezpracovanych bytu
 LDX  indRecv
#debug uint indRecv
 LDX  RecvFrom~lenData
#debug uint RecvFrom.lenData
 ADD
 AND  $FFFF
 WRX  indRecv
#debug_left uint indRecv
#srcline 355 ;          IF (recvData.data[0] AND 16#80) <> 0 THEN                      // FIN flag
 LDX  recvData~data[0]
#debug byte recvData.data[0]
 LD   byte $80
 AND
 LD   byte 0
 EQ
 NEG
 JMC  fbWebSocketClient_L87
#srcline 356 ;            IF indRecv > 1 THEN                                          // prijaty alespon opcode a payloadLen
 LDX  indRecv
#debug uint indRecv
 LD   uint 1
 GT
 JMC  fbWebSocketClient_L89
#srcline 357 ;              IF recvData.data[1] < 126 THEN                             // kratke payloadLen (zprava kratsi nez 126 bytu)
 LDX  recvData~data[1]
#debug byte recvData.data[1]
 LD   byte 126
 LT
 JMC  fbWebSocketClient_L91
#srcline 358 ;                IF indRecv >= (BYTE_TO_UINT(recvData.data[1]) + 2) THEN  // uz mame naprijimano dost dat
 LDX  indRecv
#debug uint indRecv
 LDX  recvData~data[1]
#debug byte recvData.data[1]
 LD   uint 2
 ADD
 AND  $FFFF
 LT
 NEG
 JMC  fbWebSocketClient_L93
#srcline 359 ;                  recvData.opcode := recvData.data[0] AND 16#7F;         // kod webSocket zpravy
 LDX  recvData~data[0]
#debug byte recvData.data[0]
 LD   byte $7F
 AND
 WRX  recvData~opcode
#debug_left byte recvData.opcode
#srcline 360 ;                  recvData.extPayLen := BYTE_TO_UINT(recvData.data[1]);  // delka webSocket zpravy
 LDX  recvData~data[1]
#debug byte recvData.data[1]
 WRX  recvData~extPayLen
#debug_left uint recvData.extPayLen
#srcline 361 ;                  indRecv := indRecv - 2;
 LDX  indRecv
#debug uint indRecv
 LD   uint 2
 SUB
 AND  $FFFF
 WRX  indRecv
#debug_left uint indRecv
#srcline 362 ;                  memcpy( length := indRecv, source := void(recvData.data[2]), dest := void(recvData.data)); // posunout prijata data
 NXT
 LDX  indRecv
#debug uint indRecv
 WR   __Instance__Memcpy~length
#debug_left uint __Instance__Memcpy~length
 LEAX recvData
 ADD  6  ; + offset 
 WR   __Instance__Memcpy~source
#debug_left pointer __Instance__Memcpy.source
 LEAX recvData
 ADD  4  ; + offset 
 WR   __Instance__Memcpy~dest
#debug_left pointer __Instance__Memcpy.dest
 PRV
 LEA  __Instance__Memcpy
 CAL  Memcpy_L0
#srcline 363 ;                  newPacket := 1;                                        // prijaty novy paket
 LD   bool -1      ; true
 WRX  newPacket
#debug_left bool newPacket
#srcline 364 ;                END_IF;
fbWebSocketClient_L93:
#srcline 365 ;              ELSE                                                       // dlouhe payloadLen (zprava delsi nez 125 bytu)
 JMP  fbWebSocketClient_L92
fbWebSocketClient_L91:
#srcline 366 ;                IF recvData.data[1] = 126 THEN                           // delka zpravy je typu WORD
 LDX  recvData~data[1]
#debug byte recvData.data[1]
 LD   byte 126
 EQ
 JMC  fbWebSocketClient_L95
#srcline 367 ;                  IF indRecv > 3 THEN                                    // muzeme vyhodnotit delku
 LDX  indRecv
#debug uint indRecv
 LD   uint 3
 GT
 JMC  fbWebSocketClient_L97
#srcline 368 ;                    pUint := ADR(recvData.data[2]);
 LEAX recvData
 ADD  6  ; + offset 
#debug pointer recvData.data[2]
 LEAY pUint
 WRIL 
#debug_left pointer pUint
#srcline 369 ;                    reqRecv := _internetlib_SwpUint(pUint^);             // delka zpravy (z web socket frame)
 NXT
 LEAY pUint
 LDIL    ; dereference 
 LDIW 
#debug uint pUint^
 WR   __Instance___internetlib_SwpUint~in
#debug_left uint __Instance___internetlib_SwpUint~in
 PRV
 LEA  __Instance___internetlib_SwpUint
 CAL  _internetlib_SwpUint_L0
 WRX  reqRecv
#debug_left uint reqRecv
#srcline 370 ;                    IF indRecv >= reqRecv + 4 THEN                       // mame prijato dost bytu na celou zpravu
 LDX  indRecv
#debug uint indRecv
 LDX  reqRecv
#debug uint reqRecv
 LD   uint 4
 ADD
 AND  $FFFF
 LT
 NEG
 JMC  fbWebSocketClient_L99
#srcline 371 ;                      recvData.opcode := recvData.data[0] AND 16#7F;     // kod webSocket zpravy
 LDX  recvData~data[0]
#debug byte recvData.data[0]
 LD   byte $7F
 AND
 WRX  recvData~opcode
#debug_left byte recvData.opcode
#srcline 372 ;                      recvData.extPayLen := reqRecv;                     // delka webSocket zpravy
 LDX  reqRecv
#debug uint reqRecv
 WRX  recvData~extPayLen
#debug_left uint recvData.extPayLen
#srcline 373 ;                      indRecv := indRecv - 4;
 LDX  indRecv
#debug uint indRecv
 LD   uint 4
 SUB
 AND  $FFFF
 WRX  indRecv
#debug_left uint indRecv
#srcline 374 ;                      memcpy( length := indRecv, source := void(recvData.data[4]), dest := void(recvData.data)); // posunout prijata data
 NXT
 LDX  indRecv
#debug uint indRecv
 WR   __Instance__Memcpy~length
#debug_left uint __Instance__Memcpy~length
 LEAX recvData
 ADD  8  ; + offset 
 WR   __Instance__Memcpy~source
#debug_left pointer __Instance__Memcpy.source
 LEAX recvData
 ADD  4  ; + offset 
 WR   __Instance__Memcpy~dest
#debug_left pointer __Instance__Memcpy.dest
 PRV
 LEA  __Instance__Memcpy
 CAL  Memcpy_L0
#srcline 375 ;                      newPacket := 1;                                    // prijaty novy paket
 LD   bool -1      ; true
 WRX  newPacket
#debug_left bool newPacket
#srcline 376 ;                    ELSIF reqRecv > MAX_LEN_WS_BUFFER - 4 THEN           // prilis dlouha zprava
 JMP  fbWebSocketClient_L100
fbWebSocketClient_L99:
 LDX  reqRecv
#debug uint reqRecv
 LD   uint 1440
 LD   uint 4
 SUB
 AND  $FFFF
 GT
 JMC  fbWebSocketClient_L101
#srcline 377 ;                      isError := 1; lastErrDesc := UINT_TO_STRINGF( MAX_LEN_WS_BUFFER, 'Receiving message is longer then %d bytes!');
 LD   bool -1      ; true
 WRX  isError
#debug_left bool isError
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   80
 DST    ; Level 1
 NXT
 LD   uint 1440
 WR   __Instance__UINT_TO_STRINGF~in
#debug_left uint __Instance__UINT_TO_STRINGF~in
 LD   0   ; null string
 LEA  __Instance__UINT_TO_STRINGF~format
 WRI 
 LEA  __Instance__UINT_TO_STRINGF~format
 LD   80
 DST    ; Level 2
 LEA  _str_fbWebSocketClient_16
 SCON 
#debug_left string __Instance__UINT_TO_STRINGF~format
 PDST   ; Level 2
 PRV
 LEA  __Instance__UINT_TO_STRINGF
 CAL  UINT_TO_STRINGF_L0

 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX lastErrDesc
 WRI  
 LEAX lastErrDesc
 LD   80
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string lastErrDesc
 PDST   ; Level 1
#srcline 378 ;                    ELSE
 JMP  fbWebSocketClient_L100
fbWebSocketClient_L101:
#srcline 379 ;                      // jeste nemame celou zpravu a tak musime cekat
#srcline 380 ;                    END_IF;
fbWebSocketClient_L100:
#srcline 381 ;                  END_IF;
fbWebSocketClient_L97:
#srcline 382 ;                ELSE
 JMP  fbWebSocketClient_L96
fbWebSocketClient_L95:
#srcline 383 ;                  isError := 1; lastErrDesc :='Unsupported length of received websocket message!';  // zpravy se 4-bytovou delkou nepodporujeme
 LD   bool -1      ; true
 WRX  isError
#debug_left bool isError
 LD   0   ; null string
 LEAX lastErrDesc
 WRI  
 LEAX lastErrDesc
 LD   80
 DST    ; Level 1
 LEA  _str_fbWebSocketClient_17
 SCON 
#debug_left string lastErrDesc
 PDST   ; Level 1
#srcline 384 ;                END_IF;
fbWebSocketClient_L96:
#srcline 385 ;              END_IF;
fbWebSocketClient_L92:
#srcline 386 ;            END_IF;
fbWebSocketClient_L89:
#srcline 387 ;          ELSE
 JMP  fbWebSocketClient_L88
fbWebSocketClient_L87:
#srcline 388 ;            // fragmentovana zprava (nepodporovano)
#srcline 389 ;            rqWebSocket := 0; isError := 1; lastErrDesc := 'Web Socket fragmentation is not supported!';
 LD   bool 0       ; false
 WRX  rqWebSocket
#debug_left bool rqWebSocket
 LD   bool -1      ; true
 WRX  isError
#debug_left bool isError
 LD   0   ; null string
 LEAX lastErrDesc
 WRI  
 LEAX lastErrDesc
 LD   80
 DST    ; Level 1
 LEA  _str_fbWebSocketClient_18
 SCON 
#debug_left string lastErrDesc
 PDST   ; Level 1
#srcline 390 ;          END_IF;
fbWebSocketClient_L88:
#srcline 391 ;        END_IF;
fbWebSocketClient_L86:
#srcline 392 ;      END_IF;
fbWebSocketClient_L83:
#srcline 394 ;      // zpracovat prijatou zpravu
#srcline 395 ;      IF newPacket THEN
 LDX  newPacket
#debug bool newPacket
 JMC  fbWebSocketClient_L102
#srcline 396 ;        CASE recvData.opcode OF
 LDX  recvData~opcode
#debug byte recvData.opcode
 WRY  P3__st__
 LD   0
 LDY  P3__st__
 EQ  
 JMC  fbWebSocketClient_L105
#srcline 397 ;          0 : // fragmentovana zprava (nepodporovano)
#srcline 398 ;              rqWebSocket := 0;
 LD   bool 0       ; false
 WRX  rqWebSocket
#debug_left bool rqWebSocket
#srcline 399 ;              isError := 1; lastErrDesc := 'Web Socket fragmentation is not supported!';
 LD   bool -1      ; true
 WRX  isError
#debug_left bool isError
 LD   0   ; null string
 LEAX lastErrDesc
 WRI  
 LEAX lastErrDesc
 LD   80
 DST    ; Level 1
 LEA  _str_fbWebSocketClient_19
 SCON 
#debug_left string lastErrDesc
 PDST   ; Level 1
 JMP  fbWebSocketClient_L104
fbWebSocketClient_L105:
 LD   1
 LDY  P3__st__
 EQ   
 JMD  fbWebSocketClient_L106
 LD   2
 LDY  P3__st__
 EQ   
 JMC  fbWebSocketClient_L107
fbWebSocketClient_L106:
#srcline 401 ;          1,2 : // text frame, binary frame : prijem dat
#srcline 402 ;              lenRecv := recvData.extPayLen;                 // zverejnit velikost prijatych dat
 LDX  recvData~extPayLen
#debug uint recvData.extPayLen
 WRX  lenRecv
#debug_left uint lenRecv
#srcline 403 ;              Memcpy(length := lenRecv, source := void(recvData.data), dest := void(recvBuf));
 NXT
 LDX  lenRecv
#debug uint lenRecv
 WR   __Instance__Memcpy~length
#debug_left uint __Instance__Memcpy~length
 LEAX recvData
 ADD  4  ; + offset 
 WR   __Instance__Memcpy~source
#debug_left pointer __Instance__Memcpy.source
 LDX  recvBuf
 WR   __Instance__Memcpy~dest
#debug_left pointer __Instance__Memcpy.dest
 PRV
 LEA  __Instance__Memcpy
 CAL  Memcpy_L0
#srcline 404 ;              IF recvData.opcode = 1 THEN                    // text frame
 LDX  recvData~opcode
#debug byte recvData.opcode
 LD   byte 1
 EQ
 JMC  fbWebSocketClient_L108
#srcline 405 ;                recvBuf[lenRecv] := 0;                       // koncova nula za prijatym textem
 LD   byte 0
 LDX  recvBuf
 LDX  lenRecv
#debug uint lenRecv
 RCHK 1440   ; Range Check
 ADD     ; + offset 
 WRI 
#debug_left byte recvBuf[lenRecv]
#srcline 406 ;              END_IF;
fbWebSocketClient_L108:
#srcline 407 ;              sumaRecv := sumaRecv + UINT_TO_UDINT(lenRecv);
 LDX  sumaRecv
#debug udint sumaRecv
 LDX  lenRecv
#debug uint lenRecv
 ADD
 WRX  sumaRecv
#debug_left udint sumaRecv
#srcline 408 ;              indRecv := indRecv - lenRecv;                  // priprava na dalsi prijem
 LDX  indRecv
#debug uint indRecv
 LDX  lenRecv
#debug uint lenRecv
 SUB
 AND  $FFFF
 WRX  indRecv
#debug_left uint indRecv
#srcline 409 ;              IF indRecv > 0 THEN
 LDX  indRecv
#debug uint indRecv
 LD   uint 0
 GT
 JMC  fbWebSocketClient_L110
#srcline 410 ;                Memcpy(length := indRecv, source := void(recvData.data[lenRecv]), dest := void(recvData.data[0])); // shrink
 NXT
 LDX  indRecv
#debug uint indRecv
 WR   __Instance__Memcpy~length
#debug_left uint __Instance__Memcpy~length
 LEAX recvData
 ADD  4  ; + offset 
 LDX  lenRecv
#debug uint lenRecv
 RCHK 1440   ; Range Check
 ADD     ; + offset 
 WR   __Instance__Memcpy~source
#debug_left pointer __Instance__Memcpy.source
 LEAX recvData
 ADD  4  ; + offset 
 WR   __Instance__Memcpy~dest
#debug_left pointer __Instance__Memcpy.dest
 PRV
 LEA  __Instance__Memcpy
 CAL  Memcpy_L0
#srcline 411 ;              END_IF;
fbWebSocketClient_L110:
#srcline 412 ;              isRecv := 1; cntPing := 0;                     // prisla spravna data, nulovat kontrolni citac
 LD   bool -1      ; true
 WRX  isRecv
#debug_left bool isRecv
 LD   usint 0
 WRX  cntPing
#debug_left usint cntPing
 JMP  fbWebSocketClient_L104
fbWebSocketClient_L107:
 LD   8
 LDY  P3__st__
 EQ  
 JMC  fbWebSocketClient_L112
#srcline 414 ;          8 : // connection close : zavrit spojeni
#srcline 415 ;              rqWebSocket := 0;
 LD   bool 0       ; false
 WRX  rqWebSocket
#debug_left bool rqWebSocket
#srcline 416 ;              isError := 1; lastErrDesc := 'The server requests to close the connection!';
 LD   bool -1      ; true
 WRX  isError
#debug_left bool isError
 LD   0   ; null string
 LEAX lastErrDesc
 WRI  
 LEAX lastErrDesc
 LD   80
 DST    ; Level 1
 LEA  _str_fbWebSocketClient_20
 SCON 
#debug_left string lastErrDesc
 PDST   ; Level 1
 JMP  fbWebSocketClient_L104
fbWebSocketClient_L112:
 LD   9
 LDY  P3__st__
 EQ   
 JMD  fbWebSocketClient_L113
 LD   10
 LDY  P3__st__
 EQ   
 JMC  fbWebSocketClient_L114
fbWebSocketClient_L113:
#srcline 418 ;          9, 10 : // 9 ping : odeslat pong | 10 pong
#srcline 419 ;              IF recvData.opcode = 9 THEN                    // ping
 LDX  recvData~opcode
#debug byte recvData.opcode
 LD   byte 9
 EQ
 JMC  fbWebSocketClient_L115
#srcline 420 ;                rqPong := 1;                                 // v pristim cyklu odeslat pong
 LD   bool -1      ; true
 WRX  rqPong
#debug_left bool rqPong
#srcline 421 ;                lenPong := WORD_TO_UINT( UINT_TO_WORD( recvData.extPayLen) AND 16#7F);
 LDX  recvData~extPayLen
#debug uint recvData.extPayLen
 LD   word $7F
 AND
 WRX  lenPong
#debug_left uint lenPong
#srcline 422 ;                IF lenPong > 0 THEN                          // v pingu prisel nejaky payload
 LDX  lenPong
#debug uint lenPong
 LD   uint 0
 GT
 JMC  fbWebSocketClient_L117
#srcline 423 ;                  // zapamatujeme si payload pro pong
#srcline 424 ;                  Memcpy(length := lenPong, source := void(recvData.data), dest := void(dataPong[0]));
 NXT
 LDX  lenPong
#debug uint lenPong
 WR   __Instance__Memcpy~length
#debug_left uint __Instance__Memcpy~length
 LEAX recvData
 ADD  4  ; + offset 
 WR   __Instance__Memcpy~source
#debug_left pointer __Instance__Memcpy.source
 LEAX dataPong
 WR   __Instance__Memcpy~dest
#debug_left pointer __Instance__Memcpy.dest
 PRV
 LEA  __Instance__Memcpy
 CAL  Memcpy_L0
#srcline 425 ;                END_IF;
fbWebSocketClient_L117:
#srcline 426 ;              ELSE                                           // pong
 JMP  fbWebSocketClient_L116
fbWebSocketClient_L115:
#srcline 427 ;                cntPing := 0;                                // nulovat pocitadlo pingu, ktere hlida, jestli mame spojeni se serverem
 LD   usint 0
 WRX  cntPing
#debug_left usint cntPing
#srcline 428 ;              END_IF;
fbWebSocketClient_L116:
#srcline 429 ;              TimerWs(IN := 0);                              // nulovat kontrolni casovac
 LD   bool 0       ; false
 WRX  TimerWs~IN
#debug_left bool TimerWs~IN
 LEAX TimerWs
 CAL  TON_L0
#srcline 430 ;              IF recvData.extPayLen > 0 THEN
 LDX  recvData~extPayLen
#debug uint recvData.extPayLen
 LD   uint 0
 GT
 JMC  fbWebSocketClient_L119
#srcline 431 ;                indRecv := indRecv - recvData.extPayLen;     // priprava na dalsi prijem
 LDX  indRecv
#debug uint indRecv
 LDX  recvData~extPayLen
#debug uint recvData.extPayLen
 SUB
 AND  $FFFF
 WRX  indRecv
#debug_left uint indRecv
#srcline 432 ;                IF indRecv > 0 THEN
 LDX  indRecv
#debug uint indRecv
 LD   uint 0
 GT
 JMC  fbWebSocketClient_L121
#srcline 433 ;                  Memcpy(length := indRecv, source := void(recvData.data[lenRecv]), dest := void(recvData.data[0])); // shrink
 NXT
 LDX  indRecv
#debug uint indRecv
 WR   __Instance__Memcpy~length
#debug_left uint __Instance__Memcpy~length
 LEAX recvData
 ADD  4  ; + offset 
 LDX  lenRecv
#debug uint lenRecv
 RCHK 1440   ; Range Check
 ADD     ; + offset 
 WR   __Instance__Memcpy~source
#debug_left pointer __Instance__Memcpy.source
 LEAX recvData
 ADD  4  ; + offset 
 WR   __Instance__Memcpy~dest
#debug_left pointer __Instance__Memcpy.dest
 PRV
 LEA  __Instance__Memcpy
 CAL  Memcpy_L0
#srcline 434 ;                END_IF;
fbWebSocketClient_L121:
#srcline 435 ;              END_IF;
fbWebSocketClient_L119:
 JMP  fbWebSocketClient_L104
fbWebSocketClient_L114:
fbWebSocketClient_L104:
#srcline 438 ;      END_IF;
fbWebSocketClient_L102:
#srcline 439 ;    END_IF;
fbWebSocketClient_L24:
#srcline 440 ;  ELSE                    // spojeni ukonceno
 JMP  fbWebSocketClient_L22
fbWebSocketClient_L21:
#srcline 441 ;    IF isConnected THEN   // a bylo uz navazane
 LDX  isConnected
#debug bool isConnected
 JMC  fbWebSocketClient_L123
#srcline 442 ;      rqWebSocket := 0; isError := 1; lastErrDesc := 'Connection was closed by the server!';  // zavrit web socket
 LD   bool 0       ; false
 WRX  rqWebSocket
#debug_left bool rqWebSocket
 LD   bool -1      ; true
 WRX  isError
#debug_left bool isError
 LD   0   ; null string
 LEAX lastErrDesc
 WRI  
 LEAX lastErrDesc
 LD   80
 DST    ; Level 1
 LEA  _str_fbWebSocketClient_21
 SCON 
#debug_left string lastErrDesc
 PDST   ; Level 1
#srcline 443 ;    ELSE
 JMP  fbWebSocketClient_L124
fbWebSocketClient_L123:
#srcline 444 ;      // cekat na preklad domain name na IP adresu
#srcline 445 ;      TimerWs(IN := rqConnect AND (lastErrDesc = ''), PT := T#10s);
 LDX  rqConnect
#debug bool rqConnect
 LEAX lastErrDesc
#debug string lastErrDesc
 LEA  _str_fbWebSocketClient_22
 SCMP 
 EQ   0
 AND
 WRX  TimerWs~IN
#debug_left bool TimerWs~IN
 LD   time 10000
 WRX  TimerWs~PT
#debug_left time TimerWs~PT
 LEAX TimerWs
 CAL  TON_L0
#srcline 446 ;      IF TimerWs.Q THEN
 LDX  TimerWs~Q
#debug bool TimerWs.Q
 JMC  fbWebSocketClient_L125
#srcline 447 ;        TimerWs(IN := 0); isError := 1; lastErrDesc := 'Unable to get server IP address!';
 LD   bool 0       ; false
 WRX  TimerWs~IN
#debug_left bool TimerWs~IN
 LEAX TimerWs
 CAL  TON_L0
 LD   bool -1      ; true
 WRX  isError
#debug_left bool isError
 LD   0   ; null string
 LEAX lastErrDesc
 WRI  
 LEAX lastErrDesc
 LD   80
 DST    ; Level 1
 LEA  _str_fbWebSocketClient_23
 SCON 
#debug_left string lastErrDesc
 PDST   ; Level 1
#srcline 448 ;      END_IF;
fbWebSocketClient_L125:
#srcline 449 ;    END_IF;
fbWebSocketClient_L124:
#srcline 450 ;  END_IF;
fbWebSocketClient_L22:
#srcline 452 ;  // zavrit spojeni
#srcline 453 ;  IF NOT rqWebSocket OR isError THEN
 LDX  rqWebSocket
#debug bool rqWebSocket
 NEG
 LDX  isError
#debug bool isError
 OR  
 JMC  fbWebSocketClient_L127
#srcline 454 ;    isConnected := 0; rqSendHeader := 0; indRecv := 0; lenRecv := 0; rqWebSocket := 0;
 LD   bool 0       ; false
 WRX  isConnected
#debug_left bool isConnected
 LD   bool 0       ; false
 WRX  rqSendHeader
#debug_left bool rqSendHeader
 LD   uint 0
 WRX  indRecv
#debug_left uint indRecv
 LD   uint 0
 WRX  lenRecv
#debug_left uint lenRecv
 LD   bool 0       ; false
 WRX  rqWebSocket
#debug_left bool rqWebSocket
#srcline 455 ;    CloseUniSocket( hSocket);
 NXT
 LEAX hSocket
 WR   __Instance__CloseUniSocket~chanHandle
#debug_left pointer __Instance__CloseUniSocket.chanHandle
 PRV
 LEA  __Instance__CloseUniSocket
 CAL  CloseUniSocket_L0
#srcline 456 ;    serverAdr.remoteIP := ANY_IP;
 LEA  ANY_IP
#debug pointer ANY_IP
 SRC  %IB0
 LEAX serverAdr~remoteIP
#debug_left pointer serverAdr.remoteIP
 LD   4   ;SizeOf() 
 MOV  %IB0
#srcline 457 ;  END_IF;
fbWebSocketClient_L127:
#srcline 459 ;END_FUNCTION_BLOCK
fbWebSocketClient_RET:
 ULNK
RET
E     61

; Initialize - variables
P     61
fbWebSocketClient__InstanceInit__:
 LINK 0
 LEAX Split
 CAL  fbSplitUrlAddress__InstanceInit__
 LEAX SendTo
 CAL  fbSendTo__InstanceInit__
 LEAX RecvFrom
 CAL  fbRecvFrom__InstanceInit__
 ULNK
RET
E     61
; End initialize - variables
#endpou 



 

#srcfile ''
Õı  F  |