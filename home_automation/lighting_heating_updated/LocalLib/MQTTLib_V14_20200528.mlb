(*` {CSY}Knihovna vývojového systému Mosaic{ENU}Mosaic IDE library *)
(*` {CSY}Jméno souboru{ENU}File name{} : D:\MosaicLib\MQTTLib_V14_20200528.mlb *)
(*` {CSY}Knihovna : MQTTLib{ENU}Library : MQTTLib{} 1.4 *)
(*` {CSY}Autor{ENU}Author{} : Teco a.s. *)
(*` {CSY}Autorská práva{ENU}Copyright{} : (c) 2017 Teco a.s. *)
(*` {CSY}Verze IEC pøekladaèe{ENU}IEC compiler version{} : 4.2.11.0 *)
(*` {CSY}Verze assembleru{ENU}Assembler version{} : 4.3.00 *)

//{Knihovna : MQTTLib 1.4  }
(*` {CSY}Historie{ENU}History{}: *)
(*`
{CSY}
v1.0 03.08.2017 zis - první verze knihovny 
v1.1 16.01.2018 nem - úprava fce fSwapWORD() 
v1.2 15.08.2018 zis - Pridáni nové fb "fbMQTTPublisherEx" a "fbMQTTSubscriberEx" pro dlouhé MQTT zprávy až 512 bajtu
v1.3 10.03.2019 zis - Opravena chyba v FB "fbMQTTSubscriberEx", vymazání vyrovnávací pameti pred kopírováním topicu príchozí zprávy
v1.4 28.05.2020 zis - Ve všech FB opravena chyba délky zprávy behem procesu prihlášení

{ENU}
v1.0 2017.08.03 zis - first version of library 
v1.1 2018.01.16 nem - fSwapWORD() corrected
v1.2 15.08.2018 zis - Added new fb "fbMQTTPublisherEx" and "fbMQTTSubscriberEx" for long MQTT payload messages up 512 bytes
v1.3 10.03.2019 zis - Fixed bug in FB Subscriber, clear buffer before copy incomming message topic
v1.4 28.05.2020 zis - In all FB fixed bug of message length during login process
*)

(*----------------------------------------------------------------------------*)
{LIBRARY="LOCALLIB\STDLIB_V21_20140514.MLB"}
{LIBRARY="LOCALLIB\SYSLIB_V37_20160627.MLB"}
{LIBRARY="LOCALLIB\TOSTRINGLIB_V13_20110203.MLB"}
{LIBRARY="LOCALLIB\TIMELIB_V15_20170216.MLB"}
{LIBRARY="LOCALLIB\COMLIB_V24_20161019.MLB"}
{LIBRARY="LOCALLIB\ENCRYPTLIB_V12_20160923.MLB"}
{LIBRARY="LOCALLIB\INTERNETLIB_V40_20170216.MLB"}

TYPE T_MQTT_COM_PARAM :
  STRUCT
    willRetain       : bool :=  FALSE;  (*`{ENU} Duplicate delivery of a PUBLISH Control Packet*)
    qos              : usint;  (*`{ENU} PUBLISH Quality of Service (value:0,1,2)*)
    cleanSession     : bool :=  true;
    dup              : bool;  (*`{ENU} Duplicate delivery of a PUBLISH Control Packet*)
    exIntervalSession : udint :=  10;  (*`16#A1B2C3D4; // Session Expiry Interval 4 bytes*)
  END_STRUCT;
END_TYPE

TYPE  MQTT_EX_PUBLISHER_BUFFER : ARRAY [0..512] OF usint;
END_TYPE

TYPE  MQTT_EX_SUBSCRIBER_BUFFER : ARRAY [0..512] OF usint;
END_TYPE

VAR_GLOBAL CONSTANT
 MQTT_COMM_TIMEOUT {HIDDEN} : time :=  T#5s;
 MQTT_CONTROL_PACK_CONNECT {HIDDEN} : usint :=  16#10;  (*`Client request to connect to Server*)
 MQTT_CONTROL_PACK_CONNACK {HIDDEN} : usint :=  16#20;  (*`Connect acknowledgment*)
 MQTT_CONTROL_PACK_PUBLISH {HIDDEN} : usint :=  16#30;  (*`Publish message ( Client to Server or Server to Client)*)
 MQTT_CONTROL_PACK_PUBACK {HIDDEN} : usint :=  16#40;  (*`Publish acknowledgment ( Client to Server or Server to Client)*)
 MQTT_CONTROL_PACK_PUBREC {HIDDEN} : usint :=  16#50;  (*`Publish received (assured delivery part 1) ( Client to Server or Server to Client)*)
 MQTT_CONTROL_PACK_PUBREL {HIDDEN} : usint :=  16#60;  (*`Publish release (assured delivery part 2)*)
 MQTT_CONTROL_PACK_PUBCOMP {HIDDEN} : usint :=  16#70;  (*`Publish complete (assured delivery part 3)*)
 MQTT_CONTROL_PACK_SUBSCRIBE {HIDDEN} : usint :=  16#80;  (*`Client subscribe request (Client to Server)*)
 MQTT_CONTROL_PACK_SUBACK {HIDDEN} : usint :=  16#90;  (*`Subscribe acknowledgment ( Server to Client)*)
 MQTT_CONTROL_PACK_UNSUBSCRIBE {HIDDEN} : usint :=  16#A0;  (*`Unsubscribe request (Client to Server)*)
 MQTT_CONTROL_PACK_UNSUBACK {HIDDEN} : usint :=  16#B0;  (*`Unsubscribe acknowledgment ( Server to Client)*)
 MQTT_CONTROL_PACK_PINGREQ {HIDDEN} : usint :=  16#C0;  (*`PING request (Client to Server)*)
 MQTT_CONTROL_PACK_PINGRESP {HIDDEN} : usint :=  16#D0;  (*`PING response ( Server to Client)*)
 MQTT_CONTROL_PACK_DISCONNECT {HIDDEN} : usint :=  16#E0;  (*`Client is disconnecting (Client to Server)*)
 MQTT_CONTROL_ERROR_CODE_OK : usint :=  0;
 MQTT_CONTROL_ERROR_CODE_BROKER_ANSWER_TIME_OUT : usint :=  1;
 MQTT_CONTROL_ERROR_CODE_SUBSCRIBE_FAILED : usint :=  2;
 MQTT_CONTROL_ERROR_CODE_BROKER_DISCONNECTED : usint :=  3;
 MQTT_CONTROL_ERROR_CODE_ANSWER_LENGTH_TO_LONG : usint :=  4;
 MQTT_CONTROL_ERROR_CODE_LOGIN_FAILED : usint :=  5;

END_VAR

__DECL FUNCTION MQTT_Lib_support {HIDDEN} : bool
  VAR_INPUT
    code             : udint;
    tim              : udint;
  END_VAR
END_FUNCTION

__DECL FUNCTION fSwapUINT {HIDDEN} : uint
  VAR_INPUT
    input            : uint;
  END_VAR
END_FUNCTION

__DECL FUNCTION_BLOCK fbMQTT_Comm_Init {HIDDEN}
  VAR_INPUT
    connect          : bool;
    keepAlive        : bool :=  true;
    chanCode         : uint;
    remoteIP         : TIPadr;
    remotePort       : uint;
    localPort        : uint;
  END_VAR
  VAR_OUTPUT
    status           : bool;
    error            : usint;
  END_VAR
  VAR
    ethAdr           : TRemoteEthAdr;
    KeepAliveTCP     : fbKeepAliveTCP;
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION_BLOCK fbMQTTPublisher
(*`{ENG} FB client sending a text data to the broker, using a topic name.
  {CSY} FB klient posila data brokru pomocí názvu tématu (topic).*)
  VAR_INPUT
    connect          : bool;  (*`{CSY} Príkaz k pripojení {ENU} Connect or disconnect command*)
    chanCode         : uint;  (*`{CSY} Komunikacní UNI kanál {ENU} Communication UNI channel for MQTT commands and states*)
    brokerIP         : TIPadr;  (*`{CSY} IP adresa MQTT brokeru {ENU} IP address of MQTT broker*)
    brokerPort       : uint :=  1883;  (*`{CSY} port MQTT brokru (výchozí hodnota je 1883) {ENU} port of MQTT broker (default value is 1883)*)
    localPort        : uint :=  5000;  (*`{CSY} lokální port PLC {ENU} local port PLC*)
    keepAlive        : bool :=  true;  (*`{CSY} FB udržuje komunikacní kanál otevrený {ENU} FB keep comm channel opened during communication session (Brocker keeps all settings)*)
    keepAliveInterval : time :=  T#20s;  (*`{CSY} maximální doba, kdy broker uzavre spojení a vymaže všechna nastavení publishera {ENU} maximum time when broker close session and clear all settings of publisher*)
    connTimeOut      : time :=  T#10s;  (*`{CSY} maximální casový limit odezvy od brekera {ENU} maximum timeout of response from broker*)
    pingInterval     : time :=  T#15s;  (*`{CSY} Interval pro udrženi živé relace mezi publisherem a brokerem {ENU} Interval for keep alive comm session between publisher and broker MUST BE: keepAliveInterval > pingInterval*)
    clientId_auto    : bool :=  true;  (*`{CSY} ID klienta bude generováno automaticky nebo ne {ENU} client ID will be generated automatically and append timestamp to MQTT client id*)
    clientId         : string [40];  (*`{CSY} statické ID klienta, relevantní, když clientId_auto = false {ENU} static client ID, relevant when clientId_auto = false, therefore, this ID should be unique per client and broker.*)
    loginName        : string [40];  (*`{CSY} Prihlašovací jméno, které se používá v prípade potreby aterizace {ENU} A login name, using when required authorization*)
    loginPass        : string [40];  (*`{CSY} Heslo, které se používá v prípade potreby autorizace {ENU} A password, using when required authorization*)
    com_param        : T_MQTT_COM_PARAM;  (*`{CSY} Parametry relace MQTT {ENU} Parameters of MQTT session*)
    dataTxt          : string [255];  (*`{CSY} Data k prenosu v textové podobe {ENU} data to transmit in text form*)
    topicTxt         : string [80];  (*`{CSY} Topic kam se data odesílají {ENU} topic where published sends data*)
    sendCom          : bool R_EDGE;  (*`{CSY} Príkaz k odeslání dat {ENU} command to send data*)
  END_VAR
  VAR_OUTPUT
    conn_status      : bool;  (*`{CSY} Stav pripojení TCP {ENU} TCP connection state*)
    connected_to_broker : bool;  (*`{CSY} Stav pripojení k brokeru MQTT {ENU} Connection state to MQTT broker*)
    client_id        : string [40];  (*`{CSY} ID klienta použité v komunikacní relaci {ENU} Client ID used in communication session*)
    local_port       : uint;  (*`{CSY} Lokální port PLC {ENU} Current PLC local port*)
    rxCounter        : uint;  (*`{CSY} Pocítadlo príchozích zpráv {ENU} Incoming messages counter*)
    txCounter        : uint;  (*`{CSY} Pocitadlo odchozích zpráv {ENU} Outgoing messages counter*)
    messageID        : uint;  (*`{CSY} ID odchozí zprávy používá se, když QOS > 0 {ENU} message id, used when QOS > 0*)
    busy             : bool;  (*`{CSY} FB je zaneprázdnen a není prístupný pro uživatelské aplikace {ENU} FB is busy and not accessible for user application*)
    ok               : bool;  (*`{CSY} FB je pripraven pro uživatelské príkazy {ENU} FB is ready for user app commands*)
    err              : bool;  (*`{CSY} Vyskytla se chyba {ENU} Error occurred*)
    errCode          : usint;  (*`{CSY} Kód chyby {ENU} Code of error*)
  END_VAR
  VAR
    MQTT_Comm_Init   : fbMQTT_Comm_Init;
    MQTT_ping_timer  : fbTick;
    MQTT_com_intervat : fbTick;
    MQTT_com_responce_timeout : TON;
    SendTo           : fbSendTo;
    RecvFrom         : fbRecvFrom;
    txData           : ARRAY [0..300] OF usint;
    rxData           : ARRAY [0..100] OF usint;
    payloadLengthArrayTemp : ARRAY [1..4] OF usint;
    MQTT_PROTOCOL    : string [4] :=  'MQTT';
    txMsgLength      : uint;
    payloadLength    : uint;
    payloadLength1   : uint;
    txMsgLengthTemp  : uint;
    encodedByte      : byte;
    tx_data_request  : bool;
    localPortExtension : uint;
    idle_time        : usint;
    payloadLengthSize : usint;
    reconnect_counter : usint;
    wait_response    : bool;
    connectFlags     : byte;
    aliveTime        : uint;
    pubReleaseRq     : bool;
    messageIDpubRel  : uint;
    messageIDpubRel_ptr : PTR_TO uint;
    index            : usint;
    responce_recived : bool;  (*`{CSY} {ENU} code of error*)
    messageIDlast    : uint;
  END_VAR
  VAR CONSTANT
    MQTT_PROTOCOL_VERSION : usint :=  4;
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION_BLOCK fbMQTTPublisherEx
(*`{ENG} FB client sending a data up to 512 bytes (text/binary) to the broker, using a topic name.
  {CSY} FB klient posila data až 512 bytu (text / binární) brokru pomocí názvu tématu (topic).*)
  VAR_INPUT
    connect          : bool;  (*`{CSY} Príkaz k pripojení                                               {ENU} Connect or disconnect command*)
    chanCode         : uint;  (*`{CSY} Komunikacní UNI kanál                                            {ENU} Communication UNI channel for MQTT commands and states*)
    brokerIP         : TIPadr;  (*`{CSY} IP adresa MQTT brokeru                                           {ENU} IP address of MQTT broker*)
    brokerPort       : uint :=  1883;  (*`{CSY} port MQTT brokru (výchozí hodnota je 1883)                       {ENU} port of MQTT broker (default value is 1883)*)
    localPort        : uint :=  5000;  (*`{CSY} lokální port PLC                                                 {ENU} local port PLC*)
    keepAlive        : bool :=  true;  (*`{CSY} FB udržuje komunikacní kanál otevrený                            {ENU} FB keep comm channel opened during communication session (Brocker keeps all settings)*)
    keepAliveInterval : time :=  T#20s;  (*`{CSY} maximální doba, kdy broker uzavre spojení a vymaže všechna nastavení publishera {ENU} maximum time when broker close session and clear all settings of publisher*)
    connTimeOut      : time :=  T#10s;  (*`{CSY} maximální casový limit odezvy od brekera                         {ENU} maximum timeout of response from broker*)
    pingInterval     : time :=  T#15s;  (*`{CSY} Interval pro udrženi živé relace mezi publisherem a brokerem     {ENU} Interval for keep alive comm session between publisher and broker MUST BE: keepAliveInterval > pingInterval*)
    clientId_auto    : bool :=  true;  (*`{CSY} ID klienta bude generováno automaticky nebo ne                   {ENU} client ID will be generated automatically and append timestamp to MQTT client id*)
    clientId         : string [40];  (*`{CSY} statické ID klienta, relevantní, když clientId_auto = false      {ENU} static client ID, relevant when clientId_auto = false, therefore, this ID should be unique per client and broker.*)
    loginName        : string [40];  (*`{CSY} Prihlašovací jméno, které se používá v prípade potreby aterizace {ENU} A login name, using when required authorization*)
    loginPass        : string [40];  (*`{CSY} Heslo, které se používá v prípade potreby autorizace             {ENU} A password, using when required authorization*)
    com_param        : T_MQTT_COM_PARAM;  (*`{CSY} Parametry relace MQTT                                            {ENU} Parameters of MQTT session*)
    topicTxt         : string [80];  (*`{CSY} Topic kam se data odesílají                                      {ENU} topic where published sends data*)
    sendCom          : bool R_EDGE;  (*`{CSY} Príkaz k odeslání dat                                            {ENU} command to send data*)
    pData            : PTR_TO usint;  (*`{CSY} Pointer na buffer/pamet odchozích dat                            {ENU} pointer to buffer of outgoing data*)
    dataLength       : uint;  (*`{CSY} Délka zprávy                                                     {ENU} length of message*)
  END_VAR
  VAR_OUTPUT
    conn_status      : bool;  (*`{CSY} Stav pripojení TCP {ENU} TCP connection state*)
    connected_to_broker : bool;  (*`{CSY} Stav pripojení k brokeru MQTT {ENU} Connection state to MQTT broker*)
    client_id        : string [40];  (*`{CSY} ID klienta použité v komunikacní relaci {ENU} Client ID used in communication session*)
    local_port       : uint;  (*`{CSY} Lokální port PLC {ENU} Current PLC local port*)
    rxCounter        : uint;  (*`{CSY} Pocítadlo príchozích zpráv {ENU} Incoming messages counter*)
    txCounter        : uint;  (*`{CSY} Pocitadlo odchozích zpráv {ENU} Outgoing messages counter*)
    messageID        : uint;  (*`{CSY} ID odchozí zprávy používá se, když QOS > 0 {ENU} message id, used when QOS > 0*)
    busy             : bool;  (*`{CSY} FB je zaneprázdnen a není prístupný pro uživatelské aplikace {ENU} FB is busy and not accessible for user application*)
    ok               : bool;  (*`{CSY} FB je pripraven pro uživatelské príkazy {ENU} FB is ready for user app commands*)
    err              : bool;  (*`{CSY} Vyskytla se chyba {ENU} Error occurred*)
    errCode          : usint;  (*`{CSY} Kód chyby {ENU} Code of error*)
    mesSent {HIDDEN} : bool;  (*`{CSY} {ENU} message is sent*)
    txMsgLength {HIDDEN} : uint;
  END_VAR
  VAR
    MQTT_Comm_Init   : fbMQTT_Comm_Init;
    MQTT_ping_timer  : fbTick;
    MQTT_com_intervat : fbTick;
    MQTT_com_responce_timeout : TON;
    SendTo           : fbSendTo;
    RecvFrom         : fbRecvFrom;
    txData           : ARRAY [0..512] OF usint;
    rxData           : ARRAY [0..512] OF usint;
    payloadLengthArrayTemp : ARRAY [1..4] OF usint;
    MQTT_PROTOCOL    : string [4] :=  'MQTT';
    payloadLength    : uint;
    payloadLength1   : uint;
    txMsgLengthTemp  : uint;
    encodedByte      : byte;
    tx_data_request  : bool;
    localPortExtension : uint;
    idle_time        : usint;
    payloadLengthSize : uint;
    reconnect_counter : usint;
    wait_response    : bool;
    connectFlags     : byte;
    aliveTime        : uint;
    pubReleaseRq     : bool;
    messageIDpubRel  : uint;
    messageIDpubRel_ptr : PTR_TO uint;
    index            : uint;
    responce_recived : bool;  (*`{CSY} {ENU} code of error*)
    errorCounter     : usint;
    messageIDlast    : uint;
  END_VAR
  VAR CONSTANT
    MQTT_PROTOCOL_VERSION : usint :=  4;
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION_BLOCK fbMQTTSubscriber
(*`{ENG} FB acts as client for incoming data in text form
        A client-subscriber tells the broker which topics interest it.
        Once subscribed, the broker sends messages published to that topic.
        A client can subscribe to multiple topics.
  {CSY} FB funguje jako klient pro pøíchozí data v textové podobì
        FB navazuji komunikaci definovanym MQTT brokerema  sdìlujií brokeru, ktere topiky ho zajímají.
        Po pøihlášení broker odešle zprávy publikované k tomuto topiku
        Klient se mùže pøihlásit k odbìru více témat.*)
  VAR_INPUT
    connect          : bool;  (*`{CSY} Príkaz k pripojení {ENU} Connect or disconnect command*)
    chanCode         : uint;  (*`{CSY} Komunikaèní UNI kanál {ENU} Communication UNI channel for MQTT commands and states*)
    brokerIP         : TIPadr;  (*`{CSY} IP adresa MQTT brokeru {ENU} IP address of MQTT broker*)
    brokerPort       : uint :=  1883;  (*`{CSY} port MQTT brokru (výchozí hodnota je 1883) {ENU} port of MQTT broker (default value is 1883)*)
    localPort        : uint :=  5000;  (*`{CSY} lokální port PLC {ENU} local port PLC*)
    keepAlive        : bool :=  true;  (*`{CSY} FB udržuje komunikaèní kanál otevøený {ENU} FB keep comm channel opened during communication session (Brocker keeps all settings)*)
    keepAliveInterval : time :=  T#20s;  (*`{CSY} maximální doba, kdy broker uzavøe spojení a vymaže všechna nastavení publishera {ENU} maximum time when broker close session and clear all settings of publisher*)
    connTimeOut      : time :=  T#10s;  (*`{CSY} maximální èasový limit odezvy od brekera {ENU} maximum timeout of response from broker*)
    pingInterval     : time :=  T#15s;  (*`{CSY} Interval pro udrženi živé relace mezi publisherem a brokerem {ENU} Interval for keep alive comm session between publisher and broker MUST BE: keepAliveInterval > pingInterval*)
    clientId_auto    : bool :=  true;  (*`{CSY} ID klienta bude generováno automaticky nebo ne {ENU} client ID will be generated automatically and append timestamp to MQTT client id*)
    clientId         : string [40];  (*`{CSY} statické ID klienta, relevantní, když clientId_auto = false {ENU} static client ID, relevant when clientId_auto = false, therefore, this ID should be unique per client and broker.*)
    loginName        : string [40];  (*`{CSY} Pøihlašovací jméno, které se používá v pøípadì potøeby aterizace {ENU} A login name, using when required authorization*)
    loginPass        : string [40];  (*`{CSY} Heslo, které se používá v pøípadì potøeby autorizace {ENU} A password, using when required authorization*)
    com_param        : T_MQTT_COM_PARAM;  (*`{CSY} Parametry relace MQTT {ENU} Parameters of MQTT session*)
    subRq            : bool R_EDGE;  (*`{CSY} Pøihlásit se k odbìru topiku definované v 'topicTxt' {ENU} Subscribe request to topic defined in 'topicTxt'*)
    unSubRq          : bool R_EDGE;  (*`{CSY} Odhlásit se z topiku definované v 'topicTxt' {ENU} Unsubscribe request from topic defined in 'topicTxt'*)
    topicTxt         : string [80];  (*`{CSY} Topik k odberu nebo odhlášení {ENU} Topic to subscribe or unsubscribe*)
  END_VAR
  VAR_OUTPUT
    conn_status      : bool;  (*`{CSY} Stav pripojení TCP {ENU} TCP connection state*)
    connected_to_broker : bool;  (*`{CSY} Stav pripojení k brokeru MQTT {ENU} Connection state to MQTT broker*)
    client_id        : string [40];  (*`{CSY} ID klienta použité v komunikaèní relaci {ENU} Client ID used in communication session*)
    local_port       : uint;  (*`{CSY} Lokální port PLC {ENU} Current PLC local port*)
    rxCounter        : uint;  (*`{CSY} Poèítadlo pøíchozích zpráv {ENU} Incoming messages counter*)
    txCounter        : uint;  (*`{CSY} Poèitadlo odchozích zpráv {ENU} Outgoing messages counter*)
    messageID        : uint;  (*`{CSY} ID odchozí zprávy používá se, když QOS > 0 {ENU} message id, used when QOS > 0*)
    busy             : bool;  (*`{CSY} FB je zaneprázdnìn a není pøístupný pro uživatelské aplikace {ENU} FB is busy and not accessible for user application*)
    ok               : bool;  (*`{CSY} FB je pøipraven pro uživatelské pøíkazy {ENU} FB is ready for user app commands*)
    err              : bool;  (*`{CSY} Vyskytla se chyba {ENU} Error occurred*)
    errCode          : usint;  (*`{CSY} Kód chyby {ENU} Code of error*)
    dataRec          : bool;  (*`{CSY} Indikace pøijatých dat od brokera  {ENU} Indication of received data from broker*)
    dataRecDT        : dt;  (*`{CSY} Datum a èas naposledy pøijatých dat od brokera {ENU} Date and time of last received data from broker*)
    dataTopicTxt     : string [80];  (*`{CSY} Topik pøijatých dat {ENU} Topic of received data*)
    dataTxt          : string [255];  (*`{CSY} Pøijatá data {ENU} Received data, message*)
    responce_recived : bool;  (*`{CSY} {ENU} Responce of last command recieved*)
  END_VAR
  VAR
    MQTT_Comm_Init   : fbMQTT_Comm_Init;
    MQTT_ping_timer  : fbTick;
    MQTT_com_intervat : fbTick;
    MQTT_com_responce_timeout : TON;
    index            : usint;
    SendTo           : fbSendTo;
    RecvFrom         : fbRecvFrom;
    txData           : ARRAY [0..100] OF usint;
    rxData           : ARRAY [0..300] OF usint;
    txMsgLength      : uint;
    payloadLength    : uint;
    payloadLength1   : uint;
    MQTT_PROTOCOL    : string [4] :=  'MQTT';
    tx_data_request  : bool;
    localPortExtension : uint;
    idle_time        : usint;
    reconnect_counter : usint;
    wait_response    : bool;
    connectFlags     : byte;
    aliveTime        : uint;
    inDataCom_param  : T_MQTT_COM_PARAM;
    inTopicLen       : uint;
    inMsgLen         : uint;
    pubAckRq         : bool;
    messageIDpubAck_ptr : PTR_TO uint;
    messageIDpubAck  : uint;
    pubRecRq         : bool;
    pubCompRq        : bool;
    payloadLengthSize : uint;
    payloadLengthBytes : uint;
  END_VAR
  VAR CONSTANT
    MQTT_PROTOCOL_VERSION : usint :=  4;
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION_BLOCK fbMQTTSubscriberEx
(*`{ENG} FB acts as client for incoming data in text or binary form up to 512 bytes
        A client tells the broker which topics interest it.
        Once subscribed, the broker sends messages published to that topic.
        A client can subscribe to multiple topics.
  {CSY} FB funguje jako klient pro pøíchozí data v textové nebo binární podobì až do 512 bytù
        FB navazuji komunikaci definovanym MQTT brokerema  sdìlujií brokeru, ktere topiky ho zajímají.
        Po pøihlášení broker odešle zprávy publikované k tomuto topiku
        Klient se mùže pøihlásit k odbìru více témat.*)
  VAR_INPUT
    connect          : bool;  (*`{CSY} Príkaz k pripojení {ENU} Connect or disconnect command*)
    chanCode         : uint;  (*`{CSY} Komunikaèní UNI kanál {ENU} Communication UNI channel for MQTT commands and states*)
    brokerIP         : TIPadr;  (*`{CSY} IP adresa MQTT brokeru {ENU} IP address of MQTT broker*)
    brokerPort       : uint :=  1883;  (*`{CSY} port MQTT brokru (výchozí hodnota je 1883) {ENU} port of MQTT broker (default value is 1883)*)
    localPort        : uint :=  5000;  (*`{CSY} lokální port PLC {ENU} local port PLC*)
    keepAlive        : bool :=  true;  (*`{CSY} FB udržuje komunikaèní kanál otevøený {ENU} FB keep comm channel opened during communication session (Brocker keeps all settings)*)
    keepAliveInterval : time :=  T#20s;  (*`{CSY} maximální doba, kdy broker uzavøe spojení a vymaže všechna nastavení publishera {ENU} maximum time when broker close session and clear all settings of publisher*)
    connTimeOut      : time :=  T#10s;  (*`{CSY} maximální èasový limit odezvy od brekera {ENU} maximum timeout of response from broker*)
    pingInterval     : time :=  T#15s;  (*`{CSY} Interval pro udrženi živé relace mezi publisherem a brokerem {ENU} Interval for keep alive comm session between publisher and broker MUST BE: keepAliveInterval > pingInterval*)
    clientId_auto    : bool :=  true;  (*`{CSY} ID klienta bude generováno automaticky nebo ne {ENU} client ID will be generated automatically and append timestamp to MQTT client id*)
    clientId         : string [40];  (*`{CSY} statické ID klienta, relevantní, když clientId_auto = false {ENU} static client ID, relevant when clientId_auto = false, therefore, this ID should be unique per client and broker.*)
    loginName        : string [40];  (*`{CSY} Pøihlašovací jméno, které se používá v pøípadì potøeby aterizace {ENU} A login name, using when required authorization*)
    loginPass        : string [40];  (*`{CSY} Heslo, které se používá v pøípadì potøeby autorizace {ENU} A password, using when required authorization*)
    com_param        : T_MQTT_COM_PARAM;  (*`{CSY} Parametry relace MQTT {ENU} Parameters of MQTT session*)
    subRq            : bool R_EDGE;  (*`{CSY} Pøihlásit se k odbìru topiku definované v 'topicTxt' {ENU} Subscribe request to topic defined in 'topicTxt'*)
    unSubRq          : bool R_EDGE;  (*`{CSY} Odhlásit se z topiku definované v 'topicTxt' {ENU} Unsubscribe request from topic defined in 'topicTxt'*)
    topicTxt         : string [80];  (*`{CSY} Topik k odberu nebo odhlášení {ENU} Topic to subscribe or unsubscribe*)
    pData            : PTR_TO usint;
  END_VAR
  VAR_OUTPUT
    conn_status      : bool;  (*`{CSY} Stav pripojení TCP {ENU} TCP connection state*)
    connected_to_broker : bool;  (*`{CSY} Stav pripojení k brokeru MQTT {ENU} Connection state to MQTT broker*)
    client_id        : string [40];  (*`{CSY} ID klienta použité v komunikaèní relaci {ENU} Client ID used in communication session*)
    local_port       : uint;  (*`{CSY} Lokální port PLC {ENU} Current PLC local port*)
    rxCounter        : uint;  (*`{CSY} Poèítadlo pøíchozích zpráv {ENU} Incoming messages counter*)
    txCounter        : uint;  (*`{CSY} Poèitadlo odchozích zpráv {ENU} Outgoing messages counter*)
    messageID        : uint;  (*`{CSY} ID odchozí zprávy používá se, když QOS > 0 {ENU} message id, used when QOS > 0*)
    busy             : bool;  (*`{CSY} FB je zaneprázdnìn a není pøístupný pro uživatelské aplikace {ENU} FB is busy and not accessible for user application*)
    ok               : bool;  (*`{CSY} FB je pøipraven pro uživatelské pøíkazy {ENU} FB is ready for user app commands*)
    err              : bool;  (*`{CSY} Vyskytla se chyba {ENU} Error occurred*)
    errCode          : usint;  (*`{CSY} Kód chyby {ENU} Code of error*)
    dataRec          : bool;  (*`{CSY} Indikace pøijatých dat od brokera  {ENU} Indication of received data from broker*)
    dataRecDT        : dt;  (*`{CSY} Datum a èas naposledy pøijatých dat od brokera {ENU} Date and time of last received data from broker*)
    dataTopicTxt     : string [80];  (*`{CSY} Topik pøijatých dat {ENU} Topic of received data*)
    inMsgLen         : uint;  (*`{CSY} Pocet bajtu v prijaté zpráve {ENU} Count of bytes in received message*)
    responce_recived : bool;  (*`{CSY} {ENU} Responce of last command recieved*)
  END_VAR
  VAR
    MQTT_Comm_Init   : fbMQTT_Comm_Init;
    MQTT_ping_timer  : fbTick;
    MQTT_com_intervat : fbTick;
    MQTT_com_responce_timeout : TON;
    index            : usint;
    SendTo           : fbSendTo;
    RecvFrom         : fbRecvFrom;
    txData           : ARRAY [0..100] OF usint;
    rxData           : ARRAY [0..512] OF usint;
    txMsgLength      : uint;
    payloadLength    : uint;
    payloadLength1   : uint;
    MQTT_PROTOCOL    : string [4] :=  'MQTT';
    tx_data_request  : bool;
    localPortExtension : uint;
    idle_time        : usint;
    reconnect_counter : usint;
    wait_response    : bool;
    connectFlags     : byte;
    aliveTime        : uint;
    inDataCom_param  : T_MQTT_COM_PARAM;
    inTopicLen       : uint;
    pubAckRq         : bool;
    messageIDpubAck_ptr : PTR_TO uint;
    messageIDpubAck  : uint;
    pubRecRq         : bool;
    pubCompRq        : bool;
    payloadLengthSize : uint;
    payloadLengthBytes : uint;
  END_VAR
  VAR CONSTANT
    MQTT_PROTOCOL_VERSION : usint :=  4;
  END_VAR
END_FUNCTION_BLOCK



{USES=fbMQTT_Comm_Init:GetRemoteIPaddress,CloseTCPconnection,IsEstabTCPconnection,SetRemoteIPaddress,EstabTCPconnection}
{USES=fbMQTTPublisher:GetRTC,MSEC_OF_DT,MemcpyPtr,fSwapUINT}
{USES=fbMQTTPublisherEx:GetRTC,MSEC_OF_DT,MemcpyPtr,fSwapUINT}
{USES=fbMQTTSubscriber:GetRTC,MSEC_OF_DT,MemcpyPtr,fSwapUINT,GetDateTime,Memset}
{USES=fbMQTTSubscriberEx:GetRTC,MSEC_OF_DT,MemcpyPtr,fSwapUINT,GetDateTime,Memset}
#srcfile 'C:\TECOLIBSRC\MQTT_LIB\MQTT_LIB\FBMQTTCONTROL.ST'
#pou MQTT_Lib_support
#srcline 59 ;FUNCTION MQTT_Lib_support {HIDDEN} : bool

#struct MQTT_Lib_support__temp__
  bool tmp
P     61
MQTT_Lib_support_L0:
 LINK __SizeOf(MQTT_Lib_support__temp__)
 NXT
; Initialize - dynamic variables
; End initialize - dynamic variables
#srcline 70 ;begin
#srcline 71 ;  {asm}
#srcline 72
     LD     0
#srcline 73
     LEAY   tmp
#srcline 74
     LDX    code      ;napr. TXF 689 22
#srcline 75
     SYS    1         ;testovat existenci AP
#srcline 76
     LD    -1
#srcline 77
     EQ
#srcline 78
     LD    %S43
#srcline 79
     AND   $F0
#srcline 80
     EQ    $10        ;simulator, nekontrolovat
#srcline 81
     OR
#srcline 82
     WRY    tmp       ;tmp = -1 ... AP existuje nebo bezi simulator
#srcline 83 ;  {end_asm}
#srcline 84 ;  MQTT_Lib_support := tmp OR (tim > %SL52);
 LDY  tmp
#debug bool tmp
 LDX  tim
#debug udint tim
 LD   %SL52
 GT
 OR  
 WRX  __fc__MQTT_Lib_support
#debug_left bool MQTT_Lib_support
#srcline 85 ;END_FUNCTION
 PRV  
 LDX  __fc__MQTT_Lib_support
 ULNK
RET
E     61
#endpou 

#pou fSwapUINT
#srcline 88 ;FUNCTION fSwapUINT {HIDDEN} : UINT
P     61
fSwapUINT_L0:
 LINK 0
 NXT
; Initialize - variables
 LD   0
 WRX  __fc__fSwapUINT
; End initialize - variables
#srcline 94 ;begin
#srcline 95 ;  {asm}
#srcline 96
	  ldx    input             ;nacist 2 byty
#srcline 97
	  swp				               ;prohodit spodni horni byte
#srcline 98
	  wrx    __fc__fSwapUINT   ;zapsat zpet
#srcline 99 ;  {end_asm}
#srcline 101 ;END_FUNCTION
 PRV  
 LDX  __fc__fSwapUINT
 ULNK
RET
E     61
#endpou 

#pou fbMQTT_Comm_Init
#srcline 105 ;FUNCTION_BLOCK fbMQTT_Comm_Init {HIDDEN}
P     61
fbMQTT_Comm_Init_L0:
 LINK 0
#srcline 125 ;  status := true;
 LD   bool -1       ; true
 WRX  status
#debug_left bool status
#srcline 127 ;  GetRemoteIPaddress(chanCode, ethAdr);
 NXT
 LDX  chanCode
#debug uint chanCode
 WR   __Instance__GetRemoteIPaddress~chanCode
#debug_left uint __Instance__GetRemoteIPaddress~chanCode
 LEAX ethAdr
 WR   __Instance__GetRemoteIPaddress~ethAdr
#debug_left pointer __Instance__GetRemoteIPaddress.ethAdr
 PRV
 LEA  __Instance__GetRemoteIPaddress
 CAL  GetRemoteIPaddress_L0
#srcline 129 ;  if (ethAdr.localPort <> localPort) OR connect = false then
 LDX  ethAdr~localPort
#debug uint ethAdr.localPort
 LDX  localPort
#debug uint localPort
 EQ
 NEG
 LDX  connect
#debug bool connect
 LD   bool 0       ; false
 XOR
 NEG
 OR  
 JMC  fbMQTT_Comm_Init_L1
#srcline 130 ;       CloseTCPConnection(chanCode);
 NXT
 LDX  chanCode
#debug uint chanCode
 WR   __Instance__CloseTCPconnection~chanCode
#debug_left uint __Instance__CloseTCPconnection~chanCode
 PRV
 LEA  __Instance__CloseTCPconnection
 CAL  CloseTCPconnection_L0
#srcline 131 ;       status := false;
 LD   bool 0       ; false
 WRX  status
#debug_left bool status
#srcline 132 ;  end_if;
fbMQTT_Comm_Init_L1:
#srcline 133 ;  if connect = true  then
 LDX  connect
#debug bool connect
 LD   bool -1       ; true
 XOR
 NEG
 JMC  fbMQTT_Comm_Init_L3
#srcline 134 ;      if IsEstabTCPconnection(chanCode) = false then
 NXT
 LDX  chanCode
#debug uint chanCode
 WR   __Instance__IsEstabTCPconnection~chanCode
#debug_left uint __Instance__IsEstabTCPconnection~chanCode
 PRV
 LEA  __Instance__IsEstabTCPconnection
 CAL  IsEstabTCPconnection_L0
 LD   bool 0       ; false
 XOR
 NEG
 JMC  fbMQTT_Comm_Init_L5
#srcline 135 ;           status := false;
 LD   bool 0       ; false
 WRX  status
#debug_left bool status
#srcline 136 ;           ethAdr.remoteIP   := remoteIP;
 LEAX remoteIP
#debug pointer remoteIP
 SRC  %IB0
 LEAX ethAdr~remoteIP
#debug_left pointer ethAdr.remoteIP
 LD   4   ;SizeOf() 
 MOV  %IB0
#srcline 137 ;           ethAdr.remotePort := remotePort;
 LDX  remotePort
#debug uint remotePort
 WRX  ethAdr~remotePort
#debug_left uint ethAdr.remotePort
#srcline 138 ;           ethAdr.localPort  := localPort;
 LDX  localPort
#debug uint localPort
 WRX  ethAdr~localPort
#debug_left uint ethAdr.localPort
#srcline 140 ;           SetRemoteIPaddress( true, chanCode, ethAdr );
 NXT
 LD   bool -1       ; true
 WR   __Instance__SetRemoteIPaddress~rq
#debug_left bool __Instance__SetRemoteIPaddress~rq
 LDX  chanCode
#debug uint chanCode
 WR   __Instance__SetRemoteIPaddress~chanCode
#debug_left uint __Instance__SetRemoteIPaddress~chanCode
 LEAX ethAdr
 WR   __Instance__SetRemoteIPaddress~ethAdr
#debug_left pointer __Instance__SetRemoteIPaddress.ethAdr
 PRV
 LEA  __Instance__SetRemoteIPaddress
 CAL  SetRemoteIPaddress_L0
#srcline 141 ;           EstabTCPconnection( chanCode );
 NXT
 LDX  chanCode
#debug uint chanCode
 WR   __Instance__EstabTCPconnection~chanCode
#debug_left uint __Instance__EstabTCPconnection~chanCode
 PRV
 LEA  __Instance__EstabTCPconnection
 CAL  EstabTCPconnection_L0
#srcline 142 ;           //KeepAliveTCP(rq := keepAlive,chanCode := chanCode, PT := T#5s, error => error);
#srcline 143 ;      end_if;
fbMQTT_Comm_Init_L5:
#srcline 144 ;  else
 JMP  fbMQTT_Comm_Init_L4
fbMQTT_Comm_Init_L3:
#srcline 145 ;    status := false;
 LD   bool 0       ; false
 WRX  status
#debug_left bool status
#srcline 146 ;  end_if;
fbMQTT_Comm_Init_L4:
#srcline 147 ;END_FUNCTION_BLOCK
 ULNK
RET
E     61

; Initialize - variables
P     61
fbMQTT_Comm_Init__InstanceInit__:
 LINK 0
 LD   bool -1   ; true
 WRX  keepAlive
 ULNK
RET
E     61
; End initialize - variables
#endpou 

#pou fbMQTTPublisher
#srcline 537 ;FUNCTION_BLOCK fbMQTTPublisher
#table byte __Init___fbMQTTPublisher_com_param = 
      0,  0,  1, 10;
#table byte __Init___fbMQTTPublisher_MQTT_PROTOCOL = 
    'M','Q','T','T';

#struct fbMQTTPublisher__temp__
  usint P0__st__,
  string[42] PS0__st__,
  string[42] PSC__st__
#data byte _str_fbMQTTPublisher_0 = 
  '',0
#data byte _str_fbMQTTPublisher_1 = 
  '',0
P     61
fbMQTTPublisher_L0:
 LINK __SizeOf(fbMQTTPublisher__temp__)
; Initialize - dynamic variables
; End initialize - dynamic variables
; R_EDGE, F_EDGE 
 LDX  sendCom
 LETX __EDGE_R__sendCom
 WRX  sendCom
#srcline 619 ;  err := false;
 LD   bool 0       ; false
 WRX  err
#debug_left bool err
#srcline 620 ;  
#srcline 621 ;  if MQTT_com_responce_timeout.Q then
 LDX  MQTT_com_responce_timeout~Q
#debug bool MQTT_com_responce_timeout.Q
 JMC  fbMQTTPublisher_L1
#srcline 622 ;      if responce_recived = false then
 LDX  responce_recived
#debug bool responce_recived
 LD   bool 0       ; false
 XOR
 NEG
 JMC  fbMQTTPublisher_L3
#srcline 623 ;          connected_to_broker := false;
 LD   bool 0       ; false
 WRX  connected_to_broker
#debug_left bool connected_to_broker
#srcline 624 ;      end_if;
fbMQTTPublisher_L3:
#srcline 625 ;      wait_response := false;
 LD   bool 0       ; false
 WRX  wait_response
#debug_left bool wait_response
#srcline 626 ;      busy          := false;
 LD   bool 0       ; false
 WRX  busy
#debug_left bool busy
#srcline 627 ;      ok            := false;
 LD   bool 0       ; false
 WRX  ok
#debug_left bool ok
#srcline 628 ;      err           := true;
 LD   bool -1       ; true
 WRX  err
#debug_left bool err
#srcline 629 ;      errCode       := MQTT_CONTROL_ERROR_CODE_BROKER_ANSWER_TIME_OUT;
 LD   usint 1
 WRX  errCode
#debug_left usint errCode
#srcline 630 ;   end_if;
fbMQTTPublisher_L1:
#srcline 632 ;   local_port := localPort + localPortExtension;
 LDX  localPort
#debug uint localPort
 LDX  localPortExtension
#debug uint localPortExtension
 ADD
 AND  $FFFF
 WRX  local_port
#debug_left uint local_port
#srcline 633 ;   MQTT_Comm_Init( connect := connect, chanCode := chanCode, remoteIP := brokerIP, remotePort := brokerPort, localPort := localPort + localPortExtension,
 LDX  connect
#debug bool connect
 WRX  MQTT_Comm_Init~connect
#debug_left bool MQTT_Comm_Init~connect
 LDX  chanCode
#debug uint chanCode
 WRX  MQTT_Comm_Init~chanCode
#debug_left uint MQTT_Comm_Init~chanCode
 LEAX brokerIP
#debug pointer brokerIP
 SRC  %IB0
 LEAX MQTT_Comm_Init~remoteIP
 LD   4   ;SizeOf() 
 MOV  %IB0
 LDX  brokerPort
#debug uint brokerPort
 WRX  MQTT_Comm_Init~remotePort
#debug_left uint MQTT_Comm_Init~remotePort
 LDX  localPort
#debug uint localPort
 LDX  localPortExtension
#debug uint localPortExtension
 ADD
 AND  $FFFF
 WRX  MQTT_Comm_Init~localPort
#debug_left uint MQTT_Comm_Init~localPort
#srcline 634 ;                  status   => conn_status);
 LEAX MQTT_Comm_Init
 CAL  fbMQTT_Comm_Init_L0
; output assigment 
 LDX  MQTT_Comm_Init~status
#debug bool MQTT_Comm_Init~status
 WRX  conn_status
#debug_left bool conn_status
#srcline 636 ;   MQTT_com_responce_timeout(IN := wait_response,PT := connTimeOut);
 LDX  wait_response
#debug bool wait_response
 WRX  MQTT_com_responce_timeout~IN
#debug_left bool MQTT_com_responce_timeout~IN
 LDX  connTimeOut
#debug time connTimeOut
 WRX  MQTT_com_responce_timeout~PT
#debug_left time MQTT_com_responce_timeout~PT
 LEAX MQTT_com_responce_timeout
 CAL  TON_L0
#srcline 637 ;   MQTT_ping_timer(IN := connect AND keepAlive, PT := pingInterval);
 LDX  connect
#debug bool connect
 LDX  keepAlive
#debug bool keepAlive
 AND
 WRX  MQTT_ping_timer~IN
#debug_left bool MQTT_ping_timer~IN
 LDX  pingInterval
#debug time pingInterval
 WRX  MQTT_ping_timer~PT
#debug_left time MQTT_ping_timer~PT
 LEAX MQTT_ping_timer
 CAL  fbTick_L0
#srcline 638 ;   MQTT_com_intervat(IN := connect, PT := T#5s);
 LDX  connect
#debug bool connect
 WRX  MQTT_com_intervat~IN
#debug_left bool MQTT_com_intervat~IN
 LD   time 5000
 WRX  MQTT_com_intervat~PT
#debug_left time MQTT_com_intervat~PT
 LEAX MQTT_com_intervat
 CAL  fbTick_L0
#srcline 640 ;   if connect then
 LDX  connect
#debug bool connect
 JMC  fbMQTTPublisher_L5
#srcline 641 ;       if MQTT_com_intervat.Q OR sendCom OR pubReleaseRq then
 LDX  MQTT_com_intervat~Q
#debug bool MQTT_com_intervat.Q
 LDX  sendCom
#debug bool sendCom
 OR  
 LDX  pubReleaseRq
#debug bool pubReleaseRq
 OR  
 JMC  fbMQTTPublisher_L7
#srcline 642 ;           if connected_to_broker = false then
 LDX  connected_to_broker
#debug bool connected_to_broker
 LD   bool 0       ; false
 XOR
 NEG
 JMC  fbMQTTPublisher_L9
#srcline 643 ;                 if clientId_auto then
 LDX  clientId_auto
#debug bool clientId_auto
 JMC  fbMQTTPublisher_L11
#srcline 644 ;                     client_id := DWORD_TO_STRING(DT_TO_DWORD(GetRTC())) + UINT_TO_STRING(MSEC_OF_DT(GetRTC()));
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   40
 DST    ; Level 1
 LD   0   ; null string
 WRY  PSC__st__[0]
 LEAY PSC__st__[0]
 LD   40
 DST    ; Level 2
 LEA  __Instance__GetRTC
 CAL  GetRTC_L0
 RNDD
 UDFL
 SCNV $2C30;  IEC_DWORD _TO_ IEC_STRING
 PDST   ; Level 2
 LEAY PSC__st__[0]

 SCON 
 LD   0   ; null string
 WRY  PSC__st__[0]
 LEAY PSC__st__[0]
 LD   40
 DST    ; Level 2
 NXT
 LEA  __Instance__GetRTC
 CAL  GetRTC_L0
 WR   __Instance__MSEC_OF_DT~in
#debug_left dt __Instance__MSEC_OF_DT~in
 PRV
 LEA  __Instance__MSEC_OF_DT
 CAL  MSEC_OF_DT_L0
 SCNV $0A30;  IEC_UINT _TO_ IEC_STRING
 PDST   ; Level 2
 LEAY PSC__st__[0]

 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX client_id
 WRI  
 LEAX client_id
 LD   40
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string client_id
 PDST   ; Level 1
#srcline 645 ;                 else
 JMP  fbMQTTPublisher_L12
fbMQTTPublisher_L11:
#srcline 646 ;                     client_id := clientId;
 LD   0   ; null string
 LEAX client_id
 WRI  
 LEAX client_id
 LD   40
 DST    ; Level 1
 LEAX clientId
#debug string clientId
 SCON 
#debug_left string client_id
 PDST   ; Level 1
#srcline 647 ;                 end_if;
fbMQTTPublisher_L12:
#srcline 649 ;                // Fixed header of control packet
#srcline 650 ;                // Fixed header
#srcline 651 ;                txData[0]   := MQTT_CONTROL_PACK_CONNECT; // flag bits are cleared
 LD   usint 16
 WRX  txData[0]
#debug_left usint txData[0]
#srcline 652 ;                // Variable header
#srcline 653 ;                txData[2]   := 0;
 LD   usint 0
 WRX  txData[2]
#debug_left usint txData[2]
#srcline 654 ;                txData[3]   := 4;
 LD   usint 4
 WRX  txData[3]
#debug_left usint txData[3]
#srcline 655 ;                MemcpyPtr(source := ADR(MQTT_PROTOCOL),dest := ADR(txData[4]),length := 4);
 NXT
 LEAX MQTT_PROTOCOL
#debug pointer MQTT_PROTOCOL
 LEA  __Instance__MemcpyPtr~source
 WRIL 
#debug_left udint __Instance__MemcpyPtr~source
 LEAX txData
 ADD  4  ; + offset 
#debug pointer txData[4]
 LEA  __Instance__MemcpyPtr~dest
 WRIL 
#debug_left udint __Instance__MemcpyPtr~dest
 LD   udint 4
 WR   __Instance__MemcpyPtr~length
#debug_left udint __Instance__MemcpyPtr~length
 PRV
 LEA  __Instance__MemcpyPtr
 CAL  MemcpyPtr_L0
#srcline 656 ;                txData[8]   := MQTT_PROTOCOL_VERSION;
 LD   usint 4
 WRX  txData[8]
#debug_left usint txData[8]
#srcline 657 ;                // Protocol Level byte
#srcline 658 ;                //Set connection flags
#srcline 659 ;                connectFlags := 0;
 LD   byte 0
 WRX  connectFlags
#debug_left byte connectFlags
#srcline 660 ;                if loginName <> ''        then connectFlags := 16#80; end_if;
 LEAX loginName
#debug string loginName
 LEA  _str_fbMQTTPublisher_0
 SCMP 
 EQ   0
 NEG
 JMC  fbMQTTPublisher_L13
 LD   byte $80
 WRX  connectFlags
#debug_left byte connectFlags
fbMQTTPublisher_L13:
#srcline 661 ;                if loginPass <> ''        then connectFlags := connectFlags OR 16#40; end_if;
 LEAX loginPass
#debug string loginPass
 LEA  _str_fbMQTTPublisher_1
 SCMP 
 EQ   0
 NEG
 JMC  fbMQTTPublisher_L15
 LDX  connectFlags
#debug byte connectFlags
 LD   byte $40
 OR  
 WRX  connectFlags
#debug_left byte connectFlags
fbMQTTPublisher_L15:
#srcline 662 ;                //if com_param.willRetain   then connectFlags := connectFlags OR 16#20; end_if;
#srcline 663 ;               // connectFlags := connectFlags OR SHL(IN := USINT_TO_BYTE(com_param.qos),N := 3);
#srcline 664 ;                if com_param.cleanSession then connectFlags := connectFlags OR 16#2;  end_if;
 LDX  com_param~cleanSession
#debug bool com_param.cleanSession
 JMC  fbMQTTPublisher_L17
 LDX  connectFlags
#debug byte connectFlags
 LD   byte $2
 OR  
 WRX  connectFlags
#debug_left byte connectFlags
fbMQTTPublisher_L17:
#srcline 666 ;                txData[9]   := BYTE_TO_USINT(connectFlags);//For connect set clean session
 LDX  connectFlags
#debug byte connectFlags
 WRX  txData[9]
#debug_left usint txData[9]
#srcline 667 ;                //keep alive 2 bytes, MSB+LSB
#srcline 668 ;                aliveTime := TIME_TO_UINT(keepAliveInterval)/1000;
 LDX  keepAliveInterval
#debug time keepAliveInterval
AND  $FFFF
 LD   uint 1000
 DIVL
 AND  $FFFF
 WRX  aliveTime
#debug_left uint aliveTime
#srcline 670 ;                txData[10]  := 0;
 LD   usint 0
 WRX  txData[10]
#debug_left usint txData[10]
#srcline 671 ;                txData[11]  := UINT_TO_USINT(aliveTime);
 LDX  aliveTime
#debug uint aliveTime
 AND  $FF
 WRX  txData[11]
#debug_left usint txData[11]
#srcline 672 ;                //Payload
#srcline 673 ;                payloadLength1 := LEN(IN := client_id);
 LEAX client_id
#debug string client_id
 SLEN 
 WRX  payloadLength1
#debug_left uint payloadLength1
#srcline 674 ;                txData[12]  := WORD_TO_USINT(SHR(IN := UINT_TO_WORD(payloadLength1),N := 8));
 LDX  payloadLength1
#debug uint payloadLength1
 LD   uint 8
 SHR
 AND  $FFFF
 AND  $FF
 WRX  txData[12]
#debug_left usint txData[12]
#srcline 675 ;                txData[13]  := UINT_TO_USINT(payloadLength1);
 LDX  payloadLength1
#debug uint payloadLength1
 AND  $FF
 WRX  txData[13]
#debug_left usint txData[13]
#srcline 677 ;                txMsgLength := 14;
 LD   uint 14
 WRX  txMsgLength
#debug_left uint txMsgLength
#srcline 678 ;                //Copy client ID
#srcline 679 ;                MemcpyPtr(source := ADR(client_id),dest := ADR(txData[14]), length := UINT_TO_UDINT(payloadLength1));
 NXT
 LEAX client_id
#debug pointer client_id
 LEA  __Instance__MemcpyPtr~source
 WRIL 
#debug_left udint __Instance__MemcpyPtr~source
 LEAX txData
 ADD  14  ; + offset 
#debug pointer txData[14]
 LEA  __Instance__MemcpyPtr~dest
 WRIL 
#debug_left udint __Instance__MemcpyPtr~dest
 LDX  payloadLength1
#debug uint payloadLength1
 WR   __Instance__MemcpyPtr~length
#debug_left udint __Instance__MemcpyPtr~length
 PRV
 LEA  __Instance__MemcpyPtr
 CAL  MemcpyPtr_L0
#srcline 680 ;                txMsgLength := txMsgLength + payloadLength1;
 LDX  txMsgLength
#debug uint txMsgLength
 LDX  payloadLength1
#debug uint payloadLength1
 ADD
 AND  $FFFF
 WRX  txMsgLength
#debug_left uint txMsgLength
#srcline 681 ;                //Copy user name
#srcline 682 ;                if (connectFlags AND 16#80) > 0 then
 LDX  connectFlags
#debug byte connectFlags
 LD   byte $80
 AND
 LD   byte 0
 GT
 JMC  fbMQTTPublisher_L19
#srcline 683 ;                     txData[txMsgLength]     := 0;
 LD   usint 0
 LEAX txData
 LDX  txMsgLength
#debug uint txMsgLength
 RCHK 300   ; Range Check
 ADD     ; + offset 
 WRI 
#debug_left usint txData[txMsgLength]
#srcline 684 ;                     txData[txMsgLength + 1] := LEN(IN := loginName);
 LEAX loginName
#debug string loginName
 SLEN 
 LEAX txData
 LDX  txMsgLength
#debug uint txMsgLength
 LD   uint 1
 ADD
 AND  $FFFF
 RCHK 300   ; Range Check
 ADD     ; + offset 
 WRI 
#debug_left usint txData[txMsgLength+1]
#srcline 685 ;                     payloadLength := LEN(IN := loginName);
 LEAX loginName
#debug string loginName
 SLEN 
 WRX  payloadLength
#debug_left uint payloadLength
#srcline 686 ;                     MemcpyPtr(source := ADR(loginName),dest := ADR(txData[txMsgLength + 2]),length := UINT_TO_UDINT(payloadLength));
 NXT
 LEAX loginName
#debug pointer loginName
 LEA  __Instance__MemcpyPtr~source
 WRIL 
#debug_left udint __Instance__MemcpyPtr~source
 LEAX txData
 LDX  txMsgLength
#debug uint txMsgLength
 LD   uint 2
 ADD
 AND  $FFFF
 RCHK 300   ; Range Check
 ADD     ; + offset 
#debug pointer txData[txMsgLength+2]
 LEA  __Instance__MemcpyPtr~dest
 WRIL 
#debug_left udint __Instance__MemcpyPtr~dest
 LDX  payloadLength
#debug uint payloadLength
 WR   __Instance__MemcpyPtr~length
#debug_left udint __Instance__MemcpyPtr~length
 PRV
 LEA  __Instance__MemcpyPtr
 CAL  MemcpyPtr_L0
#srcline 687 ;                     txMsgLength := txMsgLength + payloadLength + 2;
 LDX  txMsgLength
#debug uint txMsgLength
 LDX  payloadLength
#debug uint payloadLength
 ADD
 AND  $FFFF
 LD   uint 2
 ADD
 AND  $FFFF
 WRX  txMsgLength
#debug_left uint txMsgLength
#srcline 688 ;                end_if;
fbMQTTPublisher_L19:
#srcline 689 ;                //Copy password
#srcline 690 ;                if (connectFlags AND 16#40) > 0 then
 LDX  connectFlags
#debug byte connectFlags
 LD   byte $40
 AND
 LD   byte 0
 GT
 JMC  fbMQTTPublisher_L21
#srcline 691 ;                     txData[txMsgLength]     := 0;
 LD   usint 0
 LEAX txData
 LDX  txMsgLength
#debug uint txMsgLength
 RCHK 300   ; Range Check
 ADD     ; + offset 
 WRI 
#debug_left usint txData[txMsgLength]
#srcline 692 ;                     txData[txMsgLength + 1] := LEN(IN := loginPass);
 LEAX loginPass
#debug string loginPass
 SLEN 
 LEAX txData
 LDX  txMsgLength
#debug uint txMsgLength
 LD   uint 1
 ADD
 AND  $FFFF
 RCHK 300   ; Range Check
 ADD     ; + offset 
 WRI 
#debug_left usint txData[txMsgLength+1]
#srcline 693 ;                     payloadLength := LEN(IN := loginPass);
 LEAX loginPass
#debug string loginPass
 SLEN 
 WRX  payloadLength
#debug_left uint payloadLength
#srcline 694 ;                     MemcpyPtr(source := ADR(loginPass),dest := ADR(txData[txMsgLength + 2]),length := UINT_TO_UDINT(payloadLength));
 NXT
 LEAX loginPass
#debug pointer loginPass
 LEA  __Instance__MemcpyPtr~source
 WRIL 
#debug_left udint __Instance__MemcpyPtr~source
 LEAX txData
 LDX  txMsgLength
#debug uint txMsgLength
 LD   uint 2
 ADD
 AND  $FFFF
 RCHK 300   ; Range Check
 ADD     ; + offset 
#debug pointer txData[txMsgLength+2]
 LEA  __Instance__MemcpyPtr~dest
 WRIL 
#debug_left udint __Instance__MemcpyPtr~dest
 LDX  payloadLength
#debug uint payloadLength
 WR   __Instance__MemcpyPtr~length
#debug_left udint __Instance__MemcpyPtr~length
 PRV
 LEA  __Instance__MemcpyPtr
 CAL  MemcpyPtr_L0
#srcline 695 ;                     txMsgLength := txMsgLength + payloadLength + 2;
 LDX  txMsgLength
#debug uint txMsgLength
 LDX  payloadLength
#debug uint payloadLength
 ADD
 AND  $FFFF
 LD   uint 2
 ADD
 AND  $FFFF
 WRX  txMsgLength
#debug_left uint txMsgLength
#srcline 696 ;                end_if;
fbMQTTPublisher_L21:
#srcline 699 ;                // length of package
#srcline 700 ;                txData[1]       := UINT_TO_USINT(txMsgLength - 2);
 LDX  txMsgLength
#debug uint txMsgLength
 LD   uint 2
 SUB
 AND  $FFFF
 AND  $FF
 WRX  txData[1]
#debug_left usint txData[1]
#srcline 701 ;               // txMsgLength     := txMsgLength + 2;
#srcline 702 ;                tx_data_request := true;
 LD   bool -1       ; true
 WRX  tx_data_request
#debug_left bool tx_data_request
#srcline 704 ;                localPortExtension := USINT_TO_UINT(reconnect_counter);
 LDX  reconnect_counter
#debug usint reconnect_counter
 AND  $FFFF
 WRX  localPortExtension
#debug_left uint localPortExtension
#srcline 705 ;                idle_time := 2;
 LD   usint 2
 WRX  idle_time
#debug_left usint idle_time
#srcline 706 ;                // required to change port on each reconnect
#srcline 707 ;                if reconnect_counter < 100 then
 LDX  reconnect_counter
#debug usint reconnect_counter
 LD   usint 100
 LT
 JMC  fbMQTTPublisher_L23
#srcline 708 ;                    reconnect_counter := reconnect_counter + 1; //
 LDX  reconnect_counter
#debug usint reconnect_counter
 LD   usint 1
 ADD
 AND  $FF
 WRX  reconnect_counter
#debug_left usint reconnect_counter
#srcline 709 ;                else
 JMP  fbMQTTPublisher_L24
fbMQTTPublisher_L23:
#srcline 710 ;                    reconnect_counter := 0;
 LD   usint 0
 WRX  reconnect_counter
#debug_left usint reconnect_counter
#srcline 711 ;                end_if;
fbMQTTPublisher_L24:
#srcline 712 ;                responce_recived := false;
 LD   bool 0       ; false
 WRX  responce_recived
#debug_left bool responce_recived
#srcline 714 ;                busy := true;
 LD   bool -1       ; true
 WRX  busy
#debug_left bool busy
#srcline 715 ;                ok   := false;
 LD   bool 0       ; false
 WRX  ok
#debug_left bool ok
#srcline 716 ;                err  := false;
 LD   bool 0       ; false
 WRX  err
#debug_left bool err
#srcline 717 ;                return;
 JMP  fbMQTTPublisher_RET
#srcline 718 ;           //-------------------- Connected to broker -------------------------------------------------
#srcline 719 ;           else
 JMP  fbMQTTPublisher_L10
fbMQTTPublisher_L9:
#srcline 720 ;                if sendCom then
 LDX  sendCom
#debug bool sendCom
 JMC  fbMQTTPublisher_L25
#srcline 721 ;                    sendCom := false;
 LD   bool 0       ; false
 WRX  sendCom
#debug_left bool sendCom
#srcline 722 ;                     connectFlags := USINT_TO_BYTE(MQTT_CONTROL_PACK_PUBLISH);
 LD   usint 48
 AND  $FF
 WRX  connectFlags
#debug_left byte connectFlags
#srcline 723 ;                     if com_param.dup then connectFlags := connectFlags OR 16#8;  end_if;
 LDX  com_param~dup
#debug bool com_param.dup
 JMC  fbMQTTPublisher_L27
 LDX  connectFlags
#debug byte connectFlags
 LD   byte $8
 OR  
 WRX  connectFlags
#debug_left byte connectFlags
fbMQTTPublisher_L27:
#srcline 724 ;                     connectFlags := connectFlags OR SHL(IN := USINT_TO_BYTE(com_param.qos),N := 1);
 LDX  connectFlags
#debug byte connectFlags
 LDX  com_param~qos
#debug usint com_param.qos
 AND  $FF
 LD   uint 1
 SHL
 AND  $FF
 OR  
 WRX  connectFlags
#debug_left byte connectFlags
#srcline 725 ;                     if com_param.willRetain   then connectFlags := connectFlags OR 16#1; end_if;
 LDX  com_param~willRetain
#debug bool com_param.willRetain
 JMC  fbMQTTPublisher_L29
 LDX  connectFlags
#debug byte connectFlags
 LD   byte $1
 OR  
 WRX  connectFlags
#debug_left byte connectFlags
fbMQTTPublisher_L29:
#srcline 727 ;                     txData[0]     := BYTE_TO_USINT(connectFlags);
 LDX  connectFlags
#debug byte connectFlags
 WRX  txData[0]
#debug_left usint txData[0]
#srcline 729 ;                     payloadLength := LEN(IN := topicTxt);
 LEAX topicTxt
#debug string topicTxt
 SLEN 
 WRX  payloadLength
#debug_left uint payloadLength
#srcline 730 ;                   //  txData[2]     := 0;
#srcline 731 ;                   //  txData[3]     := payloadLength;
#srcline 733 ;                     txData[2]  := WORD_TO_USINT(SHR(IN := UINT_TO_WORD(payloadLength),N := 8));
 LDX  payloadLength
#debug uint payloadLength
 LD   uint 8
 SHR
 AND  $FFFF
 AND  $FF
 WRX  txData[2]
#debug_left usint txData[2]
#srcline 734 ;                     txData[3]  := UINT_TO_USINT(payloadLength);
 LDX  payloadLength
#debug uint payloadLength
 AND  $FF
 WRX  txData[3]
#debug_left usint txData[3]
#srcline 735 ;                     messageID  := messageID + 1;
 LDX  messageID
#debug uint messageID
 LD   uint 1
 ADD
 AND  $FFFF
 WRX  messageID
#debug_left uint messageID
#srcline 737 ;                     MemcpyPtr(source := ADR(topicTxt),dest := ADR(txData[4]),length := UINT_TO_UDINT(payloadLength));
 NXT
 LEAX topicTxt
#debug pointer topicTxt
 LEA  __Instance__MemcpyPtr~source
 WRIL 
#debug_left udint __Instance__MemcpyPtr~source
 LEAX txData
 ADD  4  ; + offset 
#debug pointer txData[4]
 LEA  __Instance__MemcpyPtr~dest
 WRIL 
#debug_left udint __Instance__MemcpyPtr~dest
 LDX  payloadLength
#debug uint payloadLength
 WR   __Instance__MemcpyPtr~length
#debug_left udint __Instance__MemcpyPtr~length
 PRV
 LEA  __Instance__MemcpyPtr
 CAL  MemcpyPtr_L0
#srcline 738 ;                     if com_param.qos > 0 then
 LDX  com_param~qos
#debug usint com_param.qos
 LD   usint 0
 GT
 JMC  fbMQTTPublisher_L31
#srcline 739 ;                         messageID                     := messageID + 1;
 LDX  messageID
#debug uint messageID
 LD   uint 1
 ADD
 AND  $FFFF
 WRX  messageID
#debug_left uint messageID
#srcline 740 ;                         txData[payloadLength + 4]     := WORD_TO_USINT(SHR(IN := UINT_TO_WORD(messageID), N := 8));
 LDX  messageID
#debug uint messageID
 LD   uint 8
 SHR
 AND  $FFFF
 AND  $FF
 LEAX txData
 LDX  payloadLength
#debug uint payloadLength
 LD   uint 4
 ADD
 AND  $FFFF
 RCHK 300   ; Range Check
 ADD     ; + offset 
 WRI 
#debug_left usint txData[payloadLength+4]
#srcline 741 ;                         txData[payloadLength + 4 + 1] := UINT_TO_USINT(messageID);
 LDX  messageID
#debug uint messageID
 AND  $FF
 LEAX txData
 LDX  payloadLength
#debug uint payloadLength
 LD   uint 4
 ADD
 AND  $FFFF
 LD   uint 1
 ADD
 AND  $FFFF
 RCHK 300   ; Range Check
 ADD     ; + offset 
 WRI 
#debug_left usint txData[payloadLength+4+1]
#srcline 742 ;                         payloadLength                 := payloadLength + 2;
 LDX  payloadLength
#debug uint payloadLength
 LD   uint 2
 ADD
 AND  $FFFF
 WRX  payloadLength
#debug_left uint payloadLength
#srcline 743 ;                     end_if;
fbMQTTPublisher_L31:
#srcline 744 ;                     MemcpyPtr(source := ADR(dataTxt),dest := ADR(txData[payloadLength+4]),length := LEN(dataTxt));
 NXT
 LEAX dataTxt
#debug pointer dataTxt
 LEA  __Instance__MemcpyPtr~source
 WRIL 
#debug_left udint __Instance__MemcpyPtr~source
 LEAX txData
 LDX  payloadLength
#debug uint payloadLength
 LD   uint 4
 ADD
 AND  $FFFF
 RCHK 300   ; Range Check
 ADD     ; + offset 
#debug pointer txData[payloadLength+4]
 LEA  __Instance__MemcpyPtr~dest
 WRIL 
#debug_left udint __Instance__MemcpyPtr~dest
 LEAX dataTxt
#debug string dataTxt
 SLEN 
 WR   __Instance__MemcpyPtr~length
#debug_left udint __Instance__MemcpyPtr~length
 PRV
 LEA  __Instance__MemcpyPtr
 CAL  MemcpyPtr_L0
#srcline 745 ;                     payloadLength    := payloadLength + LEN(dataTxt);
 LDX  payloadLength
#debug uint payloadLength
 LEAX dataTxt
#debug string dataTxt
 SLEN 
 ADD
 AND  $FFFF
 WRX  payloadLength
#debug_left uint payloadLength
#srcline 746 ;                     txMsgLength      := 2 + payloadLength;
 LD   uint 2
 LDX  payloadLength
#debug uint payloadLength
 ADD
 AND  $FFFF
 WRX  txMsgLength
#debug_left uint txMsgLength
#srcline 748 ;                     txMsgLengthTemp   := txMsgLength;
 LDX  txMsgLength
#debug uint txMsgLength
 WRX  txMsgLengthTemp
#debug_left uint txMsgLengthTemp
#srcline 749 ;                     payloadLengthSize := 1;
 LD   usint 1
 WRX  payloadLengthSize
#debug_left usint payloadLengthSize
#srcline 751 ;                     while txMsgLengthTemp > 0 do
fbMQTTPublisher_L33:
 LDX  txMsgLengthTemp
#debug uint txMsgLengthTemp
 LD   uint 0
 GT
 JMC  fbMQTTPublisher_L34
 DBG 
#srcline 752 ;                           encodedByte := UINT_TO_BYTE(txMsgLengthTemp MOD 128);
 LDX  txMsgLengthTemp
#debug uint txMsgLengthTemp
 LD   uint 128
 MOD
 AND  $FFFF
 AND  $FF
 WRX  encodedByte
#debug_left byte encodedByte
#srcline 753 ;                           txMsgLengthTemp := txMsgLengthTemp / 128;
 LDX  txMsgLengthTemp
#debug uint txMsgLengthTemp
 LD   uint 128
 DIVL
 AND  $FFFF
 WRX  txMsgLengthTemp
#debug_left uint txMsgLengthTemp
#srcline 754 ;                           if txMsgLengthTemp > 0 then
 LDX  txMsgLengthTemp
#debug uint txMsgLengthTemp
 LD   uint 0
 GT
 JMC  fbMQTTPublisher_L35
#srcline 755 ;                               payloadLengthArrayTemp[payloadLengthSize] := BYTE_TO_USINT(encodedByte OR 128);
 LDX  encodedByte
#debug byte encodedByte
 LD   byte 128
 OR  
 LEAX payloadLengthArrayTemp
 LDX  payloadLengthSize
#debug usint payloadLengthSize
 SUB  1   ; Low range[1]
 RCHK 3   ; Range Check
 ADD     ; + offset 
 WRI 
#debug_left usint payloadLengthArrayTemp[payloadLengthSize]
#srcline 756 ;                               payloadLengthSize := payloadLengthSize + 1;
 LDX  payloadLengthSize
#debug usint payloadLengthSize
 LD   usint 1
 ADD
 AND  $FF
 WRX  payloadLengthSize
#debug_left usint payloadLengthSize
#srcline 757 ;                           else
 JMP  fbMQTTPublisher_L36
fbMQTTPublisher_L35:
#srcline 758 ;                               payloadLengthArrayTemp[payloadLengthSize] := BYTE_TO_USINT(encodedByte);
 LDX  encodedByte
#debug byte encodedByte
 LEAX payloadLengthArrayTemp
 LDX  payloadLengthSize
#debug usint payloadLengthSize
 SUB  1   ; Low range[1]
 RCHK 3   ; Range Check
 ADD     ; + offset 
 WRI 
#debug_left usint payloadLengthArrayTemp[payloadLengthSize]
#srcline 759 ;                           end_if;
fbMQTTPublisher_L36:
#srcline 760 ;                           if payloadLengthSize > 4 then
 LDX  payloadLengthSize
#debug usint payloadLengthSize
 LD   usint 4
 GT
 JMC  fbMQTTPublisher_L37
#srcline 761 ;                               busy := false;
 LD   bool 0       ; false
 WRX  busy
#debug_left bool busy
#srcline 762 ;                               ok   := false;
 LD   bool 0       ; false
 WRX  ok
#debug_left bool ok
#srcline 763 ;                               err  := true;
 LD   bool -1       ; true
 WRX  err
#debug_left bool err
#srcline 764 ;                               //FIXME: Add error code "Payload length is out of range"
#srcline 765 ;                               return;
 JMP  fbMQTTPublisher_RET
#srcline 766 ;                           end_if;
fbMQTTPublisher_L37:
#srcline 767 ;                     end_while;
 JMP  fbMQTTPublisher_L33
fbMQTTPublisher_L34:
 NOP  -1
#srcline 769 ;                     if payloadLengthSize = 1 then
 LDX  payloadLengthSize
#debug usint payloadLengthSize
 LD   usint 1
 EQ
 JMC  fbMQTTPublisher_L39
#srcline 770 ;                         txData[1] := UINT_TO_USINT(txMsgLength);
 LDX  txMsgLength
#debug uint txMsgLength
 AND  $FF
 WRX  txData[1]
#debug_left usint txData[1]
#srcline 771 ;                     else
 JMP  fbMQTTPublisher_L40
fbMQTTPublisher_L39:
#srcline 772 ;                         txMsgLength     := txMsgLength + USINT_TO_UINT(payloadLengthSize) - 1;
 LDX  txMsgLength
#debug uint txMsgLength
 LDX  payloadLengthSize
#debug usint payloadLengthSize
 AND  $FFFF
 ADD
 AND  $FFFF
 LD   uint 1
 SUB
 AND  $FFFF
 WRX  txMsgLength
#debug_left uint txMsgLength
#srcline 773 ;                         txMsgLengthTemp := txMsgLength;
 LDX  txMsgLength
#debug uint txMsgLength
 WRX  txMsgLengthTemp
#debug_left uint txMsgLengthTemp
#srcline 775 ;                         while txMsgLengthTemp >= USINT_TO_UINT(payloadLengthSize) do
fbMQTTPublisher_L41:
 LDX  txMsgLengthTemp
#debug uint txMsgLengthTemp
 LDX  payloadLengthSize
#debug usint payloadLengthSize
 AND  $FFFF
 LT
 NEG
 JMC  fbMQTTPublisher_L42
 DBG 
#srcline 776 ;                           txData[txMsgLengthTemp + 1] := txData[txMsgLengthTemp];
 LEAX txData
 LDX  txMsgLengthTemp
#debug uint txMsgLengthTemp
 RCHK 300   ; Range Check
 ADD     ; + offset 
 LDI  
#debug usint txData[txMsgLengthTemp]
 LEAX txData
 LDX  txMsgLengthTemp
#debug uint txMsgLengthTemp
 LD   uint 1
 ADD
 AND  $FFFF
 RCHK 300   ; Range Check
 ADD     ; + offset 
 WRI 
#debug_left usint txData[txMsgLengthTemp+1]
#srcline 777 ;                           txMsgLengthTemp := txMsgLengthTemp - 1;
 LDX  txMsgLengthTemp
#debug uint txMsgLengthTemp
 LD   uint 1
 SUB
 AND  $FFFF
 WRX  txMsgLengthTemp
#debug_left uint txMsgLengthTemp
#srcline 778 ;                         end_while;
 JMP  fbMQTTPublisher_L41
fbMQTTPublisher_L42:
 NOP  -1
#srcline 779 ;                         for index := 1 to payloadLengthSize do
 LD   usint 1
 WRX  index
 LDX  payloadLengthSize
#debug usint payloadLengthSize
 WRY  P0__st__
fbMQTTPublisher_L43:
 LDX  index
 LDY  P0__st__
 GT   
 JMD  fbMQTTPublisher_L44
 DBG  
#srcline 780 ;                              txData[index] := payloadLengthArrayTemp[index];
 LEAX payloadLengthArrayTemp
 LDX  index
#debug usint index
 SUB  1   ; Low range[1]
 RCHK 3   ; Range Check
 ADD     ; + offset 
 LDI  
#debug usint payloadLengthArrayTemp[index]
 LEAX txData
 LDX  index
#debug usint index
 RCHK 300   ; Range Check
 ADD     ; + offset 
 WRI 
#debug_left usint txData[index]
#srcline 781 ;                         end_for;
 LDX  index
 LD   1
 ADD  
 WRX  index
 JMP  fbMQTTPublisher_L43
fbMQTTPublisher_L44:
 NOP  -1
#srcline 782 ;                     end_if;
fbMQTTPublisher_L40:
#srcline 785 ;                     txMsgLength      := txMsgLength + 2;
 LDX  txMsgLength
#debug uint txMsgLength
 LD   uint 2
 ADD
 AND  $FFFF
 WRX  txMsgLength
#debug_left uint txMsgLength
#srcline 786 ;                     tx_data_request  := true;
 LD   bool -1       ; true
 WRX  tx_data_request
#debug_left bool tx_data_request
#srcline 787 ;                     busy := true;
 LD   bool -1       ; true
 WRX  busy
#debug_left bool busy
#srcline 788 ;                     ok   := false;
 LD   bool 0       ; false
 WRX  ok
#debug_left bool ok
#srcline 789 ;                     err  := false;
 LD   bool 0       ; false
 WRX  err
#debug_left bool err
#srcline 790 ;                    return;
 JMP  fbMQTTPublisher_RET
#srcline 791 ;                end_if;
fbMQTTPublisher_L25:
#srcline 793 ;                if pubReleaseRq then
 LDX  pubReleaseRq
#debug bool pubReleaseRq
 JMC  fbMQTTPublisher_L45
#srcline 794 ;                    pubReleaseRq := false;
 LD   bool 0       ; false
 WRX  pubReleaseRq
#debug_left bool pubReleaseRq
#srcline 795 ;                    txData[0]        := MQTT_CONTROL_PACK_PUBREL + 2; // flag bits are cleared
 LD   usint 96
 LD   usint 2
 ADD
 AND  $FF
 WRX  txData[0]
#debug_left usint txData[0]
#srcline 796 ;                    txData[1]        := 2;
 LD   usint 2
 WRX  txData[1]
#debug_left usint txData[1]
#srcline 797 ;                    txData[2]        := WORD_TO_USINT(SHR(IN := UINT_TO_WORD(messageIDpubRel), N := 8));
 LDX  messageIDpubRel
#debug uint messageIDpubRel
 LD   uint 8
 SHR
 AND  $FFFF
 AND  $FF
 WRX  txData[2]
#debug_left usint txData[2]
#srcline 798 ;                    txData[3]        := UINT_TO_USINT(messageIDpubRel);
 LDX  messageIDpubRel
#debug uint messageIDpubRel
 AND  $FF
 WRX  txData[3]
#debug_left usint txData[3]
#srcline 799 ;                    txMsgLength      := 4;
 LD   uint 4
 WRX  txMsgLength
#debug_left uint txMsgLength
#srcline 800 ;                    tx_data_request  := true;
 LD   bool -1       ; true
 WRX  tx_data_request
#debug_left bool tx_data_request
#srcline 801 ;                    responce_recived := false;
 LD   bool 0       ; false
 WRX  responce_recived
#debug_left bool responce_recived
#srcline 802 ;                    busy             := true;
 LD   bool -1       ; true
 WRX  busy
#debug_left bool busy
#srcline 803 ;                    ok               := false;
 LD   bool 0       ; false
 WRX  ok
#debug_left bool ok
#srcline 804 ;                    err              := false;
 LD   bool 0       ; false
 WRX  err
#debug_left bool err
#srcline 805 ;                    return;
 JMP  fbMQTTPublisher_RET
#srcline 806 ;                end_if;
fbMQTTPublisher_L45:
#srcline 807 ;                //---------------------------------------------
#srcline 808 ;                if MQTT_ping_timer.Q then
 LDX  MQTT_ping_timer~Q
#debug bool MQTT_ping_timer.Q
 JMC  fbMQTTPublisher_L47
#srcline 809 ;                    //Ping request
#srcline 810 ;                     txData[0]        := MQTT_CONTROL_PACK_PINGREQ; // flag bits are cleared
 LD   usint 192
 WRX  txData[0]
#debug_left usint txData[0]
#srcline 811 ;                     txData[1]        := 0;
 LD   usint 0
 WRX  txData[1]
#debug_left usint txData[1]
#srcline 812 ;                     txMsgLength      := 2;
 LD   uint 2
 WRX  txMsgLength
#debug_left uint txMsgLength
#srcline 813 ;                     tx_data_request  := true;
 LD   bool -1       ; true
 WRX  tx_data_request
#debug_left bool tx_data_request
#srcline 814 ;                     responce_recived := false;
 LD   bool 0       ; false
 WRX  responce_recived
#debug_left bool responce_recived
#srcline 815 ;                     busy             := true;
 LD   bool -1       ; true
 WRX  busy
#debug_left bool busy
#srcline 816 ;                     ok               := false;
 LD   bool 0       ; false
 WRX  ok
#debug_left bool ok
#srcline 817 ;                     err              := false;
 LD   bool 0       ; false
 WRX  err
#debug_left bool err
#srcline 818 ;                     return;
 JMP  fbMQTTPublisher_RET
#srcline 819 ;                end_if;
fbMQTTPublisher_L47:
#srcline 821 ;           end_if;
fbMQTTPublisher_L10:
#srcline 822 ;       end_if;
fbMQTTPublisher_L7:
#srcline 824 ;      if conn_status then
 LDX  conn_status
#debug bool conn_status
 JMC  fbMQTTPublisher_L49
#srcline 825 ;           SendTo( rq := tx_data_request, chanCode := chanCode, lenTx := txMsgLength , data := void(txData));
 LDX  tx_data_request
#debug bool tx_data_request
 WRX  SendTo~rq
#debug_left bool SendTo~rq
 LDX  chanCode
#debug uint chanCode
 WRX  SendTo~chanCode
#debug_left uint SendTo~chanCode
 LDX  txMsgLength
#debug uint txMsgLength
 WRX  SendTo~lenTx
#debug_left uint SendTo~lenTx
 LEAX txData
 WRX  SendTo~data
#debug_left pointer SendTo.data
 LEAX SendTo
 CAL  fbSendTo_L0
#srcline 826 ;           if SendTo.mesSent then
 LDX  SendTo~mesSent
#debug bool SendTo.mesSent
 JMC  fbMQTTPublisher_L51
#srcline 827 ;               tx_data_request  := false;
 LD   bool 0       ; false
 WRX  tx_data_request
#debug_left bool tx_data_request
#srcline 828 ;               txCounter        := txCounter + 1;
 LDX  txCounter
#debug uint txCounter
 LD   uint 1
 ADD
 AND  $FFFF
 WRX  txCounter
#debug_left uint txCounter
#srcline 829 ;               messageIDlast    := messageID;
 LDX  messageID
#debug uint messageID
 WRX  messageIDlast
#debug_left uint messageIDlast
#srcline 830 ;               responce_recived := false;
 LD   bool 0       ; false
 WRX  responce_recived
#debug_left bool responce_recived
#srcline 832 ;               if com_param.qos = 0 then
 LDX  com_param~qos
#debug usint com_param.qos
 LD   usint 0
 EQ
 JMC  fbMQTTPublisher_L53
#srcline 833 ;                  busy := false;
 LD   bool 0       ; false
 WRX  busy
#debug_left bool busy
#srcline 834 ;                  ok   := true;
 LD   bool -1       ; true
 WRX  ok
#debug_left bool ok
#srcline 835 ;                  err  := false;
 LD   bool 0       ; false
 WRX  err
#debug_left bool err
#srcline 836 ;                  wait_response := false;
 LD   bool 0       ; false
 WRX  wait_response
#debug_left bool wait_response
#srcline 837 ;               else
 JMP  fbMQTTPublisher_L54
fbMQTTPublisher_L53:
#srcline 838 ;                  wait_response := true;
 LD   bool -1       ; true
 WRX  wait_response
#debug_left bool wait_response
#srcline 839 ;               end_if;
fbMQTTPublisher_L54:
#srcline 840 ;          end_if;
fbMQTTPublisher_L51:
#srcline 842 ;          RecvFrom( rq := true, chanCode := chanCode, lenRx := 100, data := void(rxData));
 LD   bool -1       ; true
 WRX  RecvFrom~rq
#debug_left bool RecvFrom~rq
 LDX  chanCode
#debug uint chanCode
 WRX  RecvFrom~chanCode
#debug_left uint RecvFrom~chanCode
 LD   uint 100
 WRX  RecvFrom~lenRx
#debug_left uint RecvFrom~lenRx
 LEAX rxData
 WRX  RecvFrom~data
#debug_left pointer RecvFrom.data
 LEAX RecvFrom
 CAL  fbRecvFrom_L0
#srcline 844 ;          if RecvFrom.mesRec then
 LDX  RecvFrom~mesRec
#debug bool RecvFrom.mesRec
 JMC  fbMQTTPublisher_L55
#srcline 845 ;              if RecvFrom.error = 0 then
 LDX  RecvFrom~error
#debug usint RecvFrom.error
 LD   usint 0
 EQ
 JMC  fbMQTTPublisher_L57
#srcline 846 ;                  messageIDpubRel_ptr := ADR(rxData[2]);
 LEAX rxData
 ADD  2  ; + offset 
#debug pointer rxData[2]
 LEAX messageIDpubRel_ptr
 WRIL 
#debug_left pointer messageIDpubRel_ptr
#srcline 847 ;                  messageIDpubRel     := messageIDpubRel_ptr^;
 LEAX messageIDpubRel_ptr
 LDIL    ; dereference 
 LDIW 
#debug uint messageIDpubRel_ptr^
 WRX  messageIDpubRel
#debug_left uint messageIDpubRel
#srcline 848 ;                  messageIDpubRel     := fSwapUINT(messageIDpubRel);
 NXT
 LDX  messageIDpubRel
#debug uint messageIDpubRel
 WR   __Instance__fSwapUINT~input
#debug_left uint __Instance__fSwapUINT~input
 PRV
 LEA  __Instance__fSwapUINT
 CAL  fSwapUINT_L0
 WRX  messageIDpubRel
#debug_left uint messageIDpubRel
#srcline 850 ;                  if RecvFrom.lenData = 4  AND rxData[0] = MQTT_CONTROL_PACK_CONNACK THEN
 LDX  RecvFrom~lenData
#debug uint RecvFrom.lenData
 LD   uint 4
 EQ
 LDX  rxData[0]
#debug usint rxData[0]
 LD   usint 32
 EQ
 AND
 JMC  fbMQTTPublisher_L59
#srcline 851 ;                       responce_recived := true;
 LD   bool -1       ; true
 WRX  responce_recived
#debug_left bool responce_recived
#srcline 852 ;                       wait_response    := false;
 LD   bool 0       ; false
 WRX  wait_response
#debug_left bool wait_response
#srcline 853 ;                       if rxData[3] = 0 then
 LDX  rxData[3]
#debug usint rxData[3]
 LD   usint 0
 EQ
 JMC  fbMQTTPublisher_L61
#srcline 854 ;                           connected_to_broker  := true;
 LD   bool -1       ; true
 WRX  connected_to_broker
#debug_left bool connected_to_broker
#srcline 855 ;                       else
 JMP  fbMQTTPublisher_L62
fbMQTTPublisher_L61:
#srcline 856 ;                           connected_to_broker  := false;
 LD   bool 0       ; false
 WRX  connected_to_broker
#debug_left bool connected_to_broker
#srcline 857 ;                           ok                   := false;
 LD   bool 0       ; false
 WRX  ok
#debug_left bool ok
#srcline 858 ;                           err                  := true;
 LD   bool -1       ; true
 WRX  err
#debug_left bool err
#srcline 859 ;                           errCode              := MQTT_CONTROL_ERROR_CODE_LOGIN_FAILED;
 LD   usint 5
 WRX  errCode
#debug_left usint errCode
#srcline 860 ;                       end_if;
fbMQTTPublisher_L62:
#srcline 861 ;                  elsif rxData[1] = 2 AND ((rxData[0] = MQTT_CONTROL_PACK_PUBACK  AND com_param.qos = 1) OR (rxData[0] = MQTT_CONTROL_PACK_PUBCOMP AND com_param.qos = 2) ) then // responce to connect command
 JMP  fbMQTTPublisher_L60
fbMQTTPublisher_L59:
 LDX  rxData[1]
#debug usint rxData[1]
 LD   usint 2
 EQ
 LDX  rxData[0]
#debug usint rxData[0]
 LD   usint 64
 EQ
 LDX  com_param~qos
#debug usint com_param.qos
 LD   usint 1
 EQ
 AND
 LDX  rxData[0]
#debug usint rxData[0]
 LD   usint 112
 EQ
 LDX  com_param~qos
#debug usint com_param.qos
 LD   usint 2
 EQ
 AND
 OR  
 AND
 JMC  fbMQTTPublisher_L63
#srcline 862 ;                      connected_to_broker := true;
 LD   bool -1       ; true
 WRX  connected_to_broker
#debug_left bool connected_to_broker
#srcline 863 ;                      responce_recived    := true;
 LD   bool -1       ; true
 WRX  responce_recived
#debug_left bool responce_recived
#srcline 864 ;                      wait_response       := false;
 LD   bool 0       ; false
 WRX  wait_response
#debug_left bool wait_response
#srcline 865 ;                      busy                := false;
 LD   bool 0       ; false
 WRX  busy
#debug_left bool busy
#srcline 866 ;                      ok                  := true;
 LD   bool -1       ; true
 WRX  ok
#debug_left bool ok
#srcline 867 ;                      err                 := false;
 LD   bool 0       ; false
 WRX  err
#debug_left bool err
#srcline 868 ;                  elsif RecvFrom.lenData = 4 AND com_param.qos = 2 AND rxData[0] = MQTT_CONTROL_PACK_PUBREC then
 JMP  fbMQTTPublisher_L60
fbMQTTPublisher_L63:
 LDX  RecvFrom~lenData
#debug uint RecvFrom.lenData
 LD   uint 4
 EQ
 LDX  com_param~qos
#debug usint com_param.qos
 LD   usint 2
 EQ
 AND
 LDX  rxData[0]
#debug usint rxData[0]
 LD   usint 80
 EQ
 AND
 JMC  fbMQTTPublisher_L64
#srcline 869 ;                         // messageIDpubRel_ptr := ADR(rxData[2]);
#srcline 870 ;                        //  messageIDpubRel     := messageIDpubRel_ptr^;
#srcline 871 ;                          messageIDpubRel     := fSwapUINT( messageIDpubRel_ptr^);
 NXT
 LEAX messageIDpubRel_ptr
 LDIL    ; dereference 
 LDIW 
#debug uint messageIDpubRel_ptr^
 WR   __Instance__fSwapUINT~input
#debug_left uint __Instance__fSwapUINT~input
 PRV
 LEA  __Instance__fSwapUINT
 CAL  fSwapUINT_L0
 WRX  messageIDpubRel
#debug_left uint messageIDpubRel
#srcline 872 ;                          messageIDlast       := messageIDpubRel;
 LDX  messageIDpubRel
#debug uint messageIDpubRel
 WRX  messageIDlast
#debug_left uint messageIDlast
#srcline 873 ;                          connected_to_broker := true;
 LD   bool -1       ; true
 WRX  connected_to_broker
#debug_left bool connected_to_broker
#srcline 874 ;                          responce_recived    := true;
 LD   bool -1       ; true
 WRX  responce_recived
#debug_left bool responce_recived
#srcline 875 ;                          wait_response       := false;
 LD   bool 0       ; false
 WRX  wait_response
#debug_left bool wait_response
#srcline 876 ;                          pubReleaseRq        := true;
 LD   bool -1       ; true
 WRX  pubReleaseRq
#debug_left bool pubReleaseRq
#srcline 877 ;                  elsif RecvFrom.lenData = 2 AND rxData[0] = MQTT_CONTROL_PACK_PINGRESP then
 JMP  fbMQTTPublisher_L60
fbMQTTPublisher_L64:
 LDX  RecvFrom~lenData
#debug uint RecvFrom.lenData
 LD   uint 2
 EQ
 LDX  rxData[0]
#debug usint rxData[0]
 LD   usint 208
 EQ
 AND
 JMC  fbMQTTPublisher_L65
#srcline 878 ;                         responce_recived := true;
 LD   bool -1       ; true
 WRX  responce_recived
#debug_left bool responce_recived
#srcline 879 ;                         wait_response    := false;
 LD   bool 0       ; false
 WRX  wait_response
#debug_left bool wait_response
#srcline 880 ;                         busy             := false;
 LD   bool 0       ; false
 WRX  busy
#debug_left bool busy
#srcline 881 ;                         ok               := true;
 LD   bool -1       ; true
 WRX  ok
#debug_left bool ok
#srcline 882 ;                         err              := false;
 LD   bool 0       ; false
 WRX  err
#debug_left bool err
#srcline 883 ;                  end_if;
 JMP  fbMQTTPublisher_L60
fbMQTTPublisher_L65:
fbMQTTPublisher_L60:
#srcline 884 ;                  rxCounter := rxCounter + 1;
 LDX  rxCounter
#debug uint rxCounter
 LD   uint 1
 ADD
 AND  $FFFF
 WRX  rxCounter
#debug_left uint rxCounter
#srcline 885 ;              end_if;
fbMQTTPublisher_L57:
#srcline 886 ;          end_if;
fbMQTTPublisher_L55:
#srcline 887 ;      else
 JMP  fbMQTTPublisher_L50
fbMQTTPublisher_L49:
#srcline 888 ;         connected_to_broker := false;
 LD   bool 0       ; false
 WRX  connected_to_broker
#debug_left bool connected_to_broker
#srcline 889 ;         wait_response       := false;
 LD   bool 0       ; false
 WRX  wait_response
#debug_left bool wait_response
#srcline 890 ;         pubReleaseRq        := false;
 LD   bool 0       ; false
 WRX  pubReleaseRq
#debug_left bool pubReleaseRq
#srcline 891 ;         busy                := false;
 LD   bool 0       ; false
 WRX  busy
#debug_left bool busy
#srcline 892 ;         ok                  := false;
 LD   bool 0       ; false
 WRX  ok
#debug_left bool ok
#srcline 893 ;         err                 := true;
 LD   bool -1       ; true
 WRX  err
#debug_left bool err
#srcline 894 ;         errCode             := MQTT_CONTROL_ERROR_CODE_BROKER_DISCONNECTED;
 LD   usint 3
 WRX  errCode
#debug_left usint errCode
#srcline 895 ;      end_if;
fbMQTTPublisher_L50:
#srcline 897 ;   else
 JMP  fbMQTTPublisher_L6
fbMQTTPublisher_L5:
#srcline 898 ;     connected_to_broker := false;
 LD   bool 0       ; false
 WRX  connected_to_broker
#debug_left bool connected_to_broker
#srcline 899 ;     wait_response       := false;
 LD   bool 0       ; false
 WRX  wait_response
#debug_left bool wait_response
#srcline 900 ;     pubReleaseRq        := false;
 LD   bool 0       ; false
 WRX  pubReleaseRq
#debug_left bool pubReleaseRq
#srcline 901 ;     busy                := false;
 LD   bool 0       ; false
 WRX  busy
#debug_left bool busy
#srcline 902 ;     ok                  := false;
 LD   bool 0       ; false
 WRX  ok
#debug_left bool ok
#srcline 903 ;     err                 := true;
 LD   bool -1       ; true
 WRX  err
#debug_left bool err
#srcline 904 ;     errCode             := MQTT_CONTROL_ERROR_CODE_BROKER_DISCONNECTED;
 LD   usint 3
 WRX  errCode
#debug_left usint errCode
#srcline 905 ;   end_if;
fbMQTTPublisher_L6:
#srcline 907 ;END_FUNCTION_BLOCK
fbMQTTPublisher_RET:
 ULNK
RET
E     61

; Initialize - variables
P     61
fbMQTTPublisher__InstanceInit__:
 LINK 0
 LD   uint 1883
 WRX  brokerPort
 LD   uint 5000
 WRX  localPort
 LD   bool -1   ; true
 WRX  keepAlive
 LD   time 20000
 WRX  keepAliveInterval
 LD   time 10000
 WRX  connTimeOut
 LD   time 15000
 WRX  pingInterval
 LD   bool -1   ; true
 WRX  clientId_auto
 LD   0
 SRC  byte __Init___fbMQTTPublisher_com_param
 LEAX byte com_param
 LD   7
 MOV  %X0
 LEAX MQTT_Comm_Init
 CAL  fbMQTT_Comm_Init__InstanceInit__
 LEAX SendTo
 CAL  fbSendTo__InstanceInit__
 LEAX RecvFrom
 CAL  fbRecvFrom__InstanceInit__
 LD   0
 SRC  byte __Init___fbMQTTPublisher_MQTT_PROTOCOL
 LEAX byte MQTT_PROTOCOL
 LD   5
 MOV  %X0
 LD   udint $FFFFFFFF    ; nil
 WRX  messageIDpubRel_ptr
 ULNK
RET
E     61
; End initialize - variables
#endpou 

#pou fbMQTTPublisherEx
#srcline 910 ;FUNCTION_BLOCK fbMQTTPublisherEx
#table byte __Init___fbMQTTPublisherEx_com_param = 
      0,  0,  1, 10;
#table byte __Init___fbMQTTPublisherEx_MQTT_PROTOCOL = 
    'M','Q','T','T';

#struct fbMQTTPublisherEx__temp__
  uint P0__st__,
  string[42] PS0__st__,
  string[42] PSC__st__
#data byte _str_fbMQTTPublisherEx_0 = 
  '',0
#data byte _str_fbMQTTPublisherEx_1 = 
  '',0
P     61
fbMQTTPublisherEx_L0:
 LINK __SizeOf(fbMQTTPublisherEx__temp__)
; Initialize - dynamic variables
; End initialize - dynamic variables
; R_EDGE, F_EDGE 
 LDX  sendCom
 LETX __EDGE_R__sendCom
 WRX  sendCom
#srcline 998 ;    mesSent := FALSE;
 LD   bool 0       ; false
 WRX  mesSent
#debug_left bool mesSent
#srcline 999 ;    err     := false;
 LD   bool 0       ; false
 WRX  err
#debug_left bool err
#srcline 1000 ;    
#srcline 1001 ;    if MQTT_com_responce_timeout.Q then
 LDX  MQTT_com_responce_timeout~Q
#debug bool MQTT_com_responce_timeout.Q
 JMC  fbMQTTPublisherEx_L1
#srcline 1002 ;      if responce_recived = false then
 LDX  responce_recived
#debug bool responce_recived
 LD   bool 0       ; false
 XOR
 NEG
 JMC  fbMQTTPublisherEx_L3
#srcline 1003 ;          connected_to_broker := false;
 LD   bool 0       ; false
 WRX  connected_to_broker
#debug_left bool connected_to_broker
#srcline 1004 ;      end_if;
fbMQTTPublisherEx_L3:
#srcline 1005 ;      wait_response := false;
 LD   bool 0       ; false
 WRX  wait_response
#debug_left bool wait_response
#srcline 1006 ;      busy    := false;
 LD   bool 0       ; false
 WRX  busy
#debug_left bool busy
#srcline 1007 ;      ok      := false;
 LD   bool 0       ; false
 WRX  ok
#debug_left bool ok
#srcline 1008 ;      err     := true;
 LD   bool -1       ; true
 WRX  err
#debug_left bool err
#srcline 1009 ;      errCode := MQTT_CONTROL_ERROR_CODE_BROKER_ANSWER_TIME_OUT;
 LD   usint 1
 WRX  errCode
#debug_left usint errCode
#srcline 1010 ;      errorCounter := errorCounter + 1;
 LDX  errorCounter
#debug usint errorCounter
 LD   usint 1
 ADD
 AND  $FF
 WRX  errorCounter
#debug_left usint errorCounter
#srcline 1011 ;   end_if;
fbMQTTPublisherEx_L1:
#srcline 1013 ;   local_port := localPort + localPortExtension;
 LDX  localPort
#debug uint localPort
 LDX  localPortExtension
#debug uint localPortExtension
 ADD
 AND  $FFFF
 WRX  local_port
#debug_left uint local_port
#srcline 1014 ;   MQTT_Comm_Init( connect := connect, chanCode := chanCode, remoteIP := brokerIP, remotePort := brokerPort, localPort := localPort + localPortExtension,
 LDX  connect
#debug bool connect
 WRX  MQTT_Comm_Init~connect
#debug_left bool MQTT_Comm_Init~connect
 LDX  chanCode
#debug uint chanCode
 WRX  MQTT_Comm_Init~chanCode
#debug_left uint MQTT_Comm_Init~chanCode
 LEAX brokerIP
#debug pointer brokerIP
 SRC  %IB0
 LEAX MQTT_Comm_Init~remoteIP
 LD   4   ;SizeOf() 
 MOV  %IB0
 LDX  brokerPort
#debug uint brokerPort
 WRX  MQTT_Comm_Init~remotePort
#debug_left uint MQTT_Comm_Init~remotePort
 LDX  localPort
#debug uint localPort
 LDX  localPortExtension
#debug uint localPortExtension
 ADD
 AND  $FFFF
 WRX  MQTT_Comm_Init~localPort
#debug_left uint MQTT_Comm_Init~localPort
#srcline 1015 ;                   status       => conn_status);
 LEAX MQTT_Comm_Init
 CAL  fbMQTT_Comm_Init_L0
; output assigment 
 LDX  MQTT_Comm_Init~status
#debug bool MQTT_Comm_Init~status
 WRX  conn_status
#debug_left bool conn_status
#srcline 1017 ;   MQTT_com_responce_timeout(IN := wait_response,PT := connTimeOut);
 LDX  wait_response
#debug bool wait_response
 WRX  MQTT_com_responce_timeout~IN
#debug_left bool MQTT_com_responce_timeout~IN
 LDX  connTimeOut
#debug time connTimeOut
 WRX  MQTT_com_responce_timeout~PT
#debug_left time MQTT_com_responce_timeout~PT
 LEAX MQTT_com_responce_timeout
 CAL  TON_L0
#srcline 1018 ;   MQTT_ping_timer(IN := connect AND keepAlive, PT := pingInterval);
 LDX  connect
#debug bool connect
 LDX  keepAlive
#debug bool keepAlive
 AND
 WRX  MQTT_ping_timer~IN
#debug_left bool MQTT_ping_timer~IN
 LDX  pingInterval
#debug time pingInterval
 WRX  MQTT_ping_timer~PT
#debug_left time MQTT_ping_timer~PT
 LEAX MQTT_ping_timer
 CAL  fbTick_L0
#srcline 1019 ;   MQTT_com_intervat(IN := connect, PT := T#5s);
 LDX  connect
#debug bool connect
 WRX  MQTT_com_intervat~IN
#debug_left bool MQTT_com_intervat~IN
 LD   time 5000
 WRX  MQTT_com_intervat~PT
#debug_left time MQTT_com_intervat~PT
 LEAX MQTT_com_intervat
 CAL  fbTick_L0
#srcline 1021 ;   if connect then
 LDX  connect
#debug bool connect
 JMC  fbMQTTPublisherEx_L5
#srcline 1022 ;       if MQTT_com_intervat.Q OR sendCom OR pubReleaseRq then
 LDX  MQTT_com_intervat~Q
#debug bool MQTT_com_intervat.Q
 LDX  sendCom
#debug bool sendCom
 OR  
 LDX  pubReleaseRq
#debug bool pubReleaseRq
 OR  
 JMC  fbMQTTPublisherEx_L7
#srcline 1023 ;           if connected_to_broker = false then
 LDX  connected_to_broker
#debug bool connected_to_broker
 LD   bool 0       ; false
 XOR
 NEG
 JMC  fbMQTTPublisherEx_L9
#srcline 1024 ;                 if clientId_auto then
 LDX  clientId_auto
#debug bool clientId_auto
 JMC  fbMQTTPublisherEx_L11
#srcline 1025 ;                     client_id := DWORD_TO_STRING(DT_TO_DWORD(GetRTC())) + UINT_TO_STRING(MSEC_OF_DT(GetRTC()));
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   40
 DST    ; Level 1
 LD   0   ; null string
 WRY  PSC__st__[0]
 LEAY PSC__st__[0]
 LD   40
 DST    ; Level 2
 LEA  __Instance__GetRTC
 CAL  GetRTC_L0
 RNDD
 UDFL
 SCNV $2C30;  IEC_DWORD _TO_ IEC_STRING
 PDST   ; Level 2
 LEAY PSC__st__[0]

 SCON 
 LD   0   ; null string
 WRY  PSC__st__[0]
 LEAY PSC__st__[0]
 LD   40
 DST    ; Level 2
 NXT
 LEA  __Instance__GetRTC
 CAL  GetRTC_L0
 WR   __Instance__MSEC_OF_DT~in
#debug_left dt __Instance__MSEC_OF_DT~in
 PRV
 LEA  __Instance__MSEC_OF_DT
 CAL  MSEC_OF_DT_L0
 SCNV $0A30;  IEC_UINT _TO_ IEC_STRING
 PDST   ; Level 2
 LEAY PSC__st__[0]

 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX client_id
 WRI  
 LEAX client_id
 LD   40
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string client_id
 PDST   ; Level 1
#srcline 1026 ;                 else
 JMP  fbMQTTPublisherEx_L12
fbMQTTPublisherEx_L11:
#srcline 1027 ;                     client_id := clientId;
 LD   0   ; null string
 LEAX client_id
 WRI  
 LEAX client_id
 LD   40
 DST    ; Level 1
 LEAX clientId
#debug string clientId
 SCON 
#debug_left string client_id
 PDST   ; Level 1
#srcline 1028 ;                 end_if;
fbMQTTPublisherEx_L12:
#srcline 1030 ;                // Fixed header of control packet
#srcline 1031 ;                // Fixed header
#srcline 1032 ;                txData[0] := MQTT_CONTROL_PACK_CONNECT; // flag bits are cleared
 LD   usint 16
 WRX  txData[0]
#debug_left usint txData[0]
#srcline 1033 ;                // Variable header
#srcline 1034 ;                txData[2] := 0;
 LD   usint 0
 WRX  txData[2]
#debug_left usint txData[2]
#srcline 1035 ;                txData[3] := 4;
 LD   usint 4
 WRX  txData[3]
#debug_left usint txData[3]
#srcline 1036 ;                MemcpyPtr(source := ADR(MQTT_PROTOCOL),dest := ADR(txData[4]),length := 4);
 NXT
 LEAX MQTT_PROTOCOL
#debug pointer MQTT_PROTOCOL
 LEA  __Instance__MemcpyPtr~source
 WRIL 
#debug_left udint __Instance__MemcpyPtr~source
 LEAX txData
 ADD  4  ; + offset 
#debug pointer txData[4]
 LEA  __Instance__MemcpyPtr~dest
 WRIL 
#debug_left udint __Instance__MemcpyPtr~dest
 LD   udint 4
 WR   __Instance__MemcpyPtr~length
#debug_left udint __Instance__MemcpyPtr~length
 PRV
 LEA  __Instance__MemcpyPtr
 CAL  MemcpyPtr_L0
#srcline 1037 ;                txData[8]   := MQTT_PROTOCOL_VERSION;
 LD   usint 4
 WRX  txData[8]
#debug_left usint txData[8]
#srcline 1038 ;                // Protocol Level byte
#srcline 1039 ;                //Set connection flags
#srcline 1040 ;                connectFlags := 0;
 LD   byte 0
 WRX  connectFlags
#debug_left byte connectFlags
#srcline 1041 ;                if loginName <> ''        then connectFlags := 16#80; end_if;
 LEAX loginName
#debug string loginName
 LEA  _str_fbMQTTPublisherEx_0
 SCMP 
 EQ   0
 NEG
 JMC  fbMQTTPublisherEx_L13
 LD   byte $80
 WRX  connectFlags
#debug_left byte connectFlags
fbMQTTPublisherEx_L13:
#srcline 1042 ;                if loginPass <> ''        then connectFlags := connectFlags OR 16#40; end_if;
 LEAX loginPass
#debug string loginPass
 LEA  _str_fbMQTTPublisherEx_1
 SCMP 
 EQ   0
 NEG
 JMC  fbMQTTPublisherEx_L15
 LDX  connectFlags
#debug byte connectFlags
 LD   byte $40
 OR  
 WRX  connectFlags
#debug_left byte connectFlags
fbMQTTPublisherEx_L15:
#srcline 1043 ;                //if com_param.willRetain   then connectFlags := connectFlags OR 16#20; end_if;
#srcline 1044 ;               // connectFlags := connectFlags OR SHL(IN := USINT_TO_BYTE(com_param.qos),N := 3);
#srcline 1045 ;                if com_param.cleanSession then connectFlags := connectFlags OR 16#2;  end_if;
 LDX  com_param~cleanSession
#debug bool com_param.cleanSession
 JMC  fbMQTTPublisherEx_L17
 LDX  connectFlags
#debug byte connectFlags
 LD   byte $2
 OR  
 WRX  connectFlags
#debug_left byte connectFlags
fbMQTTPublisherEx_L17:
#srcline 1047 ;                txData[9]   := BYTE_TO_USINT(connectFlags);//For connect set clean session
 LDX  connectFlags
#debug byte connectFlags
 WRX  txData[9]
#debug_left usint txData[9]
#srcline 1048 ;                //keep alive 2 bytes, MSB+LSB
#srcline 1049 ;                aliveTime := TIME_TO_UINT(keepAliveInterval)/1000;
 LDX  keepAliveInterval
#debug time keepAliveInterval
AND  $FFFF
 LD   uint 1000
 DIVL
 AND  $FFFF
 WRX  aliveTime
#debug_left uint aliveTime
#srcline 1051 ;                txData[10]  := 0;
 LD   usint 0
 WRX  txData[10]
#debug_left usint txData[10]
#srcline 1052 ;                txData[11]  := UINT_TO_USINT(aliveTime);
 LDX  aliveTime
#debug uint aliveTime
 AND  $FF
 WRX  txData[11]
#debug_left usint txData[11]
#srcline 1053 ;                //Payload
#srcline 1054 ;                payloadLength1 := LEN(IN := client_id);
 LEAX client_id
#debug string client_id
 SLEN 
 WRX  payloadLength1
#debug_left uint payloadLength1
#srcline 1055 ;                txData[12]  := WORD_TO_USINT(SHR(IN := UINT_TO_WORD(payloadLength1),N := 8));
 LDX  payloadLength1
#debug uint payloadLength1
 LD   uint 8
 SHR
 AND  $FFFF
 AND  $FF
 WRX  txData[12]
#debug_left usint txData[12]
#srcline 1056 ;                txData[13]  := UINT_TO_USINT(payloadLength1);
 LDX  payloadLength1
#debug uint payloadLength1
 AND  $FF
 WRX  txData[13]
#debug_left usint txData[13]
#srcline 1058 ;                txMsgLength := 14;
 LD   uint 14
 WRX  txMsgLength
#debug_left uint txMsgLength
#srcline 1059 ;                //Copy client ID
#srcline 1060 ;                MemcpyPtr(source := ADR(client_id),dest := ADR(txData[14]),length := UINT_TO_UDINT(payloadLength1));
 NXT
 LEAX client_id
#debug pointer client_id
 LEA  __Instance__MemcpyPtr~source
 WRIL 
#debug_left udint __Instance__MemcpyPtr~source
 LEAX txData
 ADD  14  ; + offset 
#debug pointer txData[14]
 LEA  __Instance__MemcpyPtr~dest
 WRIL 
#debug_left udint __Instance__MemcpyPtr~dest
 LDX  payloadLength1
#debug uint payloadLength1
 WR   __Instance__MemcpyPtr~length
#debug_left udint __Instance__MemcpyPtr~length
 PRV
 LEA  __Instance__MemcpyPtr
 CAL  MemcpyPtr_L0
#srcline 1061 ;                txMsgLength := txMsgLength + payloadLength1;
 LDX  txMsgLength
#debug uint txMsgLength
 LDX  payloadLength1
#debug uint payloadLength1
 ADD
 AND  $FFFF
 WRX  txMsgLength
#debug_left uint txMsgLength
#srcline 1062 ;                //Copy user name
#srcline 1063 ;                if (connectFlags AND 16#80) > 0 then
 LDX  connectFlags
#debug byte connectFlags
 LD   byte $80
 AND
 LD   byte 0
 GT
 JMC  fbMQTTPublisherEx_L19
#srcline 1064 ;                     txData[txMsgLength]     := 0;
 LD   usint 0
 LEAX txData
 LDX  txMsgLength
#debug uint txMsgLength
 RCHK 512   ; Range Check
 ADD     ; + offset 
 WRI 
#debug_left usint txData[txMsgLength]
#srcline 1065 ;                     txData[txMsgLength + 1] := LEN(IN := loginName);
 LEAX loginName
#debug string loginName
 SLEN 
 LEAX txData
 LDX  txMsgLength
#debug uint txMsgLength
 LD   uint 1
 ADD
 AND  $FFFF
 RCHK 512   ; Range Check
 ADD     ; + offset 
 WRI 
#debug_left usint txData[txMsgLength+1]
#srcline 1066 ;                     payloadLength := LEN(IN := loginName);
 LEAX loginName
#debug string loginName
 SLEN 
 WRX  payloadLength
#debug_left uint payloadLength
#srcline 1067 ;                     MemcpyPtr(source := ADR(loginName),dest := ADR(txData[txMsgLength + 2]),length := UINT_TO_UDINT(payloadLength));
 NXT
 LEAX loginName
#debug pointer loginName
 LEA  __Instance__MemcpyPtr~source
 WRIL 
#debug_left udint __Instance__MemcpyPtr~source
 LEAX txData
 LDX  txMsgLength
#debug uint txMsgLength
 LD   uint 2
 ADD
 AND  $FFFF
 RCHK 512   ; Range Check
 ADD     ; + offset 
#debug pointer txData[txMsgLength+2]
 LEA  __Instance__MemcpyPtr~dest
 WRIL 
#debug_left udint __Instance__MemcpyPtr~dest
 LDX  payloadLength
#debug uint payloadLength
 WR   __Instance__MemcpyPtr~length
#debug_left udint __Instance__MemcpyPtr~length
 PRV
 LEA  __Instance__MemcpyPtr
 CAL  MemcpyPtr_L0
#srcline 1068 ;                     txMsgLength := txMsgLength + payloadLength + 2;
 LDX  txMsgLength
#debug uint txMsgLength
 LDX  payloadLength
#debug uint payloadLength
 ADD
 AND  $FFFF
 LD   uint 2
 ADD
 AND  $FFFF
 WRX  txMsgLength
#debug_left uint txMsgLength
#srcline 1069 ;                end_if;
fbMQTTPublisherEx_L19:
#srcline 1070 ;                //Copy password
#srcline 1071 ;                if (connectFlags AND 16#40) > 0 then
 LDX  connectFlags
#debug byte connectFlags
 LD   byte $40
 AND
 LD   byte 0
 GT
 JMC  fbMQTTPublisherEx_L21
#srcline 1072 ;                     txData[txMsgLength]     := 0;
 LD   usint 0
 LEAX txData
 LDX  txMsgLength
#debug uint txMsgLength
 RCHK 512   ; Range Check
 ADD     ; + offset 
 WRI 
#debug_left usint txData[txMsgLength]
#srcline 1073 ;                     txData[txMsgLength + 1] := LEN(IN := loginPass);
 LEAX loginPass
#debug string loginPass
 SLEN 
 LEAX txData
 LDX  txMsgLength
#debug uint txMsgLength
 LD   uint 1
 ADD
 AND  $FFFF
 RCHK 512   ; Range Check
 ADD     ; + offset 
 WRI 
#debug_left usint txData[txMsgLength+1]
#srcline 1074 ;                     payloadLength := LEN(IN := loginPass);
 LEAX loginPass
#debug string loginPass
 SLEN 
 WRX  payloadLength
#debug_left uint payloadLength
#srcline 1075 ;                     MemcpyPtr(source := ADR(loginPass),dest := ADR(txData[txMsgLength + 2]),length := UINT_TO_UDINT(payloadLength));
 NXT
 LEAX loginPass
#debug pointer loginPass
 LEA  __Instance__MemcpyPtr~source
 WRIL 
#debug_left udint __Instance__MemcpyPtr~source
 LEAX txData
 LDX  txMsgLength
#debug uint txMsgLength
 LD   uint 2
 ADD
 AND  $FFFF
 RCHK 512   ; Range Check
 ADD     ; + offset 
#debug pointer txData[txMsgLength+2]
 LEA  __Instance__MemcpyPtr~dest
 WRIL 
#debug_left udint __Instance__MemcpyPtr~dest
 LDX  payloadLength
#debug uint payloadLength
 WR   __Instance__MemcpyPtr~length
#debug_left udint __Instance__MemcpyPtr~length
 PRV
 LEA  __Instance__MemcpyPtr
 CAL  MemcpyPtr_L0
#srcline 1076 ;                     txMsgLength := txMsgLength + payloadLength + 2;
 LDX  txMsgLength
#debug uint txMsgLength
 LDX  payloadLength
#debug uint payloadLength
 ADD
 AND  $FFFF
 LD   uint 2
 ADD
 AND  $FFFF
 WRX  txMsgLength
#debug_left uint txMsgLength
#srcline 1077 ;                end_if;
fbMQTTPublisherEx_L21:
#srcline 1080 ;                // length of package
#srcline 1081 ;                txData[1]       := UINT_TO_USINT(txMsgLength - 2);
 LDX  txMsgLength
#debug uint txMsgLength
 LD   uint 2
 SUB
 AND  $FFFF
 AND  $FF
 WRX  txData[1]
#debug_left usint txData[1]
#srcline 1082 ;               // txMsgLength     := txMsgLength + 2;
#srcline 1083 ;                tx_data_request := true;
 LD   bool -1       ; true
 WRX  tx_data_request
#debug_left bool tx_data_request
#srcline 1085 ;                localPortExtension := USINT_TO_UINT(reconnect_counter);
 LDX  reconnect_counter
#debug usint reconnect_counter
 AND  $FFFF
 WRX  localPortExtension
#debug_left uint localPortExtension
#srcline 1086 ;                idle_time := 2;
 LD   usint 2
 WRX  idle_time
#debug_left usint idle_time
#srcline 1087 ;                // required to change port on each reconnect
#srcline 1088 ;                if reconnect_counter < 100 then
 LDX  reconnect_counter
#debug usint reconnect_counter
 LD   usint 100
 LT
 JMC  fbMQTTPublisherEx_L23
#srcline 1089 ;                    reconnect_counter := reconnect_counter + 1; //
 LDX  reconnect_counter
#debug usint reconnect_counter
 LD   usint 1
 ADD
 AND  $FF
 WRX  reconnect_counter
#debug_left usint reconnect_counter
#srcline 1090 ;                else
 JMP  fbMQTTPublisherEx_L24
fbMQTTPublisherEx_L23:
#srcline 1091 ;                    reconnect_counter := 0;
 LD   usint 0
 WRX  reconnect_counter
#debug_left usint reconnect_counter
#srcline 1092 ;                end_if;
fbMQTTPublisherEx_L24:
#srcline 1093 ;                responce_recived := false;
 LD   bool 0       ; false
 WRX  responce_recived
#debug_left bool responce_recived
#srcline 1095 ;                busy := true;
 LD   bool -1       ; true
 WRX  busy
#debug_left bool busy
#srcline 1096 ;                ok   := false;
 LD   bool 0       ; false
 WRX  ok
#debug_left bool ok
#srcline 1097 ;                err  := false;
 LD   bool 0       ; false
 WRX  err
#debug_left bool err
#srcline 1098 ;                return;
 JMP  fbMQTTPublisherEx_RET
#srcline 1099 ;           //-------------------- Connected to broker -------------------------------------------------
#srcline 1100 ;           else
 JMP  fbMQTTPublisherEx_L10
fbMQTTPublisherEx_L9:
#srcline 1101 ;                if sendCom then
 LDX  sendCom
#debug bool sendCom
 JMC  fbMQTTPublisherEx_L25
#srcline 1102 ;                    sendCom := false;
 LD   bool 0       ; false
 WRX  sendCom
#debug_left bool sendCom
#srcline 1103 ;                     connectFlags := USINT_TO_BYTE(MQTT_CONTROL_PACK_PUBLISH);
 LD   usint 48
 AND  $FF
 WRX  connectFlags
#debug_left byte connectFlags
#srcline 1104 ;                     if com_param.dup then connectFlags := connectFlags OR 16#8;  end_if;
 LDX  com_param~dup
#debug bool com_param.dup
 JMC  fbMQTTPublisherEx_L27
 LDX  connectFlags
#debug byte connectFlags
 LD   byte $8
 OR  
 WRX  connectFlags
#debug_left byte connectFlags
fbMQTTPublisherEx_L27:
#srcline 1105 ;                     connectFlags := connectFlags OR SHL(IN := USINT_TO_BYTE(com_param.qos),N := 1);
 LDX  connectFlags
#debug byte connectFlags
 LDX  com_param~qos
#debug usint com_param.qos
 AND  $FF
 LD   uint 1
 SHL
 AND  $FF
 OR  
 WRX  connectFlags
#debug_left byte connectFlags
#srcline 1106 ;                     if com_param.willRetain   then connectFlags := connectFlags OR 16#1; end_if;
 LDX  com_param~willRetain
#debug bool com_param.willRetain
 JMC  fbMQTTPublisherEx_L29
 LDX  connectFlags
#debug byte connectFlags
 LD   byte $1
 OR  
 WRX  connectFlags
#debug_left byte connectFlags
fbMQTTPublisherEx_L29:
#srcline 1108 ;                     txData[0]     := BYTE_TO_USINT(connectFlags);
 LDX  connectFlags
#debug byte connectFlags
 WRX  txData[0]
#debug_left usint txData[0]
#srcline 1110 ;                     payloadLength := LEN(IN := topicTxt);
 LEAX topicTxt
#debug string topicTxt
 SLEN 
 WRX  payloadLength
#debug_left uint payloadLength
#srcline 1111 ;                   //  txData[2]     := 0;
#srcline 1112 ;                   //  txData[3]     := payloadLength;
#srcline 1114 ;                     txData[2]  := WORD_TO_USINT(SHR(IN := UINT_TO_WORD(payloadLength),N := 8));
 LDX  payloadLength
#debug uint payloadLength
 LD   uint 8
 SHR
 AND  $FFFF
 AND  $FF
 WRX  txData[2]
#debug_left usint txData[2]
#srcline 1115 ;                     txData[3]  := UINT_TO_USINT(payloadLength);
 LDX  payloadLength
#debug uint payloadLength
 AND  $FF
 WRX  txData[3]
#debug_left usint txData[3]
#srcline 1116 ;                     messageID  := messageID + 1;
 LDX  messageID
#debug uint messageID
 LD   uint 1
 ADD
 AND  $FFFF
 WRX  messageID
#debug_left uint messageID
#srcline 1117 ;                     MemcpyPtr(source := ADR(topicTxt),dest := ADR(txData[4]),length := UINT_TO_UDINT(payloadLength));
 NXT
 LEAX topicTxt
#debug pointer topicTxt
 LEA  __Instance__MemcpyPtr~source
 WRIL 
#debug_left udint __Instance__MemcpyPtr~source
 LEAX txData
 ADD  4  ; + offset 
#debug pointer txData[4]
 LEA  __Instance__MemcpyPtr~dest
 WRIL 
#debug_left udint __Instance__MemcpyPtr~dest
 LDX  payloadLength
#debug uint payloadLength
 WR   __Instance__MemcpyPtr~length
#debug_left udint __Instance__MemcpyPtr~length
 PRV
 LEA  __Instance__MemcpyPtr
 CAL  MemcpyPtr_L0
#srcline 1118 ;                     if com_param.qos > 0 then
 LDX  com_param~qos
#debug usint com_param.qos
 LD   usint 0
 GT
 JMC  fbMQTTPublisherEx_L31
#srcline 1120 ;                         txData[payloadLength + 4]     := WORD_TO_USINT(SHR(IN := UINT_TO_WORD(messageID), N := 8));
 LDX  messageID
#debug uint messageID
 LD   uint 8
 SHR
 AND  $FFFF
 AND  $FF
 LEAX txData
 LDX  payloadLength
#debug uint payloadLength
 LD   uint 4
 ADD
 AND  $FFFF
 RCHK 512   ; Range Check
 ADD     ; + offset 
 WRI 
#debug_left usint txData[payloadLength+4]
#srcline 1121 ;                         txData[payloadLength + 4 + 1] := UINT_TO_USINT(messageID);
 LDX  messageID
#debug uint messageID
 AND  $FF
 LEAX txData
 LDX  payloadLength
#debug uint payloadLength
 LD   uint 4
 ADD
 AND  $FFFF
 LD   uint 1
 ADD
 AND  $FFFF
 RCHK 512   ; Range Check
 ADD     ; + offset 
 WRI 
#debug_left usint txData[payloadLength+4+1]
#srcline 1122 ;                         payloadLength                 := payloadLength + 2;
 LDX  payloadLength
#debug uint payloadLength
 LD   uint 2
 ADD
 AND  $FFFF
 WRX  payloadLength
#debug_left uint payloadLength
#srcline 1123 ;                     end_if;
fbMQTTPublisherEx_L31:
#srcline 1124 ;                    // MemcpyPtr(source := ADR(dataTxt),dest := ADR(txData[payloadLength+4]),length := LEN(dataTxt));
#srcline 1125 ;                     MemcpyPtr(source := pData, dest := ADR(txData[payloadLength + 4]),length := UINT_TO_UDINT(dataLength));  //NEW
 NXT
 LEAX pData
 LDIL 
#debug pointer pData
 LEA  __Instance__MemcpyPtr~source
 WRIL 
#debug_left udint __Instance__MemcpyPtr~source
 LEAX txData
 LDX  payloadLength
#debug uint payloadLength
 LD   uint 4
 ADD
 AND  $FFFF
 RCHK 512   ; Range Check
 ADD     ; + offset 
#debug pointer txData[payloadLength+4]
 LEA  __Instance__MemcpyPtr~dest
 WRIL 
#debug_left udint __Instance__MemcpyPtr~dest
 LDX  dataLength
#debug uint dataLength
 WR   __Instance__MemcpyPtr~length
#debug_left udint __Instance__MemcpyPtr~length
 PRV
 LEA  __Instance__MemcpyPtr
 CAL  MemcpyPtr_L0
#srcline 1126 ;                    // payloadLength    := payloadLength + LEN(dataTxt);
#srcline 1127 ;                     payloadLength    := payloadLength + dataLength; //NEW
 LDX  payloadLength
#debug uint payloadLength
 LDX  dataLength
#debug uint dataLength
 ADD
 AND  $FFFF
 WRX  payloadLength
#debug_left uint payloadLength
#srcline 1128 ;                     txMsgLength      := 2 + payloadLength;
 LD   uint 2
 LDX  payloadLength
#debug uint payloadLength
 ADD
 AND  $FFFF
 WRX  txMsgLength
#debug_left uint txMsgLength
#srcline 1130 ;                     txMsgLengthTemp   := txMsgLength;
 LDX  txMsgLength
#debug uint txMsgLength
 WRX  txMsgLengthTemp
#debug_left uint txMsgLengthTemp
#srcline 1131 ;                     payloadLengthSize := 1;
 LD   uint 1
 WRX  payloadLengthSize
#debug_left uint payloadLengthSize
#srcline 1133 ;                     while txMsgLengthTemp > 0 do
fbMQTTPublisherEx_L33:
 LDX  txMsgLengthTemp
#debug uint txMsgLengthTemp
 LD   uint 0
 GT
 JMC  fbMQTTPublisherEx_L34
 DBG 
#srcline 1134 ;                           encodedByte := UINT_TO_BYTE(txMsgLengthTemp MOD 128);
 LDX  txMsgLengthTemp
#debug uint txMsgLengthTemp
 LD   uint 128
 MOD
 AND  $FFFF
 AND  $FF
 WRX  encodedByte
#debug_left byte encodedByte
#srcline 1135 ;                           txMsgLengthTemp := txMsgLengthTemp / 128;
 LDX  txMsgLengthTemp
#debug uint txMsgLengthTemp
 LD   uint 128
 DIVL
 AND  $FFFF
 WRX  txMsgLengthTemp
#debug_left uint txMsgLengthTemp
#srcline 1136 ;                           if txMsgLengthTemp > 0 then
 LDX  txMsgLengthTemp
#debug uint txMsgLengthTemp
 LD   uint 0
 GT
 JMC  fbMQTTPublisherEx_L35
#srcline 1137 ;                               payloadLengthArrayTemp[payloadLengthSize] := BYTE_TO_USINT(encodedByte OR 128);
 LDX  encodedByte
#debug byte encodedByte
 LD   byte 128
 OR  
 LEAX payloadLengthArrayTemp
 LDX  payloadLengthSize
#debug uint payloadLengthSize
 SUB  1   ; Low range[1]
 RCHK 3   ; Range Check
 ADD     ; + offset 
 WRI 
#debug_left usint payloadLengthArrayTemp[payloadLengthSize]
#srcline 1138 ;                               payloadLengthSize := payloadLengthSize + 1;
 LDX  payloadLengthSize
#debug uint payloadLengthSize
 LD   uint 1
 ADD
 AND  $FFFF
 WRX  payloadLengthSize
#debug_left uint payloadLengthSize
#srcline 1139 ;                           else
 JMP  fbMQTTPublisherEx_L36
fbMQTTPublisherEx_L35:
#srcline 1140 ;                               payloadLengthArrayTemp[payloadLengthSize] := BYTE_TO_USINT(encodedByte);
 LDX  encodedByte
#debug byte encodedByte
 LEAX payloadLengthArrayTemp
 LDX  payloadLengthSize
#debug uint payloadLengthSize
 SUB  1   ; Low range[1]
 RCHK 3   ; Range Check
 ADD     ; + offset 
 WRI 
#debug_left usint payloadLengthArrayTemp[payloadLengthSize]
#srcline 1141 ;                           end_if;
fbMQTTPublisherEx_L36:
#srcline 1142 ;                           if payloadLengthSize > 4 then
 LDX  payloadLengthSize
#debug uint payloadLengthSize
 LD   uint 4
 GT
 JMC  fbMQTTPublisherEx_L37
#srcline 1143 ;                               busy := false;
 LD   bool 0       ; false
 WRX  busy
#debug_left bool busy
#srcline 1144 ;                               ok   := false;
 LD   bool 0       ; false
 WRX  ok
#debug_left bool ok
#srcline 1145 ;                               err  := true;
 LD   bool -1       ; true
 WRX  err
#debug_left bool err
#srcline 1146 ;                               //FIXME: Add error code "Payload length is out of range"
#srcline 1147 ;                               return;
 JMP  fbMQTTPublisherEx_RET
#srcline 1148 ;                           end_if;
fbMQTTPublisherEx_L37:
#srcline 1149 ;                     end_while;
 JMP  fbMQTTPublisherEx_L33
fbMQTTPublisherEx_L34:
 NOP  -1
#srcline 1151 ;                     if payloadLengthSize = 1 then
 LDX  payloadLengthSize
#debug uint payloadLengthSize
 LD   uint 1
 EQ
 JMC  fbMQTTPublisherEx_L39
#srcline 1152 ;                         txData[1] := UINT_TO_USINT(txMsgLength);
 LDX  txMsgLength
#debug uint txMsgLength
 AND  $FF
 WRX  txData[1]
#debug_left usint txData[1]
#srcline 1153 ;                     else
 JMP  fbMQTTPublisherEx_L40
fbMQTTPublisherEx_L39:
#srcline 1154 ;                         txMsgLength     := txMsgLength + payloadLengthSize - 1;
 LDX  txMsgLength
#debug uint txMsgLength
 LDX  payloadLengthSize
#debug uint payloadLengthSize
 ADD
 AND  $FFFF
 LD   uint 1
 SUB
 AND  $FFFF
 WRX  txMsgLength
#debug_left uint txMsgLength
#srcline 1155 ;                         txMsgLengthTemp := txMsgLength;
 LDX  txMsgLength
#debug uint txMsgLength
 WRX  txMsgLengthTemp
#debug_left uint txMsgLengthTemp
#srcline 1157 ;                         while txMsgLengthTemp >= payloadLengthSize do
fbMQTTPublisherEx_L41:
 LDX  txMsgLengthTemp
#debug uint txMsgLengthTemp
 LDX  payloadLengthSize
#debug uint payloadLengthSize
 LT
 NEG
 JMC  fbMQTTPublisherEx_L42
 DBG 
#srcline 1158 ;                           txData[txMsgLengthTemp + 1] := txData[txMsgLengthTemp];
 LEAX txData
 LDX  txMsgLengthTemp
#debug uint txMsgLengthTemp
 RCHK 512   ; Range Check
 ADD     ; + offset 
 LDI  
#debug usint txData[txMsgLengthTemp]
 LEAX txData
 LDX  txMsgLengthTemp
#debug uint txMsgLengthTemp
 LD   uint 1
 ADD
 AND  $FFFF
 RCHK 512   ; Range Check
 ADD     ; + offset 
 WRI 
#debug_left usint txData[txMsgLengthTemp+1]
#srcline 1159 ;                           txMsgLengthTemp := txMsgLengthTemp - 1;
 LDX  txMsgLengthTemp
#debug uint txMsgLengthTemp
 LD   uint 1
 SUB
 AND  $FFFF
 WRX  txMsgLengthTemp
#debug_left uint txMsgLengthTemp
#srcline 1160 ;                         end_while;
 JMP  fbMQTTPublisherEx_L41
fbMQTTPublisherEx_L42:
 NOP  -1
#srcline 1161 ;                         for index := 1 to payloadLengthSize do
 LD   uint 1
 WRX  index
 LDX  payloadLengthSize
#debug uint payloadLengthSize
 WRY  P0__st__
fbMQTTPublisherEx_L43:
 LDX  index
 LDY  P0__st__
 GT   
 JMD  fbMQTTPublisherEx_L44
 DBG  
#srcline 1162 ;                              txData[index] := payloadLengthArrayTemp[index];
 LEAX payloadLengthArrayTemp
 LDX  index
#debug uint index
 SUB  1   ; Low range[1]
 RCHK 3   ; Range Check
 ADD     ; + offset 
 LDI  
#debug usint payloadLengthArrayTemp[index]
 LEAX txData
 LDX  index
#debug uint index
 RCHK 512   ; Range Check
 ADD     ; + offset 
 WRI 
#debug_left usint txData[index]
#srcline 1163 ;                         end_for;
 LDX  index
 LD   1
 ADD  
 WRX  index
 JMP  fbMQTTPublisherEx_L43
fbMQTTPublisherEx_L44:
 NOP  -1
#srcline 1164 ;                     end_if;
fbMQTTPublisherEx_L40:
#srcline 1167 ;                     txMsgLength      := txMsgLength + 2;
 LDX  txMsgLength
#debug uint txMsgLength
 LD   uint 2
 ADD
 AND  $FFFF
 WRX  txMsgLength
#debug_left uint txMsgLength
#srcline 1168 ;                     tx_data_request  := true;
 LD   bool -1       ; true
 WRX  tx_data_request
#debug_left bool tx_data_request
#srcline 1169 ;                     busy := true;
 LD   bool -1       ; true
 WRX  busy
#debug_left bool busy
#srcline 1170 ;                     ok   := false;
 LD   bool 0       ; false
 WRX  ok
#debug_left bool ok
#srcline 1171 ;                     err  := false;
 LD   bool 0       ; false
 WRX  err
#debug_left bool err
#srcline 1172 ;                    return;
 JMP  fbMQTTPublisherEx_RET
#srcline 1173 ;                end_if;
fbMQTTPublisherEx_L25:
#srcline 1175 ;                if pubReleaseRq then
 LDX  pubReleaseRq
#debug bool pubReleaseRq
 JMC  fbMQTTPublisherEx_L45
#srcline 1176 ;                    pubReleaseRq := false;
 LD   bool 0       ; false
 WRX  pubReleaseRq
#debug_left bool pubReleaseRq
#srcline 1177 ;                    txData[0]        := MQTT_CONTROL_PACK_PUBREL + 2; // flag bits are cleared
 LD   usint 96
 LD   usint 2
 ADD
 AND  $FF
 WRX  txData[0]
#debug_left usint txData[0]
#srcline 1178 ;                    txData[1]        := 2;
 LD   usint 2
 WRX  txData[1]
#debug_left usint txData[1]
#srcline 1179 ;                    txData[2]        := WORD_TO_USINT(SHR(IN := UINT_TO_WORD(messageIDpubRel), N := 8));
 LDX  messageIDpubRel
#debug uint messageIDpubRel
 LD   uint 8
 SHR
 AND  $FFFF
 AND  $FF
 WRX  txData[2]
#debug_left usint txData[2]
#srcline 1180 ;                    txData[3]        := UINT_TO_USINT(messageIDpubRel);
 LDX  messageIDpubRel
#debug uint messageIDpubRel
 AND  $FF
 WRX  txData[3]
#debug_left usint txData[3]
#srcline 1181 ;                    txMsgLength      := 4;
 LD   uint 4
 WRX  txMsgLength
#debug_left uint txMsgLength
#srcline 1182 ;                    tx_data_request  := true;
 LD   bool -1       ; true
 WRX  tx_data_request
#debug_left bool tx_data_request
#srcline 1183 ;                    responce_recived := false;
 LD   bool 0       ; false
 WRX  responce_recived
#debug_left bool responce_recived
#srcline 1184 ;                    busy             := true;
 LD   bool -1       ; true
 WRX  busy
#debug_left bool busy
#srcline 1185 ;                    ok               := false;
 LD   bool 0       ; false
 WRX  ok
#debug_left bool ok
#srcline 1186 ;                    err              := false;
 LD   bool 0       ; false
 WRX  err
#debug_left bool err
#srcline 1187 ;                    return;
 JMP  fbMQTTPublisherEx_RET
#srcline 1188 ;                end_if;
fbMQTTPublisherEx_L45:
#srcline 1189 ;                //---------------------------------------------
#srcline 1190 ;                if MQTT_ping_timer.Q then
 LDX  MQTT_ping_timer~Q
#debug bool MQTT_ping_timer.Q
 JMC  fbMQTTPublisherEx_L47
#srcline 1191 ;                    //Ping request
#srcline 1192 ;                     txData[0]        := MQTT_CONTROL_PACK_PINGREQ; // flag bits are cleared
 LD   usint 192
 WRX  txData[0]
#debug_left usint txData[0]
#srcline 1193 ;                     txData[1]        := 0;
 LD   usint 0
 WRX  txData[1]
#debug_left usint txData[1]
#srcline 1194 ;                     txMsgLength      := 2;
 LD   uint 2
 WRX  txMsgLength
#debug_left uint txMsgLength
#srcline 1195 ;                     tx_data_request  := true;
 LD   bool -1       ; true
 WRX  tx_data_request
#debug_left bool tx_data_request
#srcline 1196 ;                     responce_recived := false;
 LD   bool 0       ; false
 WRX  responce_recived
#debug_left bool responce_recived
#srcline 1197 ;                     busy             := true;
 LD   bool -1       ; true
 WRX  busy
#debug_left bool busy
#srcline 1198 ;                     ok               := false;
 LD   bool 0       ; false
 WRX  ok
#debug_left bool ok
#srcline 1199 ;                     err              := false;
 LD   bool 0       ; false
 WRX  err
#debug_left bool err
#srcline 1200 ;                     return;
 JMP  fbMQTTPublisherEx_RET
#srcline 1201 ;                end_if;
fbMQTTPublisherEx_L47:
#srcline 1203 ;           end_if;
fbMQTTPublisherEx_L10:
#srcline 1204 ;       end_if;
fbMQTTPublisherEx_L7:
#srcline 1206 ;      if conn_status then
 LDX  conn_status
#debug bool conn_status
 JMC  fbMQTTPublisherEx_L49
#srcline 1207 ;           SendTo( rq := tx_data_request, chanCode := chanCode, lenTx := txMsgLength , data := void(txData));
 LDX  tx_data_request
#debug bool tx_data_request
 WRX  SendTo~rq
#debug_left bool SendTo~rq
 LDX  chanCode
#debug uint chanCode
 WRX  SendTo~chanCode
#debug_left uint SendTo~chanCode
 LDX  txMsgLength
#debug uint txMsgLength
 WRX  SendTo~lenTx
#debug_left uint SendTo~lenTx
 LEAX txData
 WRX  SendTo~data
#debug_left pointer SendTo.data
 LEAX SendTo
 CAL  fbSendTo_L0
#srcline 1208 ;           if SendTo.mesSent then
 LDX  SendTo~mesSent
#debug bool SendTo.mesSent
 JMC  fbMQTTPublisherEx_L51
#srcline 1209 ;               tx_data_request  := false;
 LD   bool 0       ; false
 WRX  tx_data_request
#debug_left bool tx_data_request
#srcline 1210 ;               txCounter        := txCounter + 1;
 LDX  txCounter
#debug uint txCounter
 LD   uint 1
 ADD
 AND  $FFFF
 WRX  txCounter
#debug_left uint txCounter
#srcline 1211 ;               messageIDlast    := messageID;
 LDX  messageID
#debug uint messageID
 WRX  messageIDlast
#debug_left uint messageIDlast
#srcline 1212 ;             //  messageID        := messageID + 1;
#srcline 1213 ;               responce_recived := false;
 LD   bool 0       ; false
 WRX  responce_recived
#debug_left bool responce_recived
#srcline 1214 ;               mesSent          := TRUE;
 LD   bool -1       ; true
 WRX  mesSent
#debug_left bool mesSent
#srcline 1215 ;               if com_param.qos = 0 then
 LDX  com_param~qos
#debug usint com_param.qos
 LD   usint 0
 EQ
 JMC  fbMQTTPublisherEx_L53
#srcline 1216 ;                  busy := false;
 LD   bool 0       ; false
 WRX  busy
#debug_left bool busy
#srcline 1217 ;                  ok   := true;
 LD   bool -1       ; true
 WRX  ok
#debug_left bool ok
#srcline 1218 ;                  err  := false;
 LD   bool 0       ; false
 WRX  err
#debug_left bool err
#srcline 1219 ;                  wait_response := false;
 LD   bool 0       ; false
 WRX  wait_response
#debug_left bool wait_response
#srcline 1220 ;               else
 JMP  fbMQTTPublisherEx_L54
fbMQTTPublisherEx_L53:
#srcline 1221 ;                  wait_response := true;
 LD   bool -1       ; true
 WRX  wait_response
#debug_left bool wait_response
#srcline 1222 ;               end_if;
fbMQTTPublisherEx_L54:
#srcline 1223 ;          end_if;
fbMQTTPublisherEx_L51:
#srcline 1225 ;          RecvFrom( rq := true, chanCode := chanCode, lenRx := 100, data := void(rxData));
 LD   bool -1       ; true
 WRX  RecvFrom~rq
#debug_left bool RecvFrom~rq
 LDX  chanCode
#debug uint chanCode
 WRX  RecvFrom~chanCode
#debug_left uint RecvFrom~chanCode
 LD   uint 100
 WRX  RecvFrom~lenRx
#debug_left uint RecvFrom~lenRx
 LEAX rxData
 WRX  RecvFrom~data
#debug_left pointer RecvFrom.data
 LEAX RecvFrom
 CAL  fbRecvFrom_L0
#srcline 1227 ;          if RecvFrom.mesRec then
 LDX  RecvFrom~mesRec
#debug bool RecvFrom.mesRec
 JMC  fbMQTTPublisherEx_L55
#srcline 1228 ;              if RecvFrom.error = 0 then
 LDX  RecvFrom~error
#debug usint RecvFrom.error
 LD   usint 0
 EQ
 JMC  fbMQTTPublisherEx_L57
#srcline 1229 ;                  messageIDpubRel_ptr := ADR(rxData[2]);
 LEAX rxData
 ADD  2  ; + offset 
#debug pointer rxData[2]
 LEAX messageIDpubRel_ptr
 WRIL 
#debug_left pointer messageIDpubRel_ptr
#srcline 1230 ;                  messageIDpubRel     := messageIDpubRel_ptr^;
 LEAX messageIDpubRel_ptr
 LDIL    ; dereference 
 LDIW 
#debug uint messageIDpubRel_ptr^
 WRX  messageIDpubRel
#debug_left uint messageIDpubRel
#srcline 1231 ;                  messageIDpubRel     := fSwapUINT(messageIDpubRel);
 NXT
 LDX  messageIDpubRel
#debug uint messageIDpubRel
 WR   __Instance__fSwapUINT~input
#debug_left uint __Instance__fSwapUINT~input
 PRV
 LEA  __Instance__fSwapUINT
 CAL  fSwapUINT_L0
 WRX  messageIDpubRel
#debug_left uint messageIDpubRel
#srcline 1232 ;                  
#srcline 1233 ;                  if RecvFrom.lenData = 4  AND rxData[0] = MQTT_CONTROL_PACK_CONNACK THEN
 LDX  RecvFrom~lenData
#debug uint RecvFrom.lenData
 LD   uint 4
 EQ
 LDX  rxData[0]
#debug usint rxData[0]
 LD   usint 32
 EQ
 AND
 JMC  fbMQTTPublisherEx_L59
#srcline 1234 ;                       responce_recived := true;
 LD   bool -1       ; true
 WRX  responce_recived
#debug_left bool responce_recived
#srcline 1235 ;                       wait_response    := false;
 LD   bool 0       ; false
 WRX  wait_response
#debug_left bool wait_response
#srcline 1236 ;                       if rxData[3] = 0 then
 LDX  rxData[3]
#debug usint rxData[3]
 LD   usint 0
 EQ
 JMC  fbMQTTPublisherEx_L61
#srcline 1237 ;                           connected_to_broker  := true;
 LD   bool -1       ; true
 WRX  connected_to_broker
#debug_left bool connected_to_broker
#srcline 1238 ;                       else
 JMP  fbMQTTPublisherEx_L62
fbMQTTPublisherEx_L61:
#srcline 1239 ;                           connected_to_broker  := false;
 LD   bool 0       ; false
 WRX  connected_to_broker
#debug_left bool connected_to_broker
#srcline 1240 ;                           ok                   := false;
 LD   bool 0       ; false
 WRX  ok
#debug_left bool ok
#srcline 1241 ;                           err                  := true;
 LD   bool -1       ; true
 WRX  err
#debug_left bool err
#srcline 1242 ;                           errCode              := MQTT_CONTROL_ERROR_CODE_LOGIN_FAILED;
 LD   usint 5
 WRX  errCode
#debug_left usint errCode
#srcline 1243 ;                       end_if;
fbMQTTPublisherEx_L62:
#srcline 1244 ;                  elsif rxData[1] = 2 AND ((rxData[0] = MQTT_CONTROL_PACK_PUBACK  AND com_param.qos = 1) OR (rxData[0] = MQTT_CONTROL_PACK_PUBCOMP AND com_param.qos = 2) ) then // responce to connect command
 JMP  fbMQTTPublisherEx_L60
fbMQTTPublisherEx_L59:
 LDX  rxData[1]
#debug usint rxData[1]
 LD   usint 2
 EQ
 LDX  rxData[0]
#debug usint rxData[0]
 LD   usint 64
 EQ
 LDX  com_param~qos
#debug usint com_param.qos
 LD   usint 1
 EQ
 AND
 LDX  rxData[0]
#debug usint rxData[0]
 LD   usint 112
 EQ
 LDX  com_param~qos
#debug usint com_param.qos
 LD   usint 2
 EQ
 AND
 OR  
 AND
 JMC  fbMQTTPublisherEx_L63
#srcline 1245 ;                      connected_to_broker := true;
 LD   bool -1       ; true
 WRX  connected_to_broker
#debug_left bool connected_to_broker
#srcline 1246 ;                      responce_recived    := true;
 LD   bool -1       ; true
 WRX  responce_recived
#debug_left bool responce_recived
#srcline 1247 ;                      wait_response       := false;
 LD   bool 0       ; false
 WRX  wait_response
#debug_left bool wait_response
#srcline 1248 ;                      busy                := false;
 LD   bool 0       ; false
 WRX  busy
#debug_left bool busy
#srcline 1249 ;                      ok                  := true;
 LD   bool -1       ; true
 WRX  ok
#debug_left bool ok
#srcline 1250 ;                      err                 := false;
 LD   bool 0       ; false
 WRX  err
#debug_left bool err
#srcline 1251 ;                  elsif RecvFrom.lenData = 4 AND com_param.qos = 2 AND rxData[0] = MQTT_CONTROL_PACK_PUBREC then
 JMP  fbMQTTPublisherEx_L60
fbMQTTPublisherEx_L63:
 LDX  RecvFrom~lenData
#debug uint RecvFrom.lenData
 LD   uint 4
 EQ
 LDX  com_param~qos
#debug usint com_param.qos
 LD   usint 2
 EQ
 AND
 LDX  rxData[0]
#debug usint rxData[0]
 LD   usint 80
 EQ
 AND
 JMC  fbMQTTPublisherEx_L64
#srcline 1252 ;                          messageIDpubRel     := fSwapUINT( messageIDpubRel_ptr^);
 NXT
 LEAX messageIDpubRel_ptr
 LDIL    ; dereference 
 LDIW 
#debug uint messageIDpubRel_ptr^
 WR   __Instance__fSwapUINT~input
#debug_left uint __Instance__fSwapUINT~input
 PRV
 LEA  __Instance__fSwapUINT
 CAL  fSwapUINT_L0
 WRX  messageIDpubRel
#debug_left uint messageIDpubRel
#srcline 1253 ;                          connected_to_broker := true;
 LD   bool -1       ; true
 WRX  connected_to_broker
#debug_left bool connected_to_broker
#srcline 1254 ;                          responce_recived    := true;
 LD   bool -1       ; true
 WRX  responce_recived
#debug_left bool responce_recived
#srcline 1255 ;                          wait_response       := false;
 LD   bool 0       ; false
 WRX  wait_response
#debug_left bool wait_response
#srcline 1256 ;                          pubReleaseRq        := true;
 LD   bool -1       ; true
 WRX  pubReleaseRq
#debug_left bool pubReleaseRq
#srcline 1257 ;                  elsif RecvFrom.lenData = 2 AND rxData[0] = MQTT_CONTROL_PACK_PINGRESP then
 JMP  fbMQTTPublisherEx_L60
fbMQTTPublisherEx_L64:
 LDX  RecvFrom~lenData
#debug uint RecvFrom.lenData
 LD   uint 2
 EQ
 LDX  rxData[0]
#debug usint rxData[0]
 LD   usint 208
 EQ
 AND
 JMC  fbMQTTPublisherEx_L65
#srcline 1258 ;                         responce_recived := true;
 LD   bool -1       ; true
 WRX  responce_recived
#debug_left bool responce_recived
#srcline 1259 ;                         wait_response    := false;
 LD   bool 0       ; false
 WRX  wait_response
#debug_left bool wait_response
#srcline 1260 ;                         busy             := false;
 LD   bool 0       ; false
 WRX  busy
#debug_left bool busy
#srcline 1261 ;                         ok               := true;
 LD   bool -1       ; true
 WRX  ok
#debug_left bool ok
#srcline 1262 ;                         err              := false;
 LD   bool 0       ; false
 WRX  err
#debug_left bool err
#srcline 1263 ;                  end_if;
 JMP  fbMQTTPublisherEx_L60
fbMQTTPublisherEx_L65:
fbMQTTPublisherEx_L60:
#srcline 1264 ;                  rxCounter := rxCounter + 1;
 LDX  rxCounter
#debug uint rxCounter
 LD   uint 1
 ADD
 AND  $FFFF
 WRX  rxCounter
#debug_left uint rxCounter
#srcline 1265 ;              end_if;
fbMQTTPublisherEx_L57:
#srcline 1266 ;          end_if;
fbMQTTPublisherEx_L55:
#srcline 1267 ;      else
 JMP  fbMQTTPublisherEx_L50
fbMQTTPublisherEx_L49:
#srcline 1268 ;         connected_to_broker := false;
 LD   bool 0       ; false
 WRX  connected_to_broker
#debug_left bool connected_to_broker
#srcline 1269 ;         wait_response       := false;
 LD   bool 0       ; false
 WRX  wait_response
#debug_left bool wait_response
#srcline 1270 ;         pubReleaseRq        := false;
 LD   bool 0       ; false
 WRX  pubReleaseRq
#debug_left bool pubReleaseRq
#srcline 1271 ;         busy                := false;
 LD   bool 0       ; false
 WRX  busy
#debug_left bool busy
#srcline 1272 ;         ok                  := false;
 LD   bool 0       ; false
 WRX  ok
#debug_left bool ok
#srcline 1273 ;         err                 := true;
 LD   bool -1       ; true
 WRX  err
#debug_left bool err
#srcline 1274 ;         errCode             := MQTT_CONTROL_ERROR_CODE_BROKER_DISCONNECTED;
 LD   usint 3
 WRX  errCode
#debug_left usint errCode
#srcline 1275 ;      end_if;
fbMQTTPublisherEx_L50:
#srcline 1277 ;   else
 JMP  fbMQTTPublisherEx_L6
fbMQTTPublisherEx_L5:
#srcline 1278 ;     connected_to_broker := false;
 LD   bool 0       ; false
 WRX  connected_to_broker
#debug_left bool connected_to_broker
#srcline 1279 ;     wait_response       := false;
 LD   bool 0       ; false
 WRX  wait_response
#debug_left bool wait_response
#srcline 1280 ;     pubReleaseRq        := false;
 LD   bool 0       ; false
 WRX  pubReleaseRq
#debug_left bool pubReleaseRq
#srcline 1281 ;     busy                := false;
 LD   bool 0       ; false
 WRX  busy
#debug_left bool busy
#srcline 1282 ;     ok                  := false;
 LD   bool 0       ; false
 WRX  ok
#debug_left bool ok
#srcline 1283 ;     err                 := true;
 LD   bool -1       ; true
 WRX  err
#debug_left bool err
#srcline 1284 ;     errCode             := MQTT_CONTROL_ERROR_CODE_BROKER_DISCONNECTED;
 LD   usint 3
 WRX  errCode
#debug_left usint errCode
#srcline 1285 ;   end_if;
fbMQTTPublisherEx_L6:
#srcline 1288 ;END_FUNCTION_BLOCK
fbMQTTPublisherEx_RET:
 ULNK
RET
E     61

; Initialize - variables
P     61
fbMQTTPublisherEx__InstanceInit__:
 LINK 0
 LD   uint 1883
 WRX  brokerPort
 LD   uint 5000
 WRX  localPort
 LD   bool -1   ; true
 WRX  keepAlive
 LD   time 20000
 WRX  keepAliveInterval
 LD   time 10000
 WRX  connTimeOut
 LD   time 15000
 WRX  pingInterval
 LD   bool -1   ; true
 WRX  clientId_auto
 LD   0
 SRC  byte __Init___fbMQTTPublisherEx_com_param
 LEAX byte com_param
 LD   7
 MOV  %X0
 LD   udint $FFFFFFFF    ; nil
 WRX  pData
 LEAX MQTT_Comm_Init
 CAL  fbMQTT_Comm_Init__InstanceInit__
 LEAX SendTo
 CAL  fbSendTo__InstanceInit__
 LEAX RecvFrom
 CAL  fbRecvFrom__InstanceInit__
 LD   0
 SRC  byte __Init___fbMQTTPublisherEx_MQTT_PROTOCOL
 LEAX byte MQTT_PROTOCOL
 LD   5
 MOV  %X0
 LD   udint $FFFFFFFF    ; nil
 WRX  messageIDpubRel_ptr
 ULNK
RET
E     61
; End initialize - variables
#endpou 



 

#srcfile ''
#srcfile 'C:\TECOLIBSRC\MQTT_LIB\MQTT_LIB\FBMQTTSUBSCRIBER.ST'
#pou fbMQTTSubscriber
#srcline 3 ;FUNCTION_BLOCK fbMQTTSubscriber
#table byte __Init___fbMQTTSubscriber_com_param = 
      0,  0,  1, 10;
#table byte __Init___fbMQTTSubscriber_MQTT_PROTOCOL = 
    'M','Q','T','T';
#table byte __Init___fbMQTTSubscriber_inDataCom_param = 
      0,  0,  1, 10;

#struct fbMQTTSubscriber__temp__
  string[257] PS0__st__,
  string[42] PSC__st__
#data byte _str_fbMQTTSubscriber_0 = 
  '',0
#data byte _str_fbMQTTSubscriber_1 = 
  '',0
#data byte _str_fbMQTTSubscriber_2 = 
  '',0
P     61
fbMQTTSubscriber_L0:
 LINK __SizeOf(fbMQTTSubscriber__temp__)
; R_EDGE, F_EDGE 
 LDX  subRq
 LETX __EDGE_R__subRq
 WRX  subRq
 LDX  unSubRq
 LETX __EDGE_R__unSubRq
 WRX  unSubRq
#srcline 104 ;  dataRec := false;
 LD   bool 0       ; false
 WRX  dataRec
#debug_left bool dataRec
#srcline 105 ;  err     := false;
 LD   bool 0       ; false
 WRX  err
#debug_left bool err
#srcline 106 ;  if MQTT_com_responce_timeout.Q then
 LDX  MQTT_com_responce_timeout~Q
#debug bool MQTT_com_responce_timeout.Q
 JMC  fbMQTTSubscriber_L1
#srcline 107 ;      if responce_recived = false then
 LDX  responce_recived
#debug bool responce_recived
 LD   bool 0       ; false
 XOR
 NEG
 JMC  fbMQTTSubscriber_L3
#srcline 108 ;          connected_to_broker := false;
 LD   bool 0       ; false
 WRX  connected_to_broker
#debug_left bool connected_to_broker
#srcline 109 ;      end_if;
fbMQTTSubscriber_L3:
#srcline 110 ;      wait_response := false;
 LD   bool 0       ; false
 WRX  wait_response
#debug_left bool wait_response
#srcline 111 ;      busy    := false;
 LD   bool 0       ; false
 WRX  busy
#debug_left bool busy
#srcline 112 ;      ok      := false;
 LD   bool 0       ; false
 WRX  ok
#debug_left bool ok
#srcline 113 ;      err     := true;
 LD   bool -1       ; true
 WRX  err
#debug_left bool err
#srcline 114 ;      errCode := MQTT_CONTROL_ERROR_CODE_BROKER_ANSWER_TIME_OUT;
 LD   usint 1
 WRX  errCode
#debug_left usint errCode
#srcline 115 ;  end_if;
fbMQTTSubscriber_L1:
#srcline 117 ;  local_port := localPort + localPortExtension;
 LDX  localPort
#debug uint localPort
 LDX  localPortExtension
#debug uint localPortExtension
 ADD
 AND  $FFFF
 WRX  local_port
#debug_left uint local_port
#srcline 118 ;  MQTT_Comm_Init( connect := connect, chanCode := chanCode, remoteIP := brokerIP, remotePort := brokerPort, localPort := localPort + localPortExtension,
 LDX  connect
#debug bool connect
 WRX  MQTT_Comm_Init~connect
#debug_left bool MQTT_Comm_Init~connect
 LDX  chanCode
#debug uint chanCode
 WRX  MQTT_Comm_Init~chanCode
#debug_left uint MQTT_Comm_Init~chanCode
 LEAX brokerIP
#debug pointer brokerIP
 SRC  %IB0
 LEAX MQTT_Comm_Init~remoteIP
 LD   4   ;SizeOf() 
 MOV  %IB0
 LDX  brokerPort
#debug uint brokerPort
 WRX  MQTT_Comm_Init~remotePort
#debug_left uint MQTT_Comm_Init~remotePort
 LDX  localPort
#debug uint localPort
 LDX  localPortExtension
#debug uint localPortExtension
 ADD
 AND  $FFFF
 WRX  MQTT_Comm_Init~localPort
#debug_left uint MQTT_Comm_Init~localPort
#srcline 119 ;                  status  => conn_status);
 LEAX MQTT_Comm_Init
 CAL  fbMQTT_Comm_Init_L0
; output assigment 
 LDX  MQTT_Comm_Init~status
#debug bool MQTT_Comm_Init~status
 WRX  conn_status
#debug_left bool conn_status
#srcline 121 ;   MQTT_com_responce_timeout(IN := wait_response,PT := connTimeOut);
 LDX  wait_response
#debug bool wait_response
 WRX  MQTT_com_responce_timeout~IN
#debug_left bool MQTT_com_responce_timeout~IN
 LDX  connTimeOut
#debug time connTimeOut
 WRX  MQTT_com_responce_timeout~PT
#debug_left time MQTT_com_responce_timeout~PT
 LEAX MQTT_com_responce_timeout
 CAL  TON_L0
#srcline 122 ;   MQTT_ping_timer(IN := connect AND keepAlive, PT := pingInterval);
 LDX  connect
#debug bool connect
 LDX  keepAlive
#debug bool keepAlive
 AND
 WRX  MQTT_ping_timer~IN
#debug_left bool MQTT_ping_timer~IN
 LDX  pingInterval
#debug time pingInterval
 WRX  MQTT_ping_timer~PT
#debug_left time MQTT_ping_timer~PT
 LEAX MQTT_ping_timer
 CAL  fbTick_L0
#srcline 123 ;   MQTT_com_intervat(IN := connect, PT := T#5s);
 LDX  connect
#debug bool connect
 WRX  MQTT_com_intervat~IN
#debug_left bool MQTT_com_intervat~IN
 LD   time 5000
 WRX  MQTT_com_intervat~PT
#debug_left time MQTT_com_intervat~PT
 LEAX MQTT_com_intervat
 CAL  fbTick_L0
#srcline 125 ;   if connect then
 LDX  connect
#debug bool connect
 JMC  fbMQTTSubscriber_L5
#srcline 126 ;       if MQTT_com_intervat.Q OR subRq OR unSubRq OR pubAckRq OR pubRecRq OR pubCompRq then
 LDX  MQTT_com_intervat~Q
#debug bool MQTT_com_intervat.Q
 LDX  subRq
#debug bool subRq
 OR  
 LDX  unSubRq
#debug bool unSubRq
 OR  
 LDX  pubAckRq
#debug bool pubAckRq
 OR  
 LDX  pubRecRq
#debug bool pubRecRq
 OR  
 LDX  pubCompRq
#debug bool pubCompRq
 OR  
 JMC  fbMQTTSubscriber_L7
#srcline 127 ;           if connected_to_broker = false then
 LDX  connected_to_broker
#debug bool connected_to_broker
 LD   bool 0       ; false
 XOR
 NEG
 JMC  fbMQTTSubscriber_L9
#srcline 128 ;                 if clientId_auto then
 LDX  clientId_auto
#debug bool clientId_auto
 JMC  fbMQTTSubscriber_L11
#srcline 129 ;                     client_id := DWORD_TO_STRING(DT_TO_DWORD(GetRTC())) + UINT_TO_STRING(MSEC_OF_DT(GetRTC()));
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   40
 DST    ; Level 1
 LD   0   ; null string
 WRY  PSC__st__[0]
 LEAY PSC__st__[0]
 LD   40
 DST    ; Level 2
 LEA  __Instance__GetRTC
 CAL  GetRTC_L0
 RNDD
 UDFL
 SCNV $2C30;  IEC_DWORD _TO_ IEC_STRING
 PDST   ; Level 2
 LEAY PSC__st__[0]

 SCON 
 LD   0   ; null string
 WRY  PSC__st__[0]
 LEAY PSC__st__[0]
 LD   40
 DST    ; Level 2
 NXT
 LEA  __Instance__GetRTC
 CAL  GetRTC_L0
 WR   __Instance__MSEC_OF_DT~in
#debug_left dt __Instance__MSEC_OF_DT~in
 PRV
 LEA  __Instance__MSEC_OF_DT
 CAL  MSEC_OF_DT_L0
 SCNV $0A30;  IEC_UINT _TO_ IEC_STRING
 PDST   ; Level 2
 LEAY PSC__st__[0]

 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX client_id
 WRI  
 LEAX client_id
 LD   40
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string client_id
 PDST   ; Level 1
#srcline 130 ;                 else
 JMP  fbMQTTSubscriber_L12
fbMQTTSubscriber_L11:
#srcline 131 ;                     client_id := clientId;
 LD   0   ; null string
 LEAX client_id
 WRI  
 LEAX client_id
 LD   40
 DST    ; Level 1
 LEAX clientId
#debug string clientId
 SCON 
#debug_left string client_id
 PDST   ; Level 1
#srcline 132 ;                 end_if;
fbMQTTSubscriber_L12:
#srcline 134 ;                // Fixed header of control packet
#srcline 135 ;                // Fixed header
#srcline 136 ;                txData[0] := MQTT_CONTROL_PACK_CONNECT; // flag bits are cleared
 LD   usint 16
 WRX  txData[0]
#debug_left usint txData[0]
#srcline 137 ;                // Variable header
#srcline 138 ;                txData[2] := 0;
 LD   usint 0
 WRX  txData[2]
#debug_left usint txData[2]
#srcline 139 ;                txData[3] := 4;
 LD   usint 4
 WRX  txData[3]
#debug_left usint txData[3]
#srcline 140 ;                MemcpyPtr(source := ADR(MQTT_PROTOCOL),dest := ADR(txData[4]),length := 4);
 NXT
 LEAX MQTT_PROTOCOL
#debug pointer MQTT_PROTOCOL
 LEA  __Instance__MemcpyPtr~source
 WRIL 
#debug_left udint __Instance__MemcpyPtr~source
 LEAX txData
 ADD  4  ; + offset 
#debug pointer txData[4]
 LEA  __Instance__MemcpyPtr~dest
 WRIL 
#debug_left udint __Instance__MemcpyPtr~dest
 LD   udint 4
 WR   __Instance__MemcpyPtr~length
#debug_left udint __Instance__MemcpyPtr~length
 PRV
 LEA  __Instance__MemcpyPtr
 CAL  MemcpyPtr_L0
#srcline 141 ;                txData[8]   := MQTT_PROTOCOL_VERSION;
 LD   usint 4
 WRX  txData[8]
#debug_left usint txData[8]
#srcline 142 ;                // Protocol Level byte
#srcline 143 ;                //Set connection flags
#srcline 144 ;                connectFlags := 0;
 LD   byte 0
 WRX  connectFlags
#debug_left byte connectFlags
#srcline 145 ;                if loginName <> ''        then connectFlags := 16#80; end_if;
 LEAX loginName
#debug string loginName
 LEA  _str_fbMQTTSubscriber_0
 SCMP 
 EQ   0
 NEG
 JMC  fbMQTTSubscriber_L13
 LD   byte $80
 WRX  connectFlags
#debug_left byte connectFlags
fbMQTTSubscriber_L13:
#srcline 146 ;                if loginPass <> ''        then connectFlags := connectFlags OR 16#40; end_if;
 LEAX loginPass
#debug string loginPass
 LEA  _str_fbMQTTSubscriber_1
 SCMP 
 EQ   0
 NEG
 JMC  fbMQTTSubscriber_L15
 LDX  connectFlags
#debug byte connectFlags
 LD   byte $40
 OR  
 WRX  connectFlags
#debug_left byte connectFlags
fbMQTTSubscriber_L15:
#srcline 147 ;               // if com_param.willRetain   then connectFlags := connectFlags OR 16#20; end_if;
#srcline 148 ;               // connectFlags := connectFlags OR SHL(IN := USINT_TO_BYTE(com_param.qos),N := 3);
#srcline 149 ;                if com_param.cleanSession then connectFlags := connectFlags OR 16#2;  end_if;
 LDX  com_param~cleanSession
#debug bool com_param.cleanSession
 JMC  fbMQTTSubscriber_L17
 LDX  connectFlags
#debug byte connectFlags
 LD   byte $2
 OR  
 WRX  connectFlags
#debug_left byte connectFlags
fbMQTTSubscriber_L17:
#srcline 151 ;                txData[9]   := BYTE_TO_USINT(connectFlags);//For connect set clean session
 LDX  connectFlags
#debug byte connectFlags
 WRX  txData[9]
#debug_left usint txData[9]
#srcline 152 ;                //keep alive 2 bytes, MSB+LSB
#srcline 153 ;                aliveTime := TIME_TO_UINT(keepAliveInterval)/1000;
 LDX  keepAliveInterval
#debug time keepAliveInterval
AND  $FFFF
 LD   uint 1000
 DIVL
 AND  $FFFF
 WRX  aliveTime
#debug_left uint aliveTime
#srcline 155 ;                txData[10]  := 0;
 LD   usint 0
 WRX  txData[10]
#debug_left usint txData[10]
#srcline 156 ;                txData[11]  := UINT_TO_USINT(aliveTime);
 LDX  aliveTime
#debug uint aliveTime
 AND  $FF
 WRX  txData[11]
#debug_left usint txData[11]
#srcline 157 ;                //Payload
#srcline 158 ;                payloadLength1 := LEN(IN := client_id);
 LEAX client_id
#debug string client_id
 SLEN 
 WRX  payloadLength1
#debug_left uint payloadLength1
#srcline 159 ;                txData[12]  := WORD_TO_USINT(SHR(IN := UINT_TO_WORD(payloadLength1),N := 8));
 LDX  payloadLength1
#debug uint payloadLength1
 LD   uint 8
 SHR
 AND  $FFFF
 AND  $FF
 WRX  txData[12]
#debug_left usint txData[12]
#srcline 160 ;                txData[13]  := UINT_TO_USINT(payloadLength1);
 LDX  payloadLength1
#debug uint payloadLength1
 AND  $FF
 WRX  txData[13]
#debug_left usint txData[13]
#srcline 162 ;                txMsgLength := 14;
 LD   uint 14
 WRX  txMsgLength
#debug_left uint txMsgLength
#srcline 163 ;                //Copy client ID
#srcline 164 ;                MemcpyPtr(source := ADR(client_id),dest := ADR(txData[14]),length := UINT_TO_UDINT(payloadLength1));
 NXT
 LEAX client_id
#debug pointer client_id
 LEA  __Instance__MemcpyPtr~source
 WRIL 
#debug_left udint __Instance__MemcpyPtr~source
 LEAX txData
 ADD  14  ; + offset 
#debug pointer txData[14]
 LEA  __Instance__MemcpyPtr~dest
 WRIL 
#debug_left udint __Instance__MemcpyPtr~dest
 LDX  payloadLength1
#debug uint payloadLength1
 WR   __Instance__MemcpyPtr~length
#debug_left udint __Instance__MemcpyPtr~length
 PRV
 LEA  __Instance__MemcpyPtr
 CAL  MemcpyPtr_L0
#srcline 165 ;                txMsgLength := txMsgLength + payloadLength1;
 LDX  txMsgLength
#debug uint txMsgLength
 LDX  payloadLength1
#debug uint payloadLength1
 ADD
 AND  $FFFF
 WRX  txMsgLength
#debug_left uint txMsgLength
#srcline 166 ;                //Copy user name
#srcline 167 ;                if (connectFlags AND 16#80) > 0 then
 LDX  connectFlags
#debug byte connectFlags
 LD   byte $80
 AND
 LD   byte 0
 GT
 JMC  fbMQTTSubscriber_L19
#srcline 168 ;                     txData[txMsgLength]     := 0;
 LD   usint 0
 LEAX txData
 LDX  txMsgLength
#debug uint txMsgLength
 RCHK 100   ; Range Check
 ADD     ; + offset 
 WRI 
#debug_left usint txData[txMsgLength]
#srcline 169 ;                     txData[txMsgLength + 1] := LEN(IN := loginName);
 LEAX loginName
#debug string loginName
 SLEN 
 LEAX txData
 LDX  txMsgLength
#debug uint txMsgLength
 LD   uint 1
 ADD
 AND  $FFFF
 RCHK 100   ; Range Check
 ADD     ; + offset 
 WRI 
#debug_left usint txData[txMsgLength+1]
#srcline 170 ;                     payloadLength := LEN(IN := loginName);
 LEAX loginName
#debug string loginName
 SLEN 
 WRX  payloadLength
#debug_left uint payloadLength
#srcline 171 ;                     MemcpyPtr(source := ADR(loginName),dest := ADR(txData[txMsgLength + 2]),length := UINT_TO_UDINT(payloadLength));
 NXT
 LEAX loginName
#debug pointer loginName
 LEA  __Instance__MemcpyPtr~source
 WRIL 
#debug_left udint __Instance__MemcpyPtr~source
 LEAX txData
 LDX  txMsgLength
#debug uint txMsgLength
 LD   uint 2
 ADD
 AND  $FFFF
 RCHK 100   ; Range Check
 ADD     ; + offset 
#debug pointer txData[txMsgLength+2]
 LEA  __Instance__MemcpyPtr~dest
 WRIL 
#debug_left udint __Instance__MemcpyPtr~dest
 LDX  payloadLength
#debug uint payloadLength
 WR   __Instance__MemcpyPtr~length
#debug_left udint __Instance__MemcpyPtr~length
 PRV
 LEA  __Instance__MemcpyPtr
 CAL  MemcpyPtr_L0
#srcline 172 ;                     txMsgLength := txMsgLength + payloadLength + 2;
 LDX  txMsgLength
#debug uint txMsgLength
 LDX  payloadLength
#debug uint payloadLength
 ADD
 AND  $FFFF
 LD   uint 2
 ADD
 AND  $FFFF
 WRX  txMsgLength
#debug_left uint txMsgLength
#srcline 173 ;                end_if;
fbMQTTSubscriber_L19:
#srcline 174 ;                //Copy password
#srcline 175 ;                if (connectFlags AND 16#40) > 0 then
 LDX  connectFlags
#debug byte connectFlags
 LD   byte $40
 AND
 LD   byte 0
 GT
 JMC  fbMQTTSubscriber_L21
#srcline 176 ;                     txData[txMsgLength]     := 0;
 LD   usint 0
 LEAX txData
 LDX  txMsgLength
#debug uint txMsgLength
 RCHK 100   ; Range Check
 ADD     ; + offset 
 WRI 
#debug_left usint txData[txMsgLength]
#srcline 177 ;                     txData[txMsgLength + 1] := LEN(IN := loginPass);
 LEAX loginPass
#debug string loginPass
 SLEN 
 LEAX txData
 LDX  txMsgLength
#debug uint txMsgLength
 LD   uint 1
 ADD
 AND  $FFFF
 RCHK 100   ; Range Check
 ADD     ; + offset 
 WRI 
#debug_left usint txData[txMsgLength+1]
#srcline 178 ;                     payloadLength := LEN(IN := loginPass);
 LEAX loginPass
#debug string loginPass
 SLEN 
 WRX  payloadLength
#debug_left uint payloadLength
#srcline 179 ;                     MemcpyPtr(source := ADR(loginPass),dest := ADR(txData[txMsgLength + 2]),length := UINT_TO_UDINT(payloadLength));
 NXT
 LEAX loginPass
#debug pointer loginPass
 LEA  __Instance__MemcpyPtr~source
 WRIL 
#debug_left udint __Instance__MemcpyPtr~source
 LEAX txData
 LDX  txMsgLength
#debug uint txMsgLength
 LD   uint 2
 ADD
 AND  $FFFF
 RCHK 100   ; Range Check
 ADD     ; + offset 
#debug pointer txData[txMsgLength+2]
 LEA  __Instance__MemcpyPtr~dest
 WRIL 
#debug_left udint __Instance__MemcpyPtr~dest
 LDX  payloadLength
#debug uint payloadLength
 WR   __Instance__MemcpyPtr~length
#debug_left udint __Instance__MemcpyPtr~length
 PRV
 LEA  __Instance__MemcpyPtr
 CAL  MemcpyPtr_L0
#srcline 180 ;                     txMsgLength := txMsgLength + payloadLength + 2;
 LDX  txMsgLength
#debug uint txMsgLength
 LDX  payloadLength
#debug uint payloadLength
 ADD
 AND  $FFFF
 LD   uint 2
 ADD
 AND  $FFFF
 WRX  txMsgLength
#debug_left uint txMsgLength
#srcline 181 ;                end_if;
fbMQTTSubscriber_L21:
#srcline 183 ;                // length of package
#srcline 184 ;               txData[1]       := UINT_TO_USINT(txMsgLength - 2);
 LDX  txMsgLength
#debug uint txMsgLength
 LD   uint 2
 SUB
 AND  $FFFF
 AND  $FF
 WRX  txData[1]
#debug_left usint txData[1]
#srcline 186 ;                tx_data_request    := true;
 LD   bool -1       ; true
 WRX  tx_data_request
#debug_left bool tx_data_request
#srcline 187 ;                localPortExtension := USINT_TO_UINT(reconnect_counter);
 LDX  reconnect_counter
#debug usint reconnect_counter
 AND  $FFFF
 WRX  localPortExtension
#debug_left uint localPortExtension
#srcline 188 ;              //  connect_rq := true;
#srcline 189 ;                idle_time := 2;
 LD   usint 2
 WRX  idle_time
#debug_left usint idle_time
#srcline 190 ;                // required to change port on each reconnect
#srcline 191 ;                if reconnect_counter < 100 then
 LDX  reconnect_counter
#debug usint reconnect_counter
 LD   usint 100
 LT
 JMC  fbMQTTSubscriber_L23
#srcline 192 ;                    reconnect_counter := reconnect_counter + 1; //
 LDX  reconnect_counter
#debug usint reconnect_counter
 LD   usint 1
 ADD
 AND  $FF
 WRX  reconnect_counter
#debug_left usint reconnect_counter
#srcline 193 ;                else
 JMP  fbMQTTSubscriber_L24
fbMQTTSubscriber_L23:
#srcline 194 ;                    reconnect_counter := 0;
 LD   usint 0
 WRX  reconnect_counter
#debug_left usint reconnect_counter
#srcline 195 ;                end_if;
fbMQTTSubscriber_L24:
#srcline 196 ;                responce_recived := false;
 LD   bool 0       ; false
 WRX  responce_recived
#debug_left bool responce_recived
#srcline 197 ;                return;
 JMP  fbMQTTSubscriber_RET
#srcline 198 ;           //--------- Connected to brocker -------------------
#srcline 199 ;           else
 JMP  fbMQTTSubscriber_L10
fbMQTTSubscriber_L9:
#srcline 200 ;               if subRq OR unSubRq then //Subscribe or unsubsribe command from user program
 LDX  subRq
#debug bool subRq
 LDX  unSubRq
#debug bool unSubRq
 OR  
 JMC  fbMQTTSubscriber_L25
#srcline 201 ;                   if subRq then
 LDX  subRq
#debug bool subRq
 JMC  fbMQTTSubscriber_L27
#srcline 202 ;                       txData[0] := MQTT_CONTROL_PACK_SUBSCRIBE + 2;
 LD   usint 128
 LD   usint 2
 ADD
 AND  $FF
 WRX  txData[0]
#debug_left usint txData[0]
#srcline 203 ;                   else
 JMP  fbMQTTSubscriber_L28
fbMQTTSubscriber_L27:
#srcline 204 ;                       txData[0] := MQTT_CONTROL_PACK_UNSUBSCRIBE + 2;
 LD   usint 160
 LD   usint 2
 ADD
 AND  $FF
 WRX  txData[0]
#debug_left usint txData[0]
#srcline 205 ;                   end_if;
fbMQTTSubscriber_L28:
#srcline 206 ;                   //The variable header contains a Packet Identifier
#srcline 207 ;                   txData[2]        := WORD_TO_USINT(SHR(IN := UINT_TO_WORD(messageID), N := 8));
 LDX  messageID
#debug uint messageID
 LD   uint 8
 SHR
 AND  $FFFF
 AND  $FF
 WRX  txData[2]
#debug_left usint txData[2]
#srcline 208 ;                   txData[3]        := UINT_TO_USINT(messageID);
 LDX  messageID
#debug uint messageID
 AND  $FF
 WRX  txData[3]
#debug_left usint txData[3]
#srcline 210 ;                   // Payload
#srcline 211 ;                   payloadLength := LEN(IN := topicTxt);
 LEAX topicTxt
#debug string topicTxt
 SLEN 
 WRX  payloadLength
#debug_left uint payloadLength
#srcline 212 ;                   txData[4]     := WORD_TO_USINT(SHR(IN := UINT_TO_WORD(payloadLength),N := 8));
 LDX  payloadLength
#debug uint payloadLength
 LD   uint 8
 SHR
 AND  $FFFF
 AND  $FF
 WRX  txData[4]
#debug_left usint txData[4]
#srcline 213 ;                   txData[5]     := UINT_TO_USINT(payloadLength);
 LDX  payloadLength
#debug uint payloadLength
 AND  $FF
 WRX  txData[5]
#debug_left usint txData[5]
#srcline 214 ;                   
#srcline 215 ;                   MemcpyPtr(source := ADR(topicTxt),dest := ADR(txData[6]),length := UINT_TO_UDINT(payloadLength));
 NXT
 LEAX topicTxt
#debug pointer topicTxt
 LEA  __Instance__MemcpyPtr~source
 WRIL 
#debug_left udint __Instance__MemcpyPtr~source
 LEAX txData
 ADD  6  ; + offset 
#debug pointer txData[6]
 LEA  __Instance__MemcpyPtr~dest
 WRIL 
#debug_left udint __Instance__MemcpyPtr~dest
 LDX  payloadLength
#debug uint payloadLength
 WR   __Instance__MemcpyPtr~length
#debug_left udint __Instance__MemcpyPtr~length
 PRV
 LEA  __Instance__MemcpyPtr
 CAL  MemcpyPtr_L0
#srcline 216 ;                   txMsgLength := payloadLength + 4;
 LDX  payloadLength
#debug uint payloadLength
 LD   uint 4
 ADD
 AND  $FFFF
 WRX  txMsgLength
#debug_left uint txMsgLength
#srcline 217 ;                   if subRq then
 LDX  subRq
#debug bool subRq
 JMC  fbMQTTSubscriber_L29
#srcline 218 ;                       txData[txMsgLength + 2] := com_param.qos;
 LDX  com_param~qos
#debug usint com_param.qos
 LEAX txData
 LDX  txMsgLength
#debug uint txMsgLength
 LD   uint 2
 ADD
 AND  $FFFF
 RCHK 100   ; Range Check
 ADD     ; + offset 
 WRI 
#debug_left usint txData[txMsgLength+2]
#srcline 219 ;                       txMsgLength := txMsgLength + 1;
 LDX  txMsgLength
#debug uint txMsgLength
 LD   uint 1
 ADD
 AND  $FFFF
 WRX  txMsgLength
#debug_left uint txMsgLength
#srcline 220 ;                   end_if;
fbMQTTSubscriber_L29:
#srcline 222 ;                   txData[1]        := UINT_TO_USINT(txMsgLength);
 LDX  txMsgLength
#debug uint txMsgLength
 AND  $FF
 WRX  txData[1]
#debug_left usint txData[1]
#srcline 223 ;                   txMsgLength      := txMsgLength + 2;
 LDX  txMsgLength
#debug uint txMsgLength
 LD   uint 2
 ADD
 AND  $FFFF
 WRX  txMsgLength
#debug_left uint txMsgLength
#srcline 224 ;                   tx_data_request  := true;
 LD   bool -1       ; true
 WRX  tx_data_request
#debug_left bool tx_data_request
#srcline 226 ;                   busy    := true;
 LD   bool -1       ; true
 WRX  busy
#debug_left bool busy
#srcline 227 ;                   ok      := false;
 LD   bool 0       ; false
 WRX  ok
#debug_left bool ok
#srcline 228 ;                   err     := false;
 LD   bool 0       ; false
 WRX  err
#debug_left bool err
#srcline 229 ;                   errCode := MQTT_CONTROL_ERROR_CODE_OK;
 LD   usint 0
 WRX  errCode
#debug_left usint errCode
#srcline 231 ;                   subRq   := false;
 LD   bool 0       ; false
 WRX  subRq
#debug_left bool subRq
#srcline 232 ;                   unSubRq := false;
 LD   bool 0       ; false
 WRX  unSubRq
#debug_left bool unSubRq
#srcline 233 ;               end_if;
fbMQTTSubscriber_L25:
#srcline 235 ;               if pubAckRq OR pubRecRq OR pubCompRq then
 LDX  pubAckRq
#debug bool pubAckRq
 LDX  pubRecRq
#debug bool pubRecRq
 OR  
 LDX  pubCompRq
#debug bool pubCompRq
 OR  
 JMC  fbMQTTSubscriber_L31
#srcline 236 ;                   if pubAckRq then
 LDX  pubAckRq
#debug bool pubAckRq
 JMC  fbMQTTSubscriber_L33
#srcline 237 ;                       txData[0]        := MQTT_CONTROL_PACK_PUBACK;  // Publish acknowledge                      QOS=1
 LD   usint 64
 WRX  txData[0]
#debug_left usint txData[0]
#srcline 238 ;                   elsif pubRecRq then
 JMP  fbMQTTSubscriber_L34
fbMQTTSubscriber_L33:
 LDX  pubRecRq
#debug bool pubRecRq
 JMC  fbMQTTSubscriber_L35
#srcline 239 ;                       txData[0]        := MQTT_CONTROL_PACK_PUBREC;  // Publish acknowledge "Publish recived"    QOS=2
 LD   usint 80
 WRX  txData[0]
#debug_left usint txData[0]
#srcline 240 ;                   else
 JMP  fbMQTTSubscriber_L34
fbMQTTSubscriber_L35:
#srcline 241 ;                       txData[0]        := MQTT_CONTROL_PACK_PUBCOMP; // Publish acknowledge "Publish completed"  QOS=2
 LD   usint 112
 WRX  txData[0]
#debug_left usint txData[0]
#srcline 242 ;                   end_if;
fbMQTTSubscriber_L34:
#srcline 244 ;                   txData[1]        := 2;
 LD   usint 2
 WRX  txData[1]
#debug_left usint txData[1]
#srcline 245 ;                   txData[2]        := WORD_TO_USINT(SHR(IN := UINT_TO_WORD(messageIDpubAck), N := 8));
 LDX  messageIDpubAck
#debug uint messageIDpubAck
 LD   uint 8
 SHR
 AND  $FFFF
 AND  $FF
 WRX  txData[2]
#debug_left usint txData[2]
#srcline 246 ;                   txData[3]        := UINT_TO_USINT(messageIDpubAck);
 LDX  messageIDpubAck
#debug uint messageIDpubAck
 AND  $FF
 WRX  txData[3]
#debug_left usint txData[3]
#srcline 247 ;                   txMsgLength      := 4;
 LD   uint 4
 WRX  txMsgLength
#debug_left uint txMsgLength
#srcline 248 ;                   tx_data_request  := true;
 LD   bool -1       ; true
 WRX  tx_data_request
#debug_left bool tx_data_request
#srcline 249 ;                   busy             := false;
 LD   bool 0       ; false
 WRX  busy
#debug_left bool busy
#srcline 250 ;                   ok               := true;
 LD   bool -1       ; true
 WRX  ok
#debug_left bool ok
#srcline 251 ;                   err              := false;
 LD   bool 0       ; false
 WRX  err
#debug_left bool err
#srcline 252 ;                   errCode          := MQTT_CONTROL_ERROR_CODE_OK;
 LD   usint 0
 WRX  errCode
#debug_left usint errCode
#srcline 254 ;                   pubAckRq         := false;
 LD   bool 0       ; false
 WRX  pubAckRq
#debug_left bool pubAckRq
#srcline 255 ;                   pubRecRq         := false;
 LD   bool 0       ; false
 WRX  pubRecRq
#debug_left bool pubRecRq
#srcline 256 ;                   pubCompRq        := false;
 LD   bool 0       ; false
 WRX  pubCompRq
#debug_left bool pubCompRq
#srcline 257 ;                   return;
 JMP  fbMQTTSubscriber_RET
#srcline 258 ;               end_if;
fbMQTTSubscriber_L31:
#srcline 260 ;                //---------------------------------------------
#srcline 261 ;                if MQTT_ping_timer.Q then
 LDX  MQTT_ping_timer~Q
#debug bool MQTT_ping_timer.Q
 JMC  fbMQTTSubscriber_L36
#srcline 262 ;                    //Ping request
#srcline 263 ;                     txData[0]        := MQTT_CONTROL_PACK_PINGREQ; // flag bits are cleared
 LD   usint 192
 WRX  txData[0]
#debug_left usint txData[0]
#srcline 264 ;                     txData[1]        := 0;
 LD   usint 0
 WRX  txData[1]
#debug_left usint txData[1]
#srcline 265 ;                     txMsgLength      := 2;
 LD   uint 2
 WRX  txMsgLength
#debug_left uint txMsgLength
#srcline 266 ;                     tx_data_request  := true;
 LD   bool -1       ; true
 WRX  tx_data_request
#debug_left bool tx_data_request
#srcline 267 ;                     responce_recived := false;
 LD   bool 0       ; false
 WRX  responce_recived
#debug_left bool responce_recived
#srcline 268 ;                     busy             := false;
 LD   bool 0       ; false
 WRX  busy
#debug_left bool busy
#srcline 269 ;                     ok               := true;
 LD   bool -1       ; true
 WRX  ok
#debug_left bool ok
#srcline 270 ;                     err              := false;
 LD   bool 0       ; false
 WRX  err
#debug_left bool err
#srcline 271 ;                     errCode          := MQTT_CONTROL_ERROR_CODE_OK;
 LD   usint 0
 WRX  errCode
#debug_left usint errCode
#srcline 272 ;                     return;
 JMP  fbMQTTSubscriber_RET
#srcline 273 ;                end_if;
fbMQTTSubscriber_L36:
#srcline 274 ;           end_if;
fbMQTTSubscriber_L10:
#srcline 275 ;       end_if;
fbMQTTSubscriber_L7:
#srcline 277 ;      if conn_status then
 LDX  conn_status
#debug bool conn_status
 JMC  fbMQTTSubscriber_L38
#srcline 278 ;          SendTo( rq := tx_data_request, chanCode := chanCode, lenTx := txMsgLength , data := void(txData));
 LDX  tx_data_request
#debug bool tx_data_request
 WRX  SendTo~rq
#debug_left bool SendTo~rq
 LDX  chanCode
#debug uint chanCode
 WRX  SendTo~chanCode
#debug_left uint SendTo~chanCode
 LDX  txMsgLength
#debug uint txMsgLength
 WRX  SendTo~lenTx
#debug_left uint SendTo~lenTx
 LEAX txData
 WRX  SendTo~data
#debug_left pointer SendTo.data
 LEAX SendTo
 CAL  fbSendTo_L0
#srcline 279 ;          if SendTo.mesSent then
 LDX  SendTo~mesSent
#debug bool SendTo.mesSent
 JMC  fbMQTTSubscriber_L40
#srcline 280 ;              tx_data_request := false;
 LD   bool 0       ; false
 WRX  tx_data_request
#debug_left bool tx_data_request
#srcline 281 ;              txCounter := txCounter + 1;
 LDX  txCounter
#debug uint txCounter
 LD   uint 1
 ADD
 AND  $FFFF
 WRX  txCounter
#debug_left uint txCounter
#srcline 282 ;              messageID := messageID + 1;
 LDX  messageID
#debug uint messageID
 LD   uint 1
 ADD
 AND  $FFFF
 WRX  messageID
#debug_left uint messageID
#srcline 283 ;              if com_param.qos = 1 then wait_response := true; end_if;
 LDX  com_param~qos
#debug usint com_param.qos
 LD   usint 1
 EQ
 JMC  fbMQTTSubscriber_L42
 LD   bool -1       ; true
 WRX  wait_response
#debug_left bool wait_response
fbMQTTSubscriber_L42:
#srcline 284 ;          end_if;
fbMQTTSubscriber_L40:
#srcline 286 ;          RecvFrom( rq := true, chanCode := chanCode, lenRx := 300, data := void(rxData));
 LD   bool -1       ; true
 WRX  RecvFrom~rq
#debug_left bool RecvFrom~rq
 LDX  chanCode
#debug uint chanCode
 WRX  RecvFrom~chanCode
#debug_left uint RecvFrom~chanCode
 LD   uint 300
 WRX  RecvFrom~lenRx
#debug_left uint RecvFrom~lenRx
 LEAX rxData
 WRX  RecvFrom~data
#debug_left pointer RecvFrom.data
 LEAX RecvFrom
 CAL  fbRecvFrom_L0
#srcline 288 ;          if RecvFrom.mesRec then
 LDX  RecvFrom~mesRec
#debug bool RecvFrom.mesRec
 JMC  fbMQTTSubscriber_L44
#srcline 289 ;              if RecvFrom.error = 0 then
 LDX  RecvFrom~error
#debug usint RecvFrom.error
 LD   usint 0
 EQ
 JMC  fbMQTTSubscriber_L46
#srcline 290 ;                   busy     := false;
 LD   bool 0       ; false
 WRX  busy
#debug_left bool busy
#srcline 291 ;                   ok       := true;
 LD   bool -1       ; true
 WRX  ok
#debug_left bool ok
#srcline 292 ;                   err      := false;
 LD   bool 0       ; false
 WRX  err
#debug_left bool err
#srcline 293 ;                   errCode  := MQTT_CONTROL_ERROR_CODE_OK;
 LD   usint 0
 WRX  errCode
#debug_left usint errCode
#srcline 295 ;                  if RecvFrom.lenData = 4  AND rxData[0] = MQTT_CONTROL_PACK_CONNACK THEN
 LDX  RecvFrom~lenData
#debug uint RecvFrom.lenData
 LD   uint 4
 EQ
 LDX  rxData[0]
#debug usint rxData[0]
 LD   usint 32
 EQ
 AND
 JMC  fbMQTTSubscriber_L48
#srcline 296 ;                       responce_recived     := true;
 LD   bool -1       ; true
 WRX  responce_recived
#debug_left bool responce_recived
#srcline 297 ;                       wait_response        := false;
 LD   bool 0       ; false
 WRX  wait_response
#debug_left bool wait_response
#srcline 298 ;                       if rxData[3] = 0 then
 LDX  rxData[3]
#debug usint rxData[3]
 LD   usint 0
 EQ
 JMC  fbMQTTSubscriber_L50
#srcline 299 ;                           connected_to_broker  := true;
 LD   bool -1       ; true
 WRX  connected_to_broker
#debug_left bool connected_to_broker
#srcline 300 ;                       else
 JMP  fbMQTTSubscriber_L51
fbMQTTSubscriber_L50:
#srcline 301 ;                           connected_to_broker  := false;
 LD   bool 0       ; false
 WRX  connected_to_broker
#debug_left bool connected_to_broker
#srcline 302 ;                           ok                   := false;
 LD   bool 0       ; false
 WRX  ok
#debug_left bool ok
#srcline 303 ;                           err                  := true;
 LD   bool -1       ; true
 WRX  err
#debug_left bool err
#srcline 304 ;                           errCode              := MQTT_CONTROL_ERROR_CODE_LOGIN_FAILED;
 LD   usint 5
 WRX  errCode
#debug_left usint errCode
#srcline 305 ;                       end_if;
fbMQTTSubscriber_L51:
#srcline 306 ;                  elsif (RecvFrom.lenData = 4  AND  rxData[0] = MQTT_CONTROL_PACK_UNSUBACK) OR  // responce to connect command
 JMP  fbMQTTSubscriber_L49
fbMQTTSubscriber_L48:
 LDX  RecvFrom~lenData
#debug uint RecvFrom.lenData
 LD   uint 4
 EQ
 LDX  rxData[0]
#debug usint rxData[0]
 LD   usint 176
 EQ
 AND
#srcline 307 ;                         RecvFrom.lenData = 2  AND  rxData[0] = MQTT_CONTROL_PACK_PINGRESP  then
 LDX  RecvFrom~lenData
#debug uint RecvFrom.lenData
 LD   uint 2
 EQ
 LDX  rxData[0]
#debug usint rxData[0]
 LD   usint 208
 EQ
 AND
 OR  
 JMC  fbMQTTSubscriber_L52
#srcline 308 ;                          connected_to_broker  := true;
 LD   bool -1       ; true
 WRX  connected_to_broker
#debug_left bool connected_to_broker
#srcline 309 ;                          responce_recived     := true;
 LD   bool -1       ; true
 WRX  responce_recived
#debug_left bool responce_recived
#srcline 310 ;                          wait_response        := false;
 LD   bool 0       ; false
 WRX  wait_response
#debug_left bool wait_response
#srcline 311 ;                  elsif (RecvFrom.lenData = 4  AND (AND(IN1 := USINT_TO_BYTE(rxData[0]),IN2 := USINT_TO_BYTE(MQTT_CONTROL_PACK_PUBREL)) = USINT_TO_BYTE(MQTT_CONTROL_PACK_PUBREL))) then
 JMP  fbMQTTSubscriber_L49
fbMQTTSubscriber_L52:
 LDX  RecvFrom~lenData
#debug uint RecvFrom.lenData
 LD   uint 4
 EQ
 LDX  rxData[0]
#debug usint rxData[0]
 AND  $FF
 LD   usint 96
 AND  $FF
 AND
 LD   usint 96
 AND  $FF
 EQ
 AND
 JMC  fbMQTTSubscriber_L53
#srcline 312 ;                          pubCompRq           := true;
 LD   bool -1       ; true
 WRX  pubCompRq
#debug_left bool pubCompRq
#srcline 313 ;                          connected_to_broker := true;
 LD   bool -1       ; true
 WRX  connected_to_broker
#debug_left bool connected_to_broker
#srcline 314 ;                          responce_recived    := true;
 LD   bool -1       ; true
 WRX  responce_recived
#debug_left bool responce_recived
#srcline 315 ;                          wait_response       := false;
 LD   bool 0       ; false
 WRX  wait_response
#debug_left bool wait_response
#srcline 317 ;                          messageIDpubAck_ptr := ADR(rxData[2]);
 LEAX rxData
 ADD  2  ; + offset 
#debug pointer rxData[2]
 LEAX messageIDpubAck_ptr
 WRIL 
#debug_left pointer messageIDpubAck_ptr
#srcline 318 ;                          messageIDpubAck     := fSwapUINT(messageIDpubAck_ptr^);
 NXT
 LEAX messageIDpubAck_ptr
 LDIL    ; dereference 
 LDIW 
#debug uint messageIDpubAck_ptr^
 WR   __Instance__fSwapUINT~input
#debug_left uint __Instance__fSwapUINT~input
 PRV
 LEA  __Instance__fSwapUINT
 CAL  fSwapUINT_L0
 WRX  messageIDpubAck
#debug_left uint messageIDpubAck
#srcline 320 ;                  elsif RecvFrom.lenData = 5 AND rxData[0] = MQTT_CONTROL_PACK_SUBACK then // responce to subscribe command
 JMP  fbMQTTSubscriber_L49
fbMQTTSubscriber_L53:
 LDX  RecvFrom~lenData
#debug uint RecvFrom.lenData
 LD   uint 5
 EQ
 LDX  rxData[0]
#debug usint rxData[0]
 LD   usint 144
 EQ
 AND
 JMC  fbMQTTSubscriber_L54
#srcline 321 ;                         connected_to_broker := true;
 LD   bool -1       ; true
 WRX  connected_to_broker
#debug_left bool connected_to_broker
#srcline 322 ;                         responce_recived    := true;
 LD   bool -1       ; true
 WRX  responce_recived
#debug_left bool responce_recived
#srcline 323 ;                         wait_response       := false;
 LD   bool 0       ; false
 WRX  wait_response
#debug_left bool wait_response
#srcline 324 ;                         if rxData[4] = 16#80 then
 LDX  rxData[4]
#debug usint rxData[4]
 LD   usint $80
 EQ
 JMC  fbMQTTSubscriber_L55
#srcline 325 ;                             ok              := false;
 LD   bool 0       ; false
 WRX  ok
#debug_left bool ok
#srcline 326 ;                             err             := true;
 LD   bool -1       ; true
 WRX  err
#debug_left bool err
#srcline 327 ;                             errCode         := MQTT_CONTROL_ERROR_CODE_SUBSCRIBE_FAILED;
 LD   usint 2
 WRX  errCode
#debug_left usint errCode
#srcline 328 ;                         end_if;
fbMQTTSubscriber_L55:
#srcline 329 ;                  else // Incomming data from broker
 JMP  fbMQTTSubscriber_L49
fbMQTTSubscriber_L54:
#srcline 330 ;                       if  (AND(IN1 := USINT_TO_BYTE(rxData[0]),IN2 := USINT_TO_BYTE(MQTT_CONTROL_PACK_PUBLISH))) > 0 then
 LDX  rxData[0]
#debug usint rxData[0]
 AND  $FF
 LD   usint 48
 AND  $FF
 AND
 LD   byte 0
 GT
 JMC  fbMQTTSubscriber_L57
#srcline 331 ;                             connected_to_broker := true;
 LD   bool -1       ; true
 WRX  connected_to_broker
#debug_left bool connected_to_broker
#srcline 332 ;                             responce_recived    := true;
 LD   bool -1       ; true
 WRX  responce_recived
#debug_left bool responce_recived
#srcline 333 ;                             wait_response       := false;
 LD   bool 0       ; false
 WRX  wait_response
#debug_left bool wait_response
#srcline 335 ;                             index               := 1;
 LD   usint 1
 WRX  index
#debug_left usint index
#srcline 336 ;                             payloadLengthSize   := 0;
 LD   uint 0
 WRX  payloadLengthSize
#debug_left uint payloadLengthSize
#srcline 337 ;                             payloadLengthBytes  := 1;
 LD   uint 1
 WRX  payloadLengthBytes
#debug_left uint payloadLengthBytes
#srcline 339 ;                             while index <= 4 do
fbMQTTSubscriber_L59:
 LDX  index
#debug usint index
 LD   usint 4
 GT
 NEG
 JMC  fbMQTTSubscriber_L60
 DBG 
#srcline 340 ;                                if rxData[index] > 16#80 then
 LEAX rxData
 LDX  index
#debug usint index
 RCHK 300   ; Range Check
 ADD     ; + offset 
 LDI  
#debug usint rxData[index]
 LD   usint $80
 GT
 JMC  fbMQTTSubscriber_L61
#srcline 341 ;                                     payloadLengthSize := payloadLengthSize + BYTE_TO_UINT(USINT_TO_BYTE(rxData[index]) AND 16#7F);
 LDX  payloadLengthSize
#debug uint payloadLengthSize
 LEAX rxData
 LDX  index
#debug usint index
 RCHK 300   ; Range Check
 ADD     ; + offset 
 LDI  
#debug usint rxData[index]
 AND  $FF
 LD   byte $7F
 AND
 ADD
 AND  $FFFF
 WRX  payloadLengthSize
#debug_left uint payloadLengthSize
#srcline 342 ;                                     payloadLengthBytes := payloadLengthBytes + 1;
 LDX  payloadLengthBytes
#debug uint payloadLengthBytes
 LD   uint 1
 ADD
 AND  $FFFF
 WRX  payloadLengthBytes
#debug_left uint payloadLengthBytes
#srcline 343 ;                                else
 JMP  fbMQTTSubscriber_L62
fbMQTTSubscriber_L61:
#srcline 344 ;                                     if payloadLengthBytes > 1 then
 LDX  payloadLengthBytes
#debug uint payloadLengthBytes
 LD   uint 1
 GT
 JMC  fbMQTTSubscriber_L63
#srcline 345 ;                                         payloadLengthSize := payloadLengthSize + (USINT_TO_UINT(rxData[index]) * 128);
 LDX  payloadLengthSize
#debug uint payloadLengthSize
 LEAX rxData
 LDX  index
#debug usint index
 RCHK 300   ; Range Check
 ADD     ; + offset 
 LDI  
#debug usint rxData[index]
 AND  $FFFF
 LD   uint 128
 MUL
 AND  $FFFF
 ADD
 AND  $FFFF
 WRX  payloadLengthSize
#debug_left uint payloadLengthSize
#srcline 346 ;                                     else
 JMP  fbMQTTSubscriber_L64
fbMQTTSubscriber_L63:
#srcline 347 ;                                         payloadLengthSize := USINT_TO_UINT(rxData[index]);
 LEAX rxData
 LDX  index
#debug usint index
 RCHK 300   ; Range Check
 ADD     ; + offset 
 LDI  
#debug usint rxData[index]
 AND  $FFFF
 WRX  payloadLengthSize
#debug_left uint payloadLengthSize
#srcline 348 ;                                     end_if;
fbMQTTSubscriber_L64:
#srcline 349 ;                                     exit;
 JMP  fbMQTTSubscriber_L60
#srcline 350 ;                                end_if;
fbMQTTSubscriber_L62:
#srcline 351 ;                                index := index + 1;
 LDX  index
#debug usint index
 LD   usint 1
 ADD
 AND  $FF
 WRX  index
#debug_left usint index
#srcline 352 ;                             end_while;
 JMP  fbMQTTSubscriber_L59
fbMQTTSubscriber_L60:
 NOP  -1
#srcline 354 ;                             inDataCom_param.qos := BYTE_TO_USINT(SHR(IN := USINT_TO_BYTE(rxData[0]),N := 1) AND 16#3);
 LDX  rxData[0]
#debug usint rxData[0]
 AND  $FF
 LD   uint 1
 SHR
 AND  $FF
 LD   byte $3
 AND
 WRX  inDataCom_param~qos
#debug_left usint inDataCom_param.qos
#srcline 355 ;                             inTopicLen          := USINT_TO_UINT(rxData[payloadLengthBytes + 2]);
 LEAX rxData
 LDX  payloadLengthBytes
#debug uint payloadLengthBytes
 LD   uint 2
 ADD
 AND  $FFFF
 RCHK 300   ; Range Check
 ADD     ; + offset 
 LDI  
#debug usint rxData[payloadLengthBytes+2]
 AND  $FFFF
 WRX  inTopicLen
#debug_left uint inTopicLen
#srcline 358 ;                               if (RecvFrom.lenData - payloadLengthBytes - 1) = payloadLengthSize then
 LDX  RecvFrom~lenData
#debug uint RecvFrom.lenData
 LDX  payloadLengthBytes
#debug uint payloadLengthBytes
 SUB
 AND  $FFFF
 LD   uint 1
 SUB
 AND  $FFFF
 LDX  payloadLengthSize
#debug uint payloadLengthSize
 EQ
 JMC  fbMQTTSubscriber_L65
#srcline 359 ;                                  dataRec          := true;
 LD   bool -1       ; true
 WRX  dataRec
#debug_left bool dataRec
#srcline 360 ;                                  dataRecDT        := GetDateTime();
 LEA  __Instance__GetDateTime
 CAL  GetDateTime_L0
 WRX  dataRecDT
#debug_left dt dataRecDT
#srcline 361 ;                                  dataTxt          := '';
 LD   0   ; null string
 LEAX dataTxt
 WRI  
 LEAX dataTxt
 LD   255
 DST    ; Level 1
 LEA  _str_fbMQTTSubscriber_2
 SCON 
#debug_left string dataTxt
 PDST   ; Level 1
#srcline 362 ;                                  Memset(val := 0,length := 80,dest := VOID(dataTopicTxt));
 NXT
 LD   udint 0
 WR   __Instance__Memset~val
#debug_left udint __Instance__Memset~val
 LD   uint 80
 WR   __Instance__Memset~length
#debug_left uint __Instance__Memset~length
 LEAX dataTopicTxt
 WR   __Instance__Memset~dest
#debug_left pointer __Instance__Memset.dest
 PRV
 LEA  __Instance__Memset
 CAL  Memset_L0
#srcline 363 ;                                  MemcpyPtr(source := ADR(rxData[payloadLengthBytes + 3]), dest := ADR(dataTopicTxt),length := UINT_TO_UDINT(inTopicLen));
 NXT
 LEAX rxData
 LDX  payloadLengthBytes
#debug uint payloadLengthBytes
 LD   uint 3
 ADD
 AND  $FFFF
 RCHK 300   ; Range Check
 ADD     ; + offset 
#debug pointer rxData[payloadLengthBytes+3]
 LEA  __Instance__MemcpyPtr~source
 WRIL 
#debug_left udint __Instance__MemcpyPtr~source
 LEAX dataTopicTxt
#debug pointer dataTopicTxt
 LEA  __Instance__MemcpyPtr~dest
 WRIL 
#debug_left udint __Instance__MemcpyPtr~dest
 LDX  inTopicLen
#debug uint inTopicLen
 WR   __Instance__MemcpyPtr~length
#debug_left udint __Instance__MemcpyPtr~length
 PRV
 LEA  __Instance__MemcpyPtr
 CAL  MemcpyPtr_L0
#srcline 365 ;                                  if inDataCom_param.qos > 0 then
 LDX  inDataCom_param~qos
#debug usint inDataCom_param.qos
 LD   usint 0
 GT
 JMC  fbMQTTSubscriber_L67
#srcline 366 ;                                      if inDataCom_param.qos = 1 then
 LDX  inDataCom_param~qos
#debug usint inDataCom_param.qos
 LD   usint 1
 EQ
 JMC  fbMQTTSubscriber_L69
#srcline 367 ;                                          pubAckRq  := true; // Request to answer to publish command from broker when QOS=1
 LD   bool -1       ; true
 WRX  pubAckRq
#debug_left bool pubAckRq
#srcline 368 ;                                      else
 JMP  fbMQTTSubscriber_L70
fbMQTTSubscriber_L69:
#srcline 369 ;                                          pubRecRq  := true; // Request to answer to publish command from broker when QOS=2
 LD   bool -1       ; true
 WRX  pubRecRq
#debug_left bool pubRecRq
#srcline 370 ;                                      end_if;
fbMQTTSubscriber_L70:
#srcline 371 ;                                      messageIDpubAck_ptr := ADR(rxData[inTopicLen + payloadLengthBytes + 3]);
 LEAX rxData
 LDX  inTopicLen
#debug uint inTopicLen
 LDX  payloadLengthBytes
#debug uint payloadLengthBytes
 ADD
 AND  $FFFF
 LD   uint 3
 ADD
 AND  $FFFF
 RCHK 300   ; Range Check
 ADD     ; + offset 
#debug pointer rxData[inTopicLen+payloadLengthBytes+3]
 LEAX messageIDpubAck_ptr
 WRIL 
#debug_left pointer messageIDpubAck_ptr
#srcline 372 ;                                      messageIDpubAck     := fSwapUINT(messageIDpubAck_ptr^);
 NXT
 LEAX messageIDpubAck_ptr
 LDIL    ; dereference 
 LDIW 
#debug uint messageIDpubAck_ptr^
 WR   __Instance__fSwapUINT~input
#debug_left uint __Instance__fSwapUINT~input
 PRV
 LEA  __Instance__fSwapUINT
 CAL  fSwapUINT_L0
 WRX  messageIDpubAck
#debug_left uint messageIDpubAck
#srcline 374 ;                                     // inMsgLen := rxData[1] - inTopicLen - 4;
#srcline 375 ;                                      inMsgLen := payloadLengthSize - inTopicLen - 4;
 LDX  payloadLengthSize
#debug uint payloadLengthSize
 LDX  inTopicLen
#debug uint inTopicLen
 SUB
 AND  $FFFF
 LD   uint 4
 SUB
 AND  $FFFF
 WRX  inMsgLen
#debug_left uint inMsgLen
#srcline 376 ;                                    //  MemcpyPtr(source := ADR(rxData[inTopicLen + 6]),dest := ADR(dataTxt),   length := inMsgLen);
#srcline 377 ;                                        MemcpyPtr(source := ADR(rxData[inTopicLen + payloadLengthBytes + 5]),dest := ADR(dataTxt),   length := UINT_TO_UDINT(inMsgLen));
 NXT
 LEAX rxData
 LDX  inTopicLen
#debug uint inTopicLen
 LDX  payloadLengthBytes
#debug uint payloadLengthBytes
 ADD
 AND  $FFFF
 LD   uint 5
 ADD
 AND  $FFFF
 RCHK 300   ; Range Check
 ADD     ; + offset 
#debug pointer rxData[inTopicLen+payloadLengthBytes+5]
 LEA  __Instance__MemcpyPtr~source
 WRIL 
#debug_left udint __Instance__MemcpyPtr~source
 LEAX dataTxt
#debug pointer dataTxt
 LEA  __Instance__MemcpyPtr~dest
 WRIL 
#debug_left udint __Instance__MemcpyPtr~dest
 LDX  inMsgLen
#debug uint inMsgLen
 WR   __Instance__MemcpyPtr~length
#debug_left udint __Instance__MemcpyPtr~length
 PRV
 LEA  __Instance__MemcpyPtr
 CAL  MemcpyPtr_L0
#srcline 378 ;                                  else
 JMP  fbMQTTSubscriber_L68
fbMQTTSubscriber_L67:
#srcline 379 ;                                   // inMsgLen := rxData[1] - inTopicLen - 2;
#srcline 380 ;                                    inMsgLen := payloadLengthSize-inTopicLen;
 LDX  payloadLengthSize
#debug uint payloadLengthSize
 LDX  inTopicLen
#debug uint inTopicLen
 SUB
 AND  $FFFF
 WRX  inMsgLen
#debug_left uint inMsgLen
#srcline 381 ;                                    inMsgLen := inMsgLen - 2;
 LDX  inMsgLen
#debug uint inMsgLen
 LD   uint 2
 SUB
 AND  $FFFF
 WRX  inMsgLen
#debug_left uint inMsgLen
#srcline 382 ;                                    MemcpyPtr(source := ADR(rxData[inTopicLen + payloadLengthBytes + 3]),dest := ADR(dataTxt),length := UINT_TO_UDINT(inMsgLen));
 NXT
 LEAX rxData
 LDX  inTopicLen
#debug uint inTopicLen
 LDX  payloadLengthBytes
#debug uint payloadLengthBytes
 ADD
 AND  $FFFF
 LD   uint 3
 ADD
 AND  $FFFF
 RCHK 300   ; Range Check
 ADD     ; + offset 
#debug pointer rxData[inTopicLen+payloadLengthBytes+3]
 LEA  __Instance__MemcpyPtr~source
 WRIL 
#debug_left udint __Instance__MemcpyPtr~source
 LEAX dataTxt
#debug pointer dataTxt
 LEA  __Instance__MemcpyPtr~dest
 WRIL 
#debug_left udint __Instance__MemcpyPtr~dest
 LDX  inMsgLen
#debug uint inMsgLen
 WR   __Instance__MemcpyPtr~length
#debug_left udint __Instance__MemcpyPtr~length
 PRV
 LEA  __Instance__MemcpyPtr
 CAL  MemcpyPtr_L0
#srcline 383 ;                                  end_if;
fbMQTTSubscriber_L68:
#srcline 384 ;                             else
 JMP  fbMQTTSubscriber_L66
fbMQTTSubscriber_L65:
#srcline 385 ;                                ok       := false;
 LD   bool 0       ; false
 WRX  ok
#debug_left bool ok
#srcline 386 ;                                err      := true;
 LD   bool -1       ; true
 WRX  err
#debug_left bool err
#srcline 387 ;                                errCode  := MQTT_CONTROL_ERROR_CODE_ANSWER_LENGTH_TO_LONG;
 LD   usint 4
 WRX  errCode
#debug_left usint errCode
#srcline 388 ;                             end_if;
fbMQTTSubscriber_L66:
#srcline 389 ;                       end_if;
fbMQTTSubscriber_L57:
#srcline 390 ;                  end_if;
fbMQTTSubscriber_L49:
#srcline 391 ;                  rxCounter := rxCounter + 1;
 LDX  rxCounter
#debug uint rxCounter
 LD   uint 1
 ADD
 AND  $FFFF
 WRX  rxCounter
#debug_left uint rxCounter
#srcline 392 ;              end_if;
fbMQTTSubscriber_L46:
#srcline 393 ;          end_if;
fbMQTTSubscriber_L44:
#srcline 394 ;       else
 JMP  fbMQTTSubscriber_L39
fbMQTTSubscriber_L38:
#srcline 395 ;         connected_to_broker := false;
 LD   bool 0       ; false
 WRX  connected_to_broker
#debug_left bool connected_to_broker
#srcline 396 ;         wait_response       := false;
 LD   bool 0       ; false
 WRX  wait_response
#debug_left bool wait_response
#srcline 397 ;         ok                  := false;
 LD   bool 0       ; false
 WRX  ok
#debug_left bool ok
#srcline 398 ;         err                 := true;
 LD   bool -1       ; true
 WRX  err
#debug_left bool err
#srcline 399 ;         errCode             := MQTT_CONTROL_ERROR_CODE_BROKER_DISCONNECTED;
 LD   usint 3
 WRX  errCode
#debug_left usint errCode
#srcline 400 ;       end_if;
fbMQTTSubscriber_L39:
#srcline 401 ;   else
 JMP  fbMQTTSubscriber_L6
fbMQTTSubscriber_L5:
#srcline 402 ;     connected_to_broker := false;
 LD   bool 0       ; false
 WRX  connected_to_broker
#debug_left bool connected_to_broker
#srcline 403 ;     wait_response       := false;
 LD   bool 0       ; false
 WRX  wait_response
#debug_left bool wait_response
#srcline 404 ;     ok                  := false;
 LD   bool 0       ; false
 WRX  ok
#debug_left bool ok
#srcline 405 ;     err                 := true;
 LD   bool -1       ; true
 WRX  err
#debug_left bool err
#srcline 406 ;     errCode             := MQTT_CONTROL_ERROR_CODE_BROKER_DISCONNECTED;
 LD   usint 3
 WRX  errCode
#debug_left usint errCode
#srcline 407 ;   end_if;
fbMQTTSubscriber_L6:
#srcline 410 ;END_FUNCTION_BLOCK
fbMQTTSubscriber_RET:
 ULNK
RET
E     61

; Initialize - variables
P     61
fbMQTTSubscriber__InstanceInit__:
 LINK 0
 LD   uint 1883
 WRX  brokerPort
 LD   uint 5000
 WRX  localPort
 LD   bool -1   ; true
 WRX  keepAlive
 LD   time 20000
 WRX  keepAliveInterval
 LD   time 10000
 WRX  connTimeOut
 LD   time 15000
 WRX  pingInterval
 LD   bool -1   ; true
 WRX  clientId_auto
 LD   0
 SRC  byte __Init___fbMQTTSubscriber_com_param
 LEAX byte com_param
 LD   7
 MOV  %X0
 LEAX MQTT_Comm_Init
 CAL  fbMQTT_Comm_Init__InstanceInit__
 LEAX SendTo
 CAL  fbSendTo__InstanceInit__
 LEAX RecvFrom
 CAL  fbRecvFrom__InstanceInit__
 LD   0
 SRC  byte __Init___fbMQTTSubscriber_MQTT_PROTOCOL
 LEAX byte MQTT_PROTOCOL
 LD   5
 MOV  %X0
 LD   0
 SRC  byte __Init___fbMQTTSubscriber_inDataCom_param
 LEAX byte inDataCom_param
 LD   7
 MOV  %X0
 LD   udint $FFFFFFFF    ; nil
 WRX  messageIDpubAck_ptr
 ULNK
RET
E     61
; End initialize - variables
#endpou 

#pou fbMQTTSubscriberEx
#srcline 413 ;FUNCTION_BLOCK fbMQTTSubscriberEx
#table byte __Init___fbMQTTSubscriberEx_com_param = 
      0,  0,  1, 10;
#table byte __Init___fbMQTTSubscriberEx_MQTT_PROTOCOL = 
    'M','Q','T','T';
#table byte __Init___fbMQTTSubscriberEx_inDataCom_param = 
      0,  0,  1, 10;

#struct fbMQTTSubscriberEx__temp__
  string[42] PS0__st__,
  string[42] PSC__st__
#data byte _str_fbMQTTSubscriberEx_0 = 
  '',0
#data byte _str_fbMQTTSubscriberEx_1 = 
  '',0
P     61
fbMQTTSubscriberEx_L0:
 LINK __SizeOf(fbMQTTSubscriberEx__temp__)
; R_EDGE, F_EDGE 
 LDX  subRq
 LETX __EDGE_R__subRq
 WRX  subRq
 LDX  unSubRq
 LETX __EDGE_R__unSubRq
 WRX  unSubRq
#srcline 518 ;  dataRec := false;
 LD   bool 0       ; false
 WRX  dataRec
#debug_left bool dataRec
#srcline 519 ;  err     := false;
 LD   bool 0       ; false
 WRX  err
#debug_left bool err
#srcline 520 ;  if MQTT_com_responce_timeout.Q then
 LDX  MQTT_com_responce_timeout~Q
#debug bool MQTT_com_responce_timeout.Q
 JMC  fbMQTTSubscriberEx_L1
#srcline 521 ;      if responce_recived = false then
 LDX  responce_recived
#debug bool responce_recived
 LD   bool 0       ; false
 XOR
 NEG
 JMC  fbMQTTSubscriberEx_L3
#srcline 522 ;          connected_to_broker := false;
 LD   bool 0       ; false
 WRX  connected_to_broker
#debug_left bool connected_to_broker
#srcline 523 ;      end_if;
fbMQTTSubscriberEx_L3:
#srcline 524 ;      wait_response := false;
 LD   bool 0       ; false
 WRX  wait_response
#debug_left bool wait_response
#srcline 525 ;      busy := false;
 LD   bool 0       ; false
 WRX  busy
#debug_left bool busy
#srcline 526 ;      ok   := false;
 LD   bool 0       ; false
 WRX  ok
#debug_left bool ok
#srcline 527 ;      err  := true;
 LD   bool -1       ; true
 WRX  err
#debug_left bool err
#srcline 528 ;      errCode := MQTT_CONTROL_ERROR_CODE_BROKER_ANSWER_TIME_OUT;
 LD   usint 1
 WRX  errCode
#debug_left usint errCode
#srcline 529 ;  end_if;
fbMQTTSubscriberEx_L1:
#srcline 530 ;  local_port := localPort + localPortExtension;
 LDX  localPort
#debug uint localPort
 LDX  localPortExtension
#debug uint localPortExtension
 ADD
 AND  $FFFF
 WRX  local_port
#debug_left uint local_port
#srcline 531 ;  MQTT_Comm_Init( connect := connect, chanCode := chanCode, remoteIP := brokerIP, remotePort := brokerPort, localPort := localPort + localPortExtension,
 LDX  connect
#debug bool connect
 WRX  MQTT_Comm_Init~connect
#debug_left bool MQTT_Comm_Init~connect
 LDX  chanCode
#debug uint chanCode
 WRX  MQTT_Comm_Init~chanCode
#debug_left uint MQTT_Comm_Init~chanCode
 LEAX brokerIP
#debug pointer brokerIP
 SRC  %IB0
 LEAX MQTT_Comm_Init~remoteIP
 LD   4   ;SizeOf() 
 MOV  %IB0
 LDX  brokerPort
#debug uint brokerPort
 WRX  MQTT_Comm_Init~remotePort
#debug_left uint MQTT_Comm_Init~remotePort
 LDX  localPort
#debug uint localPort
 LDX  localPortExtension
#debug uint localPortExtension
 ADD
 AND  $FFFF
 WRX  MQTT_Comm_Init~localPort
#debug_left uint MQTT_Comm_Init~localPort
#srcline 532 ;                  status       => conn_status);
 LEAX MQTT_Comm_Init
 CAL  fbMQTT_Comm_Init_L0
; output assigment 
 LDX  MQTT_Comm_Init~status
#debug bool MQTT_Comm_Init~status
 WRX  conn_status
#debug_left bool conn_status
#srcline 534 ;   MQTT_com_responce_timeout(IN := wait_response,PT := connTimeOut);
 LDX  wait_response
#debug bool wait_response
 WRX  MQTT_com_responce_timeout~IN
#debug_left bool MQTT_com_responce_timeout~IN
 LDX  connTimeOut
#debug time connTimeOut
 WRX  MQTT_com_responce_timeout~PT
#debug_left time MQTT_com_responce_timeout~PT
 LEAX MQTT_com_responce_timeout
 CAL  TON_L0
#srcline 535 ;   MQTT_ping_timer(IN := connect AND keepAlive, PT := pingInterval);
 LDX  connect
#debug bool connect
 LDX  keepAlive
#debug bool keepAlive
 AND
 WRX  MQTT_ping_timer~IN
#debug_left bool MQTT_ping_timer~IN
 LDX  pingInterval
#debug time pingInterval
 WRX  MQTT_ping_timer~PT
#debug_left time MQTT_ping_timer~PT
 LEAX MQTT_ping_timer
 CAL  fbTick_L0
#srcline 536 ;   MQTT_com_intervat(IN := connect, PT := T#5s);
 LDX  connect
#debug bool connect
 WRX  MQTT_com_intervat~IN
#debug_left bool MQTT_com_intervat~IN
 LD   time 5000
 WRX  MQTT_com_intervat~PT
#debug_left time MQTT_com_intervat~PT
 LEAX MQTT_com_intervat
 CAL  fbTick_L0
#srcline 538 ;   if connect then
 LDX  connect
#debug bool connect
 JMC  fbMQTTSubscriberEx_L5
#srcline 539 ;       if MQTT_com_intervat.Q OR subRq OR unSubRq OR pubAckRq OR pubRecRq OR pubCompRq then
 LDX  MQTT_com_intervat~Q
#debug bool MQTT_com_intervat.Q
 LDX  subRq
#debug bool subRq
 OR  
 LDX  unSubRq
#debug bool unSubRq
 OR  
 LDX  pubAckRq
#debug bool pubAckRq
 OR  
 LDX  pubRecRq
#debug bool pubRecRq
 OR  
 LDX  pubCompRq
#debug bool pubCompRq
 OR  
 JMC  fbMQTTSubscriberEx_L7
#srcline 540 ;           if connected_to_broker = false then
 LDX  connected_to_broker
#debug bool connected_to_broker
 LD   bool 0       ; false
 XOR
 NEG
 JMC  fbMQTTSubscriberEx_L9
#srcline 541 ;                 if clientId_auto then
 LDX  clientId_auto
#debug bool clientId_auto
 JMC  fbMQTTSubscriberEx_L11
#srcline 542 ;                     client_id := DWORD_TO_STRING(DT_TO_DWORD(GetRTC())) + UINT_TO_STRING(MSEC_OF_DT(GetRTC()));
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   40
 DST    ; Level 1
 LD   0   ; null string
 WRY  PSC__st__[0]
 LEAY PSC__st__[0]
 LD   40
 DST    ; Level 2
 LEA  __Instance__GetRTC
 CAL  GetRTC_L0
 RNDD
 UDFL
 SCNV $2C30;  IEC_DWORD _TO_ IEC_STRING
 PDST   ; Level 2
 LEAY PSC__st__[0]

 SCON 
 LD   0   ; null string
 WRY  PSC__st__[0]
 LEAY PSC__st__[0]
 LD   40
 DST    ; Level 2
 NXT
 LEA  __Instance__GetRTC
 CAL  GetRTC_L0
 WR   __Instance__MSEC_OF_DT~in
#debug_left dt __Instance__MSEC_OF_DT~in
 PRV
 LEA  __Instance__MSEC_OF_DT
 CAL  MSEC_OF_DT_L0
 SCNV $0A30;  IEC_UINT _TO_ IEC_STRING
 PDST   ; Level 2
 LEAY PSC__st__[0]

 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX client_id
 WRI  
 LEAX client_id
 LD   40
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string client_id
 PDST   ; Level 1
#srcline 543 ;                 else
 JMP  fbMQTTSubscriberEx_L12
fbMQTTSubscriberEx_L11:
#srcline 544 ;                     client_id := clientId;
 LD   0   ; null string
 LEAX client_id
 WRI  
 LEAX client_id
 LD   40
 DST    ; Level 1
 LEAX clientId
#debug string clientId
 SCON 
#debug_left string client_id
 PDST   ; Level 1
#srcline 545 ;                 end_if;
fbMQTTSubscriberEx_L12:
#srcline 547 ;                // Fixed header of control packet
#srcline 548 ;                // Fixed header
#srcline 549 ;                txData[0] := MQTT_CONTROL_PACK_CONNECT; // flag bits are cleared
 LD   usint 16
 WRX  txData[0]
#debug_left usint txData[0]
#srcline 550 ;                // Variable header
#srcline 551 ;                txData[2] := 0;
 LD   usint 0
 WRX  txData[2]
#debug_left usint txData[2]
#srcline 552 ;                txData[3] := 4;
 LD   usint 4
 WRX  txData[3]
#debug_left usint txData[3]
#srcline 553 ;                MemcpyPtr(source := ADR(MQTT_PROTOCOL),dest := ADR(txData[4]),length := 4);
 NXT
 LEAX MQTT_PROTOCOL
#debug pointer MQTT_PROTOCOL
 LEA  __Instance__MemcpyPtr~source
 WRIL 
#debug_left udint __Instance__MemcpyPtr~source
 LEAX txData
 ADD  4  ; + offset 
#debug pointer txData[4]
 LEA  __Instance__MemcpyPtr~dest
 WRIL 
#debug_left udint __Instance__MemcpyPtr~dest
 LD   udint 4
 WR   __Instance__MemcpyPtr~length
#debug_left udint __Instance__MemcpyPtr~length
 PRV
 LEA  __Instance__MemcpyPtr
 CAL  MemcpyPtr_L0
#srcline 554 ;                txData[8]   := MQTT_PROTOCOL_VERSION;
 LD   usint 4
 WRX  txData[8]
#debug_left usint txData[8]
#srcline 555 ;                // Protocol Level byte
#srcline 556 ;                //Set connection flags
#srcline 557 ;                connectFlags := 0;
 LD   byte 0
 WRX  connectFlags
#debug_left byte connectFlags
#srcline 558 ;                if loginName <> ''        then connectFlags := 16#80; end_if;
 LEAX loginName
#debug string loginName
 LEA  _str_fbMQTTSubscriberEx_0
 SCMP 
 EQ   0
 NEG
 JMC  fbMQTTSubscriberEx_L13
 LD   byte $80
 WRX  connectFlags
#debug_left byte connectFlags
fbMQTTSubscriberEx_L13:
#srcline 559 ;                if loginPass <> ''        then connectFlags := connectFlags OR 16#40; end_if;
 LEAX loginPass
#debug string loginPass
 LEA  _str_fbMQTTSubscriberEx_1
 SCMP 
 EQ   0
 NEG
 JMC  fbMQTTSubscriberEx_L15
 LDX  connectFlags
#debug byte connectFlags
 LD   byte $40
 OR  
 WRX  connectFlags
#debug_left byte connectFlags
fbMQTTSubscriberEx_L15:
#srcline 560 ;               // if com_param.willRetain   then connectFlags := connectFlags OR 16#20; end_if;
#srcline 561 ;               // connectFlags := connectFlags OR SHL(IN := USINT_TO_BYTE(com_param.qos),N := 3);
#srcline 562 ;                if com_param.cleanSession then connectFlags := connectFlags OR 16#2;  end_if;
 LDX  com_param~cleanSession
#debug bool com_param.cleanSession
 JMC  fbMQTTSubscriberEx_L17
 LDX  connectFlags
#debug byte connectFlags
 LD   byte $2
 OR  
 WRX  connectFlags
#debug_left byte connectFlags
fbMQTTSubscriberEx_L17:
#srcline 564 ;                txData[9]   := BYTE_TO_USINT(connectFlags);//For connect set clean session
 LDX  connectFlags
#debug byte connectFlags
 WRX  txData[9]
#debug_left usint txData[9]
#srcline 565 ;                //keep alive 2 bytes, MSB+LSB
#srcline 566 ;                aliveTime := TIME_TO_UINT(keepAliveInterval)/1000;
 LDX  keepAliveInterval
#debug time keepAliveInterval
AND  $FFFF
 LD   uint 1000
 DIVL
 AND  $FFFF
 WRX  aliveTime
#debug_left uint aliveTime
#srcline 568 ;                txData[10]  := 0;
 LD   usint 0
 WRX  txData[10]
#debug_left usint txData[10]
#srcline 569 ;                txData[11]  := UINT_TO_USINT(aliveTime);
 LDX  aliveTime
#debug uint aliveTime
 AND  $FF
 WRX  txData[11]
#debug_left usint txData[11]
#srcline 570 ;                
#srcline 571 ;                payloadLength1 := LEN(IN := client_id);
 LEAX client_id
#debug string client_id
 SLEN 
 WRX  payloadLength1
#debug_left uint payloadLength1
#srcline 572 ;                txData[12]  := WORD_TO_USINT(SHR(IN := UINT_TO_WORD(payloadLength1),N := 8));
 LDX  payloadLength1
#debug uint payloadLength1
 LD   uint 8
 SHR
 AND  $FFFF
 AND  $FF
 WRX  txData[12]
#debug_left usint txData[12]
#srcline 573 ;                txData[13]  := UINT_TO_USINT(payloadLength1);
 LDX  payloadLength1
#debug uint payloadLength1
 AND  $FF
 WRX  txData[13]
#debug_left usint txData[13]
#srcline 577 ;                txMsgLength := 14;
 LD   uint 14
 WRX  txMsgLength
#debug_left uint txMsgLength
#srcline 578 ;                //Copy client ID
#srcline 579 ;                MemcpyPtr(source := ADR(client_id),dest := ADR(txData[14]),length := UINT_TO_UDINT(payloadLength1));
 NXT
 LEAX client_id
#debug pointer client_id
 LEA  __Instance__MemcpyPtr~source
 WRIL 
#debug_left udint __Instance__MemcpyPtr~source
 LEAX txData
 ADD  14  ; + offset 
#debug pointer txData[14]
 LEA  __Instance__MemcpyPtr~dest
 WRIL 
#debug_left udint __Instance__MemcpyPtr~dest
 LDX  payloadLength1
#debug uint payloadLength1
 WR   __Instance__MemcpyPtr~length
#debug_left udint __Instance__MemcpyPtr~length
 PRV
 LEA  __Instance__MemcpyPtr
 CAL  MemcpyPtr_L0
#srcline 580 ;                txMsgLength := txMsgLength + payloadLength1;
 LDX  txMsgLength
#debug uint txMsgLength
 LDX  payloadLength1
#debug uint payloadLength1
 ADD
 AND  $FFFF
 WRX  txMsgLength
#debug_left uint txMsgLength
#srcline 581 ;                //Copy user name
#srcline 582 ;                if (connectFlags AND 16#80) > 0 then
 LDX  connectFlags
#debug byte connectFlags
 LD   byte $80
 AND
 LD   byte 0
 GT
 JMC  fbMQTTSubscriberEx_L19
#srcline 583 ;                     txData[txMsgLength]     := 0;
 LD   usint 0
 LEAX txData
 LDX  txMsgLength
#debug uint txMsgLength
 RCHK 100   ; Range Check
 ADD     ; + offset 
 WRI 
#debug_left usint txData[txMsgLength]
#srcline 584 ;                     txData[txMsgLength + 1] := LEN(IN := loginName);
 LEAX loginName
#debug string loginName
 SLEN 
 LEAX txData
 LDX  txMsgLength
#debug uint txMsgLength
 LD   uint 1
 ADD
 AND  $FFFF
 RCHK 100   ; Range Check
 ADD     ; + offset 
 WRI 
#debug_left usint txData[txMsgLength+1]
#srcline 585 ;                     payloadLength := LEN(IN := loginName);
 LEAX loginName
#debug string loginName
 SLEN 
 WRX  payloadLength
#debug_left uint payloadLength
#srcline 586 ;                     MemcpyPtr(source := ADR(loginName),dest := ADR(txData[txMsgLength + 2]),length := UINT_TO_UDINT(payloadLength));
 NXT
 LEAX loginName
#debug pointer loginName
 LEA  __Instance__MemcpyPtr~source
 WRIL 
#debug_left udint __Instance__MemcpyPtr~source
 LEAX txData
 LDX  txMsgLength
#debug uint txMsgLength
 LD   uint 2
 ADD
 AND  $FFFF
 RCHK 100   ; Range Check
 ADD     ; + offset 
#debug pointer txData[txMsgLength+2]
 LEA  __Instance__MemcpyPtr~dest
 WRIL 
#debug_left udint __Instance__MemcpyPtr~dest
 LDX  payloadLength
#debug uint payloadLength
 WR   __Instance__MemcpyPtr~length
#debug_left udint __Instance__MemcpyPtr~length
 PRV
 LEA  __Instance__MemcpyPtr
 CAL  MemcpyPtr_L0
#srcline 587 ;                     txMsgLength := txMsgLength + payloadLength + 2;
 LDX  txMsgLength
#debug uint txMsgLength
 LDX  payloadLength
#debug uint payloadLength
 ADD
 AND  $FFFF
 LD   uint 2
 ADD
 AND  $FFFF
 WRX  txMsgLength
#debug_left uint txMsgLength
#srcline 588 ;                end_if;
fbMQTTSubscriberEx_L19:
#srcline 589 ;                //Copy password
#srcline 590 ;                if (connectFlags AND 16#40) > 0 then
 LDX  connectFlags
#debug byte connectFlags
 LD   byte $40
 AND
 LD   byte 0
 GT
 JMC  fbMQTTSubscriberEx_L21
#srcline 591 ;                     txData[txMsgLength]     := 0;
 LD   usint 0
 LEAX txData
 LDX  txMsgLength
#debug uint txMsgLength
 RCHK 100   ; Range Check
 ADD     ; + offset 
 WRI 
#debug_left usint txData[txMsgLength]
#srcline 592 ;                     txData[txMsgLength + 1] := LEN(IN := loginPass);
 LEAX loginPass
#debug string loginPass
 SLEN 
 LEAX txData
 LDX  txMsgLength
#debug uint txMsgLength
 LD   uint 1
 ADD
 AND  $FFFF
 RCHK 100   ; Range Check
 ADD     ; + offset 
 WRI 
#debug_left usint txData[txMsgLength+1]
#srcline 593 ;                     payloadLength := LEN(IN := loginPass);
 LEAX loginPass
#debug string loginPass
 SLEN 
 WRX  payloadLength
#debug_left uint payloadLength
#srcline 594 ;                     MemcpyPtr(source := ADR(loginPass),dest := ADR(txData[txMsgLength + 2]),length := UINT_TO_UDINT(payloadLength));
 NXT
 LEAX loginPass
#debug pointer loginPass
 LEA  __Instance__MemcpyPtr~source
 WRIL 
#debug_left udint __Instance__MemcpyPtr~source
 LEAX txData
 LDX  txMsgLength
#debug uint txMsgLength
 LD   uint 2
 ADD
 AND  $FFFF
 RCHK 100   ; Range Check
 ADD     ; + offset 
#debug pointer txData[txMsgLength+2]
 LEA  __Instance__MemcpyPtr~dest
 WRIL 
#debug_left udint __Instance__MemcpyPtr~dest
 LDX  payloadLength
#debug uint payloadLength
 WR   __Instance__MemcpyPtr~length
#debug_left udint __Instance__MemcpyPtr~length
 PRV
 LEA  __Instance__MemcpyPtr
 CAL  MemcpyPtr_L0
#srcline 595 ;                     txMsgLength := txMsgLength + payloadLength + 2;
 LDX  txMsgLength
#debug uint txMsgLength
 LDX  payloadLength
#debug uint payloadLength
 ADD
 AND  $FFFF
 LD   uint 2
 ADD
 AND  $FFFF
 WRX  txMsgLength
#debug_left uint txMsgLength
#srcline 596 ;                end_if;
fbMQTTSubscriberEx_L21:
#srcline 598 ;                // length of package
#srcline 599 ;                 txData[1]       := UINT_TO_USINT(txMsgLength - 2);
 LDX  txMsgLength
#debug uint txMsgLength
 LD   uint 2
 SUB
 AND  $FFFF
 AND  $FF
 WRX  txData[1]
#debug_left usint txData[1]
#srcline 601 ;                tx_data_request    := true;
 LD   bool -1       ; true
 WRX  tx_data_request
#debug_left bool tx_data_request
#srcline 602 ;                localPortExtension := USINT_TO_UINT(reconnect_counter);
 LDX  reconnect_counter
#debug usint reconnect_counter
 AND  $FFFF
 WRX  localPortExtension
#debug_left uint localPortExtension
#srcline 604 ;                idle_time := 2;
 LD   usint 2
 WRX  idle_time
#debug_left usint idle_time
#srcline 605 ;                // required to change port on each reconnect
#srcline 606 ;                if reconnect_counter < 100 then
 LDX  reconnect_counter
#debug usint reconnect_counter
 LD   usint 100
 LT
 JMC  fbMQTTSubscriberEx_L23
#srcline 607 ;                    reconnect_counter := reconnect_counter + 1; //
 LDX  reconnect_counter
#debug usint reconnect_counter
 LD   usint 1
 ADD
 AND  $FF
 WRX  reconnect_counter
#debug_left usint reconnect_counter
#srcline 608 ;                else
 JMP  fbMQTTSubscriberEx_L24
fbMQTTSubscriberEx_L23:
#srcline 609 ;                    reconnect_counter := 0;
 LD   usint 0
 WRX  reconnect_counter
#debug_left usint reconnect_counter
#srcline 610 ;                end_if;
fbMQTTSubscriberEx_L24:
#srcline 611 ;                responce_recived := false;
 LD   bool 0       ; false
 WRX  responce_recived
#debug_left bool responce_recived
#srcline 612 ;                return;
 JMP  fbMQTTSubscriberEx_RET
#srcline 613 ;           //--------- Connected to brocker -------------------
#srcline 614 ;           else
 JMP  fbMQTTSubscriberEx_L10
fbMQTTSubscriberEx_L9:
#srcline 615 ;               if subRq OR unSubRq then //Subscribe or unsubsribe command from user program
 LDX  subRq
#debug bool subRq
 LDX  unSubRq
#debug bool unSubRq
 OR  
 JMC  fbMQTTSubscriberEx_L25
#srcline 616 ;                   if subRq then
 LDX  subRq
#debug bool subRq
 JMC  fbMQTTSubscriberEx_L27
#srcline 617 ;                       txData[0] := MQTT_CONTROL_PACK_SUBSCRIBE + 2;
 LD   usint 128
 LD   usint 2
 ADD
 AND  $FF
 WRX  txData[0]
#debug_left usint txData[0]
#srcline 618 ;                   else
 JMP  fbMQTTSubscriberEx_L28
fbMQTTSubscriberEx_L27:
#srcline 619 ;                       txData[0] := MQTT_CONTROL_PACK_UNSUBSCRIBE + 2;
 LD   usint 160
 LD   usint 2
 ADD
 AND  $FF
 WRX  txData[0]
#debug_left usint txData[0]
#srcline 620 ;                   end_if;
fbMQTTSubscriberEx_L28:
#srcline 621 ;                   //The variable header contains a Packet Identifier
#srcline 622 ;                   txData[2]        := WORD_TO_USINT(SHR(IN := UINT_TO_WORD(messageID), N := 8));
 LDX  messageID
#debug uint messageID
 LD   uint 8
 SHR
 AND  $FFFF
 AND  $FF
 WRX  txData[2]
#debug_left usint txData[2]
#srcline 623 ;                   txData[3]        := UINT_TO_USINT(messageID);
 LDX  messageID
#debug uint messageID
 AND  $FF
 WRX  txData[3]
#debug_left usint txData[3]
#srcline 625 ;                   // Payload
#srcline 626 ;                   payloadLength := LEN(IN := topicTxt);
 LEAX topicTxt
#debug string topicTxt
 SLEN 
 WRX  payloadLength
#debug_left uint payloadLength
#srcline 628 ;                   txData[4] := WORD_TO_USINT(SHR(IN := UINT_TO_WORD(payloadLength),N := 8));
 LDX  payloadLength
#debug uint payloadLength
 LD   uint 8
 SHR
 AND  $FFFF
 AND  $FF
 WRX  txData[4]
#debug_left usint txData[4]
#srcline 629 ;                   txData[5] := UINT_TO_USINT(payloadLength);
 LDX  payloadLength
#debug uint payloadLength
 AND  $FF
 WRX  txData[5]
#debug_left usint txData[5]
#srcline 631 ;                   MemcpyPtr(source := ADR(topicTxt),dest := ADR(txData[6]),length := UINT_TO_UDINT(payloadLength));
 NXT
 LEAX topicTxt
#debug pointer topicTxt
 LEA  __Instance__MemcpyPtr~source
 WRIL 
#debug_left udint __Instance__MemcpyPtr~source
 LEAX txData
 ADD  6  ; + offset 
#debug pointer txData[6]
 LEA  __Instance__MemcpyPtr~dest
 WRIL 
#debug_left udint __Instance__MemcpyPtr~dest
 LDX  payloadLength
#debug uint payloadLength
 WR   __Instance__MemcpyPtr~length
#debug_left udint __Instance__MemcpyPtr~length
 PRV
 LEA  __Instance__MemcpyPtr
 CAL  MemcpyPtr_L0
#srcline 632 ;                   txMsgLength := payloadLength + 4;
 LDX  payloadLength
#debug uint payloadLength
 LD   uint 4
 ADD
 AND  $FFFF
 WRX  txMsgLength
#debug_left uint txMsgLength
#srcline 633 ;                   if subRq then
 LDX  subRq
#debug bool subRq
 JMC  fbMQTTSubscriberEx_L29
#srcline 634 ;                       txData[txMsgLength + 2] := com_param.qos;
 LDX  com_param~qos
#debug usint com_param.qos
 LEAX txData
 LDX  txMsgLength
#debug uint txMsgLength
 LD   uint 2
 ADD
 AND  $FFFF
 RCHK 100   ; Range Check
 ADD     ; + offset 
 WRI 
#debug_left usint txData[txMsgLength+2]
#srcline 635 ;                       txMsgLength := txMsgLength + 1;
 LDX  txMsgLength
#debug uint txMsgLength
 LD   uint 1
 ADD
 AND  $FFFF
 WRX  txMsgLength
#debug_left uint txMsgLength
#srcline 636 ;                   end_if;
fbMQTTSubscriberEx_L29:
#srcline 638 ;                   txData[1]        := UINT_TO_USINT(txMsgLength);
 LDX  txMsgLength
#debug uint txMsgLength
 AND  $FF
 WRX  txData[1]
#debug_left usint txData[1]
#srcline 639 ;                   txMsgLength      := txMsgLength + 2;
 LDX  txMsgLength
#debug uint txMsgLength
 LD   uint 2
 ADD
 AND  $FFFF
 WRX  txMsgLength
#debug_left uint txMsgLength
#srcline 640 ;                   tx_data_request  := true;
 LD   bool -1       ; true
 WRX  tx_data_request
#debug_left bool tx_data_request
#srcline 642 ;                   busy    := true;
 LD   bool -1       ; true
 WRX  busy
#debug_left bool busy
#srcline 643 ;                   ok      := false;
 LD   bool 0       ; false
 WRX  ok
#debug_left bool ok
#srcline 644 ;                   err     := false;
 LD   bool 0       ; false
 WRX  err
#debug_left bool err
#srcline 645 ;                   errCode := MQTT_CONTROL_ERROR_CODE_OK;
 LD   usint 0
 WRX  errCode
#debug_left usint errCode
#srcline 647 ;                   subRq   := false;
 LD   bool 0       ; false
 WRX  subRq
#debug_left bool subRq
#srcline 648 ;                   unSubRq := false;
 LD   bool 0       ; false
 WRX  unSubRq
#debug_left bool unSubRq
#srcline 649 ;               end_if;
fbMQTTSubscriberEx_L25:
#srcline 651 ;               if pubAckRq OR pubRecRq OR pubCompRq then
 LDX  pubAckRq
#debug bool pubAckRq
 LDX  pubRecRq
#debug bool pubRecRq
 OR  
 LDX  pubCompRq
#debug bool pubCompRq
 OR  
 JMC  fbMQTTSubscriberEx_L31
#srcline 652 ;                   if pubAckRq then
 LDX  pubAckRq
#debug bool pubAckRq
 JMC  fbMQTTSubscriberEx_L33
#srcline 653 ;                       txData[0]        := MQTT_CONTROL_PACK_PUBACK;  // Publish acknowledge                      QOS=1
 LD   usint 64
 WRX  txData[0]
#debug_left usint txData[0]
#srcline 654 ;                   elsif pubRecRq then
 JMP  fbMQTTSubscriberEx_L34
fbMQTTSubscriberEx_L33:
 LDX  pubRecRq
#debug bool pubRecRq
 JMC  fbMQTTSubscriberEx_L35
#srcline 655 ;                       txData[0]        := MQTT_CONTROL_PACK_PUBREC;  // Publish acknowledge "Publish recived"    QOS=2
 LD   usint 80
 WRX  txData[0]
#debug_left usint txData[0]
#srcline 656 ;                   else
 JMP  fbMQTTSubscriberEx_L34
fbMQTTSubscriberEx_L35:
#srcline 657 ;                       txData[0]        := MQTT_CONTROL_PACK_PUBCOMP; // Publish acknowledge "Publish completed"  QOS=2
 LD   usint 112
 WRX  txData[0]
#debug_left usint txData[0]
#srcline 658 ;                   end_if;
fbMQTTSubscriberEx_L34:
#srcline 660 ;                   txData[1]        := 2;
 LD   usint 2
 WRX  txData[1]
#debug_left usint txData[1]
#srcline 661 ;                   txData[2]        := WORD_TO_USINT(SHR(IN := UINT_TO_WORD(messageIDpubAck), N := 8));
 LDX  messageIDpubAck
#debug uint messageIDpubAck
 LD   uint 8
 SHR
 AND  $FFFF
 AND  $FF
 WRX  txData[2]
#debug_left usint txData[2]
#srcline 662 ;                   txData[3]        := UINT_TO_USINT(messageIDpubAck);
 LDX  messageIDpubAck
#debug uint messageIDpubAck
 AND  $FF
 WRX  txData[3]
#debug_left usint txData[3]
#srcline 663 ;                   txMsgLength      := 4;
 LD   uint 4
 WRX  txMsgLength
#debug_left uint txMsgLength
#srcline 664 ;                   tx_data_request  := true;
 LD   bool -1       ; true
 WRX  tx_data_request
#debug_left bool tx_data_request
#srcline 665 ;                   busy             := false;
 LD   bool 0       ; false
 WRX  busy
#debug_left bool busy
#srcline 666 ;                   ok               := true;
 LD   bool -1       ; true
 WRX  ok
#debug_left bool ok
#srcline 667 ;                   err              := false;
 LD   bool 0       ; false
 WRX  err
#debug_left bool err
#srcline 668 ;                   errCode          := MQTT_CONTROL_ERROR_CODE_OK;
 LD   usint 0
 WRX  errCode
#debug_left usint errCode
#srcline 670 ;                   pubAckRq         := false;
 LD   bool 0       ; false
 WRX  pubAckRq
#debug_left bool pubAckRq
#srcline 671 ;                   pubRecRq         := false;
 LD   bool 0       ; false
 WRX  pubRecRq
#debug_left bool pubRecRq
#srcline 672 ;                   pubCompRq        := false;
 LD   bool 0       ; false
 WRX  pubCompRq
#debug_left bool pubCompRq
#srcline 673 ;                   return;
 JMP  fbMQTTSubscriberEx_RET
#srcline 674 ;               end_if;
fbMQTTSubscriberEx_L31:
#srcline 676 ;                //---------------------------------------------
#srcline 677 ;                if MQTT_ping_timer.Q then
 LDX  MQTT_ping_timer~Q
#debug bool MQTT_ping_timer.Q
 JMC  fbMQTTSubscriberEx_L36
#srcline 678 ;                    //Ping request
#srcline 679 ;                     txData[0]        := MQTT_CONTROL_PACK_PINGREQ; // flag bits are cleared
 LD   usint 192
 WRX  txData[0]
#debug_left usint txData[0]
#srcline 680 ;                     txData[1]        := 0;
 LD   usint 0
 WRX  txData[1]
#debug_left usint txData[1]
#srcline 681 ;                     txMsgLength      := 2;
 LD   uint 2
 WRX  txMsgLength
#debug_left uint txMsgLength
#srcline 682 ;                     tx_data_request  := true;
 LD   bool -1       ; true
 WRX  tx_data_request
#debug_left bool tx_data_request
#srcline 683 ;                     responce_recived := false;
 LD   bool 0       ; false
 WRX  responce_recived
#debug_left bool responce_recived
#srcline 684 ;                     busy             := false;
 LD   bool 0       ; false
 WRX  busy
#debug_left bool busy
#srcline 685 ;                     ok               := true;
 LD   bool -1       ; true
 WRX  ok
#debug_left bool ok
#srcline 686 ;                     err              := false;
 LD   bool 0       ; false
 WRX  err
#debug_left bool err
#srcline 687 ;                     errCode          := MQTT_CONTROL_ERROR_CODE_OK;
 LD   usint 0
 WRX  errCode
#debug_left usint errCode
#srcline 688 ;                     return;
 JMP  fbMQTTSubscriberEx_RET
#srcline 689 ;                end_if;
fbMQTTSubscriberEx_L36:
#srcline 690 ;           end_if;
fbMQTTSubscriberEx_L10:
#srcline 691 ;       end_if;
fbMQTTSubscriberEx_L7:
#srcline 693 ;      if conn_status then
 LDX  conn_status
#debug bool conn_status
 JMC  fbMQTTSubscriberEx_L38
#srcline 694 ;          SendTo( rq := tx_data_request, chanCode := chanCode, lenTx := txMsgLength , data := void(txData));
 LDX  tx_data_request
#debug bool tx_data_request
 WRX  SendTo~rq
#debug_left bool SendTo~rq
 LDX  chanCode
#debug uint chanCode
 WRX  SendTo~chanCode
#debug_left uint SendTo~chanCode
 LDX  txMsgLength
#debug uint txMsgLength
 WRX  SendTo~lenTx
#debug_left uint SendTo~lenTx
 LEAX txData
 WRX  SendTo~data
#debug_left pointer SendTo.data
 LEAX SendTo
 CAL  fbSendTo_L0
#srcline 695 ;          if SendTo.mesSent then
 LDX  SendTo~mesSent
#debug bool SendTo.mesSent
 JMC  fbMQTTSubscriberEx_L40
#srcline 696 ;              tx_data_request := false;
 LD   bool 0       ; false
 WRX  tx_data_request
#debug_left bool tx_data_request
#srcline 697 ;              txCounter := txCounter + 1;
 LDX  txCounter
#debug uint txCounter
 LD   uint 1
 ADD
 AND  $FFFF
 WRX  txCounter
#debug_left uint txCounter
#srcline 698 ;              messageID := messageID + 1;
 LDX  messageID
#debug uint messageID
 LD   uint 1
 ADD
 AND  $FFFF
 WRX  messageID
#debug_left uint messageID
#srcline 699 ;              if com_param.qos = 1 then wait_response := true; end_if;
 LDX  com_param~qos
#debug usint com_param.qos
 LD   usint 1
 EQ
 JMC  fbMQTTSubscriberEx_L42
 LD   bool -1       ; true
 WRX  wait_response
#debug_left bool wait_response
fbMQTTSubscriberEx_L42:
#srcline 700 ;          end_if;
fbMQTTSubscriberEx_L40:
#srcline 702 ;          RecvFrom( rq := true, chanCode := chanCode, lenRx := 512, data := void(rxData));
 LD   bool -1       ; true
 WRX  RecvFrom~rq
#debug_left bool RecvFrom~rq
 LDX  chanCode
#debug uint chanCode
 WRX  RecvFrom~chanCode
#debug_left uint RecvFrom~chanCode
 LD   uint 512
 WRX  RecvFrom~lenRx
#debug_left uint RecvFrom~lenRx
 LEAX rxData
 WRX  RecvFrom~data
#debug_left pointer RecvFrom.data
 LEAX RecvFrom
 CAL  fbRecvFrom_L0
#srcline 704 ;          if RecvFrom.mesRec then
 LDX  RecvFrom~mesRec
#debug bool RecvFrom.mesRec
 JMC  fbMQTTSubscriberEx_L44
#srcline 705 ;              if RecvFrom.error = 0 then
 LDX  RecvFrom~error
#debug usint RecvFrom.error
 LD   usint 0
 EQ
 JMC  fbMQTTSubscriberEx_L46
#srcline 706 ;                   busy     := false;
 LD   bool 0       ; false
 WRX  busy
#debug_left bool busy
#srcline 707 ;                   ok       := true;
 LD   bool -1       ; true
 WRX  ok
#debug_left bool ok
#srcline 708 ;                   err      := false;
 LD   bool 0       ; false
 WRX  err
#debug_left bool err
#srcline 709 ;                   errCode  := MQTT_CONTROL_ERROR_CODE_OK;
 LD   usint 0
 WRX  errCode
#debug_left usint errCode
#srcline 711 ;                  if RecvFrom.lenData = 4  AND rxData[0] = MQTT_CONTROL_PACK_CONNACK THEN
 LDX  RecvFrom~lenData
#debug uint RecvFrom.lenData
 LD   uint 4
 EQ
 LDX  rxData[0]
#debug usint rxData[0]
 LD   usint 32
 EQ
 AND
 JMC  fbMQTTSubscriberEx_L48
#srcline 712 ;                       responce_recived     := true;
 LD   bool -1       ; true
 WRX  responce_recived
#debug_left bool responce_recived
#srcline 713 ;                       wait_response        := false;
 LD   bool 0       ; false
 WRX  wait_response
#debug_left bool wait_response
#srcline 714 ;                       if rxData[3] = 0 then
 LDX  rxData[3]
#debug usint rxData[3]
 LD   usint 0
 EQ
 JMC  fbMQTTSubscriberEx_L50
#srcline 715 ;                           connected_to_broker  := true;
 LD   bool -1       ; true
 WRX  connected_to_broker
#debug_left bool connected_to_broker
#srcline 716 ;                       else
 JMP  fbMQTTSubscriberEx_L51
fbMQTTSubscriberEx_L50:
#srcline 717 ;                           connected_to_broker  := false;
 LD   bool 0       ; false
 WRX  connected_to_broker
#debug_left bool connected_to_broker
#srcline 718 ;                           ok                   := false;
 LD   bool 0       ; false
 WRX  ok
#debug_left bool ok
#srcline 719 ;                           err                  := true;
 LD   bool -1       ; true
 WRX  err
#debug_left bool err
#srcline 720 ;                           errCode              := MQTT_CONTROL_ERROR_CODE_LOGIN_FAILED;
 LD   usint 5
 WRX  errCode
#debug_left usint errCode
#srcline 721 ;                       end_if;
fbMQTTSubscriberEx_L51:
#srcline 722 ;                  elsif (RecvFrom.lenData = 4  AND  rxData[0] = MQTT_CONTROL_PACK_UNSUBACK) OR  // responce to connect command
 JMP  fbMQTTSubscriberEx_L49
fbMQTTSubscriberEx_L48:
 LDX  RecvFrom~lenData
#debug uint RecvFrom.lenData
 LD   uint 4
 EQ
 LDX  rxData[0]
#debug usint rxData[0]
 LD   usint 176
 EQ
 AND
#srcline 723 ;                         RecvFrom.lenData = 2  AND  rxData[0] = MQTT_CONTROL_PACK_PINGRESP  then
 LDX  RecvFrom~lenData
#debug uint RecvFrom.lenData
 LD   uint 2
 EQ
 LDX  rxData[0]
#debug usint rxData[0]
 LD   usint 208
 EQ
 AND
 OR  
 JMC  fbMQTTSubscriberEx_L52
#srcline 724 ;                          connected_to_broker  := true;
 LD   bool -1       ; true
 WRX  connected_to_broker
#debug_left bool connected_to_broker
#srcline 725 ;                          responce_recived     := true;
 LD   bool -1       ; true
 WRX  responce_recived
#debug_left bool responce_recived
#srcline 726 ;                          wait_response        := false;
 LD   bool 0       ; false
 WRX  wait_response
#debug_left bool wait_response
#srcline 727 ;                  elsif (RecvFrom.lenData = 4  AND (AND(IN1 := USINT_TO_BYTE(rxData[0]),IN2 := USINT_TO_BYTE(MQTT_CONTROL_PACK_PUBREL)) = USINT_TO_BYTE(MQTT_CONTROL_PACK_PUBREL))) then
 JMP  fbMQTTSubscriberEx_L49
fbMQTTSubscriberEx_L52:
 LDX  RecvFrom~lenData
#debug uint RecvFrom.lenData
 LD   uint 4
 EQ
 LDX  rxData[0]
#debug usint rxData[0]
 AND  $FF
 LD   usint 96
 AND  $FF
 AND
 LD   usint 96
 AND  $FF
 EQ
 AND
 JMC  fbMQTTSubscriberEx_L53
#srcline 728 ;                          pubCompRq           := true;
 LD   bool -1       ; true
 WRX  pubCompRq
#debug_left bool pubCompRq
#srcline 729 ;                          connected_to_broker := true;
 LD   bool -1       ; true
 WRX  connected_to_broker
#debug_left bool connected_to_broker
#srcline 730 ;                          responce_recived    := true;
 LD   bool -1       ; true
 WRX  responce_recived
#debug_left bool responce_recived
#srcline 731 ;                          wait_response       := false;
 LD   bool 0       ; false
 WRX  wait_response
#debug_left bool wait_response
#srcline 733 ;                          messageIDpubAck_ptr := ADR(rxData[2]);
 LEAX rxData
 ADD  2  ; + offset 
#debug pointer rxData[2]
 LEAX messageIDpubAck_ptr
 WRIL 
#debug_left pointer messageIDpubAck_ptr
#srcline 734 ;                          messageIDpubAck     := fSwapUINT(messageIDpubAck_ptr^);
 NXT
 LEAX messageIDpubAck_ptr
 LDIL    ; dereference 
 LDIW 
#debug uint messageIDpubAck_ptr^
 WR   __Instance__fSwapUINT~input
#debug_left uint __Instance__fSwapUINT~input
 PRV
 LEA  __Instance__fSwapUINT
 CAL  fSwapUINT_L0
 WRX  messageIDpubAck
#debug_left uint messageIDpubAck
#srcline 736 ;                  elsif RecvFrom.lenData = 5 AND rxData[0] = MQTT_CONTROL_PACK_SUBACK then // responce to subscribe command
 JMP  fbMQTTSubscriberEx_L49
fbMQTTSubscriberEx_L53:
 LDX  RecvFrom~lenData
#debug uint RecvFrom.lenData
 LD   uint 5
 EQ
 LDX  rxData[0]
#debug usint rxData[0]
 LD   usint 144
 EQ
 AND
 JMC  fbMQTTSubscriberEx_L54
#srcline 737 ;                         connected_to_broker := true;
 LD   bool -1       ; true
 WRX  connected_to_broker
#debug_left bool connected_to_broker
#srcline 738 ;                         responce_recived    := true;
 LD   bool -1       ; true
 WRX  responce_recived
#debug_left bool responce_recived
#srcline 739 ;                         wait_response       := false;
 LD   bool 0       ; false
 WRX  wait_response
#debug_left bool wait_response
#srcline 740 ;                         if rxData[4] = 16#80 then
 LDX  rxData[4]
#debug usint rxData[4]
 LD   usint $80
 EQ
 JMC  fbMQTTSubscriberEx_L55
#srcline 741 ;                             ok              := false;
 LD   bool 0       ; false
 WRX  ok
#debug_left bool ok
#srcline 742 ;                             err             := true;
 LD   bool -1       ; true
 WRX  err
#debug_left bool err
#srcline 743 ;                             errCode         := MQTT_CONTROL_ERROR_CODE_SUBSCRIBE_FAILED;
 LD   usint 2
 WRX  errCode
#debug_left usint errCode
#srcline 744 ;                         end_if;
fbMQTTSubscriberEx_L55:
#srcline 745 ;                  else // Incomming data from broker
 JMP  fbMQTTSubscriberEx_L49
fbMQTTSubscriberEx_L54:
#srcline 746 ;                       if  (AND(IN1 := USINT_TO_BYTE(rxData[0]),IN2 := USINT_TO_BYTE(MQTT_CONTROL_PACK_PUBLISH))) > 0 then
 LDX  rxData[0]
#debug usint rxData[0]
 AND  $FF
 LD   usint 48
 AND  $FF
 AND
 LD   byte 0
 GT
 JMC  fbMQTTSubscriberEx_L57
#srcline 747 ;                             connected_to_broker := true;
 LD   bool -1       ; true
 WRX  connected_to_broker
#debug_left bool connected_to_broker
#srcline 748 ;                             responce_recived    := true;
 LD   bool -1       ; true
 WRX  responce_recived
#debug_left bool responce_recived
#srcline 749 ;                             wait_response       := false;
 LD   bool 0       ; false
 WRX  wait_response
#debug_left bool wait_response
#srcline 751 ;                             index               := 1;
 LD   usint 1
 WRX  index
#debug_left usint index
#srcline 752 ;                             payloadLengthSize   := 0;
 LD   uint 0
 WRX  payloadLengthSize
#debug_left uint payloadLengthSize
#srcline 753 ;                             payloadLengthBytes  := 1;
 LD   uint 1
 WRX  payloadLengthBytes
#debug_left uint payloadLengthBytes
#srcline 755 ;                             while index <= 4 do
fbMQTTSubscriberEx_L59:
 LDX  index
#debug usint index
 LD   usint 4
 GT
 NEG
 JMC  fbMQTTSubscriberEx_L60
 DBG 
#srcline 756 ;                                if rxData[index] > 16#80 then
 LEAX rxData
 LDX  index
#debug usint index
 RCHK 512   ; Range Check
 ADD     ; + offset 
 LDI  
#debug usint rxData[index]
 LD   usint $80
 GT
 JMC  fbMQTTSubscriberEx_L61
#srcline 757 ;                                     payloadLengthSize := payloadLengthSize + BYTE_TO_UINT(USINT_TO_BYTE(rxData[index]) AND 16#7F);
 LDX  payloadLengthSize
#debug uint payloadLengthSize
 LEAX rxData
 LDX  index
#debug usint index
 RCHK 512   ; Range Check
 ADD     ; + offset 
 LDI  
#debug usint rxData[index]
 AND  $FF
 LD   byte $7F
 AND
 ADD
 AND  $FFFF
 WRX  payloadLengthSize
#debug_left uint payloadLengthSize
#srcline 758 ;                                     payloadLengthBytes := payloadLengthBytes + 1;
 LDX  payloadLengthBytes
#debug uint payloadLengthBytes
 LD   uint 1
 ADD
 AND  $FFFF
 WRX  payloadLengthBytes
#debug_left uint payloadLengthBytes
#srcline 759 ;                                else
 JMP  fbMQTTSubscriberEx_L62
fbMQTTSubscriberEx_L61:
#srcline 760 ;                                     if payloadLengthBytes > 1 then
 LDX  payloadLengthBytes
#debug uint payloadLengthBytes
 LD   uint 1
 GT
 JMC  fbMQTTSubscriberEx_L63
#srcline 761 ;                                         payloadLengthSize := payloadLengthSize + (USINT_TO_UINT(rxData[index]) * 128);
 LDX  payloadLengthSize
#debug uint payloadLengthSize
 LEAX rxData
 LDX  index
#debug usint index
 RCHK 512   ; Range Check
 ADD     ; + offset 
 LDI  
#debug usint rxData[index]
 AND  $FFFF
 LD   uint 128
 MUL
 AND  $FFFF
 ADD
 AND  $FFFF
 WRX  payloadLengthSize
#debug_left uint payloadLengthSize
#srcline 762 ;                                     else
 JMP  fbMQTTSubscriberEx_L64
fbMQTTSubscriberEx_L63:
#srcline 763 ;                                         payloadLengthSize := USINT_TO_UINT(rxData[index]);
 LEAX rxData
 LDX  index
#debug usint index
 RCHK 512   ; Range Check
 ADD     ; + offset 
 LDI  
#debug usint rxData[index]
 AND  $FFFF
 WRX  payloadLengthSize
#debug_left uint payloadLengthSize
#srcline 764 ;                                     end_if;
fbMQTTSubscriberEx_L64:
#srcline 765 ;                                     exit;
 JMP  fbMQTTSubscriberEx_L60
#srcline 766 ;                                end_if;
fbMQTTSubscriberEx_L62:
#srcline 767 ;                                index := index + 1;
 LDX  index
#debug usint index
 LD   usint 1
 ADD
 AND  $FF
 WRX  index
#debug_left usint index
#srcline 768 ;                             end_while;
 JMP  fbMQTTSubscriberEx_L59
fbMQTTSubscriberEx_L60:
 NOP  -1
#srcline 770 ;                             inDataCom_param.qos := BYTE_TO_USINT(SHR(IN := USINT_TO_BYTE(rxData[0]),N := 1) AND 16#3);
 LDX  rxData[0]
#debug usint rxData[0]
 AND  $FF
 LD   uint 1
 SHR
 AND  $FF
 LD   byte $3
 AND
 WRX  inDataCom_param~qos
#debug_left usint inDataCom_param.qos
#srcline 771 ;                             inTopicLen          := USINT_TO_UINT(rxData[payloadLengthBytes + 2]);
 LEAX rxData
 LDX  payloadLengthBytes
#debug uint payloadLengthBytes
 LD   uint 2
 ADD
 AND  $FFFF
 RCHK 512   ; Range Check
 ADD     ; + offset 
 LDI  
#debug usint rxData[payloadLengthBytes+2]
 AND  $FFFF
 WRX  inTopicLen
#debug_left uint inTopicLen
#srcline 774 ;                               if (RecvFrom.lenData - payloadLengthBytes - 1) = payloadLengthSize then
 LDX  RecvFrom~lenData
#debug uint RecvFrom.lenData
 LDX  payloadLengthBytes
#debug uint payloadLengthBytes
 SUB
 AND  $FFFF
 LD   uint 1
 SUB
 AND  $FFFF
 LDX  payloadLengthSize
#debug uint payloadLengthSize
 EQ
 JMC  fbMQTTSubscriberEx_L65
#srcline 775 ;                                  dataRec          := true;
 LD   bool -1       ; true
 WRX  dataRec
#debug_left bool dataRec
#srcline 776 ;                                  dataRecDT        := GetDateTime();
 LEA  __Instance__GetDateTime
 CAL  GetDateTime_L0
 WRX  dataRecDT
#debug_left dt dataRecDT
#srcline 777 ;                                 // dataTxt          := '';
#srcline 778 ;                                 // dataTopicTxt     := '';
#srcline 779 ;                                  Memset(val := 0,length := 80,dest := VOID(dataTopicTxt));
 NXT
 LD   udint 0
 WR   __Instance__Memset~val
#debug_left udint __Instance__Memset~val
 LD   uint 80
 WR   __Instance__Memset~length
#debug_left uint __Instance__Memset~length
 LEAX dataTopicTxt
 WR   __Instance__Memset~dest
#debug_left pointer __Instance__Memset.dest
 PRV
 LEA  __Instance__Memset
 CAL  Memset_L0
#srcline 780 ;                                  MemcpyPtr(source := ADR(rxData[payloadLengthBytes + 3]), dest := ADR(dataTopicTxt),length := UINT_TO_UDINT(inTopicLen));
 NXT
 LEAX rxData
 LDX  payloadLengthBytes
#debug uint payloadLengthBytes
 LD   uint 3
 ADD
 AND  $FFFF
 RCHK 512   ; Range Check
 ADD     ; + offset 
#debug pointer rxData[payloadLengthBytes+3]
 LEA  __Instance__MemcpyPtr~source
 WRIL 
#debug_left udint __Instance__MemcpyPtr~source
 LEAX dataTopicTxt
#debug pointer dataTopicTxt
 LEA  __Instance__MemcpyPtr~dest
 WRIL 
#debug_left udint __Instance__MemcpyPtr~dest
 LDX  inTopicLen
#debug uint inTopicLen
 WR   __Instance__MemcpyPtr~length
#debug_left udint __Instance__MemcpyPtr~length
 PRV
 LEA  __Instance__MemcpyPtr
 CAL  MemcpyPtr_L0
#srcline 782 ;                                  if inDataCom_param.qos > 0 then
 LDX  inDataCom_param~qos
#debug usint inDataCom_param.qos
 LD   usint 0
 GT
 JMC  fbMQTTSubscriberEx_L67
#srcline 783 ;                                      if inDataCom_param.qos = 1 then
 LDX  inDataCom_param~qos
#debug usint inDataCom_param.qos
 LD   usint 1
 EQ
 JMC  fbMQTTSubscriberEx_L69
#srcline 784 ;                                          pubAckRq  := true; // Request to answer to publish command from broker when QOS=1
 LD   bool -1       ; true
 WRX  pubAckRq
#debug_left bool pubAckRq
#srcline 785 ;                                      else
 JMP  fbMQTTSubscriberEx_L70
fbMQTTSubscriberEx_L69:
#srcline 786 ;                                          pubRecRq  := true; // Request to answer to publish command from broker when QOS=2
 LD   bool -1       ; true
 WRX  pubRecRq
#debug_left bool pubRecRq
#srcline 787 ;                                      end_if;
fbMQTTSubscriberEx_L70:
#srcline 788 ;                                      messageIDpubAck_ptr := ADR(rxData[inTopicLen + payloadLengthBytes + 3]);
 LEAX rxData
 LDX  inTopicLen
#debug uint inTopicLen
 LDX  payloadLengthBytes
#debug uint payloadLengthBytes
 ADD
 AND  $FFFF
 LD   uint 3
 ADD
 AND  $FFFF
 RCHK 512   ; Range Check
 ADD     ; + offset 
#debug pointer rxData[inTopicLen+payloadLengthBytes+3]
 LEAX messageIDpubAck_ptr
 WRIL 
#debug_left pointer messageIDpubAck_ptr
#srcline 789 ;                                      messageIDpubAck     := fSwapUINT(messageIDpubAck_ptr^);
 NXT
 LEAX messageIDpubAck_ptr
 LDIL    ; dereference 
 LDIW 
#debug uint messageIDpubAck_ptr^
 WR   __Instance__fSwapUINT~input
#debug_left uint __Instance__fSwapUINT~input
 PRV
 LEA  __Instance__fSwapUINT
 CAL  fSwapUINT_L0
 WRX  messageIDpubAck
#debug_left uint messageIDpubAck
#srcline 791 ;                                      inMsgLen := payloadLengthSize - inTopicLen - 4;
 LDX  payloadLengthSize
#debug uint payloadLengthSize
 LDX  inTopicLen
#debug uint inTopicLen
 SUB
 AND  $FFFF
 LD   uint 4
 SUB
 AND  $FFFF
 WRX  inMsgLen
#debug_left uint inMsgLen
#srcline 793 ;                                      MemcpyPtr(source := ADR(rxData[inTopicLen + payloadLengthBytes + 5]),dest := pData,   length := UINT_TO_UDINT(inMsgLen));
 NXT
 LEAX rxData
 LDX  inTopicLen
#debug uint inTopicLen
 LDX  payloadLengthBytes
#debug uint payloadLengthBytes
 ADD
 AND  $FFFF
 LD   uint 5
 ADD
 AND  $FFFF
 RCHK 512   ; Range Check
 ADD     ; + offset 
#debug pointer rxData[inTopicLen+payloadLengthBytes+5]
 LEA  __Instance__MemcpyPtr~source
 WRIL 
#debug_left udint __Instance__MemcpyPtr~source
 LEAX pData
 LDIL 
#debug pointer pData
 LEA  __Instance__MemcpyPtr~dest
 WRIL 
#debug_left udint __Instance__MemcpyPtr~dest
 LDX  inMsgLen
#debug uint inMsgLen
 WR   __Instance__MemcpyPtr~length
#debug_left udint __Instance__MemcpyPtr~length
 PRV
 LEA  __Instance__MemcpyPtr
 CAL  MemcpyPtr_L0
#srcline 794 ;                                  else
 JMP  fbMQTTSubscriberEx_L68
fbMQTTSubscriberEx_L67:
#srcline 795 ;                                   // inMsgLen := rxData[1] - inTopicLen - 2;
#srcline 796 ;                                    inMsgLen := payloadLengthSize-inTopicLen;
 LDX  payloadLengthSize
#debug uint payloadLengthSize
 LDX  inTopicLen
#debug uint inTopicLen
 SUB
 AND  $FFFF
 WRX  inMsgLen
#debug_left uint inMsgLen
#srcline 797 ;                                    inMsgLen := inMsgLen - 2;
 LDX  inMsgLen
#debug uint inMsgLen
 LD   uint 2
 SUB
 AND  $FFFF
 WRX  inMsgLen
#debug_left uint inMsgLen
#srcline 798 ;                                    MemcpyPtr(source := ADR(rxData[inTopicLen + payloadLengthBytes + 3]),dest := pData,length := UINT_TO_UDINT(inMsgLen));
 NXT
 LEAX rxData
 LDX  inTopicLen
#debug uint inTopicLen
 LDX  payloadLengthBytes
#debug uint payloadLengthBytes
 ADD
 AND  $FFFF
 LD   uint 3
 ADD
 AND  $FFFF
 RCHK 512   ; Range Check
 ADD     ; + offset 
#debug pointer rxData[inTopicLen+payloadLengthBytes+3]
 LEA  __Instance__MemcpyPtr~source
 WRIL 
#debug_left udint __Instance__MemcpyPtr~source
 LEAX pData
 LDIL 
#debug pointer pData
 LEA  __Instance__MemcpyPtr~dest
 WRIL 
#debug_left udint __Instance__MemcpyPtr~dest
 LDX  inMsgLen
#debug uint inMsgLen
 WR   __Instance__MemcpyPtr~length
#debug_left udint __Instance__MemcpyPtr~length
 PRV
 LEA  __Instance__MemcpyPtr
 CAL  MemcpyPtr_L0
#srcline 799 ;                                  end_if;
fbMQTTSubscriberEx_L68:
#srcline 800 ;                             else
 JMP  fbMQTTSubscriberEx_L66
fbMQTTSubscriberEx_L65:
#srcline 801 ;                                ok       := false;
 LD   bool 0       ; false
 WRX  ok
#debug_left bool ok
#srcline 802 ;                                err      := true;
 LD   bool -1       ; true
 WRX  err
#debug_left bool err
#srcline 803 ;                                errCode  := MQTT_CONTROL_ERROR_CODE_ANSWER_LENGTH_TO_LONG;
 LD   usint 4
 WRX  errCode
#debug_left usint errCode
#srcline 804 ;                             end_if;
fbMQTTSubscriberEx_L66:
#srcline 805 ;                       end_if;
fbMQTTSubscriberEx_L57:
#srcline 806 ;                  end_if;
fbMQTTSubscriberEx_L49:
#srcline 807 ;                  rxCounter := rxCounter + 1;
 LDX  rxCounter
#debug uint rxCounter
 LD   uint 1
 ADD
 AND  $FFFF
 WRX  rxCounter
#debug_left uint rxCounter
#srcline 808 ;              end_if;
fbMQTTSubscriberEx_L46:
#srcline 809 ;          end_if;
fbMQTTSubscriberEx_L44:
#srcline 810 ;       else
 JMP  fbMQTTSubscriberEx_L39
fbMQTTSubscriberEx_L38:
#srcline 811 ;         connected_to_broker := false;
 LD   bool 0       ; false
 WRX  connected_to_broker
#debug_left bool connected_to_broker
#srcline 812 ;         wait_response       := false;
 LD   bool 0       ; false
 WRX  wait_response
#debug_left bool wait_response
#srcline 813 ;         ok                  := false;
 LD   bool 0       ; false
 WRX  ok
#debug_left bool ok
#srcline 814 ;         err                 := true;
 LD   bool -1       ; true
 WRX  err
#debug_left bool err
#srcline 815 ;         errCode             := MQTT_CONTROL_ERROR_CODE_BROKER_DISCONNECTED;
 LD   usint 3
 WRX  errCode
#debug_left usint errCode
#srcline 816 ;       end_if;
fbMQTTSubscriberEx_L39:
#srcline 817 ;   else
 JMP  fbMQTTSubscriberEx_L6
fbMQTTSubscriberEx_L5:
#srcline 818 ;     connected_to_broker := false;
 LD   bool 0       ; false
 WRX  connected_to_broker
#debug_left bool connected_to_broker
#srcline 819 ;     wait_response       := false;
 LD   bool 0       ; false
 WRX  wait_response
#debug_left bool wait_response
#srcline 820 ;     ok                  := false;
 LD   bool 0       ; false
 WRX  ok
#debug_left bool ok
#srcline 821 ;     err                 := true;
 LD   bool -1       ; true
 WRX  err
#debug_left bool err
#srcline 822 ;     errCode             := MQTT_CONTROL_ERROR_CODE_BROKER_DISCONNECTED;
 LD   usint 3
 WRX  errCode
#debug_left usint errCode
#srcline 823 ;   end_if;
fbMQTTSubscriberEx_L6:
#srcline 826 ;END_FUNCTION_BLOCK
fbMQTTSubscriberEx_RET:
 ULNK
RET
E     61

; Initialize - variables
P     61
fbMQTTSubscriberEx__InstanceInit__:
 LINK 0
 LD   uint 1883
 WRX  brokerPort
 LD   uint 5000
 WRX  localPort
 LD   bool -1   ; true
 WRX  keepAlive
 LD   time 20000
 WRX  keepAliveInterval
 LD   time 10000
 WRX  connTimeOut
 LD   time 15000
 WRX  pingInterval
 LD   bool -1   ; true
 WRX  clientId_auto
 LD   0
 SRC  byte __Init___fbMQTTSubscriberEx_com_param
 LEAX byte com_param
 LD   7
 MOV  %X0
 LD   udint $FFFFFFFF    ; nil
 WRX  pData
 LEAX MQTT_Comm_Init
 CAL  fbMQTT_Comm_Init__InstanceInit__
 LEAX SendTo
 CAL  fbSendTo__InstanceInit__
 LEAX RecvFrom
 CAL  fbRecvFrom__InstanceInit__
 LD   0
 SRC  byte __Init___fbMQTTSubscriberEx_MQTT_PROTOCOL
 LEAX byte MQTT_PROTOCOL
 LD   5
 MOV  %X0
 LD   0
 SRC  byte __Init___fbMQTTSubscriberEx_inDataCom_param
 LEAX byte inDataCom_param
 LD   7
 MOV  %X0
 LD   udint $FFFFFFFF    ; nil
 WRX  messageIDpubAck_ptr
 ULNK
RET
E     61
; End initialize - variables
#endpou 



 

#srcfile ''
žo  9  Ê