(*` {CSY}Knihovna vývojového systému Mosaic{ENU}Mosaic IDE library *)
(*` {CSY}Jméno souboru{ENU}File name{} : D:\MosaicLib\FileLib_V28_20200709.mlb *)
(*` {CSY}Knihovna : FileLib{ENU}Library : FileLib{} 2.8 *)
(*` {CSY}Autor{ENU}Author{} : Teco a.s. *)
(*` {CSY}Autorská práva{ENU}Copyright{} : (c) 2010 - 2020 Teco a.s. *)
(*` {CSY}Verze IEC pøekladaèe{ENU}IEC compiler version{} : 4.2.11.0 *)
(*` {CSY}Verze assembleru{ENU}Assembler version{} : 4.3.00 *)

//{Knihovna : FileLib 2.8  }
(*` {CSY}Historie{ENU}History{}: *)
(*`
{CSY}
v1.0            nem   první verze
v1.1            nem   pøidaná funkce DiskInfo()
v1.2            nem   pøidaná funkce FindFreeCluster() a funkèní blok CreatePath()
                      funkce FindFreeCluster() použita v CreatePath() a WriteFile()
v1.3            nem   nulování idle time ve WriteToFile() když busy je FALSE
                      pøidán funkèní blok WriteDbxToFile()
                      pøidán funkèní blok ReadDbxFromFile()
v1.4            nem   opraven help funkce DirCreate()
v1.5            nem   obráceno poøadí parametrù u FileOpen()
                      pøidán funkèní blok WriteToFileSeq ()
v1.6            nem   automatické zvýšení doby cyklu ve funkcích
                      DirCreate() a FileClose()
                      (u nìkterých typù SD karet mùže tato operace trvat delší dobu)
v1.7 26.10.2010 nem   pøidány závislosti na knihovnách
v1.8 14.06.2011 nem   pøidána funkce FileInfo()
v1.9 11.12.2012 nem   pøidány funkce CloseAllFiles() a OpenFilesCount()
                      (potøebná verze FW je v7.5)
                      zdokonalen test konce souboru ve funkèním bloku
                      ReadFromFile() a ReadDbxFromFile()
v2.0 03.12.2013 nem   pøidán funkèní blok DeleteDirectories()
v2.1 02.10.2015 byd   pøidán funkèní blok ReadLine()
v2.2 16.03.2016 byd   upraveny bloky WriteToFile() a WriteDbxToFile() -
                      pøed otevøením nového souboru je uzavøen aktuálnì
                      otevøený soubor (pokud existuje)
v2.3 16.01.2018 nem   pøidána funkce SetFileAttr()
v2.4 10.04.2019 nem   doplnìny funkce FileMove(),FileRename(),
                      a ForceDirs() (pouze pro CP-2xxx)
v2.5 05.06.2019 nem   doplnìna funkce DisconnectUsb() (pouze pro CP-2xxx)
v2.6 03.01.2020 nem   pøidány funkèní bloky ListDirectories() a ListDirectoriesLog(),
                      DeleteSurplusFiles() a DeleteSurplusFilesLog(),
                      DeleteOldFiles() a DeleteOldFilesLog(),
v2.7 19.02.2020 nem   pøidány funkèní bloky ZipArchive() a UnzipArchive()
                      (pouze pro CP-2xxx v3.1 a vyssi)
                byd   pøidán funkèní blok ReadLastLines()
v2.8 09.07.2020 byd   do funkèního bloku ReadFromFile pøidána kontrola velikosti souboru (potlaèení falešného chybového hlášení, které mohlo nastat ve specifických pøípadech)
{ENU}
v1.0            nem   first version
v1.1            nem   added function DiskInfo()
v1.2            nem   added function FindFreeCluster() and
                      added new function block CreatePath()
                      function FindFreeCluster() used in CreatePath()
                      and WriteFile() too
v1.3            nem   clearing idle time in WriteToFile() when busy is FALSE
                      new function block WriteDbxToFile()
                      new function block ReadDbxFromFile()
v1.4            nem   help of function DirCreate() was corrected
v1.5            nem   switch parameters order of FileOpen()
                      new function block WriteToFileSeq ()
v1.6            nem   max cycle time was automatically increased in functions
                      DirCreate() and FileClose() (because these functions can
                      spend more time depends on SD card)
v1.7 2010-10-26 nem   library dependency added
v1.8 2011-06-14 nem   added function FileInfo()
v1.9 2012-12-11 nem   added functions CloseAllFiles() a OpenFilesCount()
                      (FW v7.5 is required)
                      better test end of file in function blocks
                      ReadFromFile() and ReadDbxFromFile()
v2.0 2013-12-03 nem   added function block DeleteDirectories()
v2.1 2015-10-02 byd   added function block fbReadLineFromFile()
v2.2 2016-03-16 byd   WriteToFile() and WriteDbxToFile() was modified -
                      before opening new file actual opened file is closed
v2.3 2018-01-16 nem   added function SetFileAttr()
v2.4 2019-04-10 nem   new functions FileMove(), FileRename()
                      and ForceDirs() (for CP-2xxx only)
v2.5 2019-06-05 nem   new function DisconnectUsb() (for CP-2xxx only)
v2.6 2020-01-03 nem   added function blocks ListDirectories() and ListDirectoriesLog(),
                      DeleteSurplusFiles() and DeleteSurplusFilesLog(),
                      DeleteOldFiles() and DeleteOldFilesLog(),
v2.7 2020-02-19 nem   added function blocks ZipArchive() and UnzipArchive()
                      (for CP-2xxx only, version v3.1 or higher)
                byd   added function block ReadLastLines()
v2.8 09.07.2020 byd   added file size check to function block ReadFromFile(suppressing false error message that could occur in specific cases)
*)

(*----------------------------------------------------------------------------*)
{LIBRARY="LOCALLIB\STDLIB_V22_20180619.MLB"}
{LIBRARY="LOCALLIB\SYSLIB_V44_20200302.MLB"}
{LIBRARY="LOCALLIB\TOSTRINGLIB_V13_20110203.MLB"}

TYPE  HANDLE : udint;  (*`{CSY} identifikátor souboru {ENU} file identificator*)
END_TYPE

TYPE TDirStack {HIDDEN} :
  STRUCT
    hDir             : HANDLE;
    sDir             : string [12];
  END_STRUCT;
END_TYPE

VAR_GLOBAL CONSTANT
 INVALID_HANDLE_VALUE : HANDLE :=  0;  (*`{CSY} neplatná hodnota identifikátoru {ENU} invalid handle value*)
 MAX_PATH : uint :=  65;  (*`{CSY} max velikost cesty (poèet bytù) {ENU} max size of path (number of bytes)*)
 MAX_COUNT_OPEN_FILES : uint :=  16;  (*`{CSY} max poèet souèasnì otevøených souborù {ENU} max count of concurrently open files*)
 DIR_STACK_MAX_LEVEL : usint :=  8;  (*`{CSY} max hloubka vnoøení adresáøù pro mazání {ENU} max number of subdirectories for deletting*)

END_VAR

TYPE TFileInfo :
  STRUCT
    creationTime     : dt;  (*`{CSY} èas vytvoøení souboru {ENU} file creation time*)
    modifyTime       : dt;  (*`{CSY} èas poslední modifikace {ENU} time of last modification*)
    fileSize         : udint;  (*`{CSY} velikost souboru (poèet bytù) {ENU} size of file (number of bytes)*)
    attrib           : dword;  (*`{CSY} atributy souboru {ENU} file attributes*)
    fileName         : string [80];  (*`{CSY} jméno souboru {ENU} name of file*)
    empty {HIDDEN}   : byte;
  END_STRUCT;
END_TYPE

TYPE TFileInfo2 :
  STRUCT
    creationTime     : dt;  (*`{ENU} file creation time {CSY} èas vytvoøení souboru*)
    modifyTime       : dt;  (*`{ENU} time of last modification {CSY} èas poslední modifikace*)
    fileSize         : udint;  (*`{ENU} size of file (number of bytes) {CSY} velikost souboru (poèet bytù)*)
    attrib           : dword;  (*`{ENU} file attributes {CSY} atributy souboru*)
    fileName         : string [80];  (*`{ENU} name of file {CSY} jméno souboru nebo adresáøe*)
    pathName         : string [160];  (*`{ENU} name of path {CSY} cesta*)
  END_STRUCT;
END_TYPE

TYPE TDiskInfo :
  STRUCT
    TotalNumberOfKBytes : udint;  (*`{CSY} velikost disku (poèet kilobytù) {ENU} disc size (number of kilobytes)*)
    TotalNumberOfFreeKBytes : udint;  (*`{CSY} volné místo na disku (poèet kilobytù) {ENU} free space (number of kilobytes)*)
  END_STRUCT;
END_TYPE

TYPE TF_MODE : 
  (F_READ,
   F_WRITE,
   F_APPEND,
   F_READ_PLUS 
  );
END_TYPE

__DECL FUNCTION FileOpen : HANDLE
(*`{CSY} Otevøení souboru

   Funkce FileOpen inicializuje datové struktury potøebné pro ètení
   nebo zápis do souboru.
   Vstupní parametry jsou jméno souboru a zpùsob pøístupu k souboru.
   Dostupné pøístupy k souboru jsou :
   F_READ   Otevøe soubor pro ètení. Operace skonèí s chybou, pokud
            soubor neexistuje nebo pokud nejsou dostateèná práva
            pro pøístup k souboru.
   F_WRITE  Otevøe soubor pro zápis. Zápis bude probíhat od zaèátku souboru.
            Tato operace vždy založí nový soubor. Pokud soubor zadaného jména
            existuje, jeho obsah je smazán.
   F_APPEND Otevøe soubor pro zápis. Data budou zapsána na konec souboru.
            Pokud soubor neexistuje, tak bude založen nový soubor.
            Pokud se soubor otevøe tímto zpùsobem, tak nelze použít
            funkci FileSetPos - data budou vždy pøipojena na konec souboru.

   Funkce vrací identifikátor otevøeného souboru. Pokud se soubor nepodaøí
   otevøít je vrácen neplatný identifikátor ( INVALID_HANDLE_VALUE)

   {ENU} Open file

   FileOpen initializes the data structures needed to read or write a file.
   Specify the file's name as the string at file,
   and the kind of access you need to the file with mode parameter.
   Three fundamental kinds of access are available: read, write, and append.
   mode must be one of the constant: F_READ, F_WRITE or F_APPEND, to select one of these:

   F_READ        Open the file for reading. The operation will fail if the file
                 does not exist, or if the host system does not permit you to read it.
   F_WRITE       Open the file for writing from the beginning of the file ( effectively,
                 this always creates a new file). If the file whose name you specified
                 already existed, its old contents are discarded.
   F_APPEND      Open the file for appending data, that is writing from the end of file.
                 When you open a file this way, all data always goes to the current
                 end of file. It mens you cannot change this using FileSetPos.

   FileOpen returns a file indicator which you can use for other file operations,
   unless the file you requested could not be opened. In that situation, the result
   is INVALID_HANDLE_VALUE.*)
  VAR_INPUT
    mode             : TF_MODE;  (*`{CSY}zpùsob pøístupu k souboru (F_READ / F_WRITE / F_APPEND) {ENU} kinds of access (F_READ / F_WRITE / F_APPEND)*)
  END_VAR
  VAR_IN_OUT
    fileName         : string [80];  (*`{CSY} jméno souboru (vèetnì cesty) {ENU} file name (including path)*)
  END_VAR
END_FUNCTION

__DECL FUNCTION FileClose : bool
(*`{CSY} Zavøení souboru

   Funkce uzavøe soubor se zadaným identifikátorem,
   pokud je tento otevøen.
   
   Funkce vrací TRUE pokud je soubor úspìšnì uzavøen,
   FALSE v ostatních pøípadech

   {ENU} Closing file

   If the file identified by hFile is open,
   FileClose closes it.

   FileClose returns TRUE if successful otherwise,
   it returns FALSE.*)
  VAR_INPUT
    hFile            : HANDLE;  (*`{CSY} identifikátor souboru {ENU} file identificator*)
  END_VAR
END_FUNCTION

__DECL FUNCTION FileDelete : bool
(*`{CSY} Vymazání souboru

   Funkce smaže soubor soubor zadaného jména.
   Tuto funkci lze použít i pro smazání adresáøe.
   Pro úspìšné smazání adresáøe je nezbytné,
   aby byl adresáø prázdný.

   Funkce vrací TRUE pokud je soubor/adresáø smazán,
   FALSE v ostatních pøípadech

   {ENU} Deleting a file

   Use FileDelete to delete the file specified by fileName.
   You can use this function to delete directory as well,
   but only in case when the directory is empty.

   FileDelete returns TRUE if it succeeds, FALSE if it fails.*)
  VAR_IN_OUT
    fileName         : string [80];  (*`{CSY} jméno souboru (vèetnì cesty) {ENU} file name (including path)*)
  END_VAR
END_FUNCTION

__DECL FUNCTION FileRead : udint
(*`{CSY} Ètení souboru

   Funkce zkopíruje zadaný poèet znakù ze souboru do promìnné v pamìti PLC.
   Funkce mùže zkopírovat i menší poèet znakù než je požadováno v pøípadì,
   že dojde k chybì pøi ètení souboru nebo je dosaženo konce souboru.
   Funkce posouvá aktuální pozici pro ètení/zápis do souboru podle
   pozice naposledy pøeèteného znaku.
   
   Funkce vrací skuteèný poèet úspìšnì naètených znakù.
   
   {ENU} Read file

   FileRead attempts to copy, from the file identified by hFile,
   count elements (each of size size) into memory, starting at adrBuf.
   FileRead may copy fewer elements than count if an error, or end of file, intervenes.
   FileRead also advances the file position indicator (if any) for hFile
   by the number of characters actually read.

   The result of FileRead is the number of elements it succeeded in reading.*)
  VAR_INPUT
    hFile            : HANDLE;  (*`{CSY} identifikátor souboru {ENU} file identificator*)
    adrBuf           : udint;  (*`{CSY} adresa promìnné, do které budou zkopírovaná data ze souboru {ENU} destination variable*)
    size             : udint;  (*`{CSY} délka ètených dat (poèet bytù) {ENU} data length (number of bytes)*)
  END_VAR
END_FUNCTION

__DECL FUNCTION FileWrite : udint
(*`{CSY} Zápis do souboru

   Funkce zkopíruje zadaný poèet znakù z promìnné v pamìti PLC do souboru.
   Funkce mùže zkopírovat i menší než zadaný poèet znakù, pokud dojde
   k chybì pøi zápisu do souboru.
   Funkce posouvá aktuální pozici pro ètení/zápis do souboru podle
   pozice naposledy zapsaného znaku.

   Funkce vrací skuteèný poèet úspìšnì zapsaných znakù

   {ENU} Write to a file

   FileWrite attempts to copy, starting from the memory location adrBuf,
   count elements (each of size size) into the file identified by hFile.
   FileWrite may copy fewer elements than count if an error intervenes.
   FileWrite also advances the file position indicator (if any) for hFile
   by the number of characters actually written.

   If FileWrite succeeds in writing all the elements you specify,
   the result is the same as the argument count.
   In any event, the result is the number of complete elements
   that FileWrite copied to the file.*)
  VAR_INPUT
    hFile            : HANDLE;  (*`{CSY} identifikátor souboru {ENU} file identificator*)
    adrBuf           : udint;  (*`{CSY} adresa promìnné, ze které budou zkopírovaná data do souboru{ENU} variable address*)
    size             : udint;  (*`{CSY} délka zapisovaných dat (poèet bytù) {ENU} data length (number of bytes)*)
  END_VAR
END_FUNCTION

VAR_GLOBAL CONSTANT
 BEGIN_POS : udint :=  0;  (*`{CSY} pozice na zaèátku souboru {ENU} begin position in file*)
 END_POS : udint :=  16#FFFF_FFFF;  (*`{CSY} pozice na konci souboru {ENU} end position in file*)

END_VAR

__DECL FUNCTION FileSetPos : bool
(*`{CSY} Nastavit pozici v souboru

   Funkce umožòuje nastavit pozici pro ètení resp. pro zápis do souboru.
   Pozice je offset dat od zaèátku souboru.
   Pro nastavení pozice na zaèátek souboru lze použít konstantu BEGIN_POS.
   Pro nastavení pozice na konec souboru lze použít konstantu END_POS.
   
   Funkce vrací TRUE, pokud se podaøí nastavit žádanou pozici v souboru.
   Jinak vrací FALSE.

   {ENU} Set file position

   Objects of type FILE can have a "position" that records
   how much of the file your program has already read.
   You can use FileSetPos to set the position for the file identified by hFile.
   BEGIN_POS and END_POS are constants to set position at begin or end of file.

   FileSetPos returns TRUE when successful.
   If FileSetPos fails, the result is FALSE.*)
  VAR_INPUT
    hFile            : HANDLE;  (*`{CSY} identifikátor souboru {ENU} file identificator*)
    offset           : udint;  (*`{CSY} pozice v souboru {ENU} data offset in file*)
  END_VAR
END_FUNCTION

__DECL FUNCTION FileExists : bool
(*`{CSY} Test existence souboru

   Funkce zjistí zda existuje soubor nebo adresáø zadaného jména.
   
   Funkce vrátí TRUE pokud soubor resp. adresáø existuje,
   FALSE v ostatních pøípadech

   {ENU} Test for existence of file

   Use FileExist to test if file or directory identified by fileName exists.

   FileExist returns TRUE if file exists otherwise, it returns FALSE.*)
  VAR_IN_OUT
    fileName         : string [80];  (*`{CSY} jméno souboru (vèetnì cesty) {ENU} file name (including path)*)
  END_VAR
END_FUNCTION

VAR_GLOBAL CONSTANT
 UNKNOWN_SIZE : udint :=  16#FFFF_FFFF;  (*`{CSY} neznámá velikost {ENU} unknown size*)

END_VAR

__DECL FUNCTION FileSize : udint
(*`{CSY} Zjistit velikost souboru

   Funkce FileSize zjistí velikost souboru
   
   Funkce vrací aktuální velikost souboru.
   Pøi chybì vrací UKNOWN_SIZE, tj. 16#FFFF_FFFF

   {ENU} Find file size

   Use FileSize to test size of file identified by hFile.

   FileSize returns size of file if successful otherwise,
   it returns 16#FFFF_FFFF.*)
  VAR_INPUT
    hFile            : HANDLE;  (*`{CSY} identifikátor souboru {ENU} file identificator*)
  END_VAR
END_FUNCTION

__DECL FUNCTION DirOpen : HANDLE
(*`{CSY} Otevøení adresáøe

   Funkce otevøe adresáø zadaného jména.
   Poté zjistí informace o prvním souboru v adresáøi
   a tyto informace zapíše do promìnné dirInfo.
   Informace o dalších souborech v adresáøi lze zjistit funkcí DirRead.
   
   Funkce vrací identifikátor otevøeného adresáøe.
   Pokud se adresáø nepodaøí otevøít je vrácen neplatný identifikátor
   (INVALID_HANDLE_VALUE)

   {ENU} Open Directory

   Use DirOpen to open the directory specified by dirName.
   Then function find out information about first file in dir
   and these information are saved to variable dirInfo.
   For information about next file use function DirRead

   DirOpen returns identificator of directory when operation is succefull,
   otherwise invalid identificator (INVALID_HANDLE_VALUE).
   Function DirOpen sets all items in variable dirInfo
   which have to be type of TFileInfo*)
  VAR_IN_OUT
    dirName          : string [80];  (*`{CSY} jméno adresáøe (vèetnì cesty) {ENU} dir name (including path)*)
    dirInfo          : TFileInfo;  (*`{CSY} struktura s informacemi o prvním souboru v adresáøi {ENU} structure contains information about first file in dir*)
  END_VAR
END_FUNCTION

__DECL FUNCTION DirClose : bool
(*`{CSY} Uzavøení adresáøe

   Funkce uzavøe adresáø.
   
   Funkce vrací TRUE pokud je adresáø úspìšnì uzavøen,
   FALSE v ostatních pøípadech

   {ENU} Closing directory

   If the directory identified by hDir is open, DirClose closes it.

   DirClose returns TRUE if successful otherwise, it returns FALSE.*)
  VAR_INPUT
    hDir             : HANDLE;  (*`{CSY} identifikátor souboru {ENU} file identificator*)
  END_VAR
END_FUNCTION

__DECL FUNCTION DirRead : bool
(*`{CSY} Ètení z adresáøe

   Funkce zjistí informace o dalším souboru v adresáøi
   a tyto informace zapíše do promìnné dirInfo.
   Pøed voláním této funkce musí být adresáø otevøen funkcí DirOpen.

   Funkce vrací TRUE pokud operace dopadne úspìšnì,
   FALSE v ostatních pøípadech

   {ENU} Read from directory

   Use DirRead to read next item in the directory specified by hDdir.
   Directory have to be open by function DirOpen.

   DirRead returns TRUE if it succeeds, FALSE if it fails.
   Function DirRead sets all items in variable dirInfo
   which have to be type of TFileInfo*)
  VAR_INPUT
    hDir             : HANDLE;  (*`{CSY} identifikátor souboru {ENU} file identificator*)
  END_VAR
  VAR_IN_OUT
    dirInfo          : TFileInfo;  (*`{CSY} struktura s informacemi o dalším souboru v adresáøi {ENU} structure contains information about next file in dir*)
  END_VAR
END_FUNCTION

__DECL FUNCTION DirCreate : bool
(*`{CSY} Vytvoøení adresáøe

   Funkce vytvoøí adresáø zadaného jména.
   
   Funkce vrací TRUE pokud je adresáø úspìšnì vytvoøen,
   FALSE v ostatních pøípadech

   {ENU} Create a directory

   If the directory specified by dirName does not exist,
   DirCreate creates it.

   DirCreate returns TRUE if successful otherwise,
   it returns FALSE.*)
  VAR_IN_OUT
    dirName          : string [80];  (*`{CSY} jméno adresáøe (vèetnì cesty) {ENU} directory name (including path)*)
  END_VAR
END_FUNCTION

__DECL FUNCTION DirDelete : bool
(*`{CSY} Vymazání adresáøe

   Funkce smaže adresáø zadaného jména.
   Pro úspìšné smazání adresáøe je nezbytné,
   aby byl adresáø prázdný (aby neobsahoval žádné soubory).
   
   Funkce vrací TRUE pokud je adresáø smazán,
   FALSE v ostatních pøípadech

   {ENU} Delete directory

   Use DirDelete to delete the directory specified by dirName.
   You have to be sure the directory is empty.

   DirDelete returns TRUE if it succeeds, FALSE if it fails.*)
  VAR_IN_OUT
    dirName          : string [80];  (*`{CSY} jméno adresáøe (vèetnì cesty) {ENU} directory name (including path)*)
  END_VAR
END_FUNCTION

__DECL FUNCTION GetLastErr : udint
(*`{CSY} Zjistit kód poslední chyby

   Funkce vrátí kód poslední zaznamenané chyby vzniklé
   pøi souborové operaci. Tento kód mùže být použit jako
   parametr funkce GetLastErrTxt, která pak vrátí textový popis chyby

   Funkce vrátí kód poslední chyby pøi souborové operaci

   {ENU} Get the last error code

   The file functions maintain an global error indicator,
   to record last read or write errors have occurred.
   Use GetLastErr to query this indicator.

   GetLastErr returns 0 if no errors have occurred.
   It returns a nonzero value otherwise.*)
END_FUNCTION

__DECL FUNCTION GetLastErrTxt : bool
(*`{CSY}
   Popis
   Funkce zapíše textový popis chyby do promìnné errMessage.
   Textový popis chyby odpovídá kódu chyby,
   který je specifikován promìnnou errCode.

   Návratová hodnota
   Funkce vrací Vrací TRUE, pokud existuje popis chyby,
   jinak vrací FALSE.

   {ENU}
   Description
   Use GetLastErrTxt to get description of error specified by errCode.

   Returns
   GetLastErr returns description of error as a string.*)
  VAR_INPUT
    errCode          : udint;  (*`{CSY} chybový kód {ENU} error code*)
  END_VAR
  VAR_IN_OUT
    errMessage       : string [80];  (*`{CSY} textový popis chyby {ENU} error description*)
  END_VAR
END_FUNCTION

__DECL FUNCTION DiskInfo : bool
(*`{CSY} Zjistit informace o disku

   Funkce zjistí celkovou velikost disku a volné místo na disku
   
   Funkce vrací TRUE, pokud se podaøí zjistit informace
   o zadaném disku.V opaèném pøípadì vrací FALSE.
   Funkce DiskInfo naplní položky TotalNumberOfKBytes
   a TotalNumberOfFreeKBytes v promìnné diskDesc.
   Obì hodnoty jsou v KiloBytech.

   {ENU} Get information about disk

   Use DiskInfo to find out size of disk specified by diskName.
   If the diskName is empty, default disk is selected.

   DiskInfo returns TRUE if it succeeds, FALSE if it fails.
   Function DiskInfo sets items TotalNumberOfKBytes and
   TotalNumberOfFreeKBytes in variable diskDesc*)
  VAR_IN_OUT
    diskName         : string [80];  (*`{CSY} název disku (prázdný string pro default disk) {ENU} disk name (empty string for default disk)*)
    diskDesc         : TDiskInfo;  (*`{CSY} informace o disku {ENU} disk description*)
  END_VAR
END_FUNCTION

__DECL FUNCTION FindFreeCluster : byte
(*`{CSY} Najít volné místo na disku

   Funkce hledá volné místo na disku.
   Úèelem funkce je zrychlit následný zápis dat do souboru.
   Tato funkce je využívána napø. funkèním blokem CreatePath.
   
   Funkce vrací 0 pokud je volné místo nalezeno
   nebo 13 pokud se v hledání má pokraèovat v pøíštím cyklu PLC
   nebo jiné èíslo pokud dojde k nìjaké chybì.

   {ENU} Find free disk space

   Use FindFreeCluster to find free space to accelerate disk write.

   FindFreeCluster returns 0 if free cluster found,
   13 if function still not finished, otherwise error.*)
  VAR_IN_OUT
    fileName         : string [80];  (*`{CSY} jméno souboru (vèetnì cesty) {ENU} file name (including path)*)
  END_VAR
END_FUNCTION

__DECL FUNCTION FileInfo : bool
(*`{CSY} Zjistit informace o souboru

   Funkce zjistí následující informace o souboru :
   èas vytvoøení souboru, èas poslední modifikace,
   velikost souboru (poèet bytù) a atributy souboru
   Tyto informace zapíše do promìnné fileDesc.
   Funkce vrací TRUE pokud soubor existuje a informace
   se podaøilo zjistit, v ostatních pøípadech vrací FALSE

   {ENU} Get information about file

   Use DirRead to read following information about specified file:
   file creation time, time of last modification,
   size of file (number of bytes) and file attributes
   This information is stored to fileDesc variable.
   DirRead returns TRUE if it succeeds, FALSE if it fails.*)
  VAR_IN_OUT
    fileName         : string [80];  (*`{CSY} jméno adresáøe (vèetnì cesty) {ENU} dir name (including path)*)
    fileDesc         : TFileInfo;  (*`{CSY} struktura s informacemi o souboru {ENU} structure contains information about file*)
  END_VAR
END_FUNCTION

__DECL FUNCTION CloseAllFiles : bool
(*`{CSY} Uzavøení všech otevøených souborù

   Funkce uzavøe všechny aktuálnì otevøené soubory.
   Funkce vrací TRUE.

   {ENU} Closing all open files*)
END_FUNCTION

__DECL FUNCTION OpenFilesCount : uint
(*`{CSY} Poèet aktuálnì otevøených souborù

   Funkce vrací poèet aktuálnì otevøených souborù

   {ENU} Number of open files

   OpenFilesCount returns Number of open files.*)
END_FUNCTION

__DECL FUNCTION FileMove : bool
(*`{CSY} Pøesun/pøejmenování souboru

   Funkce zmìní název souboru z oldName na newName. Pokud je newName
   v jiné cestì než oldName pak dojde k pøesunu souboru do nového umístìní.
   Tato funkce je podporována pouze v systémech Foxtrot CP-2xxx.
   Funkce vrací TRUE pokud se pøesun/pøejmenování podaøí.

   {ENU} Move/rename file

   FileMove changes the name of the file specified by oldName to newName.
   If oldName and newName specify different paths the file is moved to the new location.
   This function is supported in system Foxtrot CP-2xxx only.

   The result of FileMove is true if the file is successfully renamed.*)
  VAR_IN_OUT
    oldName          : string [80];  (*`{CSY} pùvodní jméno souboru (vèetnì cesty) {ENU} old file name (including path)*)
    newName          : string [80];  (*`{CSY} nové jméno souboru (vèetnì cesty)    {ENU} new file name (including path)*)
  END_VAR
END_FUNCTION

__DECL FUNCTION FileRename : bool
(*`{CSY} Pøesun/pøejmenování souboru

   Funkce zmìní název souboru z oldName na newName. Pokud je newName
   v jiné cestì než oldName pak dojde k pøesunu souboru do nového umístìní.
   Tato funkce je podporována pouze v systémech Foxtrot CP-2xxx.
   Funkce vrací TRUE pokud se pøesun/pøejmenování podaøí.

   {ENU} Move/rename file

   FileMove changes the name of the file specified by oldName to newName.
   If oldName and newName specify different paths the file is moved to the new location.
   This function is supported in system Foxtrot CP-2xxx only.

   The result of FileMove is true if the file is successfully renamed.*)
  VAR_IN_OUT
    oldName          : string [80];  (*`{CSY} pùvodní jméno souboru (vèetnì cesty) {ENU} old file name (including path)*)
    newName          : string [80];  (*`{CSY} nové jméno souboru (vèetnì cesty)    {ENU} new file name (including path)*)
  END_VAR
END_FUNCTION

__DECL FUNCTION SetFileAttr : bool
(*`{CSY} Nastavit atributy souboru
   FAT FILE SYTEM :
   AM_RDO	16#01	 Read Only
   AM_HID	16#02	 Hidden
   AM_SYS	16#04	 System
   AM_VOL	16#08	 Volume Label
   AM_DIR	16#10	 Directory
   AM_ARC	16#20	 Archive

   {ENU} Set file attributes
   FAT FILE SYTEM :
   AM_RDO	16#01	 Read Only
   AM_HID	16#02	 Hidden
   AM_SYS	16#04	 System
   AM_VOL	16#08	 Volume Label
   AM_DIR	16#10	 Directory
   AM_ARC	16#20	 Archive*)
  VAR_INPUT
    attrib           : dword;  (*`{CSY} atributy {ENU} attributes*)
  END_VAR
  VAR_IN_OUT
    fileName         : string [80];  (*`{CSY} jméno souboru (vèetnì cesty) {ENU} file name (including path)*)
  END_VAR
END_FUNCTION

__DECL FUNCTION ForceDirs : bool
(*`{CSY} Založit celou cestu (pouze CP-2xxx)
   Funkce vrací TRUE pokud je adresáø úspìšnì vytvoøen,
   FALSE v ostatních pøípadech

   {ENU} Create full path (CP-2xxx only)
   DirCreate returns TRUE if successful otherwise,
   it returns FALSE.*)
  VAR_IN_OUT
    fileName         : string [80];  (*`{CSY} jméno souboru (vèetnì cesty)    {ENU} file name (including path)*)
  END_VAR
END_FUNCTION

__DECL FUNCTION_BLOCK ReadFromFile
(*`{CSY} Pøenos dat ze souboru do promìnné v PLC

   Funkèní blok pøeète data ze souboru a uloží je do promìnné v pamìti PLC
   
   Funkèní blok nastaví TRUE do promìnné done v okamžiku,
   kdy se naète poslední blok dat ze souboru.
   Bìhem naèítání dat má promìnná done hodnotu FALSE
   a promìnná busy hodnotu TRUE.
   Poèet skuteènì naètených bytù udává promìnná actSize.
   Pokud bylo ètení bez chyby, promìnná err má hodnotu FALSE,
   v pøípadì chyby má hodnotu TRUE a v promìnné errID
   je uložen chybový kód. Ten mùže být použit jako
   vstupní promìnná funkce GetLastErrTxt pro získání
   textového popisu vzniklé chyby
   
  {ENU} Copy data from file to variable

   Returns
   Busy is TRUE during file reading.
   Done is TRUE when reading is finished.
   If reading failed, err output is TRUE
   and errID output contains code of error*)
  VAR_IN_OUT
    fileName         : string [80];  (*`{CSY} jméno souboru (vèetnì cesty) {ENU} file name (including path)*)
    dstVar           : udint;  (*`{CSY} adresa promìnné, do které budou uložena data pøeètená ze souboru {ENU} address of destination variable*)
  END_VAR
  VAR_INPUT
    exec             : bool;  (*`{CSY} žádost o ètení = nábìžná hrana zahájí ètení ze souboru{ENU} read request (rising edge)*)
    seek             : udint;  (*`{CSY} offset od zaèátku souboru, od kterého je ètení zahájeno {ENU} data offset in file*)
    size             : udint;  (*`{CSY} Požadovaná velikost ètených dat (poèet bytù) {ENU} data length <= size of variable (number of bytes)*)
  END_VAR
  VAR_OUTPUT
    done             : bool;  (*`{CSY} ètení ze souboru je ukonèeno {ENU} action is done*)
    busy             : bool;  (*`{CSY} probíhá ètení ze souboru {ENU} action in progress*)
    err              : bool;  (*`{CSY} pøíznak chyby pøi ètení ze souboru {ENU} error flag*)
    errID            : udint;  (*`{CSY} chybový kód (0 = bez chyby) {ENU} error number (0 = no error)*)
    actSize          : udint;  (*`{CSY} poèet skuteènì naètených bytù {ENU} number of bytes really read*)
  END_VAR
  VAR
    execTrig         : R_TRIG;
    errTrig          : R_TRIG;
    hnd              : HANDLE;
    adrVar           : udint;
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION_BLOCK WriteToFile
(*`{CSY} Pøenos dat z promìnné v PLC do souboru

   Funkèní blok zapíše obsah promìnné PLC do souboru.
   
   Funkèní blok nastaví TRUE do promìnné done v okamžiku,
   kdy se zapíše poslední blok dat do souboru.
   Bìhem zápisu dat má promìnná done hodnotu FALSE
   a promìnná busy hodnotu TRUE.
   Poèet skuteènì zapsaných bytù udává promìnná actSize.
   Pokud byl zápis do souboru bez chyby, promìnná err
   má hodnotu FALSE, v pøípadì chyby má hodnotu TRUE
   a v promìnné errID je uložen chybový kód.
   Ten mùže být použit jako vstupní promìnná funkce GetLastErrTxt
   pro získání textového popisu vzniklé chyby.
   
   {ENU} Copy data from variable to file
   
   If file does not exist new file is created.
   If file exists file content is overwitten.

   Returns
   Busy is TRUE during file writing.
   Done is TRUE when writing is finished.
   If writing failed, err output is TRUE
   and errID output contains code of error*)
  VAR_IN_OUT
    fileName         : string [80];  (*`{CSY} jméno souboru (vèetnì cesty) {ENU} file name (including path)*)
    srcVar           : udint;  (*`{CSY} adresa promìnné, jejíž obsah bude zapsán souboru {ENU} address of source variable*)
  END_VAR
  VAR_INPUT
    exec             : bool;  (*`{CSY} žádost o zápis = nábìžná hrana zahájí zápis do souboru {ENU} write request (rising edge)*)
    seek             : udint;  (*`{CSY} offset v souboru, od kterého je zahájen zápis {ENU} data offset in file*)
    size             : udint;  (*`{CSY} velikost zapisovaných dat (poèet bytù) {ENU} data length (number of bytes)*)
  END_VAR
  VAR_OUTPUT
    done             : bool;  (*`{CSY} zápis do souboru byl dokonèen {ENU} action is done*)
    busy             : bool;  (*`{CSY} probíhá zápis do souboru {ENU} action in progress*)
    err              : bool;  (*`{CSY} pøíznak chyby pøi zápisu do souboru  {ENU} error flag*)
    errID            : udint;  (*`{CSY} chybový kód (0 = bez chyby) {ENU} error number (0 = no error)*)
    actSize          : udint;  (*`{CSY} poèet skuteènì zapsaných bytù {ENU} number of bytes really written*)
  END_VAR
  VAR
    eTrig            : R_TRIG;
    errTrig          : R_TRIG;
    hnd              : HANDLE;
    adrVar           : udint;
    idle             : uint;
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION_BLOCK CreatePath
(*`{CSY} Založit adresáø (vèetnì cesty)

   Funkèní blok zkontroluje zadanou cestu a pokud neexistuje,
   tak ji na disku vytvoøí (založí potøebné adresáøe).
   Jméno cesty udává promìnná fileName.
   Kontrola bude zahájena na nábìžnou hranu promìnné exec.

   Funkèní blok nastaví TRUE do promìnné done v okamžiku,
   kdy je zadaná cesta na disku dostupná.
   Bìhem kontroly resp. vytváøení cesty má promìnná done
   hodnotu FALSE a promìnná busy hodnotu TRUE.
   Pokud bìhem práce nebyla detekována žádná chyba
   promìnná err má hodnotu FALSE, v pøípadì chyby
   má hodnotu TRUE a v promìnné errID je uložen chybový kód.
   Ten mùže být použit jako vstupní promìnná funkce GetLastErrTxt
   pro získání textového popisu vzniklé chyby.

   {ENU} Create a directory (including path)

   Check path and create it if does not exist
   
   Returns
   Busy is TRUE during path creating.
   Done is TRUE when path creating is finished.
   If path creating failed, err output is TRUE
   and errID output contains code of error*)
  VAR_INPUT
    exec             : bool;  (*`{CSY} žádost o vytvoøení cesty = nábìžná hrana zahájí kontrolu resp. vytváøení cesty {ENU} request (rising edge)*)
  END_VAR
  VAR_IN_OUT
    fileName         : string [80];  (*`{CSY} jméno adresáøe vèetnì cesty (napø. WWW/NEW_DIR/) {ENU} dir name including path (e.g. WWW/NEW_DIR/)*)
  END_VAR
  VAR_OUTPUT
    done             : bool;  (*`{CSY} cesta byla vytvoøena {ENU} action is done*)
    busy             : bool;  (*`{CSY} probíhá vytváøení cesty {ENU} action in progress*)
    err              : bool;  (*`{CSY} pøíznak chyby pøi vytváøení cesty  {ENU} error flag*)
    errID            : udint;  (*`{CSY} chybový kód (0 = bez chyby) {ENU} error number (0 = no error)*)
  END_VAR
  VAR
    eTrig            : R_TRIG;  (*`rising edge of exec*)
    errTrig          : R_TRIG;  (*`rising edge of err*)
    createDir        : bool;
    path             : string [80];
    copy             : string [80];
    idle             : uint;
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION_BLOCK WriteDbxToFile
(*`{CSY} Pøenos dat z pamìti DataBox do souboru

   Funkèní blok zapíše obsah pamìti DataBox do souboru.
   Pokud soubor neexistuje, tak je vytvoøen.
   Pokud soubor existuje, jeho obsah je pøepsán.
   Funkèní blok je podporován na CPM øady K od verze 4.5.
   
   Funkèní blok nastaví TRUE do promìnné done v okamžiku,
   kdy se zapíše poslední blok dat do souboru.
   Bìhem zápisu dat má promìnná done hodnotu FALSE
   a promìnná busy hodnotu TRUE.
   Poèet skuteènì zapsaných bytù udává promìnná actSize.
   Pokud byl zápis do souboru bez chyby,
   promìnná err má hodnotu FALSE,
   v pøípadì chyby má hodnotu TRUE a v promìnné errID
   je uložen chybový kód. Ten mùže být použit jako
   vstupní promìnná funkce GetLastErrTxt pro získání
   textového popisu vzniklé chyby.

   {ENU} Copy data from databox to file
   
   If file does not exist new file is created.
   If file exists file content is overwitten.
   Supported on CPM type K version 4.5 and higher

   Returns
   Busy is TRUE during file writing.
   Done is TRUE when writing is finished.
   If writing failed, err output is TRUE
   and errID output contains code of error*)
  VAR_IN_OUT
    fileName         : string [80];  (*`{CSY} jméno souboru (vèetnì cesty) {ENU} file name (including path)*)
  END_VAR
  VAR_INPUT
    exec             : bool;  (*`{CSY} žádost o zápis = nábìžná hrana zahájí zápis do souboru{ENU} request (rising edge)*)
    seek             : udint;  (*`{CSY} offset v souboru, od kterého je zahájen zápis {ENU} data offset in file*)
    srcAdr           : udint;  (*`{CSY} adresa v DataBoxu, kde zaèínají data, která budou uložena do souboru {ENU} databox address*)
    size             : udint;  (*`{CSY} velikost zapisovaných dat (poèet bytù) {ENU} data length (number of bytes)*)
  END_VAR
  VAR_OUTPUT
    done             : bool;  (*`{CSY} dokonèen zápis do souboru {ENU} action is done*)
    busy             : bool;  (*`{CSY} probíhá zápis do souboru {ENU} action in progress*)
    err              : bool;  (*`{CSY} pøíznak chyby pøi zápisu do souboru {ENU} error flag*)
    errID            : udint;  (*`{CSY} chybový kód (0 = bez chyby) {ENU} error number (0 = no error)*)
    actSize          : udint;  (*`{CSY} poèet skuteènì zapsaných bytù {ENU} number of bytes really written*)
  END_VAR
  VAR
    eTrig            : R_TRIG;
    errTrig          : R_TRIG;
    hnd              : HANDLE;
    adrVar           : udint;
    idle             : uint;
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION_BLOCK ReadDbxFromFile
(*`{CSY} Pøenos dat ze souboru do pamìti DataBox

   Funkèní blok pøeète data ze souboru a uloží je do pamìti DataBox.
   Funkèní blok je podporován na CPM øady K od verze 4.5.

   Funkèní blok nastaví TRUE do promìnné done v okamžiku,
   kdy se naète poslední blok dat ze souboru.
   Bìhem naèítání dat má promìnná done hodnotu FALSE
   a promìnná busy hodnotu TRUE.
   Poèet skuteènì naètených bytù udává promìnná actSize.
   Pokud bylo ètení bez chyby, promìnná err má hodnotu FALSE,
   v pøípadì chyby má hodnotu TRUE a v promìnné errID je uložen
   chybový kód. Ten mùže být použit jako vstupní promìnná funkce
   GetLastErrTxt pro získání textového popisu vzniklé chyby.

   {ENU} Copy data from a file to DataBox memory

   Copy data from file to databox
   Supported on CPM type K version 4.5 and higher

   Returns
   Busy is TRUE during file reading.
   Done is TRUE when reading is finished.
   If reading failed, err output is TRUE
   and errID output contains code of error*)
  VAR_IN_OUT
    fileName         : string [80];  (*`{CSY} jméno souboru (vèetnì cesty) {ENU} file name (including path)*)
  END_VAR
  VAR_INPUT
    exec             : bool;  (*`{CSY} žádost o ètení = nábìžná hrana zahájí ètení ze souboru {ENU} request (rising edge)*)
    seek             : udint;  (*`{CSY} offset od zaèátku souboru, od kterého je zahájeno ètení {ENU} data offset in file*)
    dstAdr           : udint;  (*`{CSY} adresa DataBoxu, od které budou uložena data pøeètená ze souboru {ENU} databox address*)
    size             : udint;  (*`{CSY} velikost ètených dat (poèet bytù) {ENU} data length <= size of variable (number of bytes)*)
  END_VAR
  VAR_OUTPUT
    done             : bool;  (*`{CSY} ètení ze souboru je ukonèeno {ENU} action is done*)
    busy             : bool;  (*`{CSY} probíhá ètení ze souboru {ENU} action in progress*)
    err              : bool;  (*`{CSY} pøíznak chyby pøi ètení ze souboru {ENU} error flag*)
    errID            : udint;  (*`{CSY} {CSY} chybový kód (0 = bez chyby) {ENU} error number (0 = no error)*)
    actSize          : udint;  (*`{CSY} poèet skuteènì naètených bytù {ENU} number of bytes really read*)
  END_VAR
  VAR
    execTrig         : R_TRIG;
    errTrig          : R_TRIG;
    hnd              : HANDLE;
    adrVar           : udint;
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION_BLOCK WriteToFileSeq
(*`{CSY} Sekvenèní zápis dat do souboru

   Funkèní blok zapíše obsah promìnné PLC do souboru pøi každém volání,
   kdy je promìnná write nastavena na hodnotu TRUE.
   Data jsou zapisována sekvenènì za sebe, až do doby
   než je soubor uzavøen nastavení vstupu close na hodnotu TRUE.

   Promìnné open signalizuje, že je otevøen soubor pro zápis
   a bude jej nutné pøi nebo po posledním zápisu nastavením
   vstupu close zavøít.
   Poèet všech zapsaných bytù udává promìnná actSize.
   Pokud byl zápis do souboru bez chyby, promìnná err má hodnotu FALSE,
   v pøípadì chyby má hodnotu TRUE a v promìnné errID je uložen chybový kód.
   Ten mùže být použit jako vstupní promìnná funkce GetLastErrTxt
   pro získání textového popisu vzniklé chyby.

   {ENU} Sequential write data to file

   Copy data from variable to file sequentaly each time
   the write variable is set to true.
   If file does not exist new file is created.
   If file exists file content is overwitten.

   Returns
   Open is TRUE whyn file is open.
   If writing failed, err output is TRUE
   and errID output contains code of error*)
  VAR_IN_OUT
    fileName         : string [80];  (*`{CSY} jméno souboru (vèetnì cesty) {ENU} file name (including path)*)
    srcVar           : udint;  (*`{CSY} adresa promìnné, jejíž obsah bude zapsán souboru {ENU} address of source variable*)
  END_VAR
  VAR_INPUT
    write            : bool;  (*`{CSY} žádost o zápis do souboru {ENU} request*)
    close            : bool;  (*`{CSY} žádost o uzavøení souboru {ENU} close opened file*)
    size             : udint;  (*`{CSY} velikost zapisovaných dat (poèet bytù) {ENU} data length (number of bytes)*)
  END_VAR
  VAR_OUTPUT
    open             : bool;  (*`{CSY} soubor je aktuálnì otevøen pro zápis {ENU} file is open, next data will be appended to rest*)
    err              : bool;  (*`{CSY} pøíznak chyby pøi zápisu do souboru {ENU} error flag*)
    errID            : udint;  (*`{CSY} chybový kód (0 = bez chyby) {ENU} error number (0 = no error)*)
    actSize          : udint;  (*`{CSY} aktuální velikost souboru (poèet bytù) {ENU} actual file size (number of bytes)*)
  END_VAR
  VAR
    errTrig          : R_TRIG;
    wrSize           : udint;
    hnd              : HANDLE;
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION_BLOCK DeleteDirectories
(*`{CSY} Vymazat obsah adresáøe vèetnì obsahu vložených podadresáøù

   Smaže všechny soubory v adresáøi.
   Max. poèet vnoøených podadresáøù = 4

   {ENU} Delete content of directory including content of nested directories

   Delete all files in directory.
   Max. number of nested directories = 4*)
  VAR_INPUT
    exec             : bool R_EDGE;  (*`{CSY} žádost o smazání {ENU} request (rising edge)*)
  END_VAR
  VAR_IN_OUT
    dirName          : string [80];  (*`{CSY} jméno adresáøe (vèetnì cesty) {ENU} dir name (including path)*)
  END_VAR
  VAR
    dirStack         : ARRAY [0..8] OF TDirStack;
    CurrFile         : string [80];
    dirStackLev      : usint;
    i                : usint;
    lLocalFileInfo   : TFileInfo;
  END_VAR
  VAR_OUTPUT
    Done             : bool;
    Busy             : bool;
    Err              : bool;
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION_BLOCK ReadLine
(*`{CSY} Naète jeden øádek ze souboru
        Èíslo požadovaného øádku v souboru udává vstupní promìnná line.
        První øádek v souboru má èíslo 1.
        Požadovaný øádek je zapsán do promìnné txtLine vèetnì znakù CR a LF.
        Promìnná txtLine musí být typu STRING s délkou rovnou nebo vìtší než maxLen.
        Hledání øádku v souboru mùže trvat více cyklù PLC.
        Bìhem hledání je výstup busy nastaven na TRUE,
        pøi nalezení øádku se nastaví výstup done na TRUE (na 1 cykl PLC).
        Pokud je øádek delší než maxLen znakù, je nastaven výstup lineContinues
        a øádek je pøedáván po èástech, každý cykl jedna èást, poslední
        èást má výstup lineContinues nastaven na FALSE
        (výstup done je nastaven na TRUE u všech èástí dlouhého øádku).
        Pokud vznikne nìjaká chyba pøi ètení souboru je nastaven chybový
        kód do výstupu errID a promìnná errTxt obsahuje popis chyby.
        Funkèní blok ReadLine pøedpokládá, že øádky v souboru konèí znaky CRLF (16#0D,16#0A).
  {ENU} Read line from file
        Number of desired line is defined by input line.
        First line in file has number 1.
        Desired line is stored in variable txtLine including characters CR and LF.
        Variable txtLine have to be of type STRING with lenght equal or greater than maxLen.
        Finding of line in file may take more than one PLC cycle.
        Output busy is set to TRUE during searching.
        When line is found, outpud done is set to TRUE (for one cycle of PLC).
        If the line is longer than maxLen, output lineContinues is set and line is passed in multiple parts.
        Every PLC cycle one part of line is passed, last part is passed with lineContinues set to FALSE.
        (Output done is set to TRUE during passing of all parts).
        If there is any error, output errID contains error code and output errTxt description of error.
        Function block ReadLine assume that lines ends with characters CRLF (16#0D,16#0A).*)
  VAR_INPUT
    line             : udint;  (*`{CSY} Èíslo žádaného øádku (1..n)    {ENU} Number of requested line (1..n)*)
    maxLen           : udint;  (*`{CSY} Maximalní délka øádku          {ENU} Maximal length of line*)
  END_VAR
  VAR_IN_OUT
    fileName         : string [80];  (*`{CSY} Jméno souboru i s cestou       {ENU} Filename (including path)*)
    txtLine          : string [255];  (*`{CSY} Naètený øádek ze souboru       {ENU} Line from file*)
  END_VAR
  VAR_OUTPUT
    done             : bool;  (*`{CSY} Ètení ze souboru je ukonèeno   {ENU} Reading from a file is closed*)
    busy             : bool;  (*`{CSY} Zaneprázdnìn ètením ze souboru {ENU} Busy reading from a file*)
    err              : bool;  (*`{CSY} Pøíznak chyby                  {ENU} Error flag*)
    lineContinues    : bool;  (*`{CSY} Øádek byl delší než maximální délka a bude pokraèovat {ENU} Line was longer than maximum lenght and will continue*)
    actLine          : udint;  (*`{CSY} Èíslo aktuálnì naèteného øádku {ENU} Actual line number*)
    errID            : udint;  (*`{CSY} Chybový kód (0 = bez chyby)    {ENU} Error code (0 = no error)*)
    errTxt           : string [80];  (*`{CSY} Text poslední chyby            {ENU} The last error text*)
  END_VAR
  VAR
    lastLine         : udint;  (*`cislo naposled hledaneho radku*)
    lastFile         : string [80];  (*`jmeno souboru, se kterym se naposledy pracovalo*)
    actPos           : udint;  (*`aktualni pozice v souboru (offset od zacatku)*)
    actSize          : udint;  (*`pocet znaku nactenych ze souboru*)
    i                : int;
    index            : int;
    outidx           : uint;
    bufTxtReady      : bool;
    newFile          : bool;
    newFileTest      : bool;
    fileInf          : TFileInfo;  (*`struktura s informacemi o souboru*)
    empty            : word;
    ReadFile         : ReadFromFile;
  END_VAR
  VAR CONSTANT
    SEPARATOR        : ARRAY [0..1] OF byte :=  [ 16#0A, 0];
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION DisconnectUsbDisk : bool
(*`{CSY} Odpojit USB Flash disk (pouze pro CP-2xxx)

   {ENU} Unmounting USB Flash disk (CP-2xxx only)*)
END_FUNCTION

TYPE TListDirStackItem {HIDDEN} :
  STRUCT
    hd               : HANDLE;  (*`handle pro ReadDir*)
    ls               : uint;  (*`delka subName*)
  END_STRUCT;
END_TYPE

__DECL FUNCTION_BLOCK ListDirectories
(*`{ENU} Examines the contents of the directory and returns information about all entries (including the contents of all subdirectories)
  {CSY} Prozkoumá obsah daného adresáøe a vrátí postupnì informace o všech položkách v adresáøi (vèetnì obsahu všech podadresáøù)*)
  VAR_INPUT
    exec             : bool R_EDGE;  (*`{ENU} Request to explore directory {CSY} Žádost o prozkoumání adresáøe*)
    noSubDir         : bool;  (*`{ENU} Not to explore subdirectories {CSY} Neprocházet podadresáøe*)
    cancel           : bool R_EDGE;  (*`{ENU} Cancel exploring the directory and release any handle used {CSY} Zrušit prozkoumávání adresáøe a uvolnit všechny používané handly*)
    dirName          : string [80];  (*`{ENU} Directory name {CSY} Název zkoumaného adresáøe*)
  END_VAR
  VAR_OUTPUT
    done             : bool;  (*`{ENU} Directory examination complete {CSY} Prozkoumání adresáøe je dokonèeno*)
    busy             : bool;  (*`{ENU} Directory search continues {CSY} Prùzkum adresáøe pokraèuje*)
    err              : bool;  (*`{ENU} Error flag {CSY} Pøíznak chyby*)
    found            : bool;  (*`{ENU} Item (file or directory) found {CSY} Byla nalezena položka (soubor nebo adresáø)*)
    isDir            : bool;  (*`{ENU} The found item is a directory {CSY} Nalezená položka je adresáø*)
    isDirEmpty       : bool;  (*`{ENU} The item is an empty directory {CSY} Položka je prázdný adresáø*)
    fileInfo         : TFileInfo2;  (*`{ENU} Information about the found item {CSY} Informace o nalezené položce*)
  END_VAR
  VAR CONSTANT
    MAX_STACK_SIZE   : uint :=  32;
    AM_DIR           : dword := 16#10;  (*`attribute == Directory*)
  END_VAR
  VAR
    subName          : string [80];
    lastDir          : string [80];
    hd               : HANDLE;
    hdStack          : ARRAY [0..32] OF TListDirStackItem;
    i                : uint;
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION_BLOCK ListDirectoriesLog
(*`{ENU} Records activity of function block ListDirectories() into log file
  {CSY} Záznam èinnosti funkèního bloku ListDirectories() do log souboru*)
  VAR_INPUT
    logName          : string [80];  (*`{ENU} Log file name (including path) {CSY} Název log souboru (vèetnì cesty)*)
  END_VAR
  VAR_IN_OUT
    fbListDir        : ListDirectories;  (*`{ENU} Function block ListDirectories() whose activity is logged in the file {CSY} Funkèní blok ListDirectories() jehož èinnost je zaznamenána do log souboru*)
  END_VAR
  VAR_OUTPUT
    cnt              : uint;  (*`{ENU} Total count of items in directory {CSY} Celkový poèet položek v adresáøi*)
    usedSpace        : udint;  (*`{ENU} Total occupied space {CSY} Celkovì obsazené místo*)
  END_VAR
  VAR
    hf               : HANDLE;
    line             : string [255];
    startDT          : dt;
    stopDT           : dt;
    TrgBusy          : R_TRIG;
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION_BLOCK ReadLastLines
(*`{CSY}Funkce naète daný poèet øádkù od konce souboru (nebo od zadaného offsetu)
{ENU}Function retrieves a given number of lines from the end of the file (or from the specified offset)*)
  VAR_INPUT
    read             : bool R_EDGE;  (*`{CSY} spustit naètení øádkù {ENU} start lines reading*)
    lineNum          : udint;  (*`{CSY} poèet øádkù, které se chtìjí naèíst {ENU} number of lines to be read*)
    sizeOfArray      : udint;  (*`{CSY} velikost pole STRINGù v bytech, do kterého se øákdy naètou {ENU} size of array of STRING in bytes used to store read lines*)
    offset           : udint;  (*`{CSY} posunutí od konce v bytech (lze pøiøadit výstup linesOffset pokud se chce naèíst další øádky) {ENU} offset from end of file in bytes (linesOffset output can be assigned to retrieve additional lines)*)
  END_VAR
  VAR_OUTPUT
    done             : bool;  (*`{CSY} øádky se úspìšnì naèetly {ENU} lines successfully loaded*)
    busy             : bool;  (*`{CSY} probíhá ètení {ENU} reading in progress*)
    err              : bool;  (*`{CSY} pøíznak chyby pøi ètení ze souboru {ENU} error flag when reading from file*)
    linesOffset      : udint;  (*`{CSY} zaèátek pøeètených øádkù od konce souboru {ENU} the beginning of the read lines from the end of the file*)
    linesRead        : udint;  (*`{CSY} poèet opravdu pøeètených øádkù {ENU} the number of lines actually read*)
    errID            : udint;  (*`{CSY} chybový kód (0 = bez chyby) {ENU} error number (0 = no error)*)
    errTxt           : string [80];  (*`{CSY} popis chyby {ENU} description of error*)
  END_VAR
  VAR_IN_OUT
    fileName         : string [80];  (*`{CSY} jméno souboru i s cestou       {ENU} filename (including path)*)
    txtLines         : string [255];  (*`{CSY} pole STRINGù pro naètené øádky {ENU} array of STRING for read lines*)
  END_VAR
  VAR
    fSize            : udint;
    rSize            : udint;
    fPos             : udint;
    lineCnt          : udint;  (*`pocet napocitanych strane*)
    buffer           : ARRAY [0..255] OF usint;  (*`pracovni pole*)
    h                : HANDLE;
    state            : udint;
    p                : PTR_TO usint;
    pb               : PTR_TO usint;
    start            : udint;
    lEndOffset       : udint;
    endOfFile        : bool;
    maxLineLen       : udint;
    pString          : PTR_TO string [255];
  END_VAR
  VAR CONSTANT
    SEPARATOR        : string [2] :=  '$0A';
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION_BLOCK DeleteOldFiles
(*`{ENU} Examines the contents of the directory (including the contents of all subdirectories) and deletes all files that are older than the specified number of days and whose extension matches the specified mask
  {CSY} Prozkoumá obsah daného adresáøe (vèetnì obsahu všech podadresáøù) a vymaže postupnì všechny soubory, které jsou starší než zadaný poèet dnù a jejich pøípona odpovídá zadané masce*)
  VAR_INPUT
    exec             : bool R_EDGE;  (*`{ENU} Request to delete old files from directory {CSY} Žádost o odstranìní starých souborù z adresáøe*)
    delEmptyDir      : bool;  (*`{ENU} Delete empty directories too {CSY} Odstranit také prázdné adresáøe*)
    noSubDir         : bool;  (*`{ENU} Not to explore subdirectories {CSY} Neprocházet podadresáøe*)
    testOnly         : bool;  (*`{ENU} Without deleting old files and empty directories {CSY} Bez odstranìní starých souborù a prázdných adresáøe*)
    dirName          : string [80];  (*`{ENU} Directory name (case sensitive) {CSY} Název adresáøe (velikost písmen je dùležitá)*)
    fileMask         : string [80];  (*`{ENU} Mask for selection of files to be deleted (wildcard is '*') {CSY} Maska pro výbìr odstraòovaných souborù ('*' znamená všechny soubory)*)
    lifeTime         : udint;  (*`{ENU} File life time (number of days) {CSY} Životnost souboru (poèet dní)*)
  END_VAR
  VAR_OUTPUT
    done             : bool;  (*`{ENU} Deleting old files from the directory is complete {CSY} Mazání starých souborù z adresáøe je dokonèeno*)
    busy             : bool;  (*`{ENU} Deleting old files continues {CSY} Mazání starých souborù pokraèuje*)
    err              : bool;  (*`{ENU} Error flag {CSY} Pøíznak chyby*)
    isDeleted        : bool;  (*`{ENU} Old file is deleted {CSY} Starý soubor je odstranìn*)
    fileInfo         : TFileInfo2;  (*`{ENU} Information about the deleted file {CSY} Informace o smazaném souboru*)
  END_VAR
  VAR
    actDate          : dt;
    ListDir          : ListDirectories;
    fileDays         : udint;
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION_BLOCK DeleteOldFilesLog
(*`{ENU} Records activity of function block DeleteOldFilesLog() into log file
  {CSY} Záznam èinnosti funkèního bloku DeleteOldFilesLog() do log souboru*)
  VAR_INPUT
    append           : bool;  (*`{ENU} Add the log to the end of the log file {CSY} Záznam pøidávat na konec log souboru*)
    logName          : string [80];  (*`{ENU} Log file name (including path) {CSY} Název log souboru (vèetnì cesty)*)
  END_VAR
  VAR_IN_OUT
    fbDeleteOldFiles : DeleteOldFiles;  (*`{ENU} Function block DeleteOldFiles() whose activity is logged in the file {CSY} Funkèní blok DeleteOldFiles() jehož èinnost je zaznamenána do log souboru*)
  END_VAR
  VAR_OUTPUT
    cnt              : uint;  (*`{ENU} Total count of deleted items {CSY} Celkový poèet smazaných položek*)
    deletedSpace     : udint;  (*`{ENU} Total size of deleted files {CSY} Celková velikost vymazaných souborù*)
  END_VAR
  VAR
    hf               : HANDLE;
    line             : string [255];
    startDT          : dt;
    stopDT           : dt;
    TrgBusy          : R_TRIG;
  END_VAR
  VAR CONSTANT
    AM_DIR           : dword := 16#10;  (*`attribute == Directory*)
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION_BLOCK DeleteSurplusFiles
(*`{ENU} Examines the contents of the directory (including the contents of all subdirectories) and calculates the occupied space. If more than the specified maximum is occupied, it gradually deletes the oldest files (with the name corresponding to the specified mask) until the occupied space falls below the specified limit
  {CSY} Prozkoumá obsah daného adresáøe (vèetnì obsahu všech podadresáøù) a spoèítá obsazené místo. Pokud je obsazeno více než zadané maximum, tak postupnì maže nejstarší soubory (s názvem odpovídajícím zadané masce) tak dlouho, až obsazené místo klesne pod zadanou mez*)
  VAR_INPUT
    exec             : bool R_EDGE;  (*`{ENU} Request to delete surplus files from directory {CSY} Žádost o odstranìní nadbyteèných souborù z adresáøe*)
    delEmptyDir      : bool;  (*`{ENU} Delete empty directories too {CSY} Odstranit také prázdné adresáøe*)
    noSubDir         : bool;  (*`{ENU} Not to explore subdirectories {CSY} Neprocházet podadresáøe*)
    dirName          : string [80];  (*`{ENU} Directory name (case sensitive) {CSY} Název adresáøe (velikost písmen je dùležitá)*)
    fileMask         : string [80];  (*`{ENU} Mask for selection of files to be deleted (wildcard is '*') {CSY} Maska pro výbìr odstraòovaných souborù ('*' znamená všechny soubory)*)
    maxSpace         : udint;  (*`{ENU} Max used space (number of bytes) {CSY} Max obsazené místo (poèet bytù)*)
  END_VAR
  VAR_OUTPUT
    done             : bool;  (*`{ENU} Deleting surplus files from the directory is complete {CSY} Mazání nadbyteèných souborù z adresáøe je dokonèeno*)
    busy             : bool;  (*`{ENU} Deleting surplus files continues {CSY} Mazání nadbyteèných souborù pokraèuje*)
    err              : bool;  (*`{ENU} Error flag {CSY} Pøíznak chyby*)
    isDeleted        : bool;  (*`{ENU} Surplus file is deleted {CSY} Nadbyteèný soubor je odstranìn*)
    fileInfo         : TFileInfo2;  (*`{ENU} Information about the deleted file {CSY} Informace o smazaném souboru*)
  END_VAR
  VAR
    TrgRqCheck       : R_TRIG;
    ListDir          : ListDirectories;
    oldestFile       : TFileInfo2;
    usedSpace        : udint;
    nextRound        : bool;
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION_BLOCK DeleteSurplusFilesLog
(*`{ENU} Records activity of function block DeleteSurplusFiles() into log file
  {CSY} Záznam èinnosti funkèního bloku DeleteSurplusFiles() do log souboru*)
  VAR_INPUT
    append           : bool;  (*`{ENU} Add the log to the end of the log file {CSY} Záznam pøidávat na konec log souboru*)
    logName          : string [80];  (*`{ENU} Log file name (including path) {CSY} Název log souboru (vèetnì cesty)*)
  END_VAR
  VAR_IN_OUT
    fbDeleteSurplusFiles : DeleteSurplusFiles;  (*`{ENU} Function block DeleteSurplusFiles() whose activity is logged in the file {CSY} Funkèní blok DeleteSurplusFiles() jehož èinnost je zaznamenána do log souboru*)
  END_VAR
  VAR_OUTPUT
    cnt              : uint;  (*`{ENU} Total count of deleted items {CSY} Celkový poèet smazaných položek*)
    deletedSpace     : udint;  (*`{ENU} Total size of deleted files {CSY} Celková velikost vymazaných souborù*)
  END_VAR
  VAR
    hf               : HANDLE;
    line             : string [255];
    startDT          : dt;
    stopDT           : dt;
    TrgBusy          : R_TRIG;
  END_VAR
  VAR CONSTANT
    AM_DIR           : dword := 16#10;  (*`attribute == Directory*)
  END_VAR
END_FUNCTION_BLOCK

TYPE T_ZIP_LIST_TYPE : 
  (LIST_OF_INCLUDE_FILES,
   LIST_OF_EXCLUDE_FILES 
  );
END_TYPE

__DECL FUNCTION_BLOCK ZipArchive
(*`{CSY} ZipArchive zkomprimuje soubory do archivu.
   {ENU} ZipArchive stores files in zip archives.*)
  VAR_INPUT
    exec             : bool R_EDGE;  (*`{CSY} žádost o vytvoøení archivu {ENU} request to create zip archive*)
    incSubDir        : bool;  (*`{CSY} vnoøovat se do podadresáøù {ENU} recurse into directories*)
    delOrigFiles     : bool;  (*`{CSY} po vytvoøení archivu smazat pùvodní soubory (pøesun souborù do archivu){ENU} after archive created, delete original files (move into archive)*)
    junkDirNames     : bool;  (*`{CSY} v archivu vynechat názvy adresáøù (uložit pouze názvy souborù){ENU} junk directory names (store just file names)*)
    createNewArch    : bool;  (*`{CSY} vytvoøit nový zip archiv (TRUE) nebo obèerstvit existující (FALSE) {ENU} create new zip archive (TRUE) or update existing archive (FALSE)*)
    createLog        : bool;  (*`{CSY} vytváøet log soubor {ENU} create log file*)
    zipName          : string [80];  (*`{CSY} název archivu {ENU} archive name*)
    dirName          : string [80];  (*`{CSY} název adresáøe, ze kterého budeme archivovat soubory {ENU} directory name*)
    listType         : T_ZIP_LIST_TYPE;  (*`{CSY} urèuje, jestli fileList specifikuje soubory, které budou zahrnuté do archivu (LIST_OF_INCLUDE_FILES) nebo naopak soubory, které do archivu zahrnuté nebudou (LIST_OF_EXCLUDE_FILES) {ENU} fileList consists included files (LIST_OF_INCLUDE_FILES) or fileList consists excluded files (LIST_OF_EXCLUDE_FILES)*)
    fileList         : string [255];  (*`{CSY} seznam souborù (mùže obsahovat zástupné znaky '?' a '*'){ENU} list of files (wildcards '?' and '*' can be used)*)
  END_VAR
  VAR_OUTPUT
    done             : bool;  (*`{CSY} zip archiv byl úspìšnì vytvoøen {ENU} zip archive was successfully created*)
    busy             : bool;  (*`{CSY} probíhá vytváøení archivu {ENU} creating archive continues*)
    err              : bool;  (*`{CSY} došlo k chybì {ENU} error flag*)
    errTx            : string [128];  (*`{CSY} popis chyby {ENU} error description*)
    numItems         : udint;  (*`{CSY} poèet zpracovaných položek {ENU} number of processed items*)
  END_VAR
  VAR
    zipTim           : TON;
    hf               : HANDLE;
    zipLog           : string [80];
    line             : string [255];
    lastCyc          : usint;
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION_BLOCK UnzipArchive
(*`{CSY} UnzipArchive rozbalí soubory ze zip archivu.
   {ENU} UnzipArchive extracts files from zip archive.*)
  VAR_INPUT
    exec             : bool R_EDGE;  (*`{CSY} žádost o rozbalení archivu {ENU} request to extract zip archive*)
    overwrite        : bool;  (*`{CSY} pøepisovat soubory {ENU} overwrite files*)
    createLog        : bool;  (*`{CSY} vytváøet log soubor {ENU} create log file*)
    zipName          : string [80];  (*`{CSY} název archivu {ENU} archive name*)
    extractIntoDir   : string [255];  (*`{CSY} název adresáøe, do kterého se rozbalí soubory z archivu {ENU} extract files into directory*)
  END_VAR
  VAR_OUTPUT
    done             : bool;  (*`{CSY} zip archiv byl úspìšnì rozbalen {ENU} zip archive was successfully extracted*)
    busy             : bool;  (*`{CSY} probíhá rozbalování archivu {ENU} extracting archive continues*)
    err              : bool;  (*`{CSY} došlo k chybì {ENU} error flag*)
    errTx            : string [128];  (*`{CSY} popis chyby {ENU} error description*)
    numItems         : udint;  (*`{CSY} poèet zpracovaných položek {ENU} number of processed items*)
  END_VAR
  VAR
    zipTim           : TON;
    hf               : HANDLE;
    lastCyc          : usint;
    zipLog           : string [80];
    line             : string [255];
  END_VAR
END_FUNCTION_BLOCK



{USES=ReadFromFile:FileOpen,FileSetPos,FileRead,FileSize,GetLastErr,FileClose}
{USES=WriteToFile:FileClose,FileOpen,FileSetPos,FindFreeCluster,FileWrite,GetLastErr}
{USES=CreatePath:FileExists,FindFreeCluster,DirCreate,GetLastErr}
{USES=WriteDbxToFile:FileClose,FileOpen,FileSetPos,FindFreeCluster,FileWrite,GetLastErr}
{USES=ReadDbxFromFile:FileOpen,FileSetPos,FileRead,GetLastErr,FileClose}
{USES=WriteToFileSeq:FileOpen,FileWrite,FileClose,GetLastErr}
{USES=DeleteDirectories:DirClose,DirOpen,FileDelete,DirRead}
{USES=ReadLine:FileInfo,GetLastErrTxt}
{USES=ListDirectories:Memset,DirOpen,DirRead,DirClose}
{USES=ListDirectoriesLog:GetDateTime,FileClose,FileOpen,DT_TO_STRINGF,FileWrite,UDINT_TO_STRINGF,UINT_TO_STRINGF,SUB_DT_DT,TIME_TO_STRINGF}
{USES=ReadLastLines:FileOpen,FileSize,GetLastErr,GetLastErrTxt,FileSetPos,FileRead,FileClose}
{USES=DeleteOldFiles:GetDateTime,Memset,FileDelete,DirDelete}
{USES=DeleteOldFilesLog:GetDateTime,FileClose,FileOpen,DT_TO_STRINGF,FileWrite,UDINT_TO_STRINGF,UINT_TO_STRINGF,SUB_DT_DT,TIME_TO_STRINGF}
{USES=DeleteSurplusFiles:Memset,DirDelete,FileDelete}
{USES=DeleteSurplusFilesLog:GetDateTime,FileClose,FileOpen,DT_TO_STRINGF,FileWrite,UDINT_TO_STRINGF,UINT_TO_STRINGF,SUB_DT_DT,TIME_TO_STRINGF}
{USES=ZipArchive:FileOpen,GetDateTime,DT_TO_STRINGF,FileWrite,FileClose,FileSize,FileSetPos,Memset,FileDelete,FileRead,MemsetEx}
{USES=UnzipArchive:FileOpen,GetDateTime,DT_TO_STRINGF,FileWrite,FileClose,FileSize,FileSetPos,Memset,FileDelete,FileRead,MemsetEx}
#srcfile 'C:\TECOLIBSRC\FILELIB\FILELIB\FILELIB.ST'


 

#srcfile ''
#srcfile 'C:\TECOLIBSRC\FILELIB\FILELIB\FC_FILEOPEN.ST'
#pou FileOpen
#srcline 19 ;FUNCTION FileOpen : HANDLE

#struct FileOpen__temp__
  HANDLE tmp  ; {CSY} identifikátor souboru {ENU} file identificator
P     61
FileOpen_L0:
 LINK __SizeOf(FileOpen__temp__)
 NXT
; Initialize - dynamic variables
; End initialize - dynamic variables
#srcline 71 ;begin
#srcline 72 ;  {asm}
#srcline 73
       LDX  fileName       ; A1
#srcline 74
       LDX  mode           ; A0
#srcline 75
       SYS  40             ; Api_CreateFile()
#srcline 76
       WRY  tmp
#srcline 77 ;  {end_asm}
#srcline 78 ;  FileOpen := tmp;
 LDY  tmp
#debug udint tmp
 WRX  __fc__FileOpen
#debug_left udint FileOpen
#srcline 79 ;END_FUNCTION
 PRV  
 LDX  __fc__FileOpen
 ULNK
RET
E     61
#endpou 



 

#srcfile ''
#srcfile 'C:\TECOLIBSRC\FILELIB\FILELIB\FC_FILECLOSE.ST'
#pou FileClose
#srcline 3 ;FUNCTION FileClose : BOOL

#struct FileClose__temp__
  bool tmp
P     61
FileClose_L0:
 LINK __SizeOf(FileClose__temp__)
 NXT
; Initialize - dynamic variables
; End initialize - dynamic variables
#srcline 27 ;begin
#srcline 28 ;  {asm}
#srcline 29
       LD   350
#srcline 30
       SYS  25             ; increase max cycle time
#srcline 31
       LDX  hFile          ; A0
#srcline 32
       SYS  41             ; Api_CloseHandle()
#srcline 33
       WRY   tmp
#srcline 34 ;  {end_asm}
#srcline 35 ;  FileClose := tmp;
 LDY  tmp
#debug bool tmp
 WRX  __fc__FileClose
#debug_left bool FileClose
#srcline 36 ;END_FUNCTION
 PRV  
 LDX  __fc__FileClose
 ULNK
RET
E     61
#endpou 



 

#srcfile ''
#srcfile 'C:\TECOLIBSRC\FILELIB\FILELIB\FC_FILEDELETE.ST'
#pou FileDelete
#srcline 3 ;FUNCTION FileDelete : BOOL

#struct FileDelete__temp__
  bool tmp
P     61
FileDelete_L0:
 LINK __SizeOf(FileDelete__temp__)
 NXT
; Initialize - dynamic variables
; End initialize - dynamic variables
#srcline 29 ;begin
#srcline 30 ;  {asm}
#srcline 31
       LDX  fileName       ; A0
#srcline 32
       SYS  42             ; Api_DeleteFile()
#srcline 33
       WRY  tmp
#srcline 34 ;  {end_asm}
#srcline 35 ;  FileDelete := tmp;
 LDY  tmp
#debug bool tmp
 WRX  __fc__FileDelete
#debug_left bool FileDelete
#srcline 36 ;END_FUNCTION
 PRV  
 LDX  __fc__FileDelete
 ULNK
RET
E     61
#endpou 



 

#srcfile ''
#srcfile 'C:\TECOLIBSRC\FILELIB\FILELIB\FC_FILEREAD.ST'
#pou FileRead
#srcline 3 ;FUNCTION FileRead : UDINT

#struct FileRead__temp__
  udint tmp
P     61
FileRead_L0:
 LINK __SizeOf(FileRead__temp__)
 NXT
; Initialize - dynamic variables
; End initialize - dynamic variables
#srcline 33 ;begin
#srcline 34 ;  {asm}
#srcline 35
       LDX  hFile          ; A2
#srcline 36
       LDX  adrBuf         ; A1
#srcline 37
       LDX  size           ; A0
#srcline 38
       SYS  43             ; Api_ReadFile()
#srcline 39
       WRY  tmp
#srcline 40 ;  {end_asm}
#srcline 41 ;  FileRead := tmp;
 LDY  tmp
#debug udint tmp
 WRX  __fc__FileRead
#debug_left udint FileRead
#srcline 42 ;END_FUNCTION
 PRV  
 LDX  __fc__FileRead
 ULNK
RET
E     61
#endpou 



 

#srcfile ''
#srcfile 'C:\TECOLIBSRC\FILELIB\FILELIB\FC_FILEWRITE.ST'
#pou FileWrite
#srcline 3 ;FUNCTION FileWrite : UDINT

#struct FileWrite__temp__
  udint tmp
P     61
FileWrite_L0:
 LINK __SizeOf(FileWrite__temp__)
 NXT
; Initialize - dynamic variables
; End initialize - dynamic variables
#srcline 36 ;begin
#srcline 37 ;  {asm}
#srcline 38
       LDX  hFile          ; A2
#srcline 39
       LDX  adrBuf         ; A1
#srcline 40
       LDX  size           ; A0
#srcline 41
       SYS  44             ; Api_WriteFile()
#srcline 42
       WRY  tmp
#srcline 43 ;  {end_asm}
#srcline 44 ;  FileWrite := tmp;
 LDY  tmp
#debug udint tmp
 WRX  __fc__FileWrite
#debug_left udint FileWrite
#srcline 45 ;END_FUNCTION
 PRV  
 LDX  __fc__FileWrite
 ULNK
RET
E     61
#endpou 



 

#srcfile ''
#srcfile 'C:\TECOLIBSRC\FILELIB\FILELIB\FC_FILESETPOS.ST'
#pou FileSetPos
#srcline 8 ;FUNCTION FileSetPos : BOOL

#struct FileSetPos__temp__
  bool tmp
P     61
FileSetPos_L0:
 LINK __SizeOf(FileSetPos__temp__)
 NXT
; Initialize - dynamic variables
; End initialize - dynamic variables
#srcline 37 ;begin
#srcline 38 ;  {asm}
#srcline 39
       LDX  hFile          ; A1
#srcline 40
       LDX  offset         ; A0
#srcline 41
       SYS  45             ; Api_SetFilePointer()
#srcline 42
       WRY  tmp
#srcline 43 ;  {end_asm}
#srcline 44 ;  FileSetPos := tmp;
 LDY  tmp
#debug bool tmp
 WRX  __fc__FileSetPos
#debug_left bool FileSetPos
#srcline 45 ;END_FUNCTION
 PRV  
 LDX  __fc__FileSetPos
 ULNK
RET
E     61
#endpou 



 

#srcfile ''
#srcfile 'C:\TECOLIBSRC\FILELIB\FILELIB\FC_FILEEXISTS.ST'
#pou FileExists
#srcline 2 ;FUNCTION FileExists : BOOL

#struct FileExists__temp__
  bool tmp
P     61
FileExists_L0:
 LINK __SizeOf(FileExists__temp__)
 NXT
; Initialize - dynamic variables
; End initialize - dynamic variables
#srcline 23 ;begin
#srcline 24 ;  {asm}
#srcline 25
       LDX  fileName       ; A0
#srcline 26
       SYS  46             ; Api_PathFileExists()
#srcline 27
       WRY   tmp
#srcline 28 ;  {end_asm}
#srcline 29 ;  FileExists := tmp;
 LDY  tmp
#debug bool tmp
 WRX  __fc__FileExists
#debug_left bool FileExists
#srcline 30 ;END_FUNCTION
 PRV  
 LDX  __fc__FileExists
 ULNK
RET
E     61
#endpou 



 

#srcfile ''
#srcfile 'C:\TECOLIBSRC\FILELIB\FILELIB\FC_FILESIZE.ST'
#pou FileSize
#srcline 6 ;FUNCTION FileSize : UDINT

#struct FileSize__temp__
  udint tmp
P     61
FileSize_L0:
 LINK __SizeOf(FileSize__temp__)
 NXT
; Initialize - dynamic variables
; End initialize - dynamic variables
#srcline 28 ;begin
#srcline 29 ;  {asm}
#srcline 30
       LDX  hFile          ; A0
#srcline 31
       SYS  47             ; Api_GetFileSize()
#srcline 32
       WRY  tmp
#srcline 33 ;  {end_asm}
#srcline 34 ;  FileSize := tmp;
 LDY  tmp
#debug udint tmp
 WRX  __fc__FileSize
#debug_left udint FileSize
#srcline 35 ;END_FUNCTION
 PRV  
 LDX  __fc__FileSize
 ULNK
RET
E     61
#endpou 



 

#srcfile ''
#srcfile 'C:\TECOLIBSRC\FILELIB\FILELIB\FC_DIROPEN.ST'
#pou DirOpen
#srcline 3 ;FUNCTION DirOpen : HANDLE

#struct DirOpen__temp__
  HANDLE tmp  ; {CSY} identifikátor souboru {ENU} file identificator
P     61
DirOpen_L0:
 LINK __SizeOf(DirOpen__temp__)
 NXT
; Initialize - dynamic variables
; End initialize - dynamic variables
#srcline 35 ;begin
#srcline 36 ;  {asm}
#srcline 37
       LDX  dirName        ; A1
#srcline 38
       LDX  dirInfo        ; A0
#srcline 39
       SYS  50             ; Api_FindFirstFile()
#srcline 40
       WRY  tmp
#srcline 41 ;  {end_asm}
#srcline 42 ;  DirOpen := tmp;
 LDY  tmp
#debug udint tmp
 WRX  __fc__DirOpen
#debug_left udint DirOpen
#srcline 43 ;END_FUNCTION
 PRV  
 LDX  __fc__DirOpen
 ULNK
RET
E     61
#endpou 



 

#srcfile ''
#srcfile 'C:\TECOLIBSRC\FILELIB\FILELIB\FC_DIRCLOSE.ST'
#pou DirClose
#srcline 2 ;FUNCTION DirClose : BOOL

#struct DirClose__temp__
  bool tmp
P     61
DirClose_L0:
 LINK __SizeOf(DirClose__temp__)
 NXT
; Initialize - dynamic variables
; End initialize - dynamic variables
#srcline 23 ;begin
#srcline 24 ;  {asm}
#srcline 25
       LDX  hDir           ; A0
#srcline 26
       SYS  51             ; Api_FindClose()
#srcline 27
       WRY  tmp
#srcline 28 ;  {end_asm}
#srcline 29 ;  DirClose := tmp;
 LDY  tmp
#debug bool tmp
 WRX  __fc__DirClose
#debug_left bool DirClose
#srcline 30 ;END_FUNCTION
 PRV  
 LDX  __fc__DirClose
 ULNK
RET
E     61
#endpou 



 

#srcfile ''
#srcfile 'C:\TECOLIBSRC\FILELIB\FILELIB\FC_DIRREAD.ST'
#pou DirRead
#srcline 2 ;FUNCTION DirRead : BOOL

#struct DirRead__temp__
  bool tmp
P     61
DirRead_L0:
 LINK __SizeOf(DirRead__temp__)
 NXT
; Initialize - dynamic variables
; End initialize - dynamic variables
#srcline 31 ;begin
#srcline 32 ;  {asm}
#srcline 33
       LDX  hDir           ; A1
#srcline 34
       LDX  dirInfo        ; A0
#srcline 35
       SYS  53             ; Api_FindNextFile()
#srcline 36
       WRY  tmp
#srcline 37 ;  {end_asm}
#srcline 38 ;  DirRead := tmp;
 LDY  tmp
#debug bool tmp
 WRX  __fc__DirRead
#debug_left bool DirRead
#srcline 39 ;END_FUNCTION
 PRV  
 LDX  __fc__DirRead
 ULNK
RET
E     61
#endpou 



 

#srcfile ''
#srcfile 'C:\TECOLIBSRC\FILELIB\FILELIB\FC_DIRCREATE.ST'
#pou DirCreate
#srcline 2 ;FUNCTION DirCreate : BOOL

#struct DirCreate__temp__
  bool tmp
P     61
DirCreate_L0:
 LINK __SizeOf(DirCreate__temp__)
 NXT
; Initialize - dynamic variables
; End initialize - dynamic variables
#srcline 25 ;begin
#srcline 26 ;  {asm}
#srcline 27
       LD   350
#srcline 28
       SYS  25             ; increase max cycle time
#srcline 29
       LDX  dirName        ; A0
#srcline 30
       SYS  52             ; Api_CreateDirectory()
#srcline 31
       WRY  tmp
#srcline 32 ;  {end_asm}
#srcline 33 ;  DirCreate := tmp;
 LDY  tmp
#debug bool tmp
 WRX  __fc__DirCreate
#debug_left bool DirCreate
#srcline 34 ;END_FUNCTION
 PRV  
 LDX  __fc__DirCreate
 ULNK
RET
E     61
#endpou 



 

#srcfile ''
#srcfile 'C:\TECOLIBSRC\FILELIB\FILELIB\FC_DIRDELETE.ST'
#pou DirDelete
#srcline 2 ;FUNCTION DirDelete : BOOL

#struct DirDelete__temp__
  bool tmp
P     61
DirDelete_L0:
 LINK __SizeOf(DirDelete__temp__)
 NXT
; Initialize - dynamic variables
; End initialize - dynamic variables
#srcline 26 ;begin
#srcline 27 ;  {asm}
#srcline 28
       LDX  dirName        ; A0
#srcline 29
       SYS  55             ; Api_RemoveDir()
#srcline 30
       WRY  tmp
#srcline 31 ;  {end_asm}
#srcline 32 ;  DirDelete := tmp;
 LDY  tmp
#debug bool tmp
 WRX  __fc__DirDelete
#debug_left bool DirDelete
#srcline 33 ;END_FUNCTION
 PRV  
 LDX  __fc__DirDelete
 ULNK
RET
E     61
#endpou 



 

#srcfile ''
#srcfile 'C:\TECOLIBSRC\FILELIB\FILELIB\FC_GETLASTERR.ST'
#pou GetLastErr
#srcline 1 ;FUNCTION GetLastErr : UDINT

#struct GetLastErr__temp__
  udint tmp
P     61
GetLastErr_L0:
 LINK __SizeOf(GetLastErr__temp__)
 NXT
; Initialize - dynamic variables
; End initialize - dynamic variables
#srcline 23 ;begin
#srcline 24 ;  {asm}
#srcline 25
       SYS  58
#srcline 26
       WRY  tmp
#srcline 27 ;  {end_asm}
#srcline 28 ;  GetLastErr := tmp;
 LDY  tmp
#debug udint tmp
 WRX  __fc__GetLastErr
#debug_left udint GetLastErr
#srcline 29 ;END_FUNCTION
 PRV  
 LDX  __fc__GetLastErr
 ULNK
RET
E     61
#endpou 



 

#srcfile ''
#srcfile 'C:\TECOLIBSRC\FILELIB\FILELIB\FC_GETLASTERRTXT.ST'
#pou GetLastErrTxt
#srcline 1 ;FUNCTION GetLastErrTxt : BOOL

#struct GetLastErrTxt__temp__
  bool tmp
P     61
GetLastErrTxt_L0:
 LINK __SizeOf(GetLastErrTxt__temp__)
 NXT
; Initialize - dynamic variables
; End initialize - dynamic variables
#srcline 29 ;begin
#srcline 30 ;  {asm}
#srcline 31
       LDX  errCode     ;A1
#srcline 32
       LDX  errMessage  ;A0
#srcline 33
       SYS  59
#srcline 34
       WRY  tmp
#srcline 35 ;  {end_asm}
#srcline 36 ;  GetLastErrTxt := tmp;
 LDY  tmp
#debug bool tmp
 WRX  __fc__GetLastErrTxt
#debug_left bool GetLastErrTxt
#srcline 37 ;END_FUNCTION
 PRV  
 LDX  __fc__GetLastErrTxt
 ULNK
RET
E     61
#endpou 



 

#srcfile ''
#srcfile 'C:\TECOLIBSRC\FILELIB\FILELIB\FC_DISKINFO.ST'
#pou DiskInfo
#srcline 3 ;FUNCTION DiskInfo : BOOL

#struct DiskInfo__temp__
  bool tmp
P     61
DiskInfo_L0:
 LINK __SizeOf(DiskInfo__temp__)
 NXT
; Initialize - dynamic variables
; End initialize - dynamic variables
#srcline 31 ;begin
#srcline 32 ;  {asm}
#srcline 33
       LDX  diskName       ; A1
#srcline 34
       LDX  diskDesc       ; A0
#srcline 35
       SYS  56             ; Api_GetDiskFreeSpaceEx()
#srcline 36
       WRY  tmp
#srcline 37 ;  {end_asm}
#srcline 38 ;  DiskInfo := tmp;
 LDY  tmp
#debug bool tmp
 WRX  __fc__DiskInfo
#debug_left bool DiskInfo
#srcline 39 ;END_FUNCTION
 PRV  
 LDX  __fc__DiskInfo
 ULNK
RET
E     61
#endpou 



 

#srcfile ''
#srcfile 'C:\TECOLIBSRC\FILELIB\FILELIB\FINDFREECLUSTER.ST'
#pou FindFreeCluster
#srcline 2 ;FUNCTION FindFreeCluster : BYTE

#struct FindFreeCluster__temp__
  byte tmp
P     61
FindFreeCluster_L0:
 LINK __SizeOf(FindFreeCluster__temp__)
 NXT
; Initialize - dynamic variables
; End initialize - dynamic variables
#srcline 27 ;begin
#srcline 28 ;  {asm}
#srcline 29
       LDX  fileName       ; A0
#srcline 30
       SYS  49             ; FindFreeCluster()
#srcline 31
       WRY   tmp
#srcline 32 ;  {end_asm}
#srcline 33 ;  FindFreeCluster := tmp;
 LDY  tmp
#debug byte tmp
 WRX  __fc__FindFreeCluster
#debug_left byte FindFreeCluster
#srcline 34 ;END_FUNCTION
 PRV  
 LDX  __fc__FindFreeCluster
 ULNK
RET
E     61
#endpou 



 

#srcfile ''
#srcfile 'C:\TECOLIBSRC\FILELIB\FILELIB\FC_FILEINFO.ST'
#pou FileInfo
#srcline 2 ;FUNCTION FileInfo : BOOL

#struct FileInfo__temp__
  bool tmp
P     61
FileInfo_L0:
 LINK __SizeOf(FileInfo__temp__)
 NXT
; Initialize - dynamic variables
; End initialize - dynamic variables
#srcline 28 ;begin
#srcline 29 ;  {asm}
#srcline 30
       LDX  fileName       ; A1
#srcline 31
       LDX  fileDesc       ; A0
#srcline 32
       SYS  57             ; Api_GetFileInformationByHandle()
#srcline 33
       WRY  tmp
#srcline 34 ;  {end_asm}
#srcline 35 ;  
#srcline 36 ;  FileInfo := tmp;
 LDY  tmp
#debug bool tmp
 WRX  __fc__FileInfo
#debug_left bool FileInfo
#srcline 37 ;END_FUNCTION
 PRV  
 LDX  __fc__FileInfo
 ULNK
RET
E     61
#endpou 



 

#srcfile ''
#srcfile 'C:\TECOLIBSRC\FILELIB\FILELIB\CLOSEALLFILES.ST'
#pou CloseAllFiles
#srcline 2 ;FUNCTION CloseAllFiles : BOOL

#struct CloseAllFiles__temp__
  bool tmp
P     61
CloseAllFiles_L0:
 LINK __SizeOf(CloseAllFiles__temp__)
 NXT
; Initialize - dynamic variables
; End initialize - dynamic variables
#srcline 15 ;begin
#srcline 16 ;  {asm}
#srcline 17
       LD   350
#srcline 18
       SYS  25             ; increase max cycle time
#srcline 19
       LD   -1             ; -1 == zavrit vse
#srcline 20
       SYS  51             ; pretizena fc_DirClose (od FW v7.5)
#srcline 21
       WRY   tmp
#srcline 22 ;  {end_asm}
#srcline 23 ;  CloseAllFiles := tmp;
 LDY  tmp
#debug bool tmp
 WRX  __fc__CloseAllFiles
#debug_left bool CloseAllFiles
#srcline 24 ;END_FUNCTION
 PRV  
 LDX  __fc__CloseAllFiles
 ULNK
RET
E     61
#endpou 



 

#srcfile ''
#srcfile 'C:\TECOLIBSRC\FILELIB\FILELIB\OPENFILESCOUNT.ST'
#pou OpenFilesCount
#srcline 2 ;FUNCTION OpenFilesCount : UINT

#struct OpenFilesCount__temp__
  uint tmp
P     61
OpenFilesCount_L0:
 LINK __SizeOf(OpenFilesCount__temp__)
 NXT
; Initialize - dynamic variables
; End initialize - dynamic variables
#srcline 15 ;begin
#srcline 16 ;  {asm}
#srcline 17
       LD   -1             ; -1 == vratit pocet otevrenych souboru
#srcline 18
       SYS  41             ; pretizena fce fc_FileClose (od FW v7.5)
#srcline 19
       WRY   tmp
#srcline 20 ;  {end_asm}
#srcline 21 ;  OpenFilesCount := tmp;
 LDY  tmp
#debug uint tmp
 WRX  __fc__OpenFilesCount
#debug_left uint OpenFilesCount
#srcline 22 ;END_FUNCTION
 PRV  
 LDX  __fc__OpenFilesCount
 ULNK
RET
E     61
#endpou 



 

#srcfile ''
#srcfile 'C:\TECOLIBSRC\FILELIB\FILELIB\FC_FILEMOVE.ST'
#pou FileMove
#srcline 1 ;FUNCTION FileMove : BOOL

#struct FileMove__temp__
  bool tmp
P     61
FileMove_L0:
 LINK __SizeOf(FileMove__temp__)
 NXT
; Initialize - dynamic variables
; End initialize - dynamic variables
#srcline 29 ;  IF (73 = %S42) OR (74 = %S42) THEN   // centraly I a J (CP-2xxx only)
 LD   73
 LD   %S42
 EQ
 LD   74
 LD   %S42
 EQ
 OR  
 JMC  FileMove_L1
#srcline 30 ;    {asm}
#srcline 31
      LDX  oldName
#srcline 32
      LDX  newName
#srcline 33
      SYS  48
#srcline 34
      WRY  tmp
#srcline 35 ;    {end_asm}
#srcline 36 ;  END_IF;
FileMove_L1:
#srcline 38 ;  FileMove := tmp;
 LDY  tmp
#debug bool tmp
 WRX  __fc__FileMove
#debug_left bool FileMove
#srcline 39 ;END_FUNCTION
 PRV  
 LDX  __fc__FileMove
 ULNK
RET
E     61
#endpou 

#pou FileRename
#srcline 41 ;FUNCTION FileRename : BOOL

#struct FileRename__temp__
  bool tmp
P     61
FileRename_L0:
 LINK __SizeOf(FileRename__temp__)
 NXT
; Initialize - dynamic variables
; End initialize - dynamic variables
#srcline 69 ;  IF (73 = %S42) OR (74 = %S42) THEN   // centraly I a J (CP-2xxx only)
 LD   73
 LD   %S42
 EQ
 LD   74
 LD   %S42
 EQ
 OR  
 JMC  FileRename_L1
#srcline 70 ;    {asm}
#srcline 71
      LDX  oldName
#srcline 72
      LDX  newName
#srcline 73
      SYS  48
#srcline 74
      WRY  tmp
#srcline 75 ;    {end_asm}
#srcline 76 ;  END_IF;
FileRename_L1:
#srcline 78 ;  FileRename := tmp;
 LDY  tmp
#debug bool tmp
 WRX  __fc__FileRename
#debug_left bool FileRename
#srcline 79 ;END_FUNCTION
 PRV  
 LDX  __fc__FileRename
 ULNK
RET
E     61
#endpou 



 

#srcfile ''
#srcfile 'C:\TECOLIBSRC\FILELIB\FILELIB\SETFILEATTR.ST'
#pou SetFileAttr
#srcline 2 ;FUNCTION SetFileAttr : BOOL

#struct SetFileAttr__temp__
  bool tmp
P     61
SetFileAttr_L0:
 LINK __SizeOf(SetFileAttr__temp__)
 NXT
; Initialize - dynamic variables
; End initialize - dynamic variables
#srcline 31 ;begin
#srcline 32 ;  {asm}
#srcline 33
       LDX  fileName       ; A0
#srcline 34
       LDX  attrib         ; A1
#srcline 35
       SYS  66             ; Api_SetFileAttributes()
#srcline 36
       WRY  tmp
#srcline 37 ;  {end_asm}
#srcline 39 ;  SetFileAttr := tmp;
 LDY  tmp
#debug bool tmp
 WRX  __fc__SetFileAttr
#debug_left bool SetFileAttr
#srcline 40 ;END_FUNCTION
 PRV  
 LDX  __fc__SetFileAttr
 ULNK
RET
E     61
#endpou 



 

#srcfile ''
#srcfile 'C:\TECOLIBSRC\FILELIB\FILELIB\FC_FORCEDIRS.ST'
#pou ForceDirs
#srcline 1 ;FUNCTION ForceDirs : BOOL

#struct ForceDirs__temp__
  bool tmp
P     61
ForceDirs_L0:
 LINK __SizeOf(ForceDirs__temp__)
 NXT
; Initialize - dynamic variables
; End initialize - dynamic variables
#srcline 19 ;begin
#srcline 20 ;    {asm}
#srcline 21
      LDX  fileName        ; jmeno souboru s cestou
#srcline 22
      LD   1               ; subcode 1
#srcline 23
      SYS  67              ; sysFileExt, subcode 1 ... ForceDirs
#srcline 24
      WRY  tmp
#srcline 25 ;    {end_asm}
#srcline 27 ;  ForceDirs := tmp;
 LDY  tmp
#debug bool tmp
 WRX  __fc__ForceDirs
#debug_left bool ForceDirs
#srcline 28 ;END_FUNCTION
 PRV  
 LDX  __fc__ForceDirs
 ULNK
RET
E     61
#endpou 



 

#srcfile ''
#srcfile 'C:\TECOLIBSRC\FILELIB\FILELIB\READFROMFILE.ST'
#pou ReadFromFile
#srcline 2 ;FUNCTION_BLOCK ReadFromFile

#struct ReadFromFile__temp__
  udint restSize,
  udint reqSize,
  udint read
P     61
ReadFromFile_L0:
 LINK __SizeOf(ReadFromFile__temp__)
; Initialize - dynamic variables
; End initialize - dynamic variables
#srcline 55 ;  adrVar := PTR_TO_UDINT( ADR( dstVar));
 LDX  dstVar
#debug pointer dstVar
 WRX  adrVar
#debug_left udint adrVar
#srcline 56 ;  execTrig( CLK := exec);
 LDX  exec
#debug bool exec
 WRX  execTrig~CLK
#debug_left bool execTrig~CLK
 LEAX execTrig
 CAL  R_TRIG_L0
#srcline 58 ;  // open file and seek position
#srcline 59 ;  IF execTrig.Q THEN
 LDX  execTrig~Q
#debug bool execTrig.Q
 JMC  ReadFromFile_L1
#srcline 60 ;    busy := TRUE; done := FALSE; err := FALSE; errID := 0; actSize := 0;
 LD   bool -1       ; true
 WRX  busy
#debug_left bool busy
 LD   bool 0       ; false
 WRX  done
#debug_left bool done
 LD   bool 0       ; false
 WRX  err
#debug_left bool err
 LD   udint 0
 WRX  errID
#debug_left udint errID
 LD   udint 0
 WRX  actSize
#debug_left udint actSize
#srcline 61 ;    errTrig( CLK := FALSE);
 LD   bool 0       ; false
 WRX  errTrig~CLK
#debug_left bool errTrig~CLK
 LEAX errTrig
 CAL  R_TRIG_L0
#srcline 62 ;    hnd := FileOpen(fileName := fileName, mode := F_READ);
 NXT
 LDX  fileName
 WR   __Instance__FileOpen~fileName
#debug_left pointer __Instance__FileOpen.fileName
 LD   udint 0  ; TF_MODE#F_READ
 WR   __Instance__FileOpen~mode
#debug_left usint __Instance__FileOpen~mode
 PRV
 LEA  __Instance__FileOpen
 CAL  FileOpen_L0
 WRX  hnd
#debug_left udint hnd
#srcline 63 ;    IF hnd = INVALID_HANDLE_VALUE THEN
 LDX  hnd
#debug udint hnd
 LD   udint 0
 EQ
 JMC  ReadFromFile_L3
#srcline 64 ;      err := TRUE; busy := FALSE;
 LD   bool -1       ; true
 WRX  err
#debug_left bool err
 LD   bool 0       ; false
 WRX  busy
#debug_left bool busy
#srcline 65 ;    ELSE
 JMP  ReadFromFile_L4
ReadFromFile_L3:
#srcline 66 ;      IF seek <> 0 THEN
 LDX  seek
#debug udint seek
 LD   udint 0
 EQ
 NEG
 JMC  ReadFromFile_L5
#srcline 67 ;        IF FileSetPos( hFile := hnd, offset := seek) = FALSE THEN
 NXT
 LDX  hnd
#debug udint hnd
 WR   __Instance__FileSetPos~hFile
#debug_left udint __Instance__FileSetPos~hFile
 LDX  seek
#debug udint seek
 WR   __Instance__FileSetPos~offset
#debug_left udint __Instance__FileSetPos~offset
 PRV
 LEA  __Instance__FileSetPos
 CAL  FileSetPos_L0
 LD   bool 0       ; false
 XOR
 NEG
 JMC  ReadFromFile_L7
#srcline 68 ;          err := TRUE; busy := FALSE;
 LD   bool -1       ; true
 WRX  err
#debug_left bool err
 LD   bool 0       ; false
 WRX  busy
#debug_left bool busy
#srcline 69 ;        END_IF;
ReadFromFile_L7:
#srcline 70 ;      END_IF;
ReadFromFile_L5:
#srcline 71 ;    END_IF;
ReadFromFile_L4:
#srcline 72 ;  END_IF;
ReadFromFile_L1:
#srcline 74 ;  // read data from file to variable (one sector per one PLC cycle)
#srcline 75 ;  IF busy THEN
 LDX  busy
#debug bool busy
 JMC  ReadFromFile_L9
#srcline 76 ;    IF size > actSize THEN
 LDX  size
#debug udint size
 LDX  actSize
#debug udint actSize
 GT
 JMC  ReadFromFile_L11
#srcline 77 ;      restSize := size - actSize;
 LDX  size
#debug udint size
 LDX  actSize
#debug udint actSize
 SUB
 WRY  restSize
#debug_left udint restSize
#srcline 78 ;      IF restSize > 512 THEN reqSize := 512;          // more then one sector
 LDY  restSize
#debug udint restSize
 LD   udint 512
 GT
 JMC  ReadFromFile_L13
 LD   udint 512
 WRY  reqSize
#debug_left udint reqSize
#srcline 79 ;                        ELSE reqSize := restSize;     // last sector
 JMP  ReadFromFile_L14
ReadFromFile_L13:
 LDY  restSize
#debug udint restSize
 WRY  reqSize
#debug_left udint reqSize
#srcline 80 ;      END_IF;
ReadFromFile_L14:
#srcline 81 ;      read := FileRead( hFile := hnd, adrBuf := adrVar + actSize, size := reqSize);
 NXT
 LDX  hnd
#debug udint hnd
 WR   __Instance__FileRead~hFile
#debug_left udint __Instance__FileRead~hFile
 LDX  adrVar
#debug udint adrVar
 LDX  actSize
#debug udint actSize
 ADD
 WR   __Instance__FileRead~adrBuf
#debug_left udint __Instance__FileRead~adrBuf
 LDY  reqSize
#debug udint reqSize
 WR   __Instance__FileRead~size
#debug_left udint __Instance__FileRead~size
 PRV
 LEA  __Instance__FileRead
 CAL  FileRead_L0
 WRY  read
#debug_left udint read
#srcline 82 ;      actSize := actSize + read;
 LDX  actSize
#debug udint actSize
 LDY  read
#debug udint read
 ADD
 WRX  actSize
#debug_left udint actSize
#srcline 83 ;      IF read <> reqSize THEN
 LDY  read
#debug udint read
 LDY  reqSize
#debug udint reqSize
 EQ
 NEG
 JMC  ReadFromFile_L15
#srcline 84 ;        busy := FALSE;
 LD   bool 0       ; false
 WRX  busy
#debug_left bool busy
#srcline 85 ;        IF FileSize(hFile := hnd) >= actSize + seek THEN
 NXT
 LDX  hnd
#debug udint hnd
 WR   __Instance__FileSize~hFile
#debug_left udint __Instance__FileSize~hFile
 PRV
 LEA  __Instance__FileSize
 CAL  FileSize_L0
 LDX  actSize
#debug udint actSize
 LDX  seek
#debug udint seek
 ADD
 LT
 NEG
 JMC  ReadFromFile_L17
#srcline 86 ;          done := TRUE;         // end of file
 LD   bool -1       ; true
 WRX  done
#debug_left bool done
#srcline 87 ;        ELSE
 JMP  ReadFromFile_L18
ReadFromFile_L17:
#srcline 88 ;          err  := TRUE;         // propably any error
 LD   bool -1       ; true
 WRX  err
#debug_left bool err
#srcline 89 ;        END_IF;
ReadFromFile_L18:
#srcline 90 ;      ELSE
 JMP  ReadFromFile_L16
ReadFromFile_L15:
#srcline 91 ;        IF actSize = size THEN
 LDX  actSize
#debug udint actSize
 LDX  size
#debug udint size
 EQ
 JMC  ReadFromFile_L19
#srcline 92 ;          done := TRUE; busy := FALSE;
 LD   bool -1       ; true
 WRX  done
#debug_left bool done
 LD   bool 0       ; false
 WRX  busy
#debug_left bool busy
#srcline 93 ;        END_IF;
ReadFromFile_L19:
#srcline 94 ;      END_IF;
ReadFromFile_L16:
#srcline 95 ;    ELSE
 JMP  ReadFromFile_L12
ReadFromFile_L11:
#srcline 96 ;      done := TRUE;
 LD   bool -1       ; true
 WRX  done
#debug_left bool done
#srcline 97 ;    END_IF;
ReadFromFile_L12:
#srcline 98 ;  ELSE
 JMP  ReadFromFile_L10
ReadFromFile_L9:
#srcline 99 ;    done := done AND exec;
 LDX  done
#debug bool done
 LDX  exec
#debug bool exec
 AND
 WRX  done
#debug_left bool done
#srcline 100 ;    err  := err  AND exec;
 LDX  err
#debug bool err
 LDX  exec
#debug bool exec
 AND
 WRX  err
#debug_left bool err
#srcline 101 ;  END_IF;
ReadFromFile_L10:
#srcline 103 ;  // set error code, if any
#srcline 104 ;  errTrig( CLK := err);
 LDX  err
#debug bool err
 WRX  errTrig~CLK
#debug_left bool errTrig~CLK
 LEAX errTrig
 CAL  R_TRIG_L0
#srcline 105 ;  IF errTrig.Q THEN
 LDX  errTrig~Q
#debug bool errTrig.Q
 JMC  ReadFromFile_L21
#srcline 106 ;    errID := GetLastErr();
 LEA  __Instance__GetLastErr
 CAL  GetLastErr_L0
 WRX  errID
#debug_left udint errID
#srcline 107 ;  END_IF;
ReadFromFile_L21:
#srcline 109 ;  // close file
#srcline 110 ;  IF errTrig.Q OR done THEN
 LDX  errTrig~Q
#debug bool errTrig.Q
 LDX  done
#debug bool done
 OR  
 JMC  ReadFromFile_L23
#srcline 111 ;    IF hnd <> INVALID_HANDLE_VALUE THEN
 LDX  hnd
#debug udint hnd
 LD   udint 0
 EQ
 NEG
 JMC  ReadFromFile_L25
#srcline 112 ;      IF FileClose( hFile := hnd) THEN
 NXT
 LDX  hnd
#debug udint hnd
 WR   __Instance__FileClose~hFile
#debug_left udint __Instance__FileClose~hFile
 PRV
 LEA  __Instance__FileClose
 CAL  FileClose_L0
 JMC  ReadFromFile_L27
#srcline 113 ;        hnd := INVALID_HANDLE_VALUE;
 LD   udint 0
 WRX  hnd
#debug_left udint hnd
#srcline 114 ;      END_IF;
ReadFromFile_L27:
#srcline 115 ;    END_IF;
ReadFromFile_L25:
#srcline 116 ;  END_IF;
ReadFromFile_L23:
#srcline 117 ;END_FUNCTION_BLOCK
 ULNK
RET
E     61
#endpou 



 

#srcfile ''
#srcfile 'C:\TECOLIBSRC\FILELIB\FILELIB\WRITETOFILE.ST'
#pou WriteToFile
#srcline 2 ;FUNCTION_BLOCK WriteToFile

#struct WriteToFile__temp__
  udint restSize,
  udint written,
  udint reqSize,
  usint mode,
  byte res
P     61
WriteToFile_L0:
 LINK __SizeOf(WriteToFile__temp__)
; Initialize - dynamic variables
; End initialize - dynamic variables
#srcline 61 ;  adrVar := PTR_TO_UDINT( ADR( srcVar));
 LDX  srcVar
#debug pointer srcVar
 WRX  adrVar
#debug_left udint adrVar
#srcline 62 ;  eTrig(CLK := exec);
 LDX  exec
#debug bool exec
 WRX  eTrig~CLK
#debug_left bool eTrig~CLK
 LEAX eTrig
 CAL  R_TRIG_L0
#srcline 63 ;  IF idle <> 0 THEN idle := idle - 1; RETURN; END_IF; // wait 32 cycles after file create
 LDX  idle
#debug uint idle
 LD   uint 0
 EQ
 NEG
 JMC  WriteToFile_L1
 LDX  idle
#debug uint idle
 LD   uint 1
 SUB
 AND  $FFFF
 WRX  idle
#debug_left uint idle
 JMP  WriteToFile_RET
WriteToFile_L1:
#srcline 65 ;  // open file and seek position
#srcline 66 ;  IF eTrig.Q THEN
 LDX  eTrig~Q
#debug bool eTrig.Q
 JMC  WriteToFile_L3
#srcline 67 ;    IF hnd <> INVALID_HANDLE_VALUE THEN
 LDX  hnd
#debug udint hnd
 LD   udint 0
 EQ
 NEG
 JMC  WriteToFile_L5
#srcline 68 ;      FileClose( hFile := hnd);
 NXT
 LDX  hnd
#debug udint hnd
 WR   __Instance__FileClose~hFile
#debug_left udint __Instance__FileClose~hFile
 PRV
 LEA  __Instance__FileClose
 CAL  FileClose_L0
#srcline 69 ;    END_IF;
WriteToFile_L5:
#srcline 70 ;    busy := TRUE; done := FALSE; err := FALSE; errID := 0; actSize := 0;
 LD   bool -1       ; true
 WRX  busy
#debug_left bool busy
 LD   bool 0       ; false
 WRX  done
#debug_left bool done
 LD   bool 0       ; false
 WRX  err
#debug_left bool err
 LD   udint 0
 WRX  errID
#debug_left udint errID
 LD   udint 0
 WRX  actSize
#debug_left udint actSize
#srcline 71 ;    errTrig( CLK := FALSE);
 LD   bool 0       ; false
 WRX  errTrig~CLK
#debug_left bool errTrig~CLK
 LEAX errTrig
 CAL  R_TRIG_L0
#srcline 72 ;    IF seek = 0 THEN mode := F_WRITE; ELSE mode := F_APPEND; END_IF;
 LDX  seek
#debug udint seek
 LD   udint 0
 EQ
 JMC  WriteToFile_L7
 LD   udint 1  ; TF_MODE#F_WRITE
 WRY  mode
#debug_left usint mode
 JMP  WriteToFile_L8
WriteToFile_L7:
 LD   udint 2  ; TF_MODE#F_APPEND
 WRY  mode
#debug_left usint mode
WriteToFile_L8:
#srcline 73 ;    hnd := FileOpen( fileName := fileName, mode := mode);
 NXT
 LDX  fileName
 WR   __Instance__FileOpen~fileName
#debug_left pointer __Instance__FileOpen.fileName
 LDY  mode
#debug usint mode
 WR   __Instance__FileOpen~mode
#debug_left usint __Instance__FileOpen~mode
 PRV
 LEA  __Instance__FileOpen
 CAL  FileOpen_L0
 WRX  hnd
#debug_left udint hnd
#srcline 74 ;    IF hnd = INVALID_HANDLE_VALUE THEN
 LDX  hnd
#debug udint hnd
 LD   udint 0
 EQ
 JMC  WriteToFile_L9
#srcline 75 ;      err := TRUE; busy := FALSE;
 LD   bool -1       ; true
 WRX  err
#debug_left bool err
 LD   bool 0       ; false
 WRX  busy
#debug_left bool busy
#srcline 76 ;    ELSE
 JMP  WriteToFile_L10
WriteToFile_L9:
#srcline 77 ;      idle := 32;
 LD   uint 32
 WRX  idle
#debug_left uint idle
#srcline 78 ;      IF seek <> 0 AND seek <> 16#FFFF_FFFF THEN
 LDX  seek
#debug udint seek
 LD   udint 0
 EQ
 NEG
 LDX  seek
#debug udint seek
 LD   udint $FFFFFFFF
 EQ
 NEG
 AND
 JMC  WriteToFile_L11
#srcline 79 ;        IF FileSetPos( hFile := hnd, offset := seek) = FALSE THEN
 NXT
 LDX  hnd
#debug udint hnd
 WR   __Instance__FileSetPos~hFile
#debug_left udint __Instance__FileSetPos~hFile
 LDX  seek
#debug udint seek
 WR   __Instance__FileSetPos~offset
#debug_left udint __Instance__FileSetPos~offset
 PRV
 LEA  __Instance__FileSetPos
 CAL  FileSetPos_L0
 LD   bool 0       ; false
 XOR
 NEG
 JMC  WriteToFile_L13
#srcline 80 ;          err := TRUE; busy := FALSE;
 LD   bool -1       ; true
 WRX  err
#debug_left bool err
 LD   bool 0       ; false
 WRX  busy
#debug_left bool busy
#srcline 81 ;        END_IF;
WriteToFile_L13:
#srcline 82 ;      END_IF;
WriteToFile_L11:
#srcline 83 ;    END_IF;
WriteToFile_L10:
#srcline 84 ;  END_IF;
WriteToFile_L3:
#srcline 86 ;  // write data to file to variable (one sector per one PLC cycle)
#srcline 87 ;  IF busy THEN
 LDX  busy
#debug bool busy
 JMC  WriteToFile_L15
#srcline 88 ;    IF size > actSize THEN
 LDX  size
#debug udint size
 LDX  actSize
#debug udint actSize
 GT
 JMC  WriteToFile_L17
#srcline 89 ;      restSize := size - actSize;
 LDX  size
#debug udint size
 LDX  actSize
#debug udint actSize
 SUB
 WRY  restSize
#debug_left udint restSize
#srcline 90 ;      IF restSize > 512 THEN reqSize := 512;          // more then one sector
 LDY  restSize
#debug udint restSize
 LD   udint 512
 GT
 JMC  WriteToFile_L19
 LD   udint 512
 WRY  reqSize
#debug_left udint reqSize
#srcline 91 ;                        ELSE reqSize := restSize;     // last sector
 JMP  WriteToFile_L20
WriteToFile_L19:
 LDY  restSize
#debug udint restSize
 WRY  reqSize
#debug_left udint reqSize
#srcline 92 ;      END_IF;
WriteToFile_L20:
#srcline 93 ;      res := FindFreeCluster(fileName := fileName);
 NXT
 LDX  fileName
 WR   __Instance__FindFreeCluster~fileName
#debug_left pointer __Instance__FindFreeCluster.fileName
 PRV
 LEA  __Instance__FindFreeCluster
 CAL  FindFreeCluster_L0
 WRY  res
#debug_left byte res
#srcline 94 ;      IF res = 0 THEN
 LDY  res
#debug byte res
 LD   byte 0
 EQ
 JMC  WriteToFile_L21
#srcline 95 ;        written := FileWrite(hFile := hnd, adrBuf := adrVar + actSize, size := reqSize);
 NXT
 LDX  hnd
#debug udint hnd
 WR   __Instance__FileWrite~hFile
#debug_left udint __Instance__FileWrite~hFile
 LDX  adrVar
#debug udint adrVar
 LDX  actSize
#debug udint actSize
 ADD
 WR   __Instance__FileWrite~adrBuf
#debug_left udint __Instance__FileWrite~adrBuf
 LDY  reqSize
#debug udint reqSize
 WR   __Instance__FileWrite~size
#debug_left udint __Instance__FileWrite~size
 PRV
 LEA  __Instance__FileWrite
 CAL  FileWrite_L0
 WRY  written
#debug_left udint written
#srcline 96 ;        actSize := actSize + written;
 LDX  actSize
#debug udint actSize
 LDY  written
#debug udint written
 ADD
 WRX  actSize
#debug_left udint actSize
#srcline 97 ;        IF written <> reqSize THEN
 LDY  written
#debug udint written
 LDY  reqSize
#debug udint reqSize
 EQ
 NEG
 JMC  WriteToFile_L23
#srcline 98 ;          busy := FALSE; err := TRUE;
 LD   bool 0       ; false
 WRX  busy
#debug_left bool busy
 LD   bool -1       ; true
 WRX  err
#debug_left bool err
#srcline 99 ;        ELSE
 JMP  WriteToFile_L24
WriteToFile_L23:
#srcline 100 ;          IF actSize = size THEN
 LDX  actSize
#debug udint actSize
 LDX  size
#debug udint size
 EQ
 JMC  WriteToFile_L25
#srcline 101 ;            done := TRUE; busy := FALSE;
 LD   bool -1       ; true
 WRX  done
#debug_left bool done
 LD   bool 0       ; false
 WRX  busy
#debug_left bool busy
#srcline 102 ;          END_IF;
WriteToFile_L25:
#srcline 103 ;        END_IF;
WriteToFile_L24:
#srcline 104 ;      ELSE
 JMP  WriteToFile_L22
WriteToFile_L21:
#srcline 105 ;        IF res <> 13 THEN
 LDY  res
#debug byte res
 LD   byte 13
 EQ
 NEG
 JMC  WriteToFile_L27
#srcline 106 ;          busy := FALSE; err := TRUE;      // disk full or not mounted
 LD   bool 0       ; false
 WRX  busy
#debug_left bool busy
 LD   bool -1       ; true
 WRX  err
#debug_left bool err
#srcline 107 ;        END_IF;
WriteToFile_L27:
#srcline 108 ;      END_IF;
WriteToFile_L22:
#srcline 109 ;    ELSE
 JMP  WriteToFile_L18
WriteToFile_L17:
#srcline 110 ;      done := TRUE;
 LD   bool -1       ; true
 WRX  done
#debug_left bool done
#srcline 111 ;    END_IF;
WriteToFile_L18:
#srcline 112 ;  ELSE
 JMP  WriteToFile_L16
WriteToFile_L15:
#srcline 113 ;    done := done AND exec;
 LDX  done
#debug bool done
 LDX  exec
#debug bool exec
 AND
 WRX  done
#debug_left bool done
#srcline 114 ;    err  := err  AND exec;
 LDX  err
#debug bool err
 LDX  exec
#debug bool exec
 AND
 WRX  err
#debug_left bool err
#srcline 115 ;  END_IF;
WriteToFile_L16:
#srcline 117 ;  // set error code, if any
#srcline 118 ;  errTrig( CLK := err);
 LDX  err
#debug bool err
 WRX  errTrig~CLK
#debug_left bool errTrig~CLK
 LEAX errTrig
 CAL  R_TRIG_L0
#srcline 119 ;  IF errTrig.Q THEN
 LDX  errTrig~Q
#debug bool errTrig.Q
 JMC  WriteToFile_L29
#srcline 120 ;    errID := GetLastErr();
 LEA  __Instance__GetLastErr
 CAL  GetLastErr_L0
 WRX  errID
#debug_left udint errID
#srcline 121 ;  END_IF;
WriteToFile_L29:
#srcline 123 ;  // close file
#srcline 124 ;  IF errTrig.Q OR done THEN
 LDX  errTrig~Q
#debug bool errTrig.Q
 LDX  done
#debug bool done
 OR  
 JMC  WriteToFile_L31
#srcline 125 ;    IF hnd <> INVALID_HANDLE_VALUE THEN
 LDX  hnd
#debug udint hnd
 LD   udint 0
 EQ
 NEG
 JMC  WriteToFile_L33
#srcline 126 ;      IF FileClose( hFile := hnd) THEN
 NXT
 LDX  hnd
#debug udint hnd
 WR   __Instance__FileClose~hFile
#debug_left udint __Instance__FileClose~hFile
 PRV
 LEA  __Instance__FileClose
 CAL  FileClose_L0
 JMC  WriteToFile_L35
#srcline 127 ;        hnd := INVALID_HANDLE_VALUE;
 LD   udint 0
 WRX  hnd
#debug_left udint hnd
#srcline 128 ;      END_IF;
WriteToFile_L35:
#srcline 129 ;    END_IF;
WriteToFile_L33:
#srcline 130 ;  END_IF;
WriteToFile_L31:
#srcline 132 ;  IF NOT busy THEN idle := 0; END_IF;      // od v1.3
 LDX  busy
#debug bool busy
 NEG
 JMC  WriteToFile_L37
 LD   uint 0
 WRX  idle
#debug_left uint idle
WriteToFile_L37:
#srcline 133 ;END_FUNCTION_BLOCK
WriteToFile_RET:
 ULNK
RET
E     61
#endpou 



 

#srcfile ''
#srcfile 'C:\TECOLIBSRC\FILELIB\FILELIB\CREATEPATH.ST'
#pou CreatePath
#srcline 1 ;FUNCTION_BLOCK CreatePath

#struct CreatePath__temp__
  string[81] tmp,
  int pos,
  bool ok,
  byte res,
  string[82] PS0__st__
#data byte _str_CreatePath_0 = 
  '',0
#data byte _str_CreatePath_1 = 
  '/',0
P     61
CreatePath_L0:
 LINK __SizeOf(CreatePath__temp__)
; Initialize - dynamic variables
; End initialize - dynamic variables
#srcline 58 ;  eTrig(CLK := exec);
 LDX  exec
#debug bool exec
 WRX  eTrig~CLK
#debug_left bool eTrig~CLK
 LEAX eTrig
 CAL  R_TRIG_L0
#srcline 59 ;  IF eTrig.Q THEN
 LDX  eTrig~Q
#debug bool eTrig.Q
 JMC  CreatePath_L1
#srcline 60 ;    busy := TRUE; done := FALSE; err := FALSE; errID := 0; idle := 0;
 LD   bool -1       ; true
 WRX  busy
#debug_left bool busy
 LD   bool 0       ; false
 WRX  done
#debug_left bool done
 LD   bool 0       ; false
 WRX  err
#debug_left bool err
 LD   udint 0
 WRX  errID
#debug_left udint errID
 LD   uint 0
 WRX  idle
#debug_left uint idle
#srcline 61 ;    path := ''; copy := fileName; createDir := FALSE;
 LD   0   ; null string
 LEAX path
 WRI  
 LEAX path
 LD   80
 DST    ; Level 1
 LEA  _str_CreatePath_0
 SCON 
#debug_left string path
 PDST   ; Level 1
 LD   0   ; null string
 LEAX copy
 WRI  
 LEAX copy
 LD   80
 DST    ; Level 1
 LDX  fileName
#debug string fileName
 SCON 
#debug_left string copy
 PDST   ; Level 1
 LD   bool 0       ; false
 WRX  createDir
#debug_left bool createDir
#srcline 62 ;    errTrig( CLK := FALSE);
 LD   bool 0       ; false
 WRX  errTrig~CLK
#debug_left bool errTrig~CLK
 LEAX errTrig
 CAL  R_TRIG_L0
#srcline 63 ;  END_IF;
CreatePath_L1:
#srcline 65 ;  IF idle <> 0 THEN idle := idle - 1; RETURN; END_IF;
 LDX  idle
#debug uint idle
 LD   uint 0
 EQ
 NEG
 JMC  CreatePath_L3
 LDX  idle
#debug uint idle
 LD   uint 1
 SUB
 AND  $FFFF
 WRX  idle
#debug_left uint idle
 JMP  CreatePath_RET
CreatePath_L3:
#srcline 66 ;  
#srcline 67 ;  // check path and create it if path does not exist
#srcline 68 ;  IF busy THEN
 LDX  busy
#debug bool busy
 JMC  CreatePath_L5
#srcline 69 ;    IF NOT createDir THEN
 LDX  createDir
#debug bool createDir
 NEG
 JMC  CreatePath_L7
#srcline 70 ;      pos := FIND(IN1 := copy, IN2 := '/');
 LEAX copy
#debug string copy
 LEA  _str_CreatePath_1
 SFND 
 WRY  pos
#debug_left int pos
#srcline 71 ;      IF pos <> 0 THEN
 LDY  pos
#debug int pos
 EXTW 
 LD   int 0
 EQ
 NEG
 JMC  CreatePath_L9
#srcline 72 ;        tmp  := LEFT(IN := copy, L := pos);
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   80
 DST    ; Level 1
 LEAX copy
#debug string copy
 LDY  pos
#debug int pos
 EXTW 
 SLFT 
 PDST   ; Level 1
 LD   0   ; null string
 LEAY tmp
 WRI  
 LEAY tmp
 LD   80
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string tmp
 PDST   ; Level 1
#srcline 73 ;        path := CONCAT(IN1 := path, IN2 := tmp);
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   80
 DST    ; Level 1
 LEAX path
#debug string path
 SCON
 LEAY tmp
#debug string tmp

 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX path
 WRI  
 LEAX path
 LD   80
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string path
 PDST   ; Level 1
#srcline 74 ;        copy := DELETE(IN := copy, L := pos, P := 1);
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   80
 DST    ; Level 1
 LEAX copy
#debug string copy
 LDY  pos
#debug int pos
 EXTW 
 LD   1
 SUB  1
 SDEL 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX copy
 WRI  
 LEAX copy
 LD   80
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string copy
 PDST   ; Level 1
#srcline 75 ;        IF NOT FileExists( fileName := path) THEN
 NXT
 LEAX path
 WR   __Instance__FileExists~fileName
#debug_left pointer __Instance__FileExists.fileName
 PRV
 LEA  __Instance__FileExists
 CAL  FileExists_L0
 NEG
 JMC  CreatePath_L11
#srcline 76 ;          createDir := TRUE;
 LD   bool -1       ; true
 WRX  createDir
#debug_left bool createDir
#srcline 77 ;        END_IF;
CreatePath_L11:
#srcline 78 ;      ELSE
 JMP  CreatePath_L10
CreatePath_L9:
#srcline 79 ;        busy := FALSE; done := TRUE;
 LD   bool 0       ; false
 WRX  busy
#debug_left bool busy
 LD   bool -1       ; true
 WRX  done
#debug_left bool done
#srcline 80 ;      END_IF;
CreatePath_L10:
#srcline 81 ;    ELSE
 JMP  CreatePath_L8
CreatePath_L7:
#srcline 82 ;      res := FindFreeCluster(fileName := fileName);
 NXT
 LDX  fileName
 WR   __Instance__FindFreeCluster~fileName
#debug_left pointer __Instance__FindFreeCluster.fileName
 PRV
 LEA  __Instance__FindFreeCluster
 CAL  FindFreeCluster_L0
 WRY  res
#debug_left byte res
#srcline 83 ;      IF res = 0 THEN
 LDY  res
#debug byte res
 LD   byte 0
 EQ
 JMC  CreatePath_L13
#srcline 84 ;        createDir := FALSE; idle := 32;         // wait 32 cycles after dir create
 LD   bool 0       ; false
 WRX  createDir
#debug_left bool createDir
 LD   uint 32
 WRX  idle
#debug_left uint idle
#srcline 85 ;        ok := DirCreate( dirName := path);
 NXT
 LEAX path
 WR   __Instance__DirCreate~dirName
#debug_left pointer __Instance__DirCreate.dirName
 PRV
 LEA  __Instance__DirCreate
 CAL  DirCreate_L0
 WRY  ok
#debug_left bool ok
#srcline 86 ;        IF NOT ok THEN
 LDY  ok
#debug bool ok
 NEG
 JMC  CreatePath_L15
#srcline 87 ;          err := TRUE; busy := FALSE;             // dir was not created
 LD   bool -1       ; true
 WRX  err
#debug_left bool err
 LD   bool 0       ; false
 WRX  busy
#debug_left bool busy
#srcline 88 ;        END_IF;
CreatePath_L15:
#srcline 89 ;      ELSE
 JMP  CreatePath_L14
CreatePath_L13:
#srcline 90 ;        IF res <> 13 THEN
 LDY  res
#debug byte res
 LD   byte 13
 EQ
 NEG
 JMC  CreatePath_L17
#srcline 91 ;          err := TRUE; busy := FALSE;             // error disk full or not mounted
 LD   bool -1       ; true
 WRX  err
#debug_left bool err
 LD   bool 0       ; false
 WRX  busy
#debug_left bool busy
#srcline 92 ;        END_IF;
CreatePath_L17:
#srcline 93 ;      END_IF;
CreatePath_L14:
#srcline 94 ;    END_IF;
CreatePath_L8:
#srcline 95 ;  END_IF;
CreatePath_L5:
#srcline 97 ;  // set error code, if any
#srcline 98 ;  errTrig( CLK := err);
 LDX  err
#debug bool err
 WRX  errTrig~CLK
#debug_left bool errTrig~CLK
 LEAX errTrig
 CAL  R_TRIG_L0
#srcline 99 ;  IF errTrig.Q THEN
 LDX  errTrig~Q
#debug bool errTrig.Q
 JMC  CreatePath_L19
#srcline 100 ;    errID := GetLastErr();
 LEA  __Instance__GetLastErr
 CAL  GetLastErr_L0
 WRX  errID
#debug_left udint errID
#srcline 101 ;  END_IF;
CreatePath_L19:
#srcline 103 ;END_FUNCTION_BLOCK
CreatePath_RET:
 ULNK
RET
E     61
#endpou 



 

#srcfile ''
#srcfile 'C:\TECOLIBSRC\FILELIB\FILELIB\WRITEDBXTOFILE.ST'
#pou WriteDbxToFile
#srcline 1 ;FUNCTION_BLOCK WriteDbxToFile

#struct WriteDbxToFile__temp__
  udint restSize,
  udint written,
  udint reqSize,
  usint mode,
  byte res
P     61
WriteDbxToFile_L0:
 LINK __SizeOf(WriteDbxToFile__temp__)
; Initialize - dynamic variables
; End initialize - dynamic variables
#srcline 65 ;  adrVar := srcAdr + 16#8000_0000;         // + databox flag
 LDX  srcAdr
#debug udint srcAdr
 LD   udint $80000000
 ADD
 WRX  adrVar
#debug_left udint adrVar
#srcline 66 ;  eTrig(CLK := exec);
 LDX  exec
#debug bool exec
 WRX  eTrig~CLK
#debug_left bool eTrig~CLK
 LEAX eTrig
 CAL  R_TRIG_L0
#srcline 67 ;  IF idle <> 0 THEN idle := idle - 1; RETURN; END_IF; // wait 32 cycles after file create
 LDX  idle
#debug uint idle
 LD   uint 0
 EQ
 NEG
 JMC  WriteDbxToFile_L1
 LDX  idle
#debug uint idle
 LD   uint 1
 SUB
 AND  $FFFF
 WRX  idle
#debug_left uint idle
 JMP  WriteDbxToFile_RET
WriteDbxToFile_L1:
#srcline 69 ;  // open file and seek position
#srcline 70 ;  IF eTrig.Q THEN
 LDX  eTrig~Q
#debug bool eTrig.Q
 JMC  WriteDbxToFile_L3
#srcline 71 ;    IF hnd <> INVALID_HANDLE_VALUE THEN
 LDX  hnd
#debug udint hnd
 LD   udint 0
 EQ
 NEG
 JMC  WriteDbxToFile_L5
#srcline 72 ;      FileClose( hFile := hnd);
 NXT
 LDX  hnd
#debug udint hnd
 WR   __Instance__FileClose~hFile
#debug_left udint __Instance__FileClose~hFile
 PRV
 LEA  __Instance__FileClose
 CAL  FileClose_L0
#srcline 73 ;    END_IF;
WriteDbxToFile_L5:
#srcline 74 ;    busy := TRUE; done := FALSE; err := FALSE; errID := 0; actSize := 0;
 LD   bool -1       ; true
 WRX  busy
#debug_left bool busy
 LD   bool 0       ; false
 WRX  done
#debug_left bool done
 LD   bool 0       ; false
 WRX  err
#debug_left bool err
 LD   udint 0
 WRX  errID
#debug_left udint errID
 LD   udint 0
 WRX  actSize
#debug_left udint actSize
#srcline 75 ;    errTrig( CLK := FALSE);
 LD   bool 0       ; false
 WRX  errTrig~CLK
#debug_left bool errTrig~CLK
 LEAX errTrig
 CAL  R_TRIG_L0
#srcline 76 ;    IF seek = 0 THEN mode := F_WRITE; ELSE mode := F_APPEND; END_IF;
 LDX  seek
#debug udint seek
 LD   udint 0
 EQ
 JMC  WriteDbxToFile_L7
 LD   udint 1  ; TF_MODE#F_WRITE
 WRY  mode
#debug_left usint mode
 JMP  WriteDbxToFile_L8
WriteDbxToFile_L7:
 LD   udint 2  ; TF_MODE#F_APPEND
 WRY  mode
#debug_left usint mode
WriteDbxToFile_L8:
#srcline 77 ;    hnd := FileOpen( fileName := fileName, mode := mode);
 NXT
 LDX  fileName
 WR   __Instance__FileOpen~fileName
#debug_left pointer __Instance__FileOpen.fileName
 LDY  mode
#debug usint mode
 WR   __Instance__FileOpen~mode
#debug_left usint __Instance__FileOpen~mode
 PRV
 LEA  __Instance__FileOpen
 CAL  FileOpen_L0
 WRX  hnd
#debug_left udint hnd
#srcline 78 ;    IF hnd = INVALID_HANDLE_VALUE THEN
 LDX  hnd
#debug udint hnd
 LD   udint 0
 EQ
 JMC  WriteDbxToFile_L9
#srcline 79 ;      err := TRUE; busy := FALSE;
 LD   bool -1       ; true
 WRX  err
#debug_left bool err
 LD   bool 0       ; false
 WRX  busy
#debug_left bool busy
#srcline 80 ;    ELSE
 JMP  WriteDbxToFile_L10
WriteDbxToFile_L9:
#srcline 81 ;      idle := 32;
 LD   uint 32
 WRX  idle
#debug_left uint idle
#srcline 82 ;      IF seek <> 0 AND seek <> 16#FFFF_FFFF THEN
 LDX  seek
#debug udint seek
 LD   udint 0
 EQ
 NEG
 LDX  seek
#debug udint seek
 LD   udint $FFFFFFFF
 EQ
 NEG
 AND
 JMC  WriteDbxToFile_L11
#srcline 83 ;        IF FileSetPos( hFile := hnd, offset := seek) = FALSE THEN
 NXT
 LDX  hnd
#debug udint hnd
 WR   __Instance__FileSetPos~hFile
#debug_left udint __Instance__FileSetPos~hFile
 LDX  seek
#debug udint seek
 WR   __Instance__FileSetPos~offset
#debug_left udint __Instance__FileSetPos~offset
 PRV
 LEA  __Instance__FileSetPos
 CAL  FileSetPos_L0
 LD   bool 0       ; false
 XOR
 NEG
 JMC  WriteDbxToFile_L13
#srcline 84 ;          err := TRUE; busy := FALSE;
 LD   bool -1       ; true
 WRX  err
#debug_left bool err
 LD   bool 0       ; false
 WRX  busy
#debug_left bool busy
#srcline 85 ;        END_IF;
WriteDbxToFile_L13:
#srcline 86 ;      END_IF;
WriteDbxToFile_L11:
#srcline 87 ;    END_IF;
WriteDbxToFile_L10:
#srcline 88 ;  END_IF;
WriteDbxToFile_L3:
#srcline 90 ;  // write data to file to variable (one sector per one PLC cycle)
#srcline 91 ;  IF busy THEN
 LDX  busy
#debug bool busy
 JMC  WriteDbxToFile_L15
#srcline 92 ;    IF size > actSize THEN
 LDX  size
#debug udint size
 LDX  actSize
#debug udint actSize
 GT
 JMC  WriteDbxToFile_L17
#srcline 93 ;      restSize := size - actSize;
 LDX  size
#debug udint size
 LDX  actSize
#debug udint actSize
 SUB
 WRY  restSize
#debug_left udint restSize
#srcline 94 ;      IF restSize > 512 THEN reqSize := 512;          // more then one sector
 LDY  restSize
#debug udint restSize
 LD   udint 512
 GT
 JMC  WriteDbxToFile_L19
 LD   udint 512
 WRY  reqSize
#debug_left udint reqSize
#srcline 95 ;                        ELSE reqSize := restSize;     // last sector
 JMP  WriteDbxToFile_L20
WriteDbxToFile_L19:
 LDY  restSize
#debug udint restSize
 WRY  reqSize
#debug_left udint reqSize
#srcline 96 ;      END_IF;
WriteDbxToFile_L20:
#srcline 97 ;      res := FindFreeCluster(fileName := fileName);
 NXT
 LDX  fileName
 WR   __Instance__FindFreeCluster~fileName
#debug_left pointer __Instance__FindFreeCluster.fileName
 PRV
 LEA  __Instance__FindFreeCluster
 CAL  FindFreeCluster_L0
 WRY  res
#debug_left byte res
#srcline 98 ;      IF res = 0 THEN
 LDY  res
#debug byte res
 LD   byte 0
 EQ
 JMC  WriteDbxToFile_L21
#srcline 99 ;        written := FileWrite(hFile := hnd, adrBuf := adrVar + actSize, size := reqSize);
 NXT
 LDX  hnd
#debug udint hnd
 WR   __Instance__FileWrite~hFile
#debug_left udint __Instance__FileWrite~hFile
 LDX  adrVar
#debug udint adrVar
 LDX  actSize
#debug udint actSize
 ADD
 WR   __Instance__FileWrite~adrBuf
#debug_left udint __Instance__FileWrite~adrBuf
 LDY  reqSize
#debug udint reqSize
 WR   __Instance__FileWrite~size
#debug_left udint __Instance__FileWrite~size
 PRV
 LEA  __Instance__FileWrite
 CAL  FileWrite_L0
 WRY  written
#debug_left udint written
#srcline 100 ;        actSize := actSize + written;
 LDX  actSize
#debug udint actSize
 LDY  written
#debug udint written
 ADD
 WRX  actSize
#debug_left udint actSize
#srcline 101 ;        IF written <> reqSize THEN
 LDY  written
#debug udint written
 LDY  reqSize
#debug udint reqSize
 EQ
 NEG
 JMC  WriteDbxToFile_L23
#srcline 102 ;          busy := FALSE; err := TRUE;
 LD   bool 0       ; false
 WRX  busy
#debug_left bool busy
 LD   bool -1       ; true
 WRX  err
#debug_left bool err
#srcline 103 ;        ELSE
 JMP  WriteDbxToFile_L24
WriteDbxToFile_L23:
#srcline 104 ;          IF actSize = size THEN
 LDX  actSize
#debug udint actSize
 LDX  size
#debug udint size
 EQ
 JMC  WriteDbxToFile_L25
#srcline 105 ;            done := TRUE; busy := FALSE;
 LD   bool -1       ; true
 WRX  done
#debug_left bool done
 LD   bool 0       ; false
 WRX  busy
#debug_left bool busy
#srcline 106 ;          END_IF;
WriteDbxToFile_L25:
#srcline 107 ;        END_IF;
WriteDbxToFile_L24:
#srcline 108 ;      ELSE
 JMP  WriteDbxToFile_L22
WriteDbxToFile_L21:
#srcline 109 ;        IF res <> 13 THEN
 LDY  res
#debug byte res
 LD   byte 13
 EQ
 NEG
 JMC  WriteDbxToFile_L27
#srcline 110 ;          busy := FALSE; err := TRUE;      // disk full or not mounted
 LD   bool 0       ; false
 WRX  busy
#debug_left bool busy
 LD   bool -1       ; true
 WRX  err
#debug_left bool err
#srcline 111 ;        END_IF;
WriteDbxToFile_L27:
#srcline 112 ;      END_IF;
WriteDbxToFile_L22:
#srcline 113 ;    ELSE
 JMP  WriteDbxToFile_L18
WriteDbxToFile_L17:
#srcline 114 ;      done := TRUE;
 LD   bool -1       ; true
 WRX  done
#debug_left bool done
#srcline 115 ;    END_IF;
WriteDbxToFile_L18:
#srcline 116 ;  ELSE
 JMP  WriteDbxToFile_L16
WriteDbxToFile_L15:
#srcline 117 ;    done := done AND exec;
 LDX  done
#debug bool done
 LDX  exec
#debug bool exec
 AND
 WRX  done
#debug_left bool done
#srcline 118 ;    err  := err  AND exec;
 LDX  err
#debug bool err
 LDX  exec
#debug bool exec
 AND
 WRX  err
#debug_left bool err
#srcline 119 ;  END_IF;
WriteDbxToFile_L16:
#srcline 121 ;  // set error code, if any
#srcline 122 ;  errTrig( CLK := err);
 LDX  err
#debug bool err
 WRX  errTrig~CLK
#debug_left bool errTrig~CLK
 LEAX errTrig
 CAL  R_TRIG_L0
#srcline 123 ;  IF errTrig.Q THEN
 LDX  errTrig~Q
#debug bool errTrig.Q
 JMC  WriteDbxToFile_L29
#srcline 124 ;    errID := GetLastErr();
 LEA  __Instance__GetLastErr
 CAL  GetLastErr_L0
 WRX  errID
#debug_left udint errID
#srcline 125 ;  END_IF;
WriteDbxToFile_L29:
#srcline 127 ;  // close file
#srcline 128 ;  IF errTrig.Q OR done THEN
 LDX  errTrig~Q
#debug bool errTrig.Q
 LDX  done
#debug bool done
 OR  
 JMC  WriteDbxToFile_L31
#srcline 129 ;    IF hnd <> INVALID_HANDLE_VALUE THEN
 LDX  hnd
#debug udint hnd
 LD   udint 0
 EQ
 NEG
 JMC  WriteDbxToFile_L33
#srcline 130 ;      IF FileClose( hFile := hnd) THEN
 NXT
 LDX  hnd
#debug udint hnd
 WR   __Instance__FileClose~hFile
#debug_left udint __Instance__FileClose~hFile
 PRV
 LEA  __Instance__FileClose
 CAL  FileClose_L0
 JMC  WriteDbxToFile_L35
#srcline 131 ;        hnd := INVALID_HANDLE_VALUE;
 LD   udint 0
 WRX  hnd
#debug_left udint hnd
#srcline 132 ;      END_IF;
WriteDbxToFile_L35:
#srcline 133 ;    END_IF;
WriteDbxToFile_L33:
#srcline 134 ;  END_IF;
WriteDbxToFile_L31:
#srcline 136 ;  IF NOT busy THEN idle := 0; END_IF;      // od v1.3
 LDX  busy
#debug bool busy
 NEG
 JMC  WriteDbxToFile_L37
 LD   uint 0
 WRX  idle
#debug_left uint idle
WriteDbxToFile_L37:
#srcline 137 ;END_FUNCTION_BLOCK
WriteDbxToFile_RET:
 ULNK
RET
E     61
#endpou 



 

#srcfile ''
#srcfile 'C:\TECOLIBSRC\FILELIB\FILELIB\READDBXFROMFILE.ST'
#pou ReadDbxFromFile
#srcline 1 ;FUNCTION_BLOCK ReadDbxFromFile

#struct ReadDbxFromFile__temp__
  udint restSize,
  udint reqSize,
  udint read
P     61
ReadDbxFromFile_L0:
 LINK __SizeOf(ReadDbxFromFile__temp__)
; Initialize - dynamic variables
; End initialize - dynamic variables
#srcline 57 ;  adrVar := dstAdr + 16#8000_0000;         // + databox flag
 LDX  dstAdr
#debug udint dstAdr
 LD   udint $80000000
 ADD
 WRX  adrVar
#debug_left udint adrVar
#srcline 58 ;  execTrig( CLK := exec);
 LDX  exec
#debug bool exec
 WRX  execTrig~CLK
#debug_left bool execTrig~CLK
 LEAX execTrig
 CAL  R_TRIG_L0
#srcline 60 ;  // open file and seek position
#srcline 61 ;  IF execTrig.Q THEN
 LDX  execTrig~Q
#debug bool execTrig.Q
 JMC  ReadDbxFromFile_L1
#srcline 62 ;    busy := TRUE; done := FALSE; err := FALSE; errID := 0; actSize := 0;
 LD   bool -1       ; true
 WRX  busy
#debug_left bool busy
 LD   bool 0       ; false
 WRX  done
#debug_left bool done
 LD   bool 0       ; false
 WRX  err
#debug_left bool err
 LD   udint 0
 WRX  errID
#debug_left udint errID
 LD   udint 0
 WRX  actSize
#debug_left udint actSize
#srcline 63 ;    errTrig( CLK := FALSE);
 LD   bool 0       ; false
 WRX  errTrig~CLK
#debug_left bool errTrig~CLK
 LEAX errTrig
 CAL  R_TRIG_L0
#srcline 64 ;    hnd := FileOpen(fileName := fileName, mode := F_READ);
 NXT
 LDX  fileName
 WR   __Instance__FileOpen~fileName
#debug_left pointer __Instance__FileOpen.fileName
 LD   udint 0  ; TF_MODE#F_READ
 WR   __Instance__FileOpen~mode
#debug_left usint __Instance__FileOpen~mode
 PRV
 LEA  __Instance__FileOpen
 CAL  FileOpen_L0
 WRX  hnd
#debug_left udint hnd
#srcline 65 ;    IF hnd = INVALID_HANDLE_VALUE THEN
 LDX  hnd
#debug udint hnd
 LD   udint 0
 EQ
 JMC  ReadDbxFromFile_L3
#srcline 66 ;      err := TRUE; busy := FALSE;
 LD   bool -1       ; true
 WRX  err
#debug_left bool err
 LD   bool 0       ; false
 WRX  busy
#debug_left bool busy
#srcline 67 ;    ELSE
 JMP  ReadDbxFromFile_L4
ReadDbxFromFile_L3:
#srcline 68 ;      IF seek <> 0 THEN
 LDX  seek
#debug udint seek
 LD   udint 0
 EQ
 NEG
 JMC  ReadDbxFromFile_L5
#srcline 69 ;        IF FileSetPos( hFile := hnd, offset := seek) = FALSE THEN
 NXT
 LDX  hnd
#debug udint hnd
 WR   __Instance__FileSetPos~hFile
#debug_left udint __Instance__FileSetPos~hFile
 LDX  seek
#debug udint seek
 WR   __Instance__FileSetPos~offset
#debug_left udint __Instance__FileSetPos~offset
 PRV
 LEA  __Instance__FileSetPos
 CAL  FileSetPos_L0
 LD   bool 0       ; false
 XOR
 NEG
 JMC  ReadDbxFromFile_L7
#srcline 70 ;          err := TRUE; busy := FALSE;
 LD   bool -1       ; true
 WRX  err
#debug_left bool err
 LD   bool 0       ; false
 WRX  busy
#debug_left bool busy
#srcline 71 ;        END_IF;
ReadDbxFromFile_L7:
#srcline 72 ;      END_IF;
ReadDbxFromFile_L5:
#srcline 73 ;    END_IF;
ReadDbxFromFile_L4:
#srcline 74 ;  END_IF;
ReadDbxFromFile_L1:
#srcline 76 ;  // read data from file to variable (one sector per one PLC cycle)
#srcline 77 ;  IF busy THEN
 LDX  busy
#debug bool busy
 JMC  ReadDbxFromFile_L9
#srcline 78 ;    IF size > actSize THEN
 LDX  size
#debug udint size
 LDX  actSize
#debug udint actSize
 GT
 JMC  ReadDbxFromFile_L11
#srcline 79 ;      restSize := size - actSize;
 LDX  size
#debug udint size
 LDX  actSize
#debug udint actSize
 SUB
 WRY  restSize
#debug_left udint restSize
#srcline 80 ;      IF restSize > 512 THEN reqSize := 512;          // more then one sector
 LDY  restSize
#debug udint restSize
 LD   udint 512
 GT
 JMC  ReadDbxFromFile_L13
 LD   udint 512
 WRY  reqSize
#debug_left udint reqSize
#srcline 81 ;                        ELSE reqSize := restSize;     // last sector
 JMP  ReadDbxFromFile_L14
ReadDbxFromFile_L13:
 LDY  restSize
#debug udint restSize
 WRY  reqSize
#debug_left udint reqSize
#srcline 82 ;      END_IF;
ReadDbxFromFile_L14:
#srcline 83 ;      read := FileRead( hFile := hnd, adrBuf := adrVar + actSize, size := reqSize);
 NXT
 LDX  hnd
#debug udint hnd
 WR   __Instance__FileRead~hFile
#debug_left udint __Instance__FileRead~hFile
 LDX  adrVar
#debug udint adrVar
 LDX  actSize
#debug udint actSize
 ADD
 WR   __Instance__FileRead~adrBuf
#debug_left udint __Instance__FileRead~adrBuf
 LDY  reqSize
#debug udint reqSize
 WR   __Instance__FileRead~size
#debug_left udint __Instance__FileRead~size
 PRV
 LEA  __Instance__FileRead
 CAL  FileRead_L0
 WRY  read
#debug_left udint read
#srcline 84 ;      actSize := actSize + read;
 LDX  actSize
#debug udint actSize
 LDY  read
#debug udint read
 ADD
 WRX  actSize
#debug_left udint actSize
#srcline 85 ;      IF read <> reqSize THEN
 LDY  read
#debug udint read
 LDY  reqSize
#debug udint reqSize
 EQ
 NEG
 JMC  ReadDbxFromFile_L15
#srcline 86 ;        busy := FALSE;
 LD   bool 0       ; false
 WRX  busy
#debug_left bool busy
#srcline 87 ;        IF read > 0 THEN
 LDY  read
#debug udint read
 LD   udint 0
 GT
 JMC  ReadDbxFromFile_L17
#srcline 88 ;          done := TRUE;           // end of file
 LD   bool -1       ; true
 WRX  done
#debug_left bool done
#srcline 89 ;        ELSE
 JMP  ReadDbxFromFile_L18
ReadDbxFromFile_L17:
#srcline 90 ;          IF GetLastErr() = 0 THEN
 LEA  __Instance__GetLastErr
 CAL  GetLastErr_L0
 LD   udint 0
 EQ
 JMC  ReadDbxFromFile_L19
#srcline 91 ;            done := TRUE;         // end of file
 LD   bool -1       ; true
 WRX  done
#debug_left bool done
#srcline 92 ;          ELSE
 JMP  ReadDbxFromFile_L20
ReadDbxFromFile_L19:
#srcline 93 ;            err  := TRUE;         // propably any error
 LD   bool -1       ; true
 WRX  err
#debug_left bool err
#srcline 94 ;          END_IF;
ReadDbxFromFile_L20:
#srcline 95 ;        END_IF;
ReadDbxFromFile_L18:
#srcline 96 ;      ELSE
 JMP  ReadDbxFromFile_L16
ReadDbxFromFile_L15:
#srcline 97 ;        IF actSize = size THEN
 LDX  actSize
#debug udint actSize
 LDX  size
#debug udint size
 EQ
 JMC  ReadDbxFromFile_L21
#srcline 98 ;          done := TRUE; busy := FALSE;
 LD   bool -1       ; true
 WRX  done
#debug_left bool done
 LD   bool 0       ; false
 WRX  busy
#debug_left bool busy
#srcline 99 ;        END_IF;
ReadDbxFromFile_L21:
#srcline 100 ;      END_IF;
ReadDbxFromFile_L16:
#srcline 101 ;    ELSE
 JMP  ReadDbxFromFile_L12
ReadDbxFromFile_L11:
#srcline 102 ;      done := TRUE;
 LD   bool -1       ; true
 WRX  done
#debug_left bool done
#srcline 103 ;    END_IF;
ReadDbxFromFile_L12:
#srcline 104 ;  ELSE
 JMP  ReadDbxFromFile_L10
ReadDbxFromFile_L9:
#srcline 105 ;    done := done AND exec;
 LDX  done
#debug bool done
 LDX  exec
#debug bool exec
 AND
 WRX  done
#debug_left bool done
#srcline 106 ;    err  := err  AND exec;
 LDX  err
#debug bool err
 LDX  exec
#debug bool exec
 AND
 WRX  err
#debug_left bool err
#srcline 107 ;  END_IF;
ReadDbxFromFile_L10:
#srcline 109 ;  // set error code, if any
#srcline 110 ;  errTrig( CLK := err);
 LDX  err
#debug bool err
 WRX  errTrig~CLK
#debug_left bool errTrig~CLK
 LEAX errTrig
 CAL  R_TRIG_L0
#srcline 111 ;  IF errTrig.Q THEN
 LDX  errTrig~Q
#debug bool errTrig.Q
 JMC  ReadDbxFromFile_L23
#srcline 112 ;    errID := GetLastErr();
 LEA  __Instance__GetLastErr
 CAL  GetLastErr_L0
 WRX  errID
#debug_left udint errID
#srcline 113 ;  END_IF;
ReadDbxFromFile_L23:
#srcline 115 ;  // close file
#srcline 116 ;  IF errTrig.Q OR done THEN
 LDX  errTrig~Q
#debug bool errTrig.Q
 LDX  done
#debug bool done
 OR  
 JMC  ReadDbxFromFile_L25
#srcline 117 ;    IF hnd <> INVALID_HANDLE_VALUE THEN
 LDX  hnd
#debug udint hnd
 LD   udint 0
 EQ
 NEG
 JMC  ReadDbxFromFile_L27
#srcline 118 ;      IF FileClose( hFile := hnd) THEN
 NXT
 LDX  hnd
#debug udint hnd
 WR   __Instance__FileClose~hFile
#debug_left udint __Instance__FileClose~hFile
 PRV
 LEA  __Instance__FileClose
 CAL  FileClose_L0
 JMC  ReadDbxFromFile_L29
#srcline 119 ;        hnd := INVALID_HANDLE_VALUE;
 LD   udint 0
 WRX  hnd
#debug_left udint hnd
#srcline 120 ;      END_IF;
ReadDbxFromFile_L29:
#srcline 121 ;    END_IF;
ReadDbxFromFile_L27:
#srcline 122 ;  END_IF;
ReadDbxFromFile_L25:
#srcline 123 ;END_FUNCTION_BLOCK
 ULNK
RET
E     61
#endpou 



 

#srcfile ''
#srcfile 'C:\TECOLIBSRC\FILELIB\FILELIB\WRITETOFILESEQ.ST'
#pou WriteToFileSeq
#srcline 1 ;FUNCTION_BLOCK WriteToFileSeq
P     61
WriteToFileSeq_L0:
 LINK 0
#srcline 52 ;  IF NOT open THEN
 LDX  open
#debug bool open
 NEG
 JMC  WriteToFileSeq_L1
#srcline 53 ;    actSize := 0;
 LD   udint 0
 WRX  actSize
#debug_left udint actSize
#srcline 54 ;    IF write THEN
 LDX  write
#debug bool write
 JMC  WriteToFileSeq_L3
#srcline 55 ;      hnd := FileOpen(F_WRITE, fileName);
 NXT
 LD   udint 1  ; TF_MODE#F_WRITE
 WR   __Instance__FileOpen~mode
#debug_left usint __Instance__FileOpen~mode
 LDX  fileName
 WR   __Instance__FileOpen~fileName
#debug_left pointer __Instance__FileOpen.fileName
 PRV
 LEA  __Instance__FileOpen
 CAL  FileOpen_L0
 WRX  hnd
#debug_left udint hnd
#srcline 56 ;      open := hnd <> INVALID_HANDLE_VALUE;
 LDX  hnd
#debug udint hnd
 LD   udint 0
 EQ
 NEG
 WRX  open
#debug_left bool open
#srcline 57 ;      err := NOT open;
 LDX  open
#debug bool open
 NEG
 WRX  err
#debug_left bool err
#srcline 58 ;    END_IF;
WriteToFileSeq_L3:
#srcline 59 ;  END_IF;
WriteToFileSeq_L1:
#srcline 61 ;  IF open THEN
 LDX  open
#debug bool open
 JMC  WriteToFileSeq_L5
#srcline 62 ;    IF write THEN
 LDX  write
#debug bool write
 JMC  WriteToFileSeq_L7
#srcline 63 ;      IF size > 0 THEN
 LDX  size
#debug udint size
 LD   udint 0
 GT
 JMC  WriteToFileSeq_L9
#srcline 64 ;        wrSize := FileWrite(hnd, PTR_TO_UDINT(ADR(srcVar)), size);
 NXT
 LDX  hnd
#debug udint hnd
 WR   __Instance__FileWrite~hFile
#debug_left udint __Instance__FileWrite~hFile
 LDX  srcVar
#debug pointer srcVar
 WR   __Instance__FileWrite~adrBuf
#debug_left udint __Instance__FileWrite~adrBuf
 LDX  size
#debug udint size
 WR   __Instance__FileWrite~size
#debug_left udint __Instance__FileWrite~size
 PRV
 LEA  __Instance__FileWrite
 CAL  FileWrite_L0
 WRX  wrSize
#debug_left udint wrSize
#srcline 65 ;        err := size <> wrSize;
 LDX  size
#debug udint size
 LDX  wrSize
#debug udint wrSize
 EQ
 NEG
 WRX  err
#debug_left bool err
#srcline 66 ;        actSize := actSize + wrSize;
 LDX  actSize
#debug udint actSize
 LDX  wrSize
#debug udint wrSize
 ADD
 WRX  actSize
#debug_left udint actSize
#srcline 67 ;      END_IF;
WriteToFileSeq_L9:
#srcline 68 ;    END_IF;
WriteToFileSeq_L7:
#srcline 70 ;    IF close THEN
 LDX  close
#debug bool close
 JMC  WriteToFileSeq_L11
#srcline 71 ;      FileClose(hnd);
 NXT
 LDX  hnd
#debug udint hnd
 WR   __Instance__FileClose~hFile
#debug_left udint __Instance__FileClose~hFile
 PRV
 LEA  __Instance__FileClose
 CAL  FileClose_L0
#srcline 72 ;      hnd := INVALID_HANDLE_VALUE;
 LD   udint 0
 WRX  hnd
#debug_left udint hnd
#srcline 73 ;      open := false;
 LD   bool 0       ; false
 WRX  open
#debug_left bool open
#srcline 74 ;    END_IF;
WriteToFileSeq_L11:
#srcline 75 ;  END_IF;
WriteToFileSeq_L5:
#srcline 77 ;  //kod chyby
#srcline 78 ;  errTrig(CLK := err);
 LDX  err
#debug bool err
 WRX  errTrig~CLK
#debug_left bool errTrig~CLK
 LEAX errTrig
 CAL  R_TRIG_L0
#srcline 79 ;  IF errTrig.Q THEN
 LDX  errTrig~Q
#debug bool errTrig.Q
 JMC  WriteToFileSeq_L13
#srcline 80 ;    errID := GetLastErr();
 LEA  __Instance__GetLastErr
 CAL  GetLastErr_L0
 WRX  errID
#debug_left udint errID
#srcline 81 ;  END_IF;
WriteToFileSeq_L13:
#srcline 83 ;END_FUNCTION_BLOCK
 ULNK
RET
E     61
#endpou 



 

#srcfile ''
#srcfile 'C:\TECOLIBSRC\FILELIB\FILELIB\DELETEDIRECTORIES.ST'
#pou DeleteDirectories
#srcline 1 ;FUNCTION_BLOCK DeleteDirectories

#struct DeleteDirectories__temp__
  usint P0__st__,
  string[82] PS0__st__
#data byte _str_DeleteDirectories_0 = 
  '',0
#data byte _str_DeleteDirectories_1 = 
  '/',0
#data byte _str_DeleteDirectories_2 = 
  '',0
#data byte _str_DeleteDirectories_3 = 
  '',0
P     61
DeleteDirectories_L0:
 LINK __SizeOf(DeleteDirectories__temp__)
; Initialize - dynamic variables
; End initialize - dynamic variables
; R_EDGE, F_EDGE 
 LDX  exec
 LETX __EDGE_R__exec
 WRX  exec
#srcline 34 ;  Err := false;
 LD   bool 0       ; false
 WRX  Err
#debug_left bool Err
#srcline 35 ;  Done := false;
 LD   bool 0       ; false
 WRX  Done
#debug_left bool Done
#srcline 37 ;  IF exec THEN
 LDX  exec
#debug bool exec
 JMC  DeleteDirectories_L1
#srcline 38 ;    FOR i := 0 TO dirStackLev DO
 LD   usint 0
 WRX  i
 LDX  dirStackLev
#debug usint dirStackLev
 WRY  P0__st__
DeleteDirectories_L3:
 LDX  i
 LDY  P0__st__
 GT   
 JMD  DeleteDirectories_L4
 DBG  
#srcline 39 ;      IF dirStack[i].hDir <> INVALID_HANDLE_VALUE THEN
 LEAX dirStack
 LDX  i
#debug usint i
 RCHK 8   ; Range Check
 MUL  17   ; SizeOf(...)
 ADD     ; + offset 
 LDIL 
#debug udint dirStack[i].hDir
 LD   udint 0
 EQ
 NEG
 JMC  DeleteDirectories_L5
#srcline 40 ;        DirClose(hDir := dirStack[i].hDir);
 NXT
 LEAX dirStack
 LDX  i
#debug usint i
 RCHK 8   ; Range Check
 MUL  17   ; SizeOf(...)
 ADD     ; + offset 
 LDIL 
#debug udint dirStack[i].hDir
 WR   __Instance__DirClose~hDir
#debug_left udint __Instance__DirClose~hDir
 PRV
 LEA  __Instance__DirClose
 CAL  DirClose_L0
#srcline 41 ;        dirStack[i].hDir := INVALID_HANDLE_VALUE;
 LD   udint 0
 LEAX dirStack
 LDX  i
#debug usint i
 RCHK 8   ; Range Check
 MUL  17   ; SizeOf(...)
 ADD     ; + offset 
 WRIL 
#debug_left udint dirStack[i].hDir
#srcline 42 ;        dirStack[i].sDir := '';
 LD   0   ; null string
 LEAX dirStack
 LDX  i
#debug usint i
 RCHK 8   ; Range Check
 MUL  17   ; SizeOf(...)
 ADD     ; + offset 
 ADD  4  ; + offset 
 WRI  
 LEAX dirStack
 LDX  i
#debug usint i
 RCHK 8   ; Range Check
 MUL  17   ; SizeOf(...)
 ADD     ; + offset 
 ADD  4  ; + offset 
 LD   12
 DST    ; Level 1
 LEA  _str_DeleteDirectories_0
 SCON 
#debug_left string dirStack[i].sDir
 PDST   ; Level 1
#srcline 43 ;      END_IF;
DeleteDirectories_L5:
#srcline 45 ;      dirStack[0].hDir := DirOpen(dirName := DirName, dirInfo := lLocalFileInfo);
 NXT
 LDX  DirName
 WR   __Instance__DirOpen~dirName
#debug_left pointer __Instance__DirOpen.dirName
 LEAX lLocalFileInfo
 WR   __Instance__DirOpen~dirInfo
#debug_left pointer __Instance__DirOpen.dirInfo
 PRV
 LEA  __Instance__DirOpen
 CAL  DirOpen_L0
 LEAX dirStack
 WRIL 
#debug_left udint dirStack[0].hDir
#srcline 46 ;      IF dirStack[0].hDir <> INVALID_HANDLE_VALUE THEN
 LEAX dirStack
 LDIL 
#debug udint dirStack[0].hDir
 LD   udint 0
 EQ
 NEG
 JMC  DeleteDirectories_L7
#srcline 47 ;        Busy  := true;
 LD   bool -1       ; true
 WRX  Busy
#debug_left bool Busy
#srcline 48 ;      ELSE
 JMP  DeleteDirectories_L8
DeleteDirectories_L7:
#srcline 49 ;        Err   := true;
 LD   bool -1       ; true
 WRX  Err
#debug_left bool Err
#srcline 50 ;      END_IF;
DeleteDirectories_L8:
#srcline 52 ;    END_FOR;
 LDX  i
 LD   1
 ADD  
 WRX  i
 JMP  DeleteDirectories_L3
DeleteDirectories_L4:
 NOP  -1
#srcline 54 ;    dirStackLev := 0;
 LD   usint 0
 WRX  dirStackLev
#debug_left usint dirStackLev
#srcline 55 ;    Busy := 1;
 LD   bool -1      ; true
 WRX  Busy
#debug_left bool Busy
#srcline 56 ;  END_IF;
DeleteDirectories_L1:
#srcline 58 ;  IF Busy THEN
 LDX  Busy
#debug bool Busy
 JMC  DeleteDirectories_L9
#srcline 59 ;//    Stop := true;          // pro ladeni
#srcline 60 ;    IF dirStack[dirStackLev].hDir <> INVALID_HANDLE_VALUE THEN //je adresar
 LEAX dirStack
 LDX  dirStackLev
#debug usint dirStackLev
 RCHK 8   ; Range Check
 MUL  17   ; SizeOf(...)
 ADD     ; + offset 
 LDIL 
#debug udint dirStack[dirStackLev].hDir
 LD   udint 0
 EQ
 NEG
 JMC  DeleteDirectories_L11
#srcline 61 ;      CurrFile := DirName + dirStack[1].sDir + dirStack[2].sDir + dirStack[3].sDir + dirStack[4].sDir + lLocalFileInfo.fileName;
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   80
 DST    ; Level 1
 LDX  DirName
#debug string DirName
 SCON 
 LEAX dirStack
 ADD  21  ; + offset 
#debug string dirStack[1].sDir
 SCON 
 LEAX dirStack
 ADD  38  ; + offset 
#debug string dirStack[2].sDir
 SCON 
 LEAX dirStack
 ADD  55  ; + offset 
#debug string dirStack[3].sDir
 SCON 
 LEAX dirStack
 ADD  72  ; + offset 
#debug string dirStack[4].sDir
 SCON 
 LEAX lLocalFileInfo
 ADD  24  ; + offset 
#debug string lLocalFileInfo.fileName
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX CurrFile
 WRI  
 LEAX CurrFile
 LD   80
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string CurrFile
 PDST   ; Level 1
#srcline 62 ;      IF lLocalFileInfo.attrib AND 16#10 =  16#10 THEN
 LDX  lLocalFileInfo~attrib
#debug dword lLocalFileInfo.attrib
 LD   dword $10
 AND
 LD   dword $10
 EQ
 JMC  DeleteDirectories_L13
#srcline 63 ;        IF dirStackLev < DIR_STACK_MAX_LEVEL THEN
 LDX  dirStackLev
#debug usint dirStackLev
 LD   usint 8
 LT
 JMC  DeleteDirectories_L15
#srcline 64 ;          dirStackLev := dirStackLev + 1;
 LDX  dirStackLev
#debug usint dirStackLev
 LD   usint 1
 ADD
 AND  $FF
 WRX  dirStackLev
#debug_left usint dirStackLev
#srcline 65 ;          dirStack[dirStackLev].sDir := lLocalFileInfo.fileName + '/';
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   12
 DST    ; Level 1
 LEAX lLocalFileInfo
 ADD  24  ; + offset 
#debug string lLocalFileInfo.fileName
 SCON 
 LEA  _str_DeleteDirectories_1
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX dirStack
 LDX  dirStackLev
#debug usint dirStackLev
 RCHK 8   ; Range Check
 MUL  17   ; SizeOf(...)
 ADD     ; + offset 
 ADD  4  ; + offset 
 WRI  
 LEAX dirStack
 LDX  dirStackLev
#debug usint dirStackLev
 RCHK 8   ; Range Check
 MUL  17   ; SizeOf(...)
 ADD     ; + offset 
 ADD  4  ; + offset 
 LD   12
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string dirStack[dirStackLev].sDir
 PDST   ; Level 1
#srcline 66 ;          dirStack[dirStackLev].hDir := DirOpen(dirName := CurrFile, dirInfo := lLocalFileInfo);
 NXT
 LEAX CurrFile
 WR   __Instance__DirOpen~dirName
#debug_left pointer __Instance__DirOpen.dirName
 LEAX lLocalFileInfo
 WR   __Instance__DirOpen~dirInfo
#debug_left pointer __Instance__DirOpen.dirInfo
 PRV
 LEA  __Instance__DirOpen
 CAL  DirOpen_L0
 LEAX dirStack
 LDX  dirStackLev
#debug usint dirStackLev
 RCHK 8   ; Range Check
 MUL  17   ; SizeOf(...)
 ADD     ; + offset 
 WRIL 
#debug_left udint dirStack[dirStackLev].hDir
#srcline 67 ;          IF dirStack[dirStackLev].hDir = INVALID_HANDLE_VALUE THEN
 LEAX dirStack
 LDX  dirStackLev
#debug usint dirStackLev
 RCHK 8   ; Range Check
 MUL  17   ; SizeOf(...)
 ADD     ; + offset 
 LDIL 
#debug udint dirStack[dirStackLev].hDir
 LD   udint 0
 EQ
 JMC  DeleteDirectories_L17
#srcline 68 ;            FileDelete(fileName := CurrFile);
 NXT
 LEAX CurrFile
 WR   __Instance__FileDelete~fileName
#debug_left pointer __Instance__FileDelete.fileName
 PRV
 LEA  __Instance__FileDelete
 CAL  FileDelete_L0
#srcline 69 ;            (* ignorovat chybu, vznikne na prazdnem adresary     *)
#srcline 70 ;            dirStack[dirStackLev].sDir := '';
 LD   0   ; null string
 LEAX dirStack
 LDX  dirStackLev
#debug usint dirStackLev
 RCHK 8   ; Range Check
 MUL  17   ; SizeOf(...)
 ADD     ; + offset 
 ADD  4  ; + offset 
 WRI  
 LEAX dirStack
 LDX  dirStackLev
#debug usint dirStackLev
 RCHK 8   ; Range Check
 MUL  17   ; SizeOf(...)
 ADD     ; + offset 
 ADD  4  ; + offset 
 LD   12
 DST    ; Level 1
 LEA  _str_DeleteDirectories_2
 SCON 
#debug_left string dirStack[dirStackLev].sDir
 PDST   ; Level 1
#srcline 71 ;            dirStackLev := dirStackLev - 1;
 LDX  dirStackLev
#debug usint dirStackLev
 LD   usint 1
 SUB
 AND  $FF
 WRX  dirStackLev
#debug_left usint dirStackLev
#srcline 72 ;          END_IF;
DeleteDirectories_L17:
#srcline 73 ;        ELSE
 JMP  DeleteDirectories_L16
DeleteDirectories_L15:
#srcline 74 ;          Busy := false;
 LD   bool 0       ; false
 WRX  Busy
#debug_left bool Busy
#srcline 75 ;          Err := true;
 LD   bool -1       ; true
 WRX  Err
#debug_left bool Err
#srcline 76 ;          RETURN;
 JMP  DeleteDirectories_RET
#srcline 77 ;            //eErrId := 5; //to many subdirectories
#srcline 78 ;        END_IF;
DeleteDirectories_L16:
#srcline 79 ;        RETURN;
 JMP  DeleteDirectories_RET
#srcline 80 ;      ELSE
 JMP  DeleteDirectories_L14
DeleteDirectories_L13:
#srcline 81 ;        FileDelete(fileName := CurrFile);
 NXT
 LEAX CurrFile
 WR   __Instance__FileDelete~fileName
#debug_left pointer __Instance__FileDelete.fileName
 PRV
 LEA  __Instance__FileDelete
 CAL  FileDelete_L0
#srcline 82 ;      END_IF;
DeleteDirectories_L14:
#srcline 84 ;      IF NOT DirRead(hDir := dirStack[dirStackLev].hDir, dirInfo := lLocalFileInfo) THEN        //nacist dalsi jmeno
 NXT
 LEAX dirStack
 LDX  dirStackLev
#debug usint dirStackLev
 RCHK 8   ; Range Check
 MUL  17   ; SizeOf(...)
 ADD     ; + offset 
 LDIL 
#debug udint dirStack[dirStackLev].hDir
 WR   __Instance__DirRead~hDir
#debug_left udint __Instance__DirRead~hDir
 LEAX lLocalFileInfo
 WR   __Instance__DirRead~dirInfo
#debug_left pointer __Instance__DirRead.dirInfo
 PRV
 LEA  __Instance__DirRead
 CAL  DirRead_L0
 NEG
 JMC  DeleteDirectories_L19
#srcline 85 ;        DirClose(hDir := dirStack[dirStackLev].hDir);
 NXT
 LEAX dirStack
 LDX  dirStackLev
#debug usint dirStackLev
 RCHK 8   ; Range Check
 MUL  17   ; SizeOf(...)
 ADD     ; + offset 
 LDIL 
#debug udint dirStack[dirStackLev].hDir
 WR   __Instance__DirClose~hDir
#debug_left udint __Instance__DirClose~hDir
 PRV
 LEA  __Instance__DirClose
 CAL  DirClose_L0
#srcline 86 ;        CurrFile := DirName + dirStack[1].sDir + dirStack[2].sDir + dirStack[3].sDir + dirStack[4].sDir;
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   80
 DST    ; Level 1
 LDX  DirName
#debug string DirName
 SCON 
 LEAX dirStack
 ADD  21  ; + offset 
#debug string dirStack[1].sDir
 SCON 
 LEAX dirStack
 ADD  38  ; + offset 
#debug string dirStack[2].sDir
 SCON 
 LEAX dirStack
 ADD  55  ; + offset 
#debug string dirStack[3].sDir
 SCON 
 LEAX dirStack
 ADD  72  ; + offset 
#debug string dirStack[4].sDir
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX CurrFile
 WRI  
 LEAX CurrFile
 LD   80
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string CurrFile
 PDST   ; Level 1
#srcline 87 ;        dirStack[dirStackLev].hDir := INVALID_HANDLE_VALUE;
 LD   udint 0
 LEAX dirStack
 LDX  dirStackLev
#debug usint dirStackLev
 RCHK 8   ; Range Check
 MUL  17   ; SizeOf(...)
 ADD     ; + offset 
 WRIL 
#debug_left udint dirStack[dirStackLev].hDir
#srcline 88 ;        dirStack[dirStackLev].sDir := '';
 LD   0   ; null string
 LEAX dirStack
 LDX  dirStackLev
#debug usint dirStackLev
 RCHK 8   ; Range Check
 MUL  17   ; SizeOf(...)
 ADD     ; + offset 
 ADD  4  ; + offset 
 WRI  
 LEAX dirStack
 LDX  dirStackLev
#debug usint dirStackLev
 RCHK 8   ; Range Check
 MUL  17   ; SizeOf(...)
 ADD     ; + offset 
 ADD  4  ; + offset 
 LD   12
 DST    ; Level 1
 LEA  _str_DeleteDirectories_3
 SCON 
#debug_left string dirStack[dirStackLev].sDir
 PDST   ; Level 1
#srcline 89 ;        IF dirStackLev > 0 THEN
 LDX  dirStackLev
#debug usint dirStackLev
 LD   usint 0
 GT
 JMC  DeleteDirectories_L21
#srcline 90 ;          FileDelete(fileName := CurrFile);
 NXT
 LEAX CurrFile
 WR   __Instance__FileDelete~fileName
#debug_left pointer __Instance__FileDelete.fileName
 PRV
 LEA  __Instance__FileDelete
 CAL  FileDelete_L0
#srcline 91 ;          dirStackLev := dirStackLev - 1;
 LDX  dirStackLev
#debug usint dirStackLev
 LD   usint 1
 SUB
 AND  $FF
 WRX  dirStackLev
#debug_left usint dirStackLev
#srcline 92 ;        END_IF;
DeleteDirectories_L21:
#srcline 93 ;      END_IF;
DeleteDirectories_L19:
#srcline 95 ;      IF dirStack[0].hDir = INVALID_HANDLE_VALUE THEN //adresar skoncil konec
 LEAX dirStack
 LDIL 
#debug udint dirStack[0].hDir
 LD   udint 0
 EQ
 JMC  DeleteDirectories_L23
#srcline 96 ;        Busy := false;
 LD   bool 0       ; false
 WRX  Busy
#debug_left bool Busy
#srcline 97 ;        Done := true;
 LD   bool -1       ; true
 WRX  Done
#debug_left bool Done
#srcline 98 ;      END_IF;
DeleteDirectories_L23:
#srcline 99 ;    END_IF;
DeleteDirectories_L11:
#srcline 100 ;  END_IF;
DeleteDirectories_L9:
#srcline 102 ;END_FUNCTION_BLOCK
DeleteDirectories_RET:
 ULNK
RET
E     61
#endpou 



 

#srcfile ''
#srcfile 'C:\TECOLIBSRC\FILELIB\FILELIB\FBREADLINEFROMFILE.ST'
#pou ReadLine
#srcline 1 ;FUNCTION_BLOCK ReadLine

#struct ReadLine__temp__
  bool ok,
  string[257] PS0__st__
#data byte _str_ReadLine_0 = 
  '',0
#data byte _str_ReadLine_1 = 
  '',0
#data byte _str_ReadLine_2 = 
  '',0
#data byte _str_ReadLine_3 = 
  '',0
#data byte _str_ReadLine_4 = 
  'F','i','l','e',' ','n','o','t',' ','f','o','u','n','d',0
#data byte _str_ReadLine_5 = 
  'E','n','d',' ','o','f',' ','f','i','l','e','.',' ','L','i','n','e',' ','n','o',
  't',' ','f','o','u','n','d',0
P     61
ReadLine_L0:
 LINK __SizeOf(ReadLine__temp__)
; Initialize - dynamic variables
; End initialize - dynamic variables
#srcline 72 ;  done := 0;                                                        // done nastavovat pouze na 1 cykl
 LD   bool 0       ; false
 WRX  done
#debug_left bool done
#srcline 73 ;  IF line = 0 THEN                                                  // pokud je radek 0 smazat vsechny priznaky
 LDX  line
#debug udint line
 LD   udint 0
 EQ
 JMC  ReadLine_L1
#srcline 74 ;    busy := 0; errID := 0; errTxt := ''; lastFile := '';
 LD   bool 0       ; false
 WRX  busy
#debug_left bool busy
 LD   udint 0
 WRX  errID
#debug_left udint errID
 LD   0   ; null string
 LEAX errTxt
 WRI  
 LEAX errTxt
 LD   80
 DST    ; Level 1
 LEA  _str_ReadLine_0
 SCON 
#debug_left string errTxt
 PDST   ; Level 1
 LD   0   ; null string
 LEAX lastFile
 WRI  
 LEAX lastFile
 LD   80
 DST    ; Level 1
 LEA  _str_ReadLine_1
 SCON 
#debug_left string lastFile
 PDST   ; Level 1
#srcline 75 ;  ELSIF LEN(filename) > 0 THEN
 JMP  ReadLine_L2
ReadLine_L1:
 LDX  filename
#debug string filename
 SLEN 
 LD   int 0
 GTS
 JMC  ReadLine_L3
#srcline 76 ;     newFile := fileName <> lastFile;                               // novy soubor
 LDX  fileName
#debug string fileName
 LEAX lastFile
#debug string lastFile
 SCMP 
 EQ   0
 NEG
 WRX  newFile
#debug_left bool newFile
#srcline 77 ;     IF (lastLine <> line) OR newFile THEN                          // zmena radku nebo jiny soubor
 LDX  lastLine
#debug udint lastLine
 LDX  line
#debug udint line
 EQ
 NEG
 LDX  newFile
#debug bool newFile
 OR  
 JMC  ReadLine_L4
#srcline 78 ;       outidx := 0;                                                 // zacit plnit vystup od zacatku (potreba pro vetsi nez je bufTxt)
 LD   uint 0
 WRX  outidx
#debug_left uint outidx
#srcline 79 ;       busy := 1; err := 0; errID :=0; errTxt := '';                // zahajit cteni
 LD   bool -1      ; true
 WRX  busy
#debug_left bool busy
 LD   bool 0       ; false
 WRX  err
#debug_left bool err
 LD   udint 0
 WRX  errID
#debug_left udint errID
 LD   0   ; null string
 LEAX errTxt
 WRI  
 LEAX errTxt
 LD   80
 DST    ; Level 1
 LEA  _str_ReadLine_2
 SCON 
#debug_left string errTxt
 PDST   ; Level 1
#srcline 80 ;       txtLine := ''; lineContinues := 0;                           // nulovat vystup
 LD   0   ; null string
 LDX  txtLine
 WRI  
 LDX  txtLine
 LD   255
 DST    ; Level 1
 LEA  _str_ReadLine_3
 SCON 
#debug_left string txtLine
 PDST   ; Level 1
 LD   bool 0       ; false
 WRX  lineContinues
#debug_left bool lineContinues
#srcline 81 ;       IF (line < lastLine) OR (lastLine = 0) OR newFile THEN
 LDX  line
#debug udint line
 LDX  lastLine
#debug udint lastLine
 LT
 LDX  lastLine
#debug udint lastLine
 LD   udint 0
 EQ
 OR  
 LDX  newFile
#debug bool newFile
 OR  
 JMC  ReadLine_L6
#srcline 82 ;         actPos := 0; actLine := 0;                                 // od zacatku souboru
 LD   udint 0
 WRX  actPos
#debug_left udint actPos
 LD   udint 0
 WRX  actLine
#debug_left udint actLine
#srcline 83 ;         ok := FileInfo(fileName := FileName, fileDesc := fileInf); // informace o souboru
 NXT
 LDX  FileName
 WR   __Instance__FileInfo~fileName
#debug_left pointer __Instance__FileInfo.fileName
 LEAX fileInf
 WR   __Instance__FileInfo~fileDesc
#debug_left pointer __Instance__FileInfo.fileDesc
 PRV
 LEA  __Instance__FileInfo
 CAL  FileInfo_L0
 WRY  ok
#debug_left bool ok
#srcline 84 ;         IF not ok THEN
 LDY  ok
#debug bool ok
 NEG
 JMC  ReadLine_L8
#srcline 85 ;           busy := 0; err := 1; errID := 10002; errTxt := 'File not found';
 LD   bool 0       ; false
 WRX  busy
#debug_left bool busy
 LD   bool -1      ; true
 WRX  err
#debug_left bool err
 LD   udint 10002
 WRX  errID
#debug_left udint errID
 LD   0   ; null string
 LEAX errTxt
 WRI  
 LEAX errTxt
 LD   80
 DST    ; Level 1
 LEA  _str_ReadLine_4
 SCON 
#debug_left string errTxt
 PDST   ; Level 1
#srcline 86 ;         END_IF;
ReadLine_L8:
#srcline 87 ;         lastFile := fileName;                                      // pamatovat si jmeno souboru
 LD   0   ; null string
 LEAX lastFile
 WRI  
 LEAX lastFile
 LD   80
 DST    ; Level 1
 LDX  fileName
#debug string fileName
 SCON 
#debug_left string lastFile
 PDST   ; Level 1
#srcline 88 ;       END_IF;
ReadLine_L6:
#srcline 89 ;       bufTxtReady := 0;                                            // priznak nacteneho bufferu
 LD   bool 0       ; false
 WRX  bufTxtReady
#debug_left bool bufTxtReady
#srcline 90 ;     END_IF;
ReadLine_L4:
#srcline 92 ;     IF Busy OR lineContinues THEN
 LDX  Busy
#debug bool Busy
 LDX  lineContinues
#debug bool lineContinues
 OR  
 JMC  ReadLine_L10
#srcline 93 ;       // nacist cast souboru
#srcline 94 ;       IF actPos < fileInf.fileSize THEN
 LDX  actPos
#debug udint actPos
 LDX  fileInf~fileSize
#debug udint fileInf.fileSize
 LT
 JMC  ReadLine_L12
#srcline 95 ;         ReadFile(fileName := fileName, dstVar := void(txtLine), actSize => actSize, exec := true, seek := actPos, size := maxLen);// SIZEOF(bufTxt)-1);
 LDX  fileName
 WRX  ReadFile~fileName
#debug_left pointer ReadFile.fileName
 LDX  txtLine
 WRX  ReadFile~dstVar
#debug_left pointer ReadFile.dstVar
 LD   bool -1       ; true
 WRX  ReadFile~exec
#debug_left bool ReadFile~exec
 LDX  actPos
#debug udint actPos
 WRX  ReadFile~seek
#debug_left udint ReadFile~seek
 LDX  maxLen
#debug udint maxLen
 WRX  ReadFile~size
#debug_left udint ReadFile~size
 LEAX ReadFile
 CAL  ReadFromFile_L0
; output assigment 
 LDX  ReadFile~actSize
#debug udint ReadFile~actSize
 WRX  actSize
#debug_left udint actSize
#srcline 96 ;         IF ReadFile.done OR ReadFile.err THEN
 LDX  ReadFile~done
#debug bool ReadFile.done
 LDX  ReadFile~err
#debug bool ReadFile.err
 OR  
 JMC  ReadLine_L14
#srcline 97 ;           IF ReadFile.errID = 0 THEN
 LDX  ReadFile~errID
#debug udint ReadFile.errID
 LD   udint 0
 EQ
 JMC  ReadLine_L16
#srcline 98 ;             IF ReadFile.actSize <> 0 THEN
 LDX  ReadFile~actSize
#debug udint ReadFile.actSize
 LD   udint 0
 EQ
 NEG
 JMC  ReadLine_L18
#srcline 99 ;               bufTxtReady := 1;
 LD   bool -1      ; true
 WRX  bufTxtReady
#debug_left bool bufTxtReady
#srcline 100 ;             ELSE
 JMP  ReadLine_L19
ReadLine_L18:
#srcline 101 ;               busy := 0; err := 1; errID := 10001;
 LD   bool 0       ; false
 WRX  busy
#debug_left bool busy
 LD   bool -1      ; true
 WRX  err
#debug_left bool err
 LD   udint 10001
 WRX  errID
#debug_left udint errID
#srcline 102 ;             END_IF;
ReadLine_L19:
#srcline 103 ;           ELSE
 JMP  ReadLine_L17
ReadLine_L16:
#srcline 104 ;             errID := ReadFile.errID; busy := 0; err := 1;        // chyba cteni ze souboru
 LDX  ReadFile~errID
#debug udint ReadFile.errID
 WRX  errID
#debug_left udint errID
 LD   bool 0       ; false
 WRX  busy
#debug_left bool busy
 LD   bool -1      ; true
 WRX  err
#debug_left bool err
#srcline 105 ;             GetLastErrTxt(errCode := ReadFile.errID(*GetLastErr()*), errMessage := errTxt);
 NXT
 LDX  ReadFile~errID
#debug udint ReadFile.errID
 WR   __Instance__GetLastErrTxt~errCode
#debug_left udint __Instance__GetLastErrTxt~errCode
 LEAX errTxt
 WR   __Instance__GetLastErrTxt~errMessage
#debug_left pointer __Instance__GetLastErrTxt.errMessage
 PRV
 LEA  __Instance__GetLastErrTxt
 CAL  GetLastErrTxt_L0
#srcline 106 ;           END_IF;
ReadLine_L17:
#srcline 107 ;           // osetrit koncovou nulu v bufferu
#srcline 108 ;        	{asm}
#srcline 109
          	LD    0        ; null = end of string
#srcline 110
            LDX	  txtLine  ; adr dest
#srcline 111
          	LDX   actSize  ; length
#srcline 112
          	ADD            ; adr end of string
#srcline 113
          	WRI
#srcline 114 ;        	{end_asm}
#srcline 115 ;           // shodit exec pro pristi cteni souboru
#srcline 116 ;           ReadFile(fileName := FileName, dstVar := void(txtLine), exec := 0);
 LDX  FileName
 WRX  ReadFile~fileName
#debug_left pointer ReadFile.fileName
 LDX  txtLine
 WRX  ReadFile~dstVar
#debug_left pointer ReadFile.dstVar
 LD   bool 0       ; false
 WRX  ReadFile~exec
#debug_left bool ReadFile~exec
 LEAX ReadFile
 CAL  ReadFromFile_L0
#srcline 117 ;         END_IF;
ReadLine_L14:
#srcline 118 ;       ELSE
 JMP  ReadLine_L13
ReadLine_L12:
#srcline 119 ;         busy := 0; err := 1; errID := 10001;
 LD   bool 0       ; false
 WRX  busy
#debug_left bool busy
 LD   bool -1      ; true
 WRX  err
#debug_left bool err
 LD   udint 10001
 WRX  errID
#debug_left udint errID
#srcline 120 ;       END_IF;
ReadLine_L13:
#srcline 122 ;       // hledat pozadovany radek v bufferu
#srcline 123 ;       IF bufTxtReady AND (busy OR lineContinues) THEN
 LDX  bufTxtReady
#debug bool bufTxtReady
 LDX  busy
#debug bool busy
 LDX  lineContinues
#debug bool lineContinues
 OR  
 AND
 JMC  ReadLine_L20
#srcline 124 ;         index := 0;
 LD   int 0
 WRX  index
#debug_left int index
#srcline 125 ;         WHILE actLine <> line DO
ReadLine_L22:
 LDX  actLine
#debug udint actLine
 LDX  line
#debug udint line
 EQ
 NEG
 JMC  ReadLine_L23
 DBG 
#srcline 126 ;           //i := FIND( IN1 := bufTxt + index, IN2 := '$0A');  // najit konec radku
#srcline 127 ;           {asm}
#srcline 128
             LDX  txtLine
#srcline 129
             LDX  index
#srcline 130
             ADD
#srcline 131
             LEA  __Const__ReadLine_SEPARATOR
#srcline 132
             SFND
#srcline 133
             WRX  i
#srcline 134 ;           {end_asm}
#srcline 135 ;           IF i <> 0 THEN                                       // byl nalezen konec radku
 LDX  i
#debug int i
 EXTW 
 LD   int 0
 EQ
 NEG
 JMC  ReadLine_L24
#srcline 136 ;             actLine := actLine + 1;                            // zvysit pocitadla
 LDX  actLine
#debug udint actLine
 LD   udint 1
 ADD
 WRX  actLine
#debug_left udint actLine
#srcline 137 ;             IF actLine <> line THEN
 LDX  actLine
#debug udint actLine
 LDX  line
#debug udint line
 EQ
 NEG
 JMC  ReadLine_L26
#srcline 138 ;               index := index + i;                              // hledat dal
 LDX  index
#debug int index
 EXTW 
 LDX  i
#debug int i
 EXTW 
 ADD
 EXTW
 WRX  index
#debug_left int index
#srcline 139 ;             ELSE
 JMP  ReadLine_L27
ReadLine_L26:
#srcline 140 ;               lineContinues := 0;                              // nalezeno LF, radek uz je cely
 LD   bool 0       ; false
 WRX  lineContinues
#debug_left bool lineContinues
#srcline 141 ;             END_IF;
ReadLine_L27:
#srcline 142 ;           ELSE                                                 //  nebyl nalezen konec radku
 JMP  ReadLine_L25
ReadLine_L24:
#srcline 143 ;             IF (index = 0) AND (i = 0) THEN                    //  hledali jsme od zacatku a presto nebyl nalezen
 LDX  index
#debug int index
 EXTW 
 LD   int 0
 EQ
 LDX  i
#debug int i
 EXTW 
 LD   int 0
 EQ
 AND
 JMC  ReadLine_L28
#srcline 144 ;               i := UDINT_TO_INT(maxLen);// + 2; //sizeof(bufTxt) + 1            // radek v csv je delsi nez buffer, posunout pro dalsi cteni
 LDX  maxLen
#debug udint maxLen
 EXTW
 WRX  i
#debug_left int i
#srcline 145 ;               IF actLine = (line - 1) THEN
 LDX  actLine
#debug udint actLine
 LDX  line
#debug udint line
 LD   udint 1
 SUB
 EQ
 JMC  ReadLine_L30
#srcline 146 ;                 lineContinues := 1;                            // predat zacatek radku + info, ze radek bude pokracovat
 LD   bool -1      ; true
 WRX  lineContinues
#debug_left bool lineContinues
#srcline 147 ;               END_IF;
ReadLine_L30:
#srcline 148 ;             END_IF;
ReadLine_L28:
#srcline 149 ;             EXIT;                                              // v bufferu uz neni dalsi LF, pokracovat pristi cyklus
 JMP  ReadLine_L23
#srcline 150 ;           END_IF;
ReadLine_L25:
#srcline 151 ;         END_WHILE;
 JMP  ReadLine_L22
ReadLine_L23:
 NOP  -1
#srcline 153 ;         bufTxtReady := 0;                                      // pristi cykl se bude zase cist ze souboru
 LD   bool 0       ; false
 WRX  bufTxtReady
#debug_left bool bufTxtReady
#srcline 154 ;//         IF lineContinues THEN
#srcline 155 ;//           actPos := actPos + INT_TO_UDINT(i-2);                // offset v souboru pro dalsi cteni
#srcline 156 ;//         ELSE
#srcline 157 ;           actPos := actPos + INT_TO_UDINT(index + i);          // offset v souboru pro dalsi cteni
 LDX  actPos
#debug udint actPos
 LDX  index
#debug int index
 EXTW 
 LDX  i
#debug int i
 EXTW 
 ADD
 EXTW
 ADD
 WRX  actPos
#debug_left udint actPos
#srcline 158 ;//         END_IF;
#srcline 159 ;         IF actLine = line OR lineContinues THEN
 LDX  actLine
#debug udint actLine
 LDX  line
#debug udint line
 EQ
 LDX  lineContinues
#debug bool lineContinues
 OR  
 JMC  ReadLine_L32
#srcline 160 ;           done := 1;                            // radek nalezen
 LD   bool -1      ; true
 WRX  done
#debug_left bool done
#srcline 161 ;           busy := 0;
 LD   bool 0       ; false
 WRX  busy
#debug_left bool busy
#srcline 162 ;           err := 0;
 LD   bool 0       ; false
 WRX  err
#debug_left bool err
#srcline 163 ;           //koncova nula za CRLF
#srcline 164 ;        	{asm}
#srcline 165
        	  #def __READLINEFROMFILE_X0__ %X0
#srcline 166
        	  LDX txtLine
#srcline 167
        	  LDX index
#srcline 168
        	  ADD
#srcline 169
            SRC __READLINEFROMFILE_X0__
#srcline 170
        	  LDX txtLine
#srcline 171
        	  LDX  i
#srcline 172
            MOV __READLINEFROMFILE_X0__
#srcline 173
          	LD    0        ; null = end of string
#srcline 174
            LDX	  txtLine  ; adr dest
#srcline 175
          	LDX   i	       ; length (including CRLF)
#srcline 176
          	ADD            ; adr of ending null
#srcline 177
          	WRI
#srcline 178 ;        	{end_asm}
#srcline 180 ;         ELSE
 JMP  ReadLine_L33
ReadLine_L32:
#srcline 181 ;           IF actPos >= fileInf.fileSize THEN
 LDX  actPos
#debug udint actPos
 LDX  fileInf~fileSize
#debug udint fileInf.fileSize
 LT
 NEG
 JMC  ReadLine_L34
#srcline 182 ;             // pozadovany radek v souboru nenalezen (soubor nema tolik radku)
#srcline 183 ;             busy := 0; err := 1; errID := 10001;
 LD   bool 0       ; false
 WRX  busy
#debug_left bool busy
 LD   bool -1      ; true
 WRX  err
#debug_left bool err
 LD   udint 10001
 WRX  errID
#debug_left udint errID
#srcline 184 ;           END_IF;
ReadLine_L34:
#srcline 185 ;         END_IF;
ReadLine_L33:
#srcline 186 ;       END_IF;
ReadLine_L20:
#srcline 187 ;     END_IF;
ReadLine_L10:
#srcline 188 ;     lastLine := line;                                             // pamatovat si naposledy hledany radek
 LDX  line
#debug udint line
 WRX  lastLine
#debug_left udint lastLine
#srcline 189 ;  END_IF;
 JMP  ReadLine_L2
ReadLine_L3:
ReadLine_L2:
#srcline 191 ;  IF err THEN
 LDX  err
#debug bool err
 JMC  ReadLine_L36
#srcline 192 ;    IF errID = 10001 THEN
 LDX  errID
#debug udint errID
 LD   udint 10001
 EQ
 JMC  ReadLine_L38
#srcline 193 ;      errTxt := 'End of file. Line not found';                  // spolecne chybove hlaseni
 LD   0   ; null string
 LEAX errTxt
 WRI  
 LEAX errTxt
 LD   80
 DST    ; Level 1
 LEA  _str_ReadLine_5
 SCON 
#debug_left string errTxt
 PDST   ; Level 1
#srcline 194 ;    END_IF;
ReadLine_L38:
#srcline 195 ;  END_IF;
ReadLine_L36:
#srcline 196 ;END_FUNCTION_BLOCK
 ULNK
RET
E     61

; Initialize - variables
P     61
ReadLine__InstanceInit__:
 LINK 0
 ULNK
RET
E     61
; End initialize - variables
#endpou 



 

#srcfile ''
#srcfile 'C:\TECOLIBSRC\FILELIB\FILELIB\DISCONNECTUSBDISK.ST'
#pou DisconnectUsbDisk
#srcline 1 ;FUNCTION DisconnectUsbDisk : BOOL

#struct DisconnectUsbDisk__temp__
  bool tmp
P     61
DisconnectUsbDisk_L0:
 LINK __SizeOf(DisconnectUsbDisk__temp__)
 NXT
; Initialize - dynamic variables
; End initialize - dynamic variables
#srcline 15 ;  IF %S37.6 THEN
 LD   %S37.6
 JMC  DisconnectUsbDisk_L1
#srcline 16 ;    {asm}
#srcline 17
      LD  16#2F425355    ; 'USB/'
#srcline 18
      LD  2              ;
#srcline 19
      SYS 67             ; DisconnectUsb ( char *diskName)
#srcline 20
      WRY tmp
#srcline 21 ;    {end_asm}
#srcline 22 ;  END_IF;
DisconnectUsbDisk_L1:
#srcline 23 ;  DisconnectUsbDisk := tmp;
 LDY  tmp
#debug bool tmp
 WRX  __fc__DisconnectUsbDisk
#debug_left bool DisconnectUsbDisk
#srcline 24 ;END_FUNCTION
 PRV  
 LDX  __fc__DisconnectUsbDisk
 ULNK
RET
E     61
#endpou 



 

#srcfile ''
#srcfile 'C:\TECOLIBSRC\FILELIB\FILELIB\FBDIRLIST.ST'
#pou ListDirectories
#srcline 8 ;FUNCTION_BLOCK ListDirectories

#struct ListDirectories__temp__
  pointer ps,
  string[81] tmpName,
  string[162] PS0__st__
#data byte _str_ListDirectories_0 = 
  '',0
#data byte _str_ListDirectories_1 = 
  '',0
P     61
ListDirectories_L0:
 LINK __SizeOf(ListDirectories__temp__)
; Initialize - dynamic variables
 LD   udint $FFFFFFFF    ; nil
 WRY  ps
; End initialize - dynamic variables
; R_EDGE, F_EDGE 
 LDX  exec
 LETX __EDGE_R__exec
 WRX  exec
 LDX  cancel
 LETX __EDGE_R__cancel
 WRX  cancel
#srcline 44 ;  IF exec AND NOT busy AND NOT done THEN               // zahajit prohledavani adresare
 LDX  exec
#debug bool exec
 LDX  busy
#debug bool busy
 NEG
 AND
 LDX  done
#debug bool done
 NEG
 AND
 JMC  ListDirectories_L1
#srcline 45 ;    i := 0; err := 0; busy := 1; hd := INVALID_HANDLE_VALUE;
 LD   uint 0
 WRX  i
#debug_left uint i
 LD   bool 0       ; false
 WRX  err
#debug_left bool err
 LD   bool -1      ; true
 WRX  busy
#debug_left bool busy
 LD   udint 0
 WRX  hd
#debug_left udint hd
#srcline 46 ;    Memset(val := 0, length := sizeof(hdStack), dest := void(hdStack));
 NXT
 LD   udint 0
 WR   __Instance__Memset~val
#debug_left udint __Instance__Memset~val
 LD   198  ; SizeOf()
 WR   __Instance__Memset~length
#debug_left uint __Instance__Memset~length
 LEAX hdStack
 WR   __Instance__Memset~dest
#debug_left pointer __Instance__Memset.dest
 PRV
 LEA  __Instance__Memset
 CAL  Memset_L0
#srcline 47 ;    Memset(val := 0, length := sizeof(fileInfo), dest := void(fileInfo));
 NXT
 LD   udint 0
 WR   __Instance__Memset~val
#debug_left udint __Instance__Memset~val
 LD   266  ; SizeOf()
 WR   __Instance__Memset~length
#debug_left uint __Instance__Memset~length
 LEAX fileInfo
 WR   __Instance__Memset~dest
#debug_left pointer __Instance__Memset.dest
 PRV
 LEA  __Instance__Memset
 CAL  Memset_L0
#srcline 48 ;    subName := ''; lastDir := '';
 LD   0   ; null string
 LEAX subName
 WRI  
 LEAX subName
 LD   80
 DST    ; Level 1
 LEA  _str_ListDirectories_0
 SCON 
#debug_left string subName
 PDST   ; Level 1
 LD   0   ; null string
 LEAX lastDir
 WRI  
 LEAX lastDir
 LD   80
 DST    ; Level 1
 LEA  _str_ListDirectories_1
 SCON 
#debug_left string lastDir
 PDST   ; Level 1
#srcline 49 ;    isDir := 1;                                        // otevrit prvni adresar
 LD   bool -1      ; true
 WRX  isDir
#debug_left bool isDir
#srcline 50 ;  END_IF;
ListDirectories_L1:
#srcline 52 ;  done := 0; found := 0;
 LD   bool 0       ; false
 WRX  done
#debug_left bool done
 LD   bool 0       ; false
 WRX  found
#debug_left bool found
#srcline 53 ;  IF busy AND NOT cancel THEN
 LDX  busy
#debug bool busy
 LDX  cancel
#debug bool cancel
 NEG
 AND
 JMC  ListDirectories_L3
#srcline 54 ;    isDirEmpty := 0;
 LD   bool 0       ; false
 WRX  isDirEmpty
#debug_left bool isDirEmpty
#srcline 55 ;    IF isDir THEN                                      // naposledy jsme precetli jmeno adresare
 LDX  isDir
#debug bool isDir
 JMC  ListDirectories_L5
#srcline 56 ;      IF i < MAX_STACK_SIZE THEN                       // zanorit se do adresare
 LDX  i
#debug uint i
 LD   uint 32
 LT
 JMC  ListDirectories_L7
#srcline 57 ;        hdStack[i].hd := hd;                           // ulozit handle do stacku
 LDX  hd
#debug udint hd
 LEAX hdStack
 LDX  i
#debug uint i
 RCHK 32   ; Range Check
 MUL  6   ; SizeOf(...)
 ADD     ; + offset 
 WRIL 
#debug_left udint hdStack[i].hd
#srcline 58 ;        hdStack[i].ls := LEN(lastDir);                 // ulozit take delku nazvu podadresare
 LEAX lastDir
#debug string lastDir
 SLEN 
 LEAX hdStack
 LDX  i
#debug uint i
 RCHK 32   ; Range Check
 MUL  6   ; SizeOf(...)
 ADD     ; + offset 
 ADD  4  ; + offset 
 WRIW 
#debug_left uint hdStack[i].ls
#srcline 59 ;        i := i + 1;
 LDX  i
#debug uint i
 LD   uint 1
 ADD
 AND  $FFFF
 WRX  i
#debug_left uint i
#srcline 60 ;        subName := subName + lastDir;                  // cesta k adresari
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   80
 DST    ; Level 1
 LEAX subName
#debug string subName
 SCON 
 LEAX lastDir
#debug string lastDir
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX subName
 WRI  
 LEAX subName
 LD   80
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string subName
 PDST   ; Level 1
#srcline 61 ;        tmpName := dirName + subName;
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   80
 DST    ; Level 1
 LEAX dirName
#debug string dirName
 SCON 
 LEAX subName
#debug string subName
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAY tmpName
 WRI  
 LEAY tmpName
 LD   80
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string tmpName
 PDST   ; Level 1
#srcline 62 ;        hd := DirOpen( dirName := tmpName, dirInfo := void(fileInfo));
 NXT
 LEAY tmpName
 WR   __Instance__DirOpen~dirName
#debug_left pointer __Instance__DirOpen.dirName
 LEAX fileInfo
 WR   __Instance__DirOpen~dirInfo
#debug_left pointer __Instance__DirOpen.dirInfo
 PRV
 LEA  __Instance__DirOpen
 CAL  DirOpen_L0
 WRX  hd
#debug_left udint hd
#srcline 63 ;        IF hd <> INVALID_HANDLE_VALUE THEN
 LDX  hd
#debug udint hd
 LD   udint 0
 EQ
 NEG
 JMC  ListDirectories_L9
#srcline 64 ;          isDir := (fileInfo.attrib AND AM_DIR) <> 0;
 LDX  fileInfo~attrib
#debug dword fileInfo.attrib
 LD   dword 16
 AND
 LD   dword 0
 EQ
 NEG
 WRX  isDir
#debug_left bool isDir
#srcline 65 ;          IF isDir THEN
 LDX  isDir
#debug bool isDir
 JMC  ListDirectories_L11
#srcline 66 ;            lastDir := fileInfo.fileName;
 LD   0   ; null string
 LEAX lastDir
 WRI  
 LEAX lastDir
 LD   80
 DST    ; Level 1
 LEAX fileInfo
 ADD  24  ; + offset 
#debug string fileInfo.fileName
 SCON 
#debug_left string lastDir
 PDST   ; Level 1
#srcline 67 ;          END_IF;
ListDirectories_L11:
#srcline 68 ;          found := 1;
 LD   bool -1      ; true
 WRX  found
#debug_left bool found
#srcline 69 ;        ELSE
 JMP  ListDirectories_L10
ListDirectories_L9:
#srcline 70 ;          IF i > 1 THEN                                // prazdny adresar
 LDX  i
#debug uint i
 LD   uint 1
 GT
 JMC  ListDirectories_L13
#srcline 71 ;            fileInfo.attrib := AM_DIR;                 // nastavit atributy
 LD   dword 16
 WRX  fileInfo~attrib
#debug_left dword fileInfo.attrib
#srcline 72 ;            fileInfo.fileName := lastDir;              // zverejnit jmeno prazdneho adresare
 LD   0   ; null string
 LEAX fileInfo
 ADD  24  ; + offset 
 WRI  
 LEAX fileInfo
 ADD  24  ; + offset 
 LD   80
 DST    ; Level 1
 LEAX lastDir
#debug string lastDir
 SCON 
#debug_left string fileInfo.fileName
 PDST   ; Level 1
#srcline 73 ;            i := i - 1; hd := hdStack[i].hd;           // pokracovat o uroven vyse
 LDX  i
#debug uint i
 LD   uint 1
 SUB
 AND  $FFFF
 WRX  i
#debug_left uint i
 LEAX hdStack
 LDX  i
#debug uint i
 RCHK 32   ; Range Check
 MUL  6   ; SizeOf(...)
 ADD     ; + offset 
 LDIL 
#debug udint hdStack[i].hd
 WRX  hd
#debug_left udint hd
#srcline 74 ;            ps := ADR( subName) + LEN(subName);        // ptr na konec subName
 LEAX subName
#debug pointer subName
 LEAX subName
#debug string subName
 SLEN 
 ADD
 LEAY ps
 WRIL 
#debug_left pointer ps
#srcline 75 ;            ps := ps - UINT_TO_UDINT( hdStack[i].ls);  // couvnout o jeden adresar
 LEAY ps
 LDIL 
#debug pointer ps
 LEAX hdStack
 LDX  i
#debug uint i
 RCHK 32   ; Range Check
 MUL  6   ; SizeOf(...)
 ADD     ; + offset 
 ADD  4  ; + offset 
 LDIW 
#debug uint hdStack[i].ls
 SUB
 LEAY ps
 WRIL 
#debug_left pointer ps
#srcline 76 ;            ps^ := 0;                                  // zkratit subName
 LD   0   ; null string
 LEAY ps
 LDIL    ; dereference 
 WRI  
 LEAY ps
 LDIL    ; dereference 
 LD   80
 DST    ; Level 1
 LD   string 0
 SCON 
#debug_left string ps^
 PDST   ; Level 1
#srcline 77 ;            isDir := 0; isDirEmpty := 1;               // priznak prazdneho adresare
 LD   bool 0       ; false
 WRX  isDir
#debug_left bool isDir
 LD   bool -1      ; true
 WRX  isDirEmpty
#debug_left bool isDirEmpty
#srcline 78 ;          ELSE
 JMP  ListDirectories_L14
ListDirectories_L13:
#srcline 79 ;            err := 1;
 LD   bool -1      ; true
 WRX  err
#debug_left bool err
#srcline 80 ;          END_IF;
ListDirectories_L14:
#srcline 81 ;        END_IF;
ListDirectories_L10:
#srcline 82 ;      ELSE
 JMP  ListDirectories_L8
ListDirectories_L7:
#srcline 83 ;        err := 1;                                      // prilis velka hloubka adresaru
 LD   bool -1      ; true
 WRX  err
#debug_left bool err
#srcline 84 ;      END_IF;
ListDirectories_L8:
#srcline 85 ;    ELSE
 JMP  ListDirectories_L6
ListDirectories_L5:
#srcline 86 ;      IF DirRead( hDir := hd, dirInfo := void(fileInfo)) THEN // nacist dalsi soubor
 NXT
 LDX  hd
#debug udint hd
 WR   __Instance__DirRead~hDir
#debug_left udint __Instance__DirRead~hDir
 LEAX fileInfo
 WR   __Instance__DirRead~dirInfo
#debug_left pointer __Instance__DirRead.dirInfo
 PRV
 LEA  __Instance__DirRead
 CAL  DirRead_L0
 JMC  ListDirectories_L15
#srcline 87 ;        isDir := (fileInfo.attrib AND AM_DIR) <> 0;
 LDX  fileInfo~attrib
#debug dword fileInfo.attrib
 LD   dword 16
 AND
 LD   dword 0
 EQ
 NEG
 WRX  isDir
#debug_left bool isDir
#srcline 88 ;        IF isDir THEN
 LDX  isDir
#debug bool isDir
 JMC  ListDirectories_L17
#srcline 89 ;          lastDir := fileInfo.fileName;
 LD   0   ; null string
 LEAX lastDir
 WRI  
 LEAX lastDir
 LD   80
 DST    ; Level 1
 LEAX fileInfo
 ADD  24  ; + offset 
#debug string fileInfo.fileName
 SCON 
#debug_left string lastDir
 PDST   ; Level 1
#srcline 90 ;        END_IF;
ListDirectories_L17:
#srcline 91 ;        found := 1;
 LD   bool -1      ; true
 WRX  found
#debug_left bool found
#srcline 92 ;      ELSE                                             // pokracovat o uroven vyse
 JMP  ListDirectories_L16
ListDirectories_L15:
#srcline 93 ;        DirClose(hDir := hd);
 NXT
 LDX  hd
#debug udint hd
 WR   __Instance__DirClose~hDir
#debug_left udint __Instance__DirClose~hDir
 PRV
 LEA  __Instance__DirClose
 CAL  DirClose_L0
#srcline 94 ;        IF i > 1 THEN
 LDX  i
#debug uint i
 LD   uint 1
 GT
 JMC  ListDirectories_L19
#srcline 95 ;          i := i -1;
 LDX  i
#debug uint i
 LD   uint 1
 SUB
 AND  $FFFF
 WRX  i
#debug_left uint i
#srcline 96 ;          hd := hdStack[i].hd;                         // pokracovat o uroven vyse
 LEAX hdStack
 LDX  i
#debug uint i
 RCHK 32   ; Range Check
 MUL  6   ; SizeOf(...)
 ADD     ; + offset 
 LDIL 
#debug udint hdStack[i].hd
 WRX  hd
#debug_left udint hd
#srcline 97 ;          ps := ADR( subName) + LEN(subName);          // ptr na konec subName
 LEAX subName
#debug pointer subName
 LEAX subName
#debug string subName
 SLEN 
 ADD
 LEAY ps
 WRIL 
#debug_left pointer ps
#srcline 98 ;          ps := ps - UINT_TO_UDINT( hdStack[i].ls);    // couvnout o jeden adresar
 LEAY ps
 LDIL 
#debug pointer ps
 LEAX hdStack
 LDX  i
#debug uint i
 RCHK 32   ; Range Check
 MUL  6   ; SizeOf(...)
 ADD     ; + offset 
 ADD  4  ; + offset 
 LDIW 
#debug uint hdStack[i].ls
 SUB
 LEAY ps
 WRIL 
#debug_left pointer ps
#srcline 99 ;          ps^ := 0;                                    // zkratit subName
 LD   0   ; null string
 LEAY ps
 LDIL    ; dereference 
 WRI  
 LEAY ps
 LDIL    ; dereference 
 LD   80
 DST    ; Level 1
 LD   string 0
 SCON 
#debug_left string ps^
 PDST   ; Level 1
#srcline 100 ;        ELSE
 JMP  ListDirectories_L20
ListDirectories_L19:
#srcline 101 ;          done := 1; busy := 0;                        // hotovo
 LD   bool -1      ; true
 WRX  done
#debug_left bool done
 LD   bool 0       ; false
 WRX  busy
#debug_left bool busy
#srcline 102 ;        END_IF;
ListDirectories_L20:
#srcline 103 ;      END_IF;
ListDirectories_L16:
#srcline 104 ;    END_IF;
ListDirectories_L6:
#srcline 106 ;    fileInfo.pathName := dirName + subName;            // cesta
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   160
 DST    ; Level 1
 LEAX dirName
#debug string dirName
 SCON 
 LEAX subName
#debug string subName
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX fileInfo
 ADD  105  ; + offset 
 WRI  
 LEAX fileInfo
 ADD  105  ; + offset 
 LD   160
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string fileInfo.pathName
 PDST   ; Level 1
#srcline 108 ;    IF noSubDir THEN
 LDX  noSubDir
#debug bool noSubDir
 JMC  ListDirectories_L21
#srcline 109 ;      isDir := 0;                                      // nevstupovat do podadresaru
 LD   bool 0       ; false
 WRX  isDir
#debug_left bool isDir
#srcline 110 ;    END_IF;
ListDirectories_L21:
#srcline 112 ;    IF err OR cancel THEN                              // zavrit vse
 LDX  err
#debug bool err
 LDX  cancel
#debug bool cancel
 OR  
 JMC  ListDirectories_L23
#srcline 113 ;      busy := 0; isDir := 0;
 LD   bool 0       ; false
 WRX  busy
#debug_left bool busy
 LD   bool 0       ; false
 WRX  isDir
#debug_left bool isDir
#srcline 114 ;      WHILE i > 0 DO
ListDirectories_L25:
 LDX  i
#debug uint i
 LD   uint 0
 GT
 JMC  ListDirectories_L26
 DBG 
#srcline 115 ;        DirClose(hDir := hd);
 NXT
 LDX  hd
#debug udint hd
 WR   __Instance__DirClose~hDir
#debug_left udint __Instance__DirClose~hDir
 PRV
 LEA  __Instance__DirClose
 CAL  DirClose_L0
#srcline 116 ;        i := i - 1; hd := hdStack[i].hd;
 LDX  i
#debug uint i
 LD   uint 1
 SUB
 AND  $FFFF
 WRX  i
#debug_left uint i
 LEAX hdStack
 LDX  i
#debug uint i
 RCHK 32   ; Range Check
 MUL  6   ; SizeOf(...)
 ADD     ; + offset 
 LDIL 
#debug udint hdStack[i].hd
 WRX  hd
#debug_left udint hd
#srcline 117 ;      END_WHILE;
 JMP  ListDirectories_L25
ListDirectories_L26:
 NOP  -1
#srcline 118 ;      Memset(val := 0, length := sizeof(fileInfo), dest := void(fileInfo));
 NXT
 LD   udint 0
 WR   __Instance__Memset~val
#debug_left udint __Instance__Memset~val
 LD   266  ; SizeOf()
 WR   __Instance__Memset~length
#debug_left uint __Instance__Memset~length
 LEAX fileInfo
 WR   __Instance__Memset~dest
#debug_left pointer __Instance__Memset.dest
 PRV
 LEA  __Instance__Memset
 CAL  Memset_L0
#srcline 119 ;    END_IF;
ListDirectories_L23:
#srcline 120 ;  END_IF;
ListDirectories_L3:
#srcline 121 ;END_FUNCTION_BLOCK
 ULNK
RET
E     61

; Initialize - variables
P     61
ListDirectories__InstanceInit__:
 LINK 0
 ULNK
RET
E     61
; End initialize - variables
#endpou 

#pou ListDirectoriesLog
#srcline 124 ;FUNCTION_BLOCK ListDirectoriesLog

#struct ListDirectoriesLog__temp__
  uint i,
  uint P0__st__,
  string[257] PS0__st__,
  string[82] PS1__st__
#data byte _str_ListDirectoriesLog_0 = 
  '%','T','D','D','.','M','M','.','Y','Y','Y','Y',' ','h','h',':','m','m',':','s',
  's','.','z','z','z',' ',' ','C','o','n','t','e','n','t','s',' ','o','f',' ','d',
  'i','r','e','c','t','o','r','y',':',' ',0
#data byte _str_ListDirectoriesLog_1 = 
  $0D,$0A,$0D,$0A,0
#data byte _str_ListDirectoriesLog_2 = 
  ' ',0
#data byte _str_ListDirectoriesLog_3 = 
  ' ',' ',' ',' ',' ','D','I','R',0
#data byte _str_ListDirectoriesLog_4 = 
  ' ',' ','%','T','D','D','.','M','M','.','Y','Y','Y','Y',0
#data byte _str_ListDirectoriesLog_5 = 
  ' ',' ','%','T','h','h',':','m','m',':','s','s',0
#data byte _str_ListDirectoriesLog_6 = 
  '%','8','d',0
#data byte _str_ListDirectoriesLog_7 = 
  ' ',' ','%','T','D','D','.','M','M','.','Y','Y','Y','Y',0
#data byte _str_ListDirectoriesLog_8 = 
  ' ',' ','%','T','h','h',':','m','m',':','s','s',0
#data byte _str_ListDirectoriesLog_9 = 
  $0D,$0A,0
#data byte _str_ListDirectoriesLog_10 = 
  $0D,$0A,'T','o','t','a','l',' ','i','t','e','m','s',':',' ','%','d',',',' ',' ',0
#data byte _str_ListDirectoriesLog_11 = 
  'U','s','e','d',' ','s','p','a','c','e',':',' ','%','d',',',' ',' ',0
#data byte _str_ListDirectoriesLog_12 = 
  'P','r','o','c','e','s','s','i','n','g',' ','t','i','m','e',':',' ','%','T','s',
  '.','z','z','z',' ','[','s','e','c',']',$0D,$0A,0
P     61
ListDirectoriesLog_L0:
 LINK __SizeOf(ListDirectoriesLog__temp__)
; Initialize - dynamic variables
; End initialize - dynamic variables
#srcline 150 ;  TrgBusy(CLK := fbListDir.busy);
 LDX  fbListDir
 ADD  82  ; + offset 
 MUL  8   ; -> bool pointer 
 ADD  1   ; Bool offset 
 LDIB 
#debug bool fbListDir.busy
 WRX  TrgBusy~CLK
#debug_left bool TrgBusy~CLK
 LEAX TrgBusy
 CAL  R_TRIG_L0
#srcline 151 ;  IF TrgBusy.Q THEN                     // pruzkum adresare zahajen
 LDX  TrgBusy~Q
#debug bool TrgBusy.Q
 JMC  ListDirectoriesLog_L1
#srcline 152 ;    cnt := 0; usedSpace := 0;
 LD   uint 0
 WRX  cnt
#debug_left uint cnt
 LD   udint 0
 WRX  usedSpace
#debug_left udint usedSpace
#srcline 153 ;    startDT := GetDateTime();
 LEA  __Instance__GetDateTime
 CAL  GetDateTime_L0
 WRX  startDT
#debug_left dt startDT
#srcline 154 ;    IF hf <> INVALID_HANDLE_VALUE THEN
 LDX  hf
#debug udint hf
 LD   udint 0
 EQ
 NEG
 JMC  ListDirectoriesLog_L3
#srcline 155 ;      FileClose(hFile := hf); hf := INVALID_HANDLE_VALUE;  // pro jistotu
 NXT
 LDX  hf
#debug udint hf
 WR   __Instance__FileClose~hFile
#debug_left udint __Instance__FileClose~hFile
 PRV
 LEA  __Instance__FileClose
 CAL  FileClose_L0
 LD   udint 0
 WRX  hf
#debug_left udint hf
#srcline 156 ;    END_IF;
ListDirectoriesLog_L3:
#srcline 157 ;    hf := FileOpen( mode := F_WRITE, fileName := logName);
 NXT
 LD   udint 1  ; TF_MODE#F_WRITE
 WR   __Instance__FileOpen~mode
#debug_left usint __Instance__FileOpen~mode
 LEAX logName
 WR   __Instance__FileOpen~fileName
#debug_left pointer __Instance__FileOpen.fileName
 PRV
 LEA  __Instance__FileOpen
 CAL  FileOpen_L0
 WRX  hf
#debug_left udint hf
#srcline 158 ;    line := DT_TO_STRINGF( startDT, '%TDD.MM.YYYY$A0hh:mm:ss.zzz  Contents of directory: ') + fbListDir.dirName + '$0D$0A$0D$0A';
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 NXT
 LDX  startDT
#debug dt startDT
 WR   __Instance__DT_TO_STRINGF~in
#debug_left dt __Instance__DT_TO_STRINGF~in
 LD   0   ; null string
 LEA  __Instance__DT_TO_STRINGF~format
 WRI 
 LEA  __Instance__DT_TO_STRINGF~format
 LD   80
 DST    ; Level 2
 LEA  _str_ListDirectoriesLog_0
 SCON 
#debug_left string __Instance__DT_TO_STRINGF~format
 PDST   ; Level 2
 PRV
 LEA  __Instance__DT_TO_STRINGF
 CAL  DT_TO_STRINGF_L0

 SCON 
 LDX  fbListDir
 ADD  1  ; + offset 
#debug string fbListDir.dirName
 SCON 
 LEA  _str_ListDirectoriesLog_1
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX line
 WRI  
 LEAX line
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string line
 PDST   ; Level 1
#srcline 159 ;    FileWrite( hFile := hf, adrBuf := PTR_TO_UDINT( ADR( line)), size := LEN(line));
 NXT
 LDX  hf
#debug udint hf
 WR   __Instance__FileWrite~hFile
#debug_left udint __Instance__FileWrite~hFile
 LEAX line
#debug pointer line
 WR   __Instance__FileWrite~adrBuf
#debug_left udint __Instance__FileWrite~adrBuf
 LEAX line
#debug string line
 SLEN 
 WR   __Instance__FileWrite~size
#debug_left udint __Instance__FileWrite~size
 PRV
 LEA  __Instance__FileWrite
 CAL  FileWrite_L0
#srcline 160 ;  END_IF;
ListDirectoriesLog_L1:
#srcline 162 ;  IF fbListDir.found THEN                 // nalezena polozka v adresari
 LDX  fbListDir
 ADD  82  ; + offset 
 MUL  8   ; -> bool pointer 
 ADD  3   ; Bool offset 
 LDIB 
#debug bool fbListDir.found
 JMC  ListDirectoriesLog_L5
#srcline 163 ;    cnt := cnt + 1;
 LDX  cnt
#debug uint cnt
 LD   uint 1
 ADD
 AND  $FFFF
 WRX  cnt
#debug_left uint cnt
#srcline 164 ;    line := fbListDir.fileInfo.pathName + fbListDir.fileInfo.fileName;  // jmeno souboru/adresare (vcetne cesty)
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LDX  fbListDir
 ADD  188  ; + offset 
#debug string fbListDir.fileInfo.pathName
 SCON 
 LDX  fbListDir
 ADD  107  ; + offset 
#debug string fbListDir.fileInfo.fileName
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX line
 WRI  
 LEAX line
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string line
 PDST   ; Level 1
#srcline 165 ;    FOR i := LEN(line) TO 40 DO
 LEAX line
#debug string line
 SLEN 
 WRY  i
 LD   uint 40
 WRY  P0__st__
ListDirectoriesLog_L7:
 LDY  i
 LDY  P0__st__
 GT   
 JMD  ListDirectoriesLog_L8
 DBG  
#srcline 166 ;      line := line + ' ';               // doplnit mezery
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LEAX line
#debug string line
 SCON 
 LEA  _str_ListDirectoriesLog_2
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX line
 WRI  
 LEAX line
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string line
 PDST   ; Level 1
#srcline 167 ;    END_FOR;
 LDY  i
 LD   1
 ADD  
 WRY  i
 JMP  ListDirectoriesLog_L7
ListDirectoriesLog_L8:
 NOP  -1
#srcline 168 ;    IF fbListDir.isDir THEN               // nalezena polozka je adresar
 LDX  fbListDir
 ADD  82  ; + offset 
 MUL  8   ; -> bool pointer 
 ADD  4   ; Bool offset 
 LDIB 
#debug bool fbListDir.isDir
 JMC  ListDirectoriesLog_L9
#srcline 169 ;      line := line + '     DIR' +                                                // adresar
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LEAX line
#debug string line
 SCON 
 LEA  _str_ListDirectoriesLog_3
 SCON 
#srcline 170 ;              DT_TO_STRINGF( fbListDir.fileInfo.creationTime, '  %TDD.MM.YYYY') +  // datum
 NXT
 LDX  fbListDir
 ADD  83  ; + offset 
 LDIQ 
#debug dt fbListDir.fileInfo.creationTime
 WR   __Instance__DT_TO_STRINGF~in
#debug_left dt __Instance__DT_TO_STRINGF~in
 LD   0   ; null string
 LEA  __Instance__DT_TO_STRINGF~format
 WRI 
 LEA  __Instance__DT_TO_STRINGF~format
 LD   80
 DST    ; Level 2
 LEA  _str_ListDirectoriesLog_4
 SCON 
#debug_left string __Instance__DT_TO_STRINGF~format
 PDST   ; Level 2
 PRV
 LEA  __Instance__DT_TO_STRINGF
 CAL  DT_TO_STRINGF_L0

 SCON 
#srcline 171 ;              DT_TO_STRINGF( fbListDir.fileInfo.creationTime, '  %Thh:mm:ss');     // cas (vytvoreni adresare)
 NXT
 LDX  fbListDir
 ADD  83  ; + offset 
 LDIQ 
#debug dt fbListDir.fileInfo.creationTime
 WR   __Instance__DT_TO_STRINGF~in
#debug_left dt __Instance__DT_TO_STRINGF~in
 LD   0   ; null string
 LEA  __Instance__DT_TO_STRINGF~format
 WRI 
 LEA  __Instance__DT_TO_STRINGF~format
 LD   80
 DST    ; Level 2
 LEA  _str_ListDirectoriesLog_5
 SCON 
#debug_left string __Instance__DT_TO_STRINGF~format
 PDST   ; Level 2
 PRV
 LEA  __Instance__DT_TO_STRINGF
 CAL  DT_TO_STRINGF_L0

 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX line
 WRI  
 LEAX line
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string line
 PDST   ; Level 1
#srcline 172 ;    ELSE                                // nalezena polozka je soubor
 JMP  ListDirectoriesLog_L10
ListDirectoriesLog_L9:
#srcline 173 ;      line := line + UDINT_TO_STRINGF( fbListDir.fileInfo.fileSize, '%8d') +       // velikost souboru
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LEAX line
#debug string line
 SCON 
 NXT
 LDX  fbListDir
 ADD  99  ; + offset 
 LDIL 
#debug udint fbListDir.fileInfo.fileSize
 WR   __Instance__UDINT_TO_STRINGF~in
#debug_left udint __Instance__UDINT_TO_STRINGF~in
 LD   0   ; null string
 LEA  __Instance__UDINT_TO_STRINGF~format
 WRI 
 LEA  __Instance__UDINT_TO_STRINGF~format
 LD   80
 DST    ; Level 2
 LEA  _str_ListDirectoriesLog_6
 SCON 
#debug_left string __Instance__UDINT_TO_STRINGF~format
 PDST   ; Level 2
 PRV
 LEA  __Instance__UDINT_TO_STRINGF
 CAL  UDINT_TO_STRINGF_L0

 SCON 
#srcline 174 ;              DT_TO_STRINGF( fbListDir.fileInfo.modifyTime, '  %TDD.MM.YYYY') +    // datum
 NXT
 LDX  fbListDir
 ADD  91  ; + offset 
 LDIQ 
#debug dt fbListDir.fileInfo.modifyTime
 WR   __Instance__DT_TO_STRINGF~in
#debug_left dt __Instance__DT_TO_STRINGF~in
 LD   0   ; null string
 LEA  __Instance__DT_TO_STRINGF~format
 WRI 
 LEA  __Instance__DT_TO_STRINGF~format
 LD   80
 DST    ; Level 2
 LEA  _str_ListDirectoriesLog_7
 SCON 
#debug_left string __Instance__DT_TO_STRINGF~format
 PDST   ; Level 2
 PRV
 LEA  __Instance__DT_TO_STRINGF
 CAL  DT_TO_STRINGF_L0

 SCON 
#srcline 175 ;              DT_TO_STRINGF( fbListDir.fileInfo.modifyTime, '  %Thh:mm:ss');       // cas (posledni modifikace)
 NXT
 LDX  fbListDir
 ADD  91  ; + offset 
 LDIQ 
#debug dt fbListDir.fileInfo.modifyTime
 WR   __Instance__DT_TO_STRINGF~in
#debug_left dt __Instance__DT_TO_STRINGF~in
 LD   0   ; null string
 LEA  __Instance__DT_TO_STRINGF~format
 WRI 
 LEA  __Instance__DT_TO_STRINGF~format
 LD   80
 DST    ; Level 2
 LEA  _str_ListDirectoriesLog_8
 SCON 
#debug_left string __Instance__DT_TO_STRINGF~format
 PDST   ; Level 2
 PRV
 LEA  __Instance__DT_TO_STRINGF
 CAL  DT_TO_STRINGF_L0

 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX line
 WRI  
 LEAX line
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string line
 PDST   ; Level 1
#srcline 176 ;      usedSpace := usedSpace + fbListDir.fileInfo.fileSize;
 LDX  usedSpace
#debug udint usedSpace
 LDX  fbListDir
 ADD  99  ; + offset 
 LDIL 
#debug udint fbListDir.fileInfo.fileSize
 ADD
 WRX  usedSpace
#debug_left udint usedSpace
#srcline 177 ;    END_IF;
ListDirectoriesLog_L10:
#srcline 178 ;    line := line + '$0D$0A';
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LEAX line
#debug string line
 SCON 
 LEA  _str_ListDirectoriesLog_9
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX line
 WRI  
 LEAX line
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string line
 PDST   ; Level 1
#srcline 179 ;    FileWrite( hFile := hf, adrBuf := PTR_TO_UDINT( ADR( line)), size := LEN(line));
 NXT
 LDX  hf
#debug udint hf
 WR   __Instance__FileWrite~hFile
#debug_left udint __Instance__FileWrite~hFile
 LEAX line
#debug pointer line
 WR   __Instance__FileWrite~adrBuf
#debug_left udint __Instance__FileWrite~adrBuf
 LEAX line
#debug string line
 SLEN 
 WR   __Instance__FileWrite~size
#debug_left udint __Instance__FileWrite~size
 PRV
 LEA  __Instance__FileWrite
 CAL  FileWrite_L0
#srcline 180 ;  END_IF;
ListDirectoriesLog_L5:
#srcline 182 ;  IF (hf <> INVALID_HANDLE_VALUE) AND NOT fbListDir.busy THEN  // pruzkum adresare ukoncen
 LDX  hf
#debug udint hf
 LD   udint 0
 EQ
 NEG
 LDX  fbListDir
 ADD  82  ; + offset 
 MUL  8   ; -> bool pointer 
 ADD  1   ; Bool offset 
 LDIB 
#debug bool fbListDir.busy
 NEG
 AND
 JMC  ListDirectoriesLog_L11
#srcline 183 ;    stopDT := GetDateTime();
 LEA  __Instance__GetDateTime
 CAL  GetDateTime_L0
 WRX  stopDT
#debug_left dt stopDT
#srcline 184 ;    line := UINT_TO_STRINGF( cnt, '$0D$0ATotal items: %d,  ') +
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 NXT
 LDX  cnt
#debug uint cnt
 WR   __Instance__UINT_TO_STRINGF~in
#debug_left uint __Instance__UINT_TO_STRINGF~in
 LD   0   ; null string
 LEA  __Instance__UINT_TO_STRINGF~format
 WRI 
 LEA  __Instance__UINT_TO_STRINGF~format
 LD   80
 DST    ; Level 2
 LEA  _str_ListDirectoriesLog_10
 SCON 
#debug_left string __Instance__UINT_TO_STRINGF~format
 PDST   ; Level 2
 PRV
 LEA  __Instance__UINT_TO_STRINGF
 CAL  UINT_TO_STRINGF_L0

 SCON 
#srcline 185 ;            UDINT_TO_STRINGF( usedSpace, 'Used space: %d,  ') +
 NXT
 LDX  usedSpace
#debug udint usedSpace
 WR   __Instance__UDINT_TO_STRINGF~in
#debug_left udint __Instance__UDINT_TO_STRINGF~in
 LD   0   ; null string
 LEA  __Instance__UDINT_TO_STRINGF~format
 WRI 
 LEA  __Instance__UDINT_TO_STRINGF~format
 LD   80
 DST    ; Level 2
 LEA  _str_ListDirectoriesLog_11
 SCON 
#debug_left string __Instance__UDINT_TO_STRINGF~format
 PDST   ; Level 2
 PRV
 LEA  __Instance__UDINT_TO_STRINGF
 CAL  UDINT_TO_STRINGF_L0

 SCON 
#srcline 186 ;            TIME_TO_STRINGF( SUB_DT_DT( stopDT, startDT), 'Processing time: %Ts.zzz [sec]$0D$0A');
 NXT
 NXT
 LDX  stopDT
#debug dt stopDT
 WR   __Instance__SUB_DT_DT~IN1
#debug_left dt __Instance__SUB_DT_DT~IN1
 LDX  startDT
#debug dt startDT
 WR   __Instance__SUB_DT_DT~IN2
#debug_left dt __Instance__SUB_DT_DT~IN2
 PRV
 LEA  __Instance__SUB_DT_DT
 CAL  SUB_DT_DT_L0
 WR   __Instance__TIME_TO_STRINGF~in
#debug_left time __Instance__TIME_TO_STRINGF~in
 LD   0   ; null string
 LEA  __Instance__TIME_TO_STRINGF~format
 WRI 
 LEA  __Instance__TIME_TO_STRINGF~format
 LD   80
 DST    ; Level 2
 LEA  _str_ListDirectoriesLog_12
 SCON 
#debug_left string __Instance__TIME_TO_STRINGF~format
 PDST   ; Level 2
 PRV
 LEA  __Instance__TIME_TO_STRINGF
 CAL  TIME_TO_STRINGF_L0

 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX line
 WRI  
 LEAX line
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string line
 PDST   ; Level 1
#srcline 187 ;    FileWrite( hFile := hf, adrBuf := PTR_TO_UDINT( ADR( line)), size := LEN(line));
 NXT
 LDX  hf
#debug udint hf
 WR   __Instance__FileWrite~hFile
#debug_left udint __Instance__FileWrite~hFile
 LEAX line
#debug pointer line
 WR   __Instance__FileWrite~adrBuf
#debug_left udint __Instance__FileWrite~adrBuf
 LEAX line
#debug string line
 SLEN 
 WR   __Instance__FileWrite~size
#debug_left udint __Instance__FileWrite~size
 PRV
 LEA  __Instance__FileWrite
 CAL  FileWrite_L0
#srcline 188 ;    FileClose(hFile := hf); hf := INVALID_HANDLE_VALUE;
 NXT
 LDX  hf
#debug udint hf
 WR   __Instance__FileClose~hFile
#debug_left udint __Instance__FileClose~hFile
 PRV
 LEA  __Instance__FileClose
 CAL  FileClose_L0
 LD   udint 0
 WRX  hf
#debug_left udint hf
#srcline 189 ;  END_IF;
ListDirectoriesLog_L11:
#srcline 190 ;END_FUNCTION_BLOCK
 ULNK
RET
E     61

; Initialize - variables
P     61
ListDirectoriesLog__InstanceInit__:
 LINK 0
 ULNK
RET
E     61
; End initialize - variables
#endpou 



 

#srcfile ''
#srcfile 'C:\TECOLIBSRC\FILELIB\FILELIB\READLASTLINES.ST'
#pou ReadLastLines
#srcline 1 ;FUNCTION_BLOCK ReadLastLines

#struct ReadLastLines__temp__
  udint P0__st__,
  string[82] PS0__st__
#data byte _str_ReadLastLines_0 = 
  '',0
P     61
ReadLastLines_L0:
 LINK __SizeOf(ReadLastLines__temp__)
; Initialize - dynamic variables
; End initialize - dynamic variables
; R_EDGE, F_EDGE 
 LDX  read
 LETX __EDGE_R__read
 WRX  read
#srcline 48 ;  err := false;
 LD   bool 0       ; false
 WRX  err
#debug_left bool err
#srcline 49 ;  done := false;
 LD   bool 0       ; false
 WRX  done
#debug_left bool done
#srcline 50 ;  busy := busy OR read;
 LDX  busy
#debug bool busy
 LDX  read
#debug bool read
 OR  
 WRX  busy
#debug_left bool busy
#srcline 51 ;  
#srcline 52 ;  IF busy THEN
 LDX  busy
#debug bool busy
 JMC  ReadLastLines_L1
#srcline 53 ;    IF h = INVALID_HANDLE_VALUE THEN
 LDX  h
#debug udint h
 LD   udint 0
 EQ
 JMC  ReadLastLines_L3
#srcline 54 ;      linesRead := 0;
 LD   udint 0
 WRX  linesRead
#debug_left udint linesRead
#srcline 55 ;      errID := 0;
 LD   udint 0
 WRX  errID
#debug_left udint errID
#srcline 56 ;      errTxt := '';
 LD   0   ; null string
 LEAX errTxt
 WRI  
 LEAX errTxt
 LD   80
 DST    ; Level 1
 LEA  _str_ReadLastLines_0
 SCON 
#debug_left string errTxt
 PDST   ; Level 1
#srcline 57 ;      maxLineLen := sizeOfArray / lineNum;
 LDX  sizeOfArray
#debug udint sizeOfArray
 LDX  lineNum
#debug udint lineNum
 DIVL
 WRX  maxLineLen
#debug_left udint maxLineLen
#srcline 58 ;      h := FileOpen(mode := TF_MODE#F_READ, fileName := filename);
 NXT
 LD   udint 0  ; TF_MODE#F_READ
 WR   __Instance__FileOpen~mode
#debug_left usint __Instance__FileOpen~mode
 LDX  filename
 WR   __Instance__FileOpen~fileName
#debug_left pointer __Instance__FileOpen.fileName
 PRV
 LEA  __Instance__FileOpen
 CAL  FileOpen_L0
 WRX  h
#debug_left udint h
#srcline 59 ;      IF h <> INVALID_HANDLE_VALUE THEN
 LDX  h
#debug udint h
 LD   udint 0
 EQ
 NEG
 JMC  ReadLastLines_L5
#srcline 60 ;        fSize := FileSize(hFile := h);
 NXT
 LDX  h
#debug udint h
 WR   __Instance__FileSize~hFile
#debug_left udint __Instance__FileSize~hFile
 PRV
 LEA  __Instance__FileSize
 CAL  FileSize_L0
 WRX  fSize
#debug_left udint fSize
#srcline 61 ;        //FileClose(hFile := h);
#srcline 62 ;        //h := FileOpen(mode := TF_MODE#F_READ, fileName := filename);
#srcline 63 ;        lEndOffset := Offset;
 LDX  Offset
#debug udint Offset
 WRX  lEndOffset
#debug_left udint lEndOffset
#srcline 64 ;        state := 1;
 LD   udint 1
 WRX  state
#debug_left udint state
#srcline 65 ;      ELSE
 JMP  ReadLastLines_L6
ReadLastLines_L5:
#srcline 66 ;        err  := true;
 LD   bool -1       ; true
 WRX  err
#debug_left bool err
#srcline 67 ;        errID := GetLastErr();
 LEA  __Instance__GetLastErr
 CAL  GetLastErr_L0
 WRX  errID
#debug_left udint errID
#srcline 68 ;        GetLastErrTxt(errCode := errID, errMessage := errTxt);
 NXT
 LDX  errID
#debug udint errID
 WR   __Instance__GetLastErrTxt~errCode
#debug_left udint __Instance__GetLastErrTxt~errCode
 LEAX errTxt
 WR   __Instance__GetLastErrTxt~errMessage
#debug_left pointer __Instance__GetLastErrTxt.errMessage
 PRV
 LEA  __Instance__GetLastErrTxt
 CAL  GetLastErrTxt_L0
#srcline 69 ;      END_IF;
ReadLastLines_L6:
#srcline 70 ;    ELSE
 JMP  ReadLastLines_L4
ReadLastLines_L3:
#srcline 71 ;      CASE state OF
 LDX  state
#debug udint state
 WRY  P0__st__
 LD   1
 LDY  P0__st__
 EQ  
 JMC  ReadLastLines_L8
#srcline 72 ;        1 : //nacist kus
#srcline 73 ;          endOfFile := fSize < sizeof(buffer) + lEndOffset;
 LDX  fSize
#debug udint fSize
 LD   256  ; SizeOf()
 LDX  lEndOffset
#debug udint lEndOffset
 ADD
 LT
 WRX  endOfFile
#debug_left bool endOfFile
#srcline 74 ;          IF endOfFile THEN
 LDX  endOfFile
#debug bool endOfFile
 JMC  ReadLastLines_L9
#srcline 75 ;            err := NOT FileSetPos(hFile := h, offset := 0);
 NXT
 LDX  h
#debug udint h
 WR   __Instance__FileSetPos~hFile
#debug_left udint __Instance__FileSetPos~hFile
 LD   udint 0
 WR   __Instance__FileSetPos~offset
#debug_left udint __Instance__FileSetPos~offset
 PRV
 LEA  __Instance__FileSetPos
 CAL  FileSetPos_L0
 NEG
 WRX  err
#debug_left bool err
#srcline 76 ;          ELSE
 JMP  ReadLastLines_L10
ReadLastLines_L9:
#srcline 77 ;            err := NOT FileSetPos(hFile := h, offset := fSize - sizeof(buffer) - lEndOffset);
 NXT
 LDX  h
#debug udint h
 WR   __Instance__FileSetPos~hFile
#debug_left udint __Instance__FileSetPos~hFile
 LDX  fSize
#debug udint fSize
 LD   256  ; SizeOf()
 SUB
 LDX  lEndOffset
#debug udint lEndOffset
 SUB
 WR   __Instance__FileSetPos~offset
#debug_left udint __Instance__FileSetPos~offset
 PRV
 LEA  __Instance__FileSetPos
 CAL  FileSetPos_L0
 NEG
 WRX  err
#debug_left bool err
#srcline 78 ;          END_IF;
ReadLastLines_L10:
#srcline 79 ;          IF err THEN
 LDX  err
#debug bool err
 JMC  ReadLastLines_L11
#srcline 80 ;            errID := GetLastErr();
 LEA  __Instance__GetLastErr
 CAL  GetLastErr_L0
 WRX  errID
#debug_left udint errID
#srcline 81 ;            GetLastErrTxt(errCode := errID, errMessage := errTxt);
 NXT
 LDX  errID
#debug udint errID
 WR   __Instance__GetLastErrTxt~errCode
#debug_left udint __Instance__GetLastErrTxt~errCode
 LEAX errTxt
 WR   __Instance__GetLastErrTxt~errMessage
#debug_left pointer __Instance__GetLastErrTxt.errMessage
 PRV
 LEA  __Instance__GetLastErrTxt
 CAL  GetLastErrTxt_L0
#srcline 82 ;          ELSE
 JMP  ReadLastLines_L12
ReadLastLines_L11:
#srcline 83 ;            IF endOfFile THEN
 LDX  endOfFile
#debug bool endOfFile
 JMC  ReadLastLines_L13
#srcline 84 ;              rSize := FileRead(hFile := h, adrBuf := PTR_TO_UDINT(ADR(buffer)), size := fSize - lEndOffset); //docist zbytek
 NXT
 LDX  h
#debug udint h
 WR   __Instance__FileRead~hFile
#debug_left udint __Instance__FileRead~hFile
 LEAX buffer
#debug pointer buffer
 WR   __Instance__FileRead~adrBuf
#debug_left udint __Instance__FileRead~adrBuf
 LDX  fSize
#debug udint fSize
 LDX  lEndOffset
#debug udint lEndOffset
 SUB
 WR   __Instance__FileRead~size
#debug_left udint __Instance__FileRead~size
 PRV
 LEA  __Instance__FileRead
 CAL  FileRead_L0
 WRX  rSize
#debug_left udint rSize
#srcline 85 ;            ELSE
 JMP  ReadLastLines_L14
ReadLastLines_L13:
#srcline 86 ;              rSize := FileRead(hFile := h, adrBuf := PTR_TO_UDINT(ADR(buffer)), size := sizeof(buffer));
 NXT
 LDX  h
#debug udint h
 WR   __Instance__FileRead~hFile
#debug_left udint __Instance__FileRead~hFile
 LEAX buffer
#debug pointer buffer
 WR   __Instance__FileRead~adrBuf
#debug_left udint __Instance__FileRead~adrBuf
 LD   256  ; SizeOf()
 WR   __Instance__FileRead~size
#debug_left udint __Instance__FileRead~size
 PRV
 LEA  __Instance__FileRead
 CAL  FileRead_L0
 WRX  rSize
#debug_left udint rSize
#srcline 87 ;            END_IF;
ReadLastLines_L14:
#srcline 88 ;            IF rSize = 0 THEN //nepovedlo se cteni
 LDX  rSize
#debug udint rSize
 LD   udint 0
 EQ
 JMC  ReadLastLines_L15
#srcline 89 ;              err  := true;
 LD   bool -1       ; true
 WRX  err
#debug_left bool err
#srcline 90 ;              errID := GetLastErr();
 LEA  __Instance__GetLastErr
 CAL  GetLastErr_L0
 WRX  errID
#debug_left udint errID
#srcline 91 ;              GetLastErrTxt(errCode := errID, errMessage := errTxt);
 NXT
 LDX  errID
#debug udint errID
 WR   __Instance__GetLastErrTxt~errCode
#debug_left udint __Instance__GetLastErrTxt~errCode
 LEAX errTxt
 WR   __Instance__GetLastErrTxt~errMessage
#debug_left pointer __Instance__GetLastErrTxt.errMessage
 PRV
 LEA  __Instance__GetLastErrTxt
 CAL  GetLastErrTxt_L0
#srcline 92 ;            ELSE
 JMP  ReadLastLines_L16
ReadLastLines_L15:
#srcline 93 ;              p := ADR(buffer) + rSize - 1;
 LEAX buffer
#debug pointer buffer
 LDX  rSize
#debug udint rSize
 ADD
 LD   udint 1
 SUB
 LEAX p
 WRIL 
#debug_left pointer p
#srcline 94 ;              start := PTR_TO_UDINT(p); //poznamenat pocatecni pozici
 LEAX p
 LDIL 
#debug pointer p
 WRX  start
#debug_left udint start
#srcline 95 ;              IF lEndOffset = offset THEN
 LDX  lEndOffset
#debug udint lEndOffset
 LDX  offset
#debug udint offset
 EQ
 JMC  ReadLastLines_L17
#srcline 96 ;                IF p^ = 10 THEN //zacali jsme cist a soubor konci prazdnym radkem - ignorovat
 LEAX p
 LDIL    ; dereference 
 LDI  
#debug usint p^
 LD   usint 10
 EQ
 JMC  ReadLastLines_L19
#srcline 97 ;                  lineCnt := 0 - 1;
 LD   udint 0
 LD   udint 1
 SUB
 WRX  lineCnt
#debug_left udint lineCnt
#srcline 98 ;                ELSE
 JMP  ReadLastLines_L20
ReadLastLines_L19:
#srcline 99 ;                  lineCnt := 0;
 LD   udint 0
 WRX  lineCnt
#debug_left udint lineCnt
#srcline 100 ;                END_IF;
ReadLastLines_L20:
#srcline 101 ;              END_IF;
ReadLastLines_L17:
#srcline 102 ;              state := 2;
 LD   udint 2
 WRX  state
#debug_left udint state
#srcline 103 ;            END_IF;
ReadLastLines_L16:
#srcline 104 ;          END_IF;
ReadLastLines_L12:
 JMP  ReadLastLines_L7
ReadLastLines_L8:
 LD   2
 LDY  P0__st__
 EQ  
 JMC  ReadLastLines_L21
#srcline 105 ;        2 : //projit nacteny
#srcline 106 ;          pb := ADR(buffer) - 1;
 LEAX buffer
#debug pointer buffer
 LD   udint 1
 SUB
 LEAX pb
 WRIL 
#debug_left pointer pb
#srcline 107 ;          WHILE state = 2 DO
ReadLastLines_L22:
 LDX  state
#debug udint state
 LD   udint 2
 EQ
 JMC  ReadLastLines_L23
 DBG 
#srcline 108 ;            WHILE PTR_TO_UDINT(p) > PTR_TO_UDINT(pb) DO
ReadLastLines_L24:
 LEAX p
 LDIL 
#debug pointer p
 LEAX pb
 LDIL 
#debug pointer pb
 GT
 JMC  ReadLastLines_L25
 DBG 
#srcline 109 ;              lEndOffset := lEndOffset + 1;
 LDX  lEndOffset
#debug udint lEndOffset
 LD   udint 1
 ADD
 WRX  lEndOffset
#debug_left udint lEndOffset
#srcline 110 ;              IF p^ = 10 THEN //nalezen radek
 LEAX p
 LDIL    ; dereference 
 LDI  
#debug usint p^
 LD   usint 10
 EQ
 JMC  ReadLastLines_L26
#srcline 111 ;                lineCnt := lineCnt + 1;
 LDX  lineCnt
#debug udint lineCnt
 LD   udint 1
 ADD
 WRX  lineCnt
#debug_left udint lineCnt
#srcline 112 ;                p := p - 1; //posunout pred
 LEAX p
 LDIL 
#debug pointer p
 LD   udint 1
 SUB
 LEAX p
 WRIL 
#debug_left pointer p
#srcline 113 ;                EXIT;
 JMP  ReadLastLines_L25
#srcline 114 ;              END_IF;
ReadLastLines_L26:
#srcline 115 ;              p := p - 1;
 LEAX p
 LDIL 
#debug pointer p
 LD   udint 1
 SUB
 LEAX p
 WRIL 
#debug_left pointer p
#srcline 116 ;            END_WHILE;
 JMP  ReadLastLines_L24
ReadLastLines_L25:
 NOP  -1
#srcline 117 ;            IF lineCnt = lineNum THEN //nasel jsem zadany pocet radku
 LDX  lineCnt
#debug udint lineCnt
 LDX  lineNum
#debug udint lineNum
 EQ
 JMC  ReadLastLines_L28
#srcline 118 ;              lEndOffset := lEndOffset - 1; //posledni enter nepotrebuju
 LDX  lEndOffset
#debug udint lEndOffset
 LD   udint 1
 SUB
 WRX  lEndOffset
#debug_left udint lEndOffset
#srcline 119 ;              linesOffset := lEndOffset;
 LDX  lEndOffset
#debug udint lEndOffset
 WRX  linesOffset
#debug_left udint linesOffset
#srcline 120 ;              p := ADR(buffer) + sizeof(buffer) - 1;
 LEAX buffer
#debug pointer buffer
 LD   256  ; SizeOf()
 ADD
 LD   udint 1
 SUB
 LEAX p
 WRIL 
#debug_left pointer p
#srcline 121 ;              p^ := 0;
 LD   usint 0
 LEAX p
 LDIL    ; dereference 
 WRI 
#debug_left usint p^
#srcline 122 ;              state := 3;
 LD   udint 3
 WRX  state
#debug_left udint state
#srcline 123 ;            ELSE
 JMP  ReadLastLines_L29
ReadLastLines_L28:
#srcline 124 ;              IF PTR_TO_UDINT(p) <= PTR_TO_UDINT(ADR(buffer)) THEN //jeste mame kde hledat
 LEAX p
 LDIL 
#debug pointer p
 LEAX buffer
#debug pointer buffer
 GT
 NEG
 JMC  ReadLastLines_L30
#srcline 125 ;                IF endOfFile THEN //nenasel jsem vsechny, dam to co mam
 LDX  endOfFile
#debug bool endOfFile
 JMC  ReadLastLines_L32
#srcline 126 ;                  linesOffset := lEndOffset;
 LDX  lEndOffset
#debug udint lEndOffset
 WRX  linesOffset
#debug_left udint linesOffset
#srcline 127 ;                  p := ADR(buffer) + sizeof(buffer) - 1;
 LEAX buffer
#debug pointer buffer
 LD   256  ; SizeOf()
 ADD
 LD   udint 1
 SUB
 LEAX p
 WRIL 
#debug_left pointer p
#srcline 128 ;                  p^ := 0;
 LD   usint 0
 LEAX p
 LDIL    ; dereference 
 WRI 
#debug_left usint p^
#srcline 129 ;                  state := 3;
 LD   udint 3
 WRX  state
#debug_left udint state
#srcline 130 ;                ELSE
 JMP  ReadLastLines_L33
ReadLastLines_L32:
#srcline 131 ;                  state := 1;
 LD   udint 1
 WRX  state
#debug_left udint state
#srcline 132 ;                END_IF;
ReadLastLines_L33:
#srcline 133 ;              END_IF;
ReadLastLines_L30:
#srcline 134 ;            END_IF;
ReadLastLines_L29:
#srcline 135 ;          END_WHILE;
 JMP  ReadLastLines_L22
ReadLastLines_L23:
 NOP  -1
 JMP  ReadLastLines_L7
ReadLastLines_L21:
 LD   3
 LDY  P0__st__
 EQ  
 JMC  ReadLastLines_L34
#srcline 136 ;        3 :
#srcline 137 ;          IF lEndOffset = 0 THEN //pro pripad, ze jsem precetli posledni radek soubor zakonceny enterem a dalsi uz tam neni
 LDX  lEndOffset
#debug udint lEndOffset
 LD   udint 0
 EQ
 JMC  ReadLastLines_L35
#srcline 138 ;            done := 0;
 LD   bool 0       ; false
 WRX  done
#debug_left bool done
#srcline 139 ;          ELSE
 JMP  ReadLastLines_L36
ReadLastLines_L35:
#srcline 140 ;            err := NOT FileSetPos(hFile := h, offset := fSize - lEndOffset);
 NXT
 LDX  h
#debug udint h
 WR   __Instance__FileSetPos~hFile
#debug_left udint __Instance__FileSetPos~hFile
 LDX  fSize
#debug udint fSize
 LDX  lEndOffset
#debug udint lEndOffset
 SUB
 WR   __Instance__FileSetPos~offset
#debug_left udint __Instance__FileSetPos~offset
 PRV
 LEA  __Instance__FileSetPos
 CAL  FileSetPos_L0
 NEG
 WRX  err
#debug_left bool err
#srcline 141 ;            IF err THEN
 LDX  err
#debug bool err
 JMC  ReadLastLines_L37
#srcline 142 ;              errID := GetLastErr();
 LEA  __Instance__GetLastErr
 CAL  GetLastErr_L0
 WRX  errID
#debug_left udint errID
#srcline 143 ;              GetLastErrTxt(errCode := errID, errMessage := errTxt);
 NXT
 LDX  errID
#debug udint errID
 WR   __Instance__GetLastErrTxt~errCode
#debug_left udint __Instance__GetLastErrTxt~errCode
 LEAX errTxt
 WR   __Instance__GetLastErrTxt~errMessage
#debug_left pointer __Instance__GetLastErrTxt.errMessage
 PRV
 LEA  __Instance__GetLastErrTxt
 CAL  GetLastErrTxt_L0
#srcline 144 ;            ELSE
 JMP  ReadLastLines_L38
ReadLastLines_L37:
#srcline 145 ;              pString := ADR(txtLines)+linesRead*maxLineLen;
 LDX  txtLines
#debug pointer txtLines
 LDX  linesRead
#debug udint linesRead
 LDX  maxLineLen
#debug udint maxLineLen
 MUL
 ADD
 LEAX pString
 WRIL 
#debug_left pointer pString
#srcline 146 ;              rSize := FileRead(hFile := h, adrBuf := PTR_TO_UDINT(pString), size := maxLineLen-1);
 NXT
 LDX  h
#debug udint h
 WR   __Instance__FileRead~hFile
#debug_left udint __Instance__FileRead~hFile
 LEAX pString
 LDIL 
#debug pointer pString
 WR   __Instance__FileRead~adrBuf
#debug_left udint __Instance__FileRead~adrBuf
 LDX  maxLineLen
#debug udint maxLineLen
 LD   udint 1
 SUB
 WR   __Instance__FileRead~size
#debug_left udint __Instance__FileRead~size
 PRV
 LEA  __Instance__FileRead
 CAL  FileRead_L0
 WRX  rSize
#debug_left udint rSize
#srcline 147 ;              IF rSize = 0 THEN //nepovedlo se cteni
 LDX  rSize
#debug udint rSize
 LD   udint 0
 EQ
 JMC  ReadLastLines_L39
#srcline 148 ;                err  := true;
 LD   bool -1       ; true
 WRX  err
#debug_left bool err
#srcline 149 ;                errID := GetLastErr();
 LEA  __Instance__GetLastErr
 CAL  GetLastErr_L0
 WRX  errID
#debug_left udint errID
#srcline 150 ;                GetLastErrTxt(errCode := errID, errMessage := errTxt);
 NXT
 LDX  errID
#debug udint errID
 WR   __Instance__GetLastErrTxt~errCode
#debug_left udint __Instance__GetLastErrTxt~errCode
 LEAX errTxt
 WR   __Instance__GetLastErrTxt~errMessage
#debug_left pointer __Instance__GetLastErrTxt.errMessage
 PRV
 LEA  __Instance__GetLastErrTxt
 CAL  GetLastErrTxt_L0
#srcline 151 ;              ELSE
 JMP  ReadLastLines_L40
ReadLastLines_L39:
#srcline 152 ;                p := pString + rSize;
 LEAX pString
 LDIL 
#debug pointer pString
 LDX  rSize
#debug udint rSize
 ADD
 LEAX p
 WRIL 
#debug_left pointer p
#srcline 153 ;                p^ := 0;
 LD   usint 0
 LEAX p
 LDIL    ; dereference 
 WRI 
#debug_left usint p^
#srcline 154 ;                linesRead := linesRead + 1;
 LDX  linesRead
#debug udint linesRead
 LD   udint 1
 ADD
 WRX  linesRead
#debug_left udint linesRead
#srcline 155 ;                fPos  := FIND(IN1 := pString^, IN2 := SEPARATOR);
 LEAX pString
 LDIL    ; dereference 
#debug string pString^
 LEA  __Const__ReadLastLines_SEPARATOR
 SFND 
 WRX  fPos
#debug_left udint fPos
#srcline 156 ;                IF fPos > 0 THEN
 LDX  fPos
#debug udint fPos
 LD   udint 0
 GT
 JMC  ReadLastLines_L41
#srcline 157 ;                  p := pString + fPos - 1;
 LEAX pString
 LDIL 
#debug pointer pString
 LDX  fPos
#debug udint fPos
 ADD
 LD   udint 1
 SUB
 LEAX p
 WRIL 
#debug_left pointer p
#srcline 158 ;                  p^ := 0;
 LD   usint 0
 LEAX p
 LDIL    ; dereference 
 WRI 
#debug_left usint p^
#srcline 159 ;                  IF fPos > 1 THEN
 LDX  fPos
#debug udint fPos
 LD   udint 1
 GT
 JMC  ReadLastLines_L43
#srcline 160 ;                    p := pString + fPos - 2;
 LEAX pString
 LDIL 
#debug pointer pString
 LDX  fPos
#debug udint fPos
 ADD
 LD   udint 2
 SUB
 LEAX p
 WRIL 
#debug_left pointer p
#srcline 161 ;                    IF p^ = 13 THEN p^ := 0; END_IF;
 LEAX p
 LDIL    ; dereference 
 LDI  
#debug usint p^
 LD   usint 13
 EQ
 JMC  ReadLastLines_L45
 LD   usint 0
 LEAX p
 LDIL    ; dereference 
 WRI 
#debug_left usint p^
ReadLastLines_L45:
#srcline 162 ;                  END_IF;
ReadLastLines_L43:
#srcline 163 ;                  lEndOffset := lEndOffset - fPos;
 LDX  lEndOffset
#debug udint lEndOffset
 LDX  fPos
#debug udint fPos
 SUB
 WRX  lEndOffset
#debug_left udint lEndOffset
#srcline 164 ;                ELSE
 JMP  ReadLastLines_L42
ReadLastLines_L41:
#srcline 165 ;                  lEndOffset := lEndOffset - rSize;
 LDX  lEndOffset
#debug udint lEndOffset
 LDX  rSize
#debug udint rSize
 SUB
 WRX  lEndOffset
#debug_left udint lEndOffset
#srcline 166 ;                  state := 4; //docist zbytek radku zvlast
 LD   udint 4
 WRX  state
#debug_left udint state
#srcline 167 ;                END_IF;
ReadLastLines_L42:
#srcline 168 ;                IF linesRead = lineNum OR lEndOffset = 0 THEN //konec mam vse
 LDX  linesRead
#debug udint linesRead
 LDX  lineNum
#debug udint lineNum
 EQ
 LDX  lEndOffset
#debug udint lEndOffset
 LD   udint 0
 EQ
 OR  
 JMC  ReadLastLines_L47
#srcline 169 ;                  done := true;
 LD   bool -1       ; true
 WRX  done
#debug_left bool done
#srcline 170 ;                END_IF;
ReadLastLines_L47:
#srcline 171 ;              END_IF;
ReadLastLines_L40:
#srcline 172 ;            END_IF;
ReadLastLines_L38:
#srcline 173 ;          END_IF;
ReadLastLines_L36:
 JMP  ReadLastLines_L7
ReadLastLines_L34:
 LD   4
 LDY  P0__st__
 EQ  
 JMC  ReadLastLines_L49
#srcline 174 ;        4 : //docitani radku
#srcline 175 ;          pString := ADR(buffer);
 LEAX buffer
#debug pointer buffer
 LEAX pString
 WRIL 
#debug_left pointer pString
#srcline 176 ;          rSize := FileRead(hFile := h, adrBuf := PTR_TO_UDINT(pString), size := sizeof(buffer)-1);
 NXT
 LDX  h
#debug udint h
 WR   __Instance__FileRead~hFile
#debug_left udint __Instance__FileRead~hFile
 LEAX pString
 LDIL 
#debug pointer pString
 WR   __Instance__FileRead~adrBuf
#debug_left udint __Instance__FileRead~adrBuf
 LD   256  ; SizeOf()
 LD   udint 1
 SUB
 WR   __Instance__FileRead~size
#debug_left udint __Instance__FileRead~size
 PRV
 LEA  __Instance__FileRead
 CAL  FileRead_L0
 WRX  rSize
#debug_left udint rSize
#srcline 177 ;          IF rSize = 0 THEN //uz neni co cist?
 LDX  rSize
#debug udint rSize
 LD   udint 0
 EQ
 JMC  ReadLastLines_L50
#srcline 178 ;            done := true;
 LD   bool -1       ; true
 WRX  done
#debug_left bool done
#srcline 179 ;          ELSE
 JMP  ReadLastLines_L51
ReadLastLines_L50:
#srcline 180 ;            fPos := FIND(IN1 := pString^, IN2 := SEPARATOR);
 LEAX pString
 LDIL    ; dereference 
#debug string pString^
 LEA  __Const__ReadLastLines_SEPARATOR
 SFND 
 WRX  fPos
#debug_left udint fPos
#srcline 181 ;            IF fPos > 0 THEN
 LDX  fPos
#debug udint fPos
 LD   udint 0
 GT
 JMC  ReadLastLines_L52
#srcline 182 ;              lEndOffset := lEndOffset - fPos;
 LDX  lEndOffset
#debug udint lEndOffset
 LDX  fPos
#debug udint fPos
 SUB
 WRX  lEndOffset
#debug_left udint lEndOffset
#srcline 183 ;              state := 3; //nasli jsme konec, cteme dalsi radek
 LD   udint 3
 WRX  state
#debug_left udint state
#srcline 184 ;            ELSE
 JMP  ReadLastLines_L53
ReadLastLines_L52:
#srcline 185 ;              lEndOffset := lEndOffset - rSize;
 LDX  lEndOffset
#debug udint lEndOffset
 LDX  rSize
#debug udint rSize
 SUB
 WRX  lEndOffset
#debug_left udint lEndOffset
#srcline 186 ;            END_IF;
ReadLastLines_L53:
#srcline 187 ;          END_IF;
ReadLastLines_L51:
 JMP  ReadLastLines_L7
ReadLastLines_L49:
#srcline 188 ;      ELSE
#srcline 189 ;      ;
#srcline 190 ;      END_CASE;
ReadLastLines_L7:
#srcline 191 ;    END_IF;
ReadLastLines_L4:
#srcline 192 ;    busy := NOT err AND NOT done;
 LDX  err
#debug bool err
 NEG
 LDX  done
#debug bool done
 NEG
 AND
 WRX  busy
#debug_left bool busy
#srcline 193 ;    IF NOT busy THEN
 LDX  busy
#debug bool busy
 NEG
 JMC  ReadLastLines_L54
#srcline 194 ;      IF h <> INVALID_HANDLE_VALUE THEN
 LDX  h
#debug udint h
 LD   udint 0
 EQ
 NEG
 JMC  ReadLastLines_L56
#srcline 195 ;        FileClose(hFile := h);
 NXT
 LDX  h
#debug udint h
 WR   __Instance__FileClose~hFile
#debug_left udint __Instance__FileClose~hFile
 PRV
 LEA  __Instance__FileClose
 CAL  FileClose_L0
#srcline 196 ;        h := INVALID_HANDLE_VALUE;
 LD   udint 0
 WRX  h
#debug_left udint h
#srcline 197 ;      END_IF;
ReadLastLines_L56:
#srcline 198 ;    END_IF;
ReadLastLines_L54:
#srcline 199 ;  END_IF;
ReadLastLines_L1:
#srcline 200 ;END_FUNCTION_BLOCK
 ULNK
RET
E     61

; Initialize - variables
P     61
ReadLastLines__InstanceInit__:
 LINK 0
 LD   udint $FFFFFFFF    ; nil
 WRX  p
 LD   udint $FFFFFFFF    ; nil
 WRX  pb
 LD   udint $FFFFFFFF    ; nil
 WRX  pString
 ULNK
RET
E     61
; End initialize - variables
#endpou 



 

#srcfile ''
#srcfile 'C:\TECOLIBSRC\FILELIB\FILELIB\FBDELETEOLDFILES.ST'
#pou DeleteOldFiles
#srcline 1 ;FUNCTION_BLOCK DeleteOldFiles

#struct DeleteOldFiles__temp__
  bool correspond,
  int lenMask,
  int lenFileName,
  int posStar,
  string[256] tmpStr,
  string[257] PS0__st__
#data byte _str_DeleteOldFiles_0 = 
  '*',0
#data byte _str_DeleteOldFiles_1 = 
  '*',0
#data byte _str_DeleteOldFiles_2 = 
  '*',0
#data byte _str_DeleteOldFiles_3 = 
  '*',0
P     61
DeleteOldFiles_L0:
 LINK __SizeOf(DeleteOldFiles__temp__)
; Initialize - dynamic variables
; End initialize - dynamic variables
; R_EDGE, F_EDGE 
 LDX  exec
 LETX __EDGE_R__exec
 WRX  exec
#srcline 37 ;  isDeleted := 0;
 LD   bool 0       ; false
 WRX  isDeleted
#debug_left bool isDeleted
#srcline 38 ;  ListDir( exec := exec, noSubDir := noSubDir, dirName := dirName, done => done, busy => busy, err => err);
 LDX  exec
#debug bool exec
 WRX  ListDir~exec
#debug_left bool ListDir~exec
 LDX  noSubDir
#debug bool noSubDir
 WRX  ListDir~noSubDir
#debug_left bool ListDir~noSubDir
 LD   0   ; null string
 LEAX ListDir~dirName
 WRI 
 LEAX ListDir~dirName
 LD   80
 DST    ; Level 1
 LEAX dirName
#debug string dirName
 SCON 
#debug_left string ListDir~dirName
 PDST   ; Level 1
 LEAX ListDir
 CAL  ListDirectories_L0
; output assigment 
 LDX  ListDir~done
#debug bool ListDir~done
 WRX  done
#debug_left bool done
 LDX  ListDir~busy
#debug bool ListDir~busy
 WRX  busy
#debug_left bool busy
 LDX  ListDir~err
#debug bool ListDir~err
 WRX  err
#debug_left bool err
#srcline 40 ;  IF ListDir.busy OR ListDir.done THEN
 LDX  ListDir~busy
#debug bool ListDir.busy
 LDX  ListDir~done
#debug bool ListDir.done
 OR  
 JMC  DeleteOldFiles_L1
#srcline 41 ;    actDate := GetDateTime();
 LEA  __Instance__GetDateTime
 CAL  GetDateTime_L0
 WRX  actDate
#debug_left dt actDate
#srcline 42 ;    Memset(val := 0, length := sizeof( fileInfo), dest := void( fileInfo));
 NXT
 LD   udint 0
 WR   __Instance__Memset~val
#debug_left udint __Instance__Memset~val
 LD   266  ; SizeOf()
 WR   __Instance__Memset~length
#debug_left uint __Instance__Memset~length
 LEAX fileInfo
 WR   __Instance__Memset~dest
#debug_left pointer __Instance__Memset.dest
 PRV
 LEA  __Instance__Memset
 CAL  Memset_L0
#srcline 43 ;  END_IF;
DeleteOldFiles_L1:
#srcline 45 ;  IF ListDir.found AND NOT ListDir.isDir THEN  // vyhodnotit masku souboru
 LDX  ListDir~found
#debug bool ListDir.found
 LDX  ListDir~isDir
#debug bool ListDir.isDir
 NEG
 AND
 JMC  DeleteOldFiles_L3
#srcline 46 ;    IF fileMask = '*' THEN   // vsechny soubory (maska obsahuje pouze '*')
 LEAX fileMask
#debug string fileMask
 LEA  _str_DeleteOldFiles_0
 SCMP 
 EQ   0
 JMC  DeleteOldFiles_L5
#srcline 47 ;      correspond := 1;
 LD   bool -1      ; true
 WRY  correspond
#debug_left bool correspond
#srcline 48 ;    ELSE
 JMP  DeleteOldFiles_L6
DeleteOldFiles_L5:
#srcline 49 ;      correspond := 0;
 LD   bool 0       ; false
 WRY  correspond
#debug_left bool correspond
#srcline 50 ;      posStar := FIND(IN1 := fileMask, IN2 := '*');
 LEAX fileMask
#debug string fileMask
 LEA  _str_DeleteOldFiles_1
 SFND 
 WRY  posStar
#debug_left int posStar
#srcline 51 ;      IF posStar <> 0 THEN   // maska obsahuje '*'
 LDY  posStar
#debug int posStar
 EXTW 
 LD   int 0
 EQ
 NEG
 JMC  DeleteOldFiles_L7
#srcline 52 ;        lenMask := LEN( fileMask);
 LEAX fileMask
#debug string fileMask
 SLEN 
 WRY  lenMask
#debug_left int lenMask
#srcline 53 ;        lenFileName := LEN(ListDir.fileInfo.fileName);
 LEAX ListDir
 ADD  107  ; + offset 
#debug string ListDir.fileInfo.fileName
 SLEN 
 WRY  lenFileName
#debug_left int lenFileName
#srcline 54 ;        IF posStar = 1 THEN  // '*' v masce je na zacatku => konec nazvu souboru musi odpovidat masce
 LDY  posStar
#debug int posStar
 EXTW 
 LD   int 1
 EQ
 JMC  DeleteOldFiles_L9
#srcline 55 ;          IF lenFileName > (lenMask - 2) THEN
 LDY  lenFileName
#debug int lenFileName
 EXTW 
 LDY  lenMask
#debug int lenMask
 EXTW 
 LD   int 2
 SUB
 EXTW
 GTS
 JMC  DeleteOldFiles_L11
#srcline 56 ;            tmpStr := '*' + MID( IN := ListDir.fileInfo.fileName, L := 80, P := lenFileName - (lenMask - 2));
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LEA  _str_DeleteOldFiles_2
 SCON 
 LEAX ListDir
 ADD  107  ; + offset 
#debug string ListDir.fileInfo.fileName
 LD   80
 LDY  lenFileName
#debug int lenFileName
 EXTW 
 LDY  lenMask
#debug int lenMask
 EXTW 
 LD   int 2
 SUB
 EXTW
 SUB
 EXTW
 SUB  1
 SMID 
 PDST   ; Level 1
 LD   0   ; null string
 LEAY tmpStr
 WRI  
 LEAY tmpStr
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string tmpStr
 PDST   ; Level 1
#srcline 57 ;            correspond := tmpStr = fileMask;
 LEAY tmpStr
#debug string tmpStr
 LEAX fileMask
#debug string fileMask
 SCMP 
 EQ   0
 WRY  correspond
#debug_left bool correspond
#srcline 58 ;          END_IF;
DeleteOldFiles_L11:
#srcline 59 ;        ELSE  // '*' v masce neni na zacatku
 JMP  DeleteOldFiles_L10
DeleteOldFiles_L9:
#srcline 60 ;          IF posStar = lenMask THEN  // '*' je na konci
 LDY  posStar
#debug int posStar
 EXTW 
 LDY  lenMask
#debug int lenMask
 EXTW 
 EQ
 JMC  DeleteOldFiles_L13
#srcline 61 ;            tmpStr := LEFT(IN := ListDir.fileInfo.fileName, L := lenMask-1) + '*';
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LEAX ListDir
 ADD  107  ; + offset 
#debug string ListDir.fileInfo.fileName
 LDY  lenMask
#debug int lenMask
 EXTW 
 LD   int 1
 SUB
 EXTW
 SLFT 
 LEA  _str_DeleteOldFiles_3
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAY tmpStr
 WRI  
 LEAY tmpStr
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string tmpStr
 PDST   ; Level 1
#srcline 62 ;            correspond := tmpStr = fileMask;
 LEAY tmpStr
#debug string tmpStr
 LEAX fileMask
#debug string fileMask
 SCMP 
 EQ   0
 WRY  correspond
#debug_left bool correspond
#srcline 63 ;          ELSE  // '*' v masce je uprostred
 JMP  DeleteOldFiles_L14
DeleteOldFiles_L13:
#srcline 64 ;            IF lenFileName > (posStar - 2) THEN
 LDY  lenFileName
#debug int lenFileName
 EXTW 
 LDY  posStar
#debug int posStar
 EXTW 
 LD   int 2
 SUB
 EXTW
 GTS
 JMC  DeleteOldFiles_L15
#srcline 65 ;              tmpStr := LEFT(IN := ListDir.fileInfo.fileName, L := posStar - 1);
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LEAX ListDir
 ADD  107  ; + offset 
#debug string ListDir.fileInfo.fileName
 LDY  posStar
#debug int posStar
 EXTW 
 LD   int 1
 SUB
 EXTW
 SLFT 
 PDST   ; Level 1
 LD   0   ; null string
 LEAY tmpStr
 WRI  
 LEAY tmpStr
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string tmpStr
 PDST   ; Level 1
#srcline 66 ;              correspond := FIND(IN1 := fileMask, IN2 := tmpStr) = 1;
 LEAX fileMask
#debug string fileMask
 LEAY tmpStr
#debug string tmpStr
 SFND 
 LD   int 1
 EQ
 WRY  correspond
#debug_left bool correspond
#srcline 67 ;              IF correspond THEN
 LDY  correspond
#debug bool correspond
 JMC  DeleteOldFiles_L17
#srcline 68 ;                tmpStr := MID( IN := ListDir.fileInfo.fileName, L := 80, P := lenFileName - (posStar - 2));
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LEAX ListDir
 ADD  107  ; + offset 
#debug string ListDir.fileInfo.fileName
 LD   80
 LDY  lenFileName
#debug int lenFileName
 EXTW 
 LDY  posStar
#debug int posStar
 EXTW 
 LD   int 2
 SUB
 EXTW
 SUB
 EXTW
 SUB  1
 SMID 
 PDST   ; Level 1
 LD   0   ; null string
 LEAY tmpStr
 WRI  
 LEAY tmpStr
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string tmpStr
 PDST   ; Level 1
#srcline 69 ;                correspond := FIND(IN1 := fileMask, IN2 := tmpStr) = (posStar + 1);
 LEAX fileMask
#debug string fileMask
 LEAY tmpStr
#debug string tmpStr
 SFND 
 LDY  posStar
#debug int posStar
 EXTW 
 LD   int 1
 ADD
 EXTW
 EQ
 WRY  correspond
#debug_left bool correspond
#srcline 70 ;              END_IF;
DeleteOldFiles_L17:
#srcline 71 ;            END_IF;
DeleteOldFiles_L15:
#srcline 72 ;          END_IF;
DeleteOldFiles_L14:
#srcline 73 ;        END_IF;
DeleteOldFiles_L10:
#srcline 74 ;      ELSE   // maska neobsahuje '*' => nazev souboru musi presne odpovidat masce
 JMP  DeleteOldFiles_L8
DeleteOldFiles_L7:
#srcline 75 ;        correspond := ListDir.fileInfo.fileName = fileMask;
 LEAX ListDir
 ADD  107  ; + offset 
#debug string ListDir.fileInfo.fileName
 LEAX fileMask
#debug string fileMask
 SCMP 
 EQ   0
 WRY  correspond
#debug_left bool correspond
#srcline 76 ;      END_IF;
DeleteOldFiles_L8:
#srcline 77 ;    END_IF;
DeleteOldFiles_L6:
#srcline 78 ;    IF correspond THEN
 LDY  correspond
#debug bool correspond
 JMC  DeleteOldFiles_L19
#srcline 79 ;      fileDays := LREAL_TO_UDINT( (DT_TO_LREAL( actDate) - DT_TO_LREAL( ListDir.fileInfo.modifyTime)) / 86400.0);
 LDX  actDate
#debug dt actDate
 LDX  ListDir~fileInfo~modifyTime
#debug dt ListDir.fileInfo.modifyTime
 SUDF
 LDQ  lreal 86400.0
 DIDF
 RNDD
 UDFL
 WRX  fileDays
#debug_left udint fileDays
#srcline 80 ;      IF fileDays >= lifeTime THEN
 LDX  fileDays
#debug udint fileDays
 LDX  lifeTime
#debug udint lifeTime
 LT
 NEG
 JMC  DeleteOldFiles_L21
#srcline 81 ;        fileInfo := ListDir.fileInfo;
 LEAX ListDir~fileInfo
#debug pointer ListDir.fileInfo
 SRC  %IB0
 LEAX fileInfo
#debug_left pointer fileInfo
 LD   266   ;SizeOf() 
 MOV  %IB0
#srcline 82 ;        IF testOnly THEN
 LDX  testOnly
#debug bool testOnly
 JMC  DeleteOldFiles_L23
#srcline 83 ;          isDeleted := 1;            // simulace vymazani
 LD   bool -1      ; true
 WRX  isDeleted
#debug_left bool isDeleted
#srcline 84 ;        ELSE
 JMP  DeleteOldFiles_L24
DeleteOldFiles_L23:
#srcline 85 ;          tmpStr := fileInfo.pathName + fileInfo.fileName;
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LEAX fileInfo
 ADD  105  ; + offset 
#debug string fileInfo.pathName
 SCON 
 LEAX fileInfo
 ADD  24  ; + offset 
#debug string fileInfo.fileName
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAY tmpStr
 WRI  
 LEAY tmpStr
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string tmpStr
 PDST   ; Level 1
#srcline 86 ;          IF FileDelete( fileName := tmpStr) THEN
 NXT
 LEAY tmpStr
 WR   __Instance__FileDelete~fileName
#debug_left pointer __Instance__FileDelete.fileName
 PRV
 LEA  __Instance__FileDelete
 CAL  FileDelete_L0
 JMC  DeleteOldFiles_L25
#srcline 87 ;            isDeleted := 1;          // smazano
 LD   bool -1      ; true
 WRX  isDeleted
#debug_left bool isDeleted
#srcline 88 ;          END_IF;
DeleteOldFiles_L25:
#srcline 89 ;        END_IF;
DeleteOldFiles_L24:
#srcline 90 ;      END_IF;
DeleteOldFiles_L21:
#srcline 91 ;    END_IF;
DeleteOldFiles_L19:
#srcline 93 ;  ELSIF ListDir.isDirEmpty THEN      // adresar je prazdny
 JMP  DeleteOldFiles_L4
DeleteOldFiles_L3:
 LDX  ListDir~isDirEmpty
#debug bool ListDir.isDirEmpty
 JMC  DeleteOldFiles_L27
#srcline 94 ;    IF delEmptyDir THEN              // mazat prazdne adresare
 LDX  delEmptyDir
#debug bool delEmptyDir
 JMC  DeleteOldFiles_L28
#srcline 95 ;      fileInfo := ListDir.fileInfo;
 LEAX ListDir~fileInfo
#debug pointer ListDir.fileInfo
 SRC  %IB0
 LEAX fileInfo
#debug_left pointer fileInfo
 LD   266   ;SizeOf() 
 MOV  %IB0
#srcline 96 ;      IF testOnly THEN
 LDX  testOnly
#debug bool testOnly
 JMC  DeleteOldFiles_L30
#srcline 97 ;        isDeleted := 1;              // simulace vymazani
 LD   bool -1      ; true
 WRX  isDeleted
#debug_left bool isDeleted
#srcline 98 ;      ELSE
 JMP  DeleteOldFiles_L31
DeleteOldFiles_L30:
#srcline 99 ;        tmpStr := fileInfo.pathName + fileInfo.fileName;
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LEAX fileInfo
 ADD  105  ; + offset 
#debug string fileInfo.pathName
 SCON 
 LEAX fileInfo
 ADD  24  ; + offset 
#debug string fileInfo.fileName
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAY tmpStr
 WRI  
 LEAY tmpStr
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string tmpStr
 PDST   ; Level 1
#srcline 100 ;        IF DirDelete(dirName := tmpStr) THEN
 NXT
 LEAY tmpStr
 WR   __Instance__DirDelete~dirName
#debug_left pointer __Instance__DirDelete.dirName
 PRV
 LEA  __Instance__DirDelete
 CAL  DirDelete_L0
 JMC  DeleteOldFiles_L32
#srcline 101 ;          isDeleted := 1;            // smazano
 LD   bool -1      ; true
 WRX  isDeleted
#debug_left bool isDeleted
#srcline 102 ;        END_IF;
DeleteOldFiles_L32:
#srcline 103 ;      END_IF;
DeleteOldFiles_L31:
#srcline 104 ;    END_IF;
DeleteOldFiles_L28:
#srcline 105 ;  END_IF;
 JMP  DeleteOldFiles_L4
DeleteOldFiles_L27:
DeleteOldFiles_L4:
#srcline 106 ;END_FUNCTION_BLOCK
 ULNK
RET
E     61

; Initialize - variables
P     61
DeleteOldFiles__InstanceInit__:
 LINK 0
 LEAX ListDir
 CAL  ListDirectories__InstanceInit__
 ULNK
RET
E     61
; End initialize - variables
#endpou 

#pou DeleteOldFilesLog
#srcline 109 ;FUNCTION_BLOCK DeleteOldFilesLog

#struct DeleteOldFilesLog__temp__
  uint i,
  usint fmode,
  uint P0__st__,
  string[257] PS0__st__,
  string[82] PS1__st__
#data byte _str_DeleteOldFilesLog_0 = 
  '%','T','D','D','.','M','M','.','Y','Y','Y','Y',' ','h','h',':','m','m',':','s',
  's','.','z','z','z',' ',' ','L','i','s','t',' ','o','f',' ','f','i','l','e','s',
  ' ','d','e','l','e','t','e','d',' ','f','r','o','m',' ','d','i','r','e','c','t',
  'o','r','y',':',' ',0
#data byte _str_DeleteOldFilesLog_1 = 
  $0D,$0A,0
#data byte _str_DeleteOldFilesLog_2 = 
  ' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',
  ' ',' ',' ',' ',' ','F','i','l','e','M','a','s','k',':',' ','"',0
#data byte _str_DeleteOldFilesLog_3 = 
  '"',' ','|',' ','L','i','f','e','T','i','m','e',':',' ','%','d',' ','[','d','a',
  'y','s',']',0
#data byte _str_DeleteOldFilesLog_4 = 
  ' ','|',' ','d','e','l','e','t','e',' ','e','m','p','t','y',' ','d','i','r',0
#data byte _str_DeleteOldFilesLog_5 = 
  ' ','|',' ','n','o',' ','s','u','b','d','i','r',0
#data byte _str_DeleteOldFilesLog_6 = 
  ' ','|',' ','t','e','s','t',' ','o','n','l','y',0
#data byte _str_DeleteOldFilesLog_7 = 
  $0D,$0A,$0D,$0A,0
#data byte _str_DeleteOldFilesLog_8 = 
  ' ',0
#data byte _str_DeleteOldFilesLog_9 = 
  ' ',' ',' ',' ',' ','D','I','R',$0D,$0A,0
#data byte _str_DeleteOldFilesLog_10 = 
  '%','8','d',0
#data byte _str_DeleteOldFilesLog_11 = 
  ' ',' ','%','T','D','D','.','M','M','.','Y','Y','Y','Y',0
#data byte _str_DeleteOldFilesLog_12 = 
  ' ',' ','%','T','h','h',':','m','m',':','s','s',$0D,$0A,0
#data byte _str_DeleteOldFilesLog_13 = 
  $0D,$0A,'T','o','t','a','l',' ','i','t','e','m','s',':',' ','%','d',',',' ',' ',0
#data byte _str_DeleteOldFilesLog_14 = 
  'T','o','t','a','l',' ','d','e','l','e','t','e','d',':',' ','%','d',',',' ',' ',0
#data byte _str_DeleteOldFilesLog_15 = 
  'P','r','o','c','e','s','s','i','n','g',' ','t','i','m','e',':',' ','%','T','s',
  '.','z','z','z',' ','[','s','e','c',']',$0D,$0A,'-','-','-',$0D,$0A,0
P     61
DeleteOldFilesLog_L0:
 LINK __SizeOf(DeleteOldFilesLog__temp__)
; Initialize - dynamic variables
; End initialize - dynamic variables
#srcline 140 ;  TrgBusy(CLK := fbDeleteOldFiles.busy);
 LDX  fbDeleteOldFiles
 ADD  167  ; + offset 
 MUL  8   ; -> bool pointer 
 ADD  1   ; Bool offset 
 LDIB 
#debug bool fbDeleteOldFiles.busy
 WRX  TrgBusy~CLK
#debug_left bool TrgBusy~CLK
 LEAX TrgBusy
 CAL  R_TRIG_L0
#srcline 141 ;  IF TrgBusy.Q THEN                     // pruzkum adresare zahajen
 LDX  TrgBusy~Q
#debug bool TrgBusy.Q
 JMC  DeleteOldFilesLog_L1
#srcline 142 ;    cnt := 0; deletedSpace := 0;
 LD   uint 0
 WRX  cnt
#debug_left uint cnt
 LD   udint 0
 WRX  deletedSpace
#debug_left udint deletedSpace
#srcline 143 ;    startDT := GetDateTime();
 LEA  __Instance__GetDateTime
 CAL  GetDateTime_L0
 WRX  startDT
#debug_left dt startDT
#srcline 144 ;    IF hf <> INVALID_HANDLE_VALUE THEN
 LDX  hf
#debug udint hf
 LD   udint 0
 EQ
 NEG
 JMC  DeleteOldFilesLog_L3
#srcline 145 ;      FileClose(hFile := hf); hf := INVALID_HANDLE_VALUE;  // pro jistotu
 NXT
 LDX  hf
#debug udint hf
 WR   __Instance__FileClose~hFile
#debug_left udint __Instance__FileClose~hFile
 PRV
 LEA  __Instance__FileClose
 CAL  FileClose_L0
 LD   udint 0
 WRX  hf
#debug_left udint hf
#srcline 146 ;    END_IF;
DeleteOldFilesLog_L3:
#srcline 147 ;    IF append THEN fmode := F_APPEND; ELSE fmode := F_WRITE; END_IF;
 LDX  append
#debug bool append
 JMC  DeleteOldFilesLog_L5
 LD   udint 2  ; TF_MODE#F_APPEND
 WRY  fmode
#debug_left usint fmode
 JMP  DeleteOldFilesLog_L6
DeleteOldFilesLog_L5:
 LD   udint 1  ; TF_MODE#F_WRITE
 WRY  fmode
#debug_left usint fmode
DeleteOldFilesLog_L6:
#srcline 148 ;    hf := FileOpen( mode := fmode, fileName := logName);
 NXT
 LDY  fmode
#debug usint fmode
 WR   __Instance__FileOpen~mode
#debug_left usint __Instance__FileOpen~mode
 LEAX logName
 WR   __Instance__FileOpen~fileName
#debug_left pointer __Instance__FileOpen.fileName
 PRV
 LEA  __Instance__FileOpen
 CAL  FileOpen_L0
 WRX  hf
#debug_left udint hf
#srcline 149 ;    line := DT_TO_STRINGF( startDT, '%TDD.MM.YYYY$A0hh:mm:ss.zzz  List of files deleted from directory: ') + fbDeleteOldFiles.dirName + '$0D$0A';
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 NXT
 LDX  startDT
#debug dt startDT
 WR   __Instance__DT_TO_STRINGF~in
#debug_left dt __Instance__DT_TO_STRINGF~in
 LD   0   ; null string
 LEA  __Instance__DT_TO_STRINGF~format
 WRI 
 LEA  __Instance__DT_TO_STRINGF~format
 LD   80
 DST    ; Level 2
 LEA  _str_DeleteOldFilesLog_0
 SCON 
#debug_left string __Instance__DT_TO_STRINGF~format
 PDST   ; Level 2
 PRV
 LEA  __Instance__DT_TO_STRINGF
 CAL  DT_TO_STRINGF_L0

 SCON 
 LDX  fbDeleteOldFiles
 ADD  1  ; + offset 
#debug string fbDeleteOldFiles.dirName
 SCON 
 LEA  _str_DeleteOldFilesLog_1
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX line
 WRI  
 LEAX line
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string line
 PDST   ; Level 1
#srcline 150 ;    FileWrite( hFile := hf, adrBuf := PTR_TO_UDINT( ADR( line)), size := LEN(line));
 NXT
 LDX  hf
#debug udint hf
 WR   __Instance__FileWrite~hFile
#debug_left udint __Instance__FileWrite~hFile
 LEAX line
#debug pointer line
 WR   __Instance__FileWrite~adrBuf
#debug_left udint __Instance__FileWrite~adrBuf
 LEAX line
#debug string line
 SLEN 
 WR   __Instance__FileWrite~size
#debug_left udint __Instance__FileWrite~size
 PRV
 LEA  __Instance__FileWrite
 CAL  FileWrite_L0
#srcline 151 ;    line := '                         FileMask: "' + fbDeleteOldFiles.fileMask + UDINT_TO_STRINGF( fbDeleteOldFiles.lifeTime, '" | LifeTime: %d [days]');
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LEA  _str_DeleteOldFilesLog_2
 SCON 
 LDX  fbDeleteOldFiles
 ADD  82  ; + offset 
#debug string fbDeleteOldFiles.fileMask
 SCON 
 NXT
 LDX  fbDeleteOldFiles
 ADD  163  ; + offset 
 LDIL 
#debug udint fbDeleteOldFiles.lifeTime
 WR   __Instance__UDINT_TO_STRINGF~in
#debug_left udint __Instance__UDINT_TO_STRINGF~in
 LD   0   ; null string
 LEA  __Instance__UDINT_TO_STRINGF~format
 WRI 
 LEA  __Instance__UDINT_TO_STRINGF~format
 LD   80
 DST    ; Level 2
 LEA  _str_DeleteOldFilesLog_3
 SCON 
#debug_left string __Instance__UDINT_TO_STRINGF~format
 PDST   ; Level 2
 PRV
 LEA  __Instance__UDINT_TO_STRINGF
 CAL  UDINT_TO_STRINGF_L0

 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX line
 WRI  
 LEAX line
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string line
 PDST   ; Level 1
#srcline 152 ;    IF fbDeleteOldFiles.delEmptyDir THEN
 LDX  fbDeleteOldFiles
 MUL  8   ; -> bool pointer 
 ADD  1   ; Bool offset 
 LDIB 
#debug bool fbDeleteOldFiles.delEmptyDir
 JMC  DeleteOldFilesLog_L7
#srcline 153 ;      line := line + ' | delete empty dir';
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LEAX line
#debug string line
 SCON 
 LEA  _str_DeleteOldFilesLog_4
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX line
 WRI  
 LEAX line
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string line
 PDST   ; Level 1
#srcline 154 ;    END_IF;
DeleteOldFilesLog_L7:
#srcline 155 ;    IF fbDeleteOldFiles.noSubDir THEN
 LDX  fbDeleteOldFiles
 MUL  8   ; -> bool pointer 
 ADD  2   ; Bool offset 
 LDIB 
#debug bool fbDeleteOldFiles.noSubDir
 JMC  DeleteOldFilesLog_L9
#srcline 156 ;      line := line + ' | no subdir';
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LEAX line
#debug string line
 SCON 
 LEA  _str_DeleteOldFilesLog_5
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX line
 WRI  
 LEAX line
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string line
 PDST   ; Level 1
#srcline 157 ;    END_IF;
DeleteOldFilesLog_L9:
#srcline 158 ;    IF fbDeleteOldFiles.testOnly THEN
 LDX  fbDeleteOldFiles
 MUL  8   ; -> bool pointer 
 ADD  3   ; Bool offset 
 LDIB 
#debug bool fbDeleteOldFiles.testOnly
 JMC  DeleteOldFilesLog_L11
#srcline 159 ;      line := line + ' | test only';
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LEAX line
#debug string line
 SCON 
 LEA  _str_DeleteOldFilesLog_6
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX line
 WRI  
 LEAX line
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string line
 PDST   ; Level 1
#srcline 160 ;    END_IF;
DeleteOldFilesLog_L11:
#srcline 161 ;    line := line + '$0D$0A$0D$0A';
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LEAX line
#debug string line
 SCON 
 LEA  _str_DeleteOldFilesLog_7
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX line
 WRI  
 LEAX line
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string line
 PDST   ; Level 1
#srcline 162 ;    FileWrite( hFile := hf, adrBuf := PTR_TO_UDINT( ADR( line)), size := LEN(line));
 NXT
 LDX  hf
#debug udint hf
 WR   __Instance__FileWrite~hFile
#debug_left udint __Instance__FileWrite~hFile
 LEAX line
#debug pointer line
 WR   __Instance__FileWrite~adrBuf
#debug_left udint __Instance__FileWrite~adrBuf
 LEAX line
#debug string line
 SLEN 
 WR   __Instance__FileWrite~size
#debug_left udint __Instance__FileWrite~size
 PRV
 LEA  __Instance__FileWrite
 CAL  FileWrite_L0
#srcline 163 ;  END_IF;
DeleteOldFilesLog_L1:
#srcline 165 ;  IF fbDeleteOldFiles.isDeleted THEN             // smazana polozka v adresari
 LDX  fbDeleteOldFiles
 ADD  167  ; + offset 
 MUL  8   ; -> bool pointer 
 ADD  3   ; Bool offset 
 LDIB 
#debug bool fbDeleteOldFiles.isDeleted
 JMC  DeleteOldFilesLog_L13
#srcline 166 ;    cnt := cnt + 1;
 LDX  cnt
#debug uint cnt
 LD   uint 1
 ADD
 AND  $FFFF
 WRX  cnt
#debug_left uint cnt
#srcline 167 ;    line := fbDeleteOldFiles.fileInfo.pathName + fbDeleteOldFiles.fileInfo.fileName;      // jmeno souboru/adresare
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LDX  fbDeleteOldFiles
 ADD  273  ; + offset 
#debug string fbDeleteOldFiles.fileInfo.pathName
 SCON 
 LDX  fbDeleteOldFiles
 ADD  192  ; + offset 
#debug string fbDeleteOldFiles.fileInfo.fileName
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX line
 WRI  
 LEAX line
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string line
 PDST   ; Level 1
#srcline 168 ;    FOR i := LEN(line) TO 40 DO
 LEAX line
#debug string line
 SLEN 
 WRY  i
 LD   uint 40
 WRY  P0__st__
DeleteOldFilesLog_L15:
 LDY  i
 LDY  P0__st__
 GT   
 JMD  DeleteOldFilesLog_L16
 DBG  
#srcline 169 ;      line := line + ' ';                      // doplnit mezery
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LEAX line
#debug string line
 SCON 
 LEA  _str_DeleteOldFilesLog_8
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX line
 WRI  
 LEAX line
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string line
 PDST   ; Level 1
#srcline 170 ;    END_FOR;
 LDY  i
 LD   1
 ADD  
 WRY  i
 JMP  DeleteOldFilesLog_L15
DeleteOldFilesLog_L16:
 NOP  -1
#srcline 171 ;    IF (fbDeleteOldFiles.fileInfo.attrib AND AM_DIR) <> 0 THEN
 LDX  fbDeleteOldFiles
 ADD  188  ; + offset 
 LDIL 
#debug dword fbDeleteOldFiles.fileInfo.attrib
 LD   dword 16
 AND
 LD   dword 0
 EQ
 NEG
 JMC  DeleteOldFilesLog_L17
#srcline 172 ;      line := line + '     DIR$0D$0A';
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LEAX line
#debug string line
 SCON 
 LEA  _str_DeleteOldFilesLog_9
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX line
 WRI  
 LEAX line
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string line
 PDST   ; Level 1
#srcline 173 ;    ELSE
 JMP  DeleteOldFilesLog_L18
DeleteOldFilesLog_L17:
#srcline 174 ;      line := line + UDINT_TO_STRINGF( fbDeleteOldFiles.fileInfo.fileSize, '%8d') +        // velikost souboru
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LEAX line
#debug string line
 SCON 
 NXT
 LDX  fbDeleteOldFiles
 ADD  184  ; + offset 
 LDIL 
#debug udint fbDeleteOldFiles.fileInfo.fileSize
 WR   __Instance__UDINT_TO_STRINGF~in
#debug_left udint __Instance__UDINT_TO_STRINGF~in
 LD   0   ; null string
 LEA  __Instance__UDINT_TO_STRINGF~format
 WRI 
 LEA  __Instance__UDINT_TO_STRINGF~format
 LD   80
 DST    ; Level 2
 LEA  _str_DeleteOldFilesLog_10
 SCON 
#debug_left string __Instance__UDINT_TO_STRINGF~format
 PDST   ; Level 2
 PRV
 LEA  __Instance__UDINT_TO_STRINGF
 CAL  UDINT_TO_STRINGF_L0

 SCON 
#srcline 175 ;              DT_TO_STRINGF( fbDeleteOldFiles.fileInfo.modifyTime, '  %TDD.MM.YYYY') +     // datum
 NXT
 LDX  fbDeleteOldFiles
 ADD  176  ; + offset 
 LDIQ 
#debug dt fbDeleteOldFiles.fileInfo.modifyTime
 WR   __Instance__DT_TO_STRINGF~in
#debug_left dt __Instance__DT_TO_STRINGF~in
 LD   0   ; null string
 LEA  __Instance__DT_TO_STRINGF~format
 WRI 
 LEA  __Instance__DT_TO_STRINGF~format
 LD   80
 DST    ; Level 2
 LEA  _str_DeleteOldFilesLog_11
 SCON 
#debug_left string __Instance__DT_TO_STRINGF~format
 PDST   ; Level 2
 PRV
 LEA  __Instance__DT_TO_STRINGF
 CAL  DT_TO_STRINGF_L0

 SCON 
#srcline 176 ;              DT_TO_STRINGF( fbDeleteOldFiles.fileInfo.modifyTime, '  %Thh:mm:ss$0D$0A');  // cas (posledni modifikace)
 NXT
 LDX  fbDeleteOldFiles
 ADD  176  ; + offset 
 LDIQ 
#debug dt fbDeleteOldFiles.fileInfo.modifyTime
 WR   __Instance__DT_TO_STRINGF~in
#debug_left dt __Instance__DT_TO_STRINGF~in
 LD   0   ; null string
 LEA  __Instance__DT_TO_STRINGF~format
 WRI 
 LEA  __Instance__DT_TO_STRINGF~format
 LD   80
 DST    ; Level 2
 LEA  _str_DeleteOldFilesLog_12
 SCON 
#debug_left string __Instance__DT_TO_STRINGF~format
 PDST   ; Level 2
 PRV
 LEA  __Instance__DT_TO_STRINGF
 CAL  DT_TO_STRINGF_L0

 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX line
 WRI  
 LEAX line
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string line
 PDST   ; Level 1
#srcline 177 ;    END_IF;
DeleteOldFilesLog_L18:
#srcline 178 ;    deletedSpace := deletedSpace + fbDeleteOldFiles.fileInfo.fileSize;
 LDX  deletedSpace
#debug udint deletedSpace
 LDX  fbDeleteOldFiles
 ADD  184  ; + offset 
 LDIL 
#debug udint fbDeleteOldFiles.fileInfo.fileSize
 ADD
 WRX  deletedSpace
#debug_left udint deletedSpace
#srcline 179 ;    FileWrite( hFile := hf, adrBuf := PTR_TO_UDINT( ADR( line)), size := LEN(line));
 NXT
 LDX  hf
#debug udint hf
 WR   __Instance__FileWrite~hFile
#debug_left udint __Instance__FileWrite~hFile
 LEAX line
#debug pointer line
 WR   __Instance__FileWrite~adrBuf
#debug_left udint __Instance__FileWrite~adrBuf
 LEAX line
#debug string line
 SLEN 
 WR   __Instance__FileWrite~size
#debug_left udint __Instance__FileWrite~size
 PRV
 LEA  __Instance__FileWrite
 CAL  FileWrite_L0
#srcline 180 ;  END_IF;
DeleteOldFilesLog_L13:
#srcline 182 ;  IF (hf <> INVALID_HANDLE_VALUE) AND NOT fbDeleteOldFiles.busy THEN  // pruzkum adresare ukoncen
 LDX  hf
#debug udint hf
 LD   udint 0
 EQ
 NEG
 LDX  fbDeleteOldFiles
 ADD  167  ; + offset 
 MUL  8   ; -> bool pointer 
 ADD  1   ; Bool offset 
 LDIB 
#debug bool fbDeleteOldFiles.busy
 NEG
 AND
 JMC  DeleteOldFilesLog_L19
#srcline 183 ;    stopDT := GetDateTime();
 LEA  __Instance__GetDateTime
 CAL  GetDateTime_L0
 WRX  stopDT
#debug_left dt stopDT
#srcline 184 ;    line := UINT_TO_STRINGF( cnt, '$0D$0ATotal items: %d,  ') +
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 NXT
 LDX  cnt
#debug uint cnt
 WR   __Instance__UINT_TO_STRINGF~in
#debug_left uint __Instance__UINT_TO_STRINGF~in
 LD   0   ; null string
 LEA  __Instance__UINT_TO_STRINGF~format
 WRI 
 LEA  __Instance__UINT_TO_STRINGF~format
 LD   80
 DST    ; Level 2
 LEA  _str_DeleteOldFilesLog_13
 SCON 
#debug_left string __Instance__UINT_TO_STRINGF~format
 PDST   ; Level 2
 PRV
 LEA  __Instance__UINT_TO_STRINGF
 CAL  UINT_TO_STRINGF_L0

 SCON 
#srcline 185 ;            UDINT_TO_STRINGF( deletedSpace, 'Total deleted: %d,  ') +
 NXT
 LDX  deletedSpace
#debug udint deletedSpace
 WR   __Instance__UDINT_TO_STRINGF~in
#debug_left udint __Instance__UDINT_TO_STRINGF~in
 LD   0   ; null string
 LEA  __Instance__UDINT_TO_STRINGF~format
 WRI 
 LEA  __Instance__UDINT_TO_STRINGF~format
 LD   80
 DST    ; Level 2
 LEA  _str_DeleteOldFilesLog_14
 SCON 
#debug_left string __Instance__UDINT_TO_STRINGF~format
 PDST   ; Level 2
 PRV
 LEA  __Instance__UDINT_TO_STRINGF
 CAL  UDINT_TO_STRINGF_L0

 SCON 
#srcline 186 ;            TIME_TO_STRINGF( SUB_DT_DT( stopDT, startDT), 'Processing time: %Ts.zzz [sec]$0D$0A---$0D$0A');
 NXT
 NXT
 LDX  stopDT
#debug dt stopDT
 WR   __Instance__SUB_DT_DT~IN1
#debug_left dt __Instance__SUB_DT_DT~IN1
 LDX  startDT
#debug dt startDT
 WR   __Instance__SUB_DT_DT~IN2
#debug_left dt __Instance__SUB_DT_DT~IN2
 PRV
 LEA  __Instance__SUB_DT_DT
 CAL  SUB_DT_DT_L0
 WR   __Instance__TIME_TO_STRINGF~in
#debug_left time __Instance__TIME_TO_STRINGF~in
 LD   0   ; null string
 LEA  __Instance__TIME_TO_STRINGF~format
 WRI 
 LEA  __Instance__TIME_TO_STRINGF~format
 LD   80
 DST    ; Level 2
 LEA  _str_DeleteOldFilesLog_15
 SCON 
#debug_left string __Instance__TIME_TO_STRINGF~format
 PDST   ; Level 2
 PRV
 LEA  __Instance__TIME_TO_STRINGF
 CAL  TIME_TO_STRINGF_L0

 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX line
 WRI  
 LEAX line
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string line
 PDST   ; Level 1
#srcline 187 ;    FileWrite( hFile := hf, adrBuf := PTR_TO_UDINT( ADR( line)), size := LEN(line));
 NXT
 LDX  hf
#debug udint hf
 WR   __Instance__FileWrite~hFile
#debug_left udint __Instance__FileWrite~hFile
 LEAX line
#debug pointer line
 WR   __Instance__FileWrite~adrBuf
#debug_left udint __Instance__FileWrite~adrBuf
 LEAX line
#debug string line
 SLEN 
 WR   __Instance__FileWrite~size
#debug_left udint __Instance__FileWrite~size
 PRV
 LEA  __Instance__FileWrite
 CAL  FileWrite_L0
#srcline 188 ;    FileClose(hFile := hf); hf := INVALID_HANDLE_VALUE;
 NXT
 LDX  hf
#debug udint hf
 WR   __Instance__FileClose~hFile
#debug_left udint __Instance__FileClose~hFile
 PRV
 LEA  __Instance__FileClose
 CAL  FileClose_L0
 LD   udint 0
 WRX  hf
#debug_left udint hf
#srcline 189 ;  END_IF;
DeleteOldFilesLog_L19:
#srcline 190 ;END_FUNCTION_BLOCK
 ULNK
RET
E     61

; Initialize - variables
P     61
DeleteOldFilesLog__InstanceInit__:
 LINK 0
 ULNK
RET
E     61
; End initialize - variables
#endpou 



 

#srcfile ''
#srcfile 'C:\TECOLIBSRC\FILELIB\FILELIB\FBDELETESURPLUSFILES.ST'
#pou DeleteSurplusFiles
#srcline 1 ;FUNCTION_BLOCK DeleteSurplusFiles

#struct DeleteSurplusFiles__temp__
  bool correspond,
  int lenMask,
  int lenFileName,
  int posStar,
  string[256] tmpStr,
  string[257] PS0__st__
#data byte _str_DeleteSurplusFiles_0 = 
  '*',0
#data byte _str_DeleteSurplusFiles_1 = 
  '*',0
#data byte _str_DeleteSurplusFiles_2 = 
  '*',0
#data byte _str_DeleteSurplusFiles_3 = 
  '*',0
P     61
DeleteSurplusFiles_L0:
 LINK __SizeOf(DeleteSurplusFiles__temp__)
; Initialize - dynamic variables
; End initialize - dynamic variables
; R_EDGE, F_EDGE 
 LDX  exec
 LETX __EDGE_R__exec
 WRX  exec
#srcline 36 ;  TrgRqCheck( CLK := exec OR nextRound);                    // nabezna hrana pro kazde vyhledavaci kolo
 LDX  exec
#debug bool exec
 LDX  nextRound
#debug bool nextRound
 OR  
 WRX  TrgRqCheck~CLK
#debug_left bool TrgRqCheck~CLK
 LEAX TrgRqCheck
 CAL  R_TRIG_L0
#srcline 37 ;  IF TrgRqCheck.Q THEN                                      // inicializace
 LDX  TrgRqCheck~Q
#debug bool TrgRqCheck.Q
 JMC  DeleteSurplusFiles_L1
#srcline 38 ;    Memset( val := 0, length := sizeof( oldestFile), dest := void( oldestFile));
 NXT
 LD   udint 0
 WR   __Instance__Memset~val
#debug_left udint __Instance__Memset~val
 LD   266  ; SizeOf()
 WR   __Instance__Memset~length
#debug_left uint __Instance__Memset~length
 LEAX oldestFile
 WR   __Instance__Memset~dest
#debug_left pointer __Instance__Memset.dest
 PRV
 LEA  __Instance__Memset
 CAL  Memset_L0
#srcline 39 ;    oldestFile.modifyTime := DT#2099-01-01-00:00:00.0;
 LDQ  dt 4070908800
 WRX  oldestFile~modifyTime
#debug_left dt oldestFile.modifyTime
#srcline 40 ;    usedSpace := 0;
 LD   udint 0
 WRX  usedSpace
#debug_left udint usedSpace
#srcline 41 ;  END_IF;
DeleteSurplusFiles_L1:
#srcline 43 ;  isDeleted := 0;
 LD   bool 0       ; false
 WRX  isDeleted
#debug_left bool isDeleted
#srcline 44 ;  ListDir( exec := exec OR nextRound, noSubDir := noSubDir, dirName := dirName, done => done, busy => busy, err => err);
 LDX  exec
#debug bool exec
 LDX  nextRound
#debug bool nextRound
 OR  
 WRX  ListDir~exec
#debug_left bool ListDir~exec
 LDX  noSubDir
#debug bool noSubDir
 WRX  ListDir~noSubDir
#debug_left bool ListDir~noSubDir
 LD   0   ; null string
 LEAX ListDir~dirName
 WRI 
 LEAX ListDir~dirName
 LD   80
 DST    ; Level 1
 LEAX dirName
#debug string dirName
 SCON 
#debug_left string ListDir~dirName
 PDST   ; Level 1
 LEAX ListDir
 CAL  ListDirectories_L0
; output assigment 
 LDX  ListDir~done
#debug bool ListDir~done
 WRX  done
#debug_left bool done
 LDX  ListDir~busy
#debug bool ListDir~busy
 WRX  busy
#debug_left bool busy
 LDX  ListDir~err
#debug bool ListDir~err
 WRX  err
#debug_left bool err
#srcline 45 ;  IF ListDir.busy OR ListDir.done THEN
 LDX  ListDir~busy
#debug bool ListDir.busy
 LDX  ListDir~done
#debug bool ListDir.done
 OR  
 JMC  DeleteSurplusFiles_L3
#srcline 46 ;    Memset(val := 0, length := sizeof( fileInfo), dest := void( fileInfo)); nextRound := 0;
 NXT
 LD   udint 0
 WR   __Instance__Memset~val
#debug_left udint __Instance__Memset~val
 LD   266  ; SizeOf()
 WR   __Instance__Memset~length
#debug_left uint __Instance__Memset~length
 LEAX fileInfo
 WR   __Instance__Memset~dest
#debug_left pointer __Instance__Memset.dest
 PRV
 LEA  __Instance__Memset
 CAL  Memset_L0
 LD   bool 0       ; false
 WRX  nextRound
#debug_left bool nextRound
#srcline 47 ;  END_IF;
DeleteSurplusFiles_L3:
#srcline 49 ;  // spocitat obsazene misto a najit nejstarsi soubor
#srcline 50 ;  IF ListDir.found THEN                                     // nalezena polozka v adresari
 LDX  ListDir~found
#debug bool ListDir.found
 JMC  DeleteSurplusFiles_L5
#srcline 51 ;    IF NOT ListDir.isDir THEN                               // nalezena polozka je soubor
 LDX  ListDir~isDir
#debug bool ListDir.isDir
 NEG
 JMC  DeleteSurplusFiles_L7
#srcline 52 ;      usedSpace := usedSpace + ListDir.fileInfo.fileSize;   // pocitat obsazene misto
 LDX  usedSpace
#debug udint usedSpace
 LDX  ListDir~fileInfo~fileSize
#debug udint ListDir.fileInfo.fileSize
 ADD
 WRX  usedSpace
#debug_left udint usedSpace
#srcline 54 ;      IF fileMask = '*' THEN   // vsechny soubory (maska obsahuje pouze '*')
 LEAX fileMask
#debug string fileMask
 LEA  _str_DeleteSurplusFiles_0
 SCMP 
 EQ   0
 JMC  DeleteSurplusFiles_L9
#srcline 55 ;        correspond := 1;
 LD   bool -1      ; true
 WRY  correspond
#debug_left bool correspond
#srcline 56 ;      ELSE
 JMP  DeleteSurplusFiles_L10
DeleteSurplusFiles_L9:
#srcline 57 ;        correspond := 0;
 LD   bool 0       ; false
 WRY  correspond
#debug_left bool correspond
#srcline 58 ;        posStar := FIND(IN1 := fileMask, IN2 := '*');
 LEAX fileMask
#debug string fileMask
 LEA  _str_DeleteSurplusFiles_1
 SFND 
 WRY  posStar
#debug_left int posStar
#srcline 59 ;        IF posStar <> 0 THEN   // maska obsahuje '*'
 LDY  posStar
#debug int posStar
 EXTW 
 LD   int 0
 EQ
 NEG
 JMC  DeleteSurplusFiles_L11
#srcline 60 ;          lenMask := LEN( fileMask);
 LEAX fileMask
#debug string fileMask
 SLEN 
 WRY  lenMask
#debug_left int lenMask
#srcline 61 ;          lenFileName := LEN(ListDir.fileInfo.fileName);
 LEAX ListDir
 ADD  107  ; + offset 
#debug string ListDir.fileInfo.fileName
 SLEN 
 WRY  lenFileName
#debug_left int lenFileName
#srcline 62 ;          IF posStar = 1 THEN  // '*' v masce je na zacatku => konec nazvu souboru musi odpovidat masce
 LDY  posStar
#debug int posStar
 EXTW 
 LD   int 1
 EQ
 JMC  DeleteSurplusFiles_L13
#srcline 63 ;            IF lenFileName > (lenMask - 2) THEN
 LDY  lenFileName
#debug int lenFileName
 EXTW 
 LDY  lenMask
#debug int lenMask
 EXTW 
 LD   int 2
 SUB
 EXTW
 GTS
 JMC  DeleteSurplusFiles_L15
#srcline 64 ;              tmpStr := '*' + MID( IN := ListDir.fileInfo.fileName, L := 80, P := lenFileName - (lenMask - 2));
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LEA  _str_DeleteSurplusFiles_2
 SCON 
 LEAX ListDir
 ADD  107  ; + offset 
#debug string ListDir.fileInfo.fileName
 LD   80
 LDY  lenFileName
#debug int lenFileName
 EXTW 
 LDY  lenMask
#debug int lenMask
 EXTW 
 LD   int 2
 SUB
 EXTW
 SUB
 EXTW
 SUB  1
 SMID 
 PDST   ; Level 1
 LD   0   ; null string
 LEAY tmpStr
 WRI  
 LEAY tmpStr
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string tmpStr
 PDST   ; Level 1
#srcline 65 ;              correspond := tmpStr = fileMask;
 LEAY tmpStr
#debug string tmpStr
 LEAX fileMask
#debug string fileMask
 SCMP 
 EQ   0
 WRY  correspond
#debug_left bool correspond
#srcline 66 ;            END_IF;
DeleteSurplusFiles_L15:
#srcline 67 ;          ELSE  // '*' v masce neni na zacatku
 JMP  DeleteSurplusFiles_L14
DeleteSurplusFiles_L13:
#srcline 68 ;            IF posStar = lenMask THEN  // '*' je na konci
 LDY  posStar
#debug int posStar
 EXTW 
 LDY  lenMask
#debug int lenMask
 EXTW 
 EQ
 JMC  DeleteSurplusFiles_L17
#srcline 69 ;              tmpStr := LEFT(IN := ListDir.fileInfo.fileName, L := lenMask-1) + '*';
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LEAX ListDir
 ADD  107  ; + offset 
#debug string ListDir.fileInfo.fileName
 LDY  lenMask
#debug int lenMask
 EXTW 
 LD   int 1
 SUB
 EXTW
 SLFT 
 LEA  _str_DeleteSurplusFiles_3
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAY tmpStr
 WRI  
 LEAY tmpStr
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string tmpStr
 PDST   ; Level 1
#srcline 70 ;              correspond := tmpStr = fileMask;
 LEAY tmpStr
#debug string tmpStr
 LEAX fileMask
#debug string fileMask
 SCMP 
 EQ   0
 WRY  correspond
#debug_left bool correspond
#srcline 71 ;            ELSE  // '*' v masce je uprostred
 JMP  DeleteSurplusFiles_L18
DeleteSurplusFiles_L17:
#srcline 72 ;              IF lenFileName > (posStar - 2) THEN
 LDY  lenFileName
#debug int lenFileName
 EXTW 
 LDY  posStar
#debug int posStar
 EXTW 
 LD   int 2
 SUB
 EXTW
 GTS
 JMC  DeleteSurplusFiles_L19
#srcline 73 ;                tmpStr := LEFT(IN := ListDir.fileInfo.fileName, L := posStar - 1);
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LEAX ListDir
 ADD  107  ; + offset 
#debug string ListDir.fileInfo.fileName
 LDY  posStar
#debug int posStar
 EXTW 
 LD   int 1
 SUB
 EXTW
 SLFT 
 PDST   ; Level 1
 LD   0   ; null string
 LEAY tmpStr
 WRI  
 LEAY tmpStr
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string tmpStr
 PDST   ; Level 1
#srcline 74 ;                correspond := FIND(IN1 := fileMask, IN2 := tmpStr) = 1;
 LEAX fileMask
#debug string fileMask
 LEAY tmpStr
#debug string tmpStr
 SFND 
 LD   int 1
 EQ
 WRY  correspond
#debug_left bool correspond
#srcline 75 ;                IF correspond THEN
 LDY  correspond
#debug bool correspond
 JMC  DeleteSurplusFiles_L21
#srcline 76 ;                  tmpStr := MID( IN := ListDir.fileInfo.fileName, L := 80, P := lenFileName - (posStar - 2));
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LEAX ListDir
 ADD  107  ; + offset 
#debug string ListDir.fileInfo.fileName
 LD   80
 LDY  lenFileName
#debug int lenFileName
 EXTW 
 LDY  posStar
#debug int posStar
 EXTW 
 LD   int 2
 SUB
 EXTW
 SUB
 EXTW
 SUB  1
 SMID 
 PDST   ; Level 1
 LD   0   ; null string
 LEAY tmpStr
 WRI  
 LEAY tmpStr
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string tmpStr
 PDST   ; Level 1
#srcline 77 ;                  correspond := FIND(IN1 := fileMask, IN2 := tmpStr) = (posStar + 1);
 LEAX fileMask
#debug string fileMask
 LEAY tmpStr
#debug string tmpStr
 SFND 
 LDY  posStar
#debug int posStar
 EXTW 
 LD   int 1
 ADD
 EXTW
 EQ
 WRY  correspond
#debug_left bool correspond
#srcline 78 ;                END_IF;
DeleteSurplusFiles_L21:
#srcline 79 ;              END_IF;
DeleteSurplusFiles_L19:
#srcline 80 ;            END_IF;
DeleteSurplusFiles_L18:
#srcline 81 ;          END_IF;
DeleteSurplusFiles_L14:
#srcline 82 ;        ELSE   // maska neobsahuje '*' => nazev souboru musi presne odpovidat masce
 JMP  DeleteSurplusFiles_L12
DeleteSurplusFiles_L11:
#srcline 83 ;          correspond := ListDir.fileInfo.fileName = fileMask;
 LEAX ListDir
 ADD  107  ; + offset 
#debug string ListDir.fileInfo.fileName
 LEAX fileMask
#debug string fileMask
 SCMP 
 EQ   0
 WRY  correspond
#debug_left bool correspond
#srcline 84 ;        END_IF;
DeleteSurplusFiles_L12:
#srcline 85 ;      END_IF;
DeleteSurplusFiles_L10:
#srcline 87 ;      IF correspond THEN
 LDY  correspond
#debug bool correspond
 JMC  DeleteSurplusFiles_L23
#srcline 88 ;        IF oldestFile.modifyTime > ListDir.fileInfo.modifyTime THEN  // nalezen jeste starsi soubor
 LDX  oldestFile~modifyTime
#debug dt oldestFile.modifyTime
 LDX  ListDir~fileInfo~modifyTime
#debug dt ListDir.fileInfo.modifyTime
 GTDF
 JMC  DeleteSurplusFiles_L25
#srcline 89 ;          oldestFile := ListDir.fileInfo;                     // zapamatovat si ho
 LEAX ListDir~fileInfo
#debug pointer ListDir.fileInfo
 SRC  %IB0
 LEAX oldestFile
#debug_left pointer oldestFile
 LD   266   ;SizeOf() 
 MOV  %IB0
#srcline 90 ;        END_IF;
DeleteSurplusFiles_L25:
#srcline 91 ;      END_IF;
DeleteSurplusFiles_L23:
#srcline 92 ;    END_IF;
DeleteSurplusFiles_L7:
#srcline 93 ;  ELSE
 JMP  DeleteSurplusFiles_L6
DeleteSurplusFiles_L5:
#srcline 94 ;    IF ListDir.busy THEN                                    // probiha listovani v adresarich
 LDX  ListDir~busy
#debug bool ListDir.busy
 JMC  DeleteSurplusFiles_L27
#srcline 95 ;      IF ListDir.isDirEmpty THEN                            // nalezen prazdny adresar
 LDX  ListDir~isDirEmpty
#debug bool ListDir.isDirEmpty
 JMC  DeleteSurplusFiles_L29
#srcline 96 ;        IF delEmptyDir THEN                                 // a mazeme prazdne adresare
 LDX  delEmptyDir
#debug bool delEmptyDir
 JMC  DeleteSurplusFiles_L31
#srcline 97 ;          tmpStr := ListDir.fileInfo.pathName + ListDir.fileInfo.fileName;
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LEAX ListDir
 ADD  188  ; + offset 
#debug string ListDir.fileInfo.pathName
 SCON 
 LEAX ListDir
 ADD  107  ; + offset 
#debug string ListDir.fileInfo.fileName
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAY tmpStr
 WRI  
 LEAY tmpStr
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string tmpStr
 PDST   ; Level 1
#srcline 98 ;          IF DirDelete(dirName := tmpStr) THEN              // smazat
 NXT
 LEAY tmpStr
 WR   __Instance__DirDelete~dirName
#debug_left pointer __Instance__DirDelete.dirName
 PRV
 LEA  __Instance__DirDelete
 CAL  DirDelete_L0
 JMC  DeleteSurplusFiles_L33
#srcline 99 ;            isDeleted := 1;
 LD   bool -1      ; true
 WRX  isDeleted
#debug_left bool isDeleted
#srcline 100 ;            fileInfo := ListDir.fileInfo;
 LEAX ListDir~fileInfo
#debug pointer ListDir.fileInfo
 SRC  %IB0
 LEAX fileInfo
#debug_left pointer fileInfo
 LD   266   ;SizeOf() 
 MOV  %IB0
#srcline 101 ;          END_IF;
DeleteSurplusFiles_L33:
#srcline 102 ;        END_IF;
DeleteSurplusFiles_L31:
#srcline 103 ;      END_IF;
DeleteSurplusFiles_L29:
#srcline 104 ;    END_IF;
DeleteSurplusFiles_L27:
#srcline 105 ;  END_IF;
DeleteSurplusFiles_L6:
#srcline 107 ;  // zjistit jestli je obsazene misto vetsi nez povolene maximum, pokud ano tak vymazat nejstarsi soubor
#srcline 108 ;  IF ListDir.done OR ListDir.err THEN                       // konec listovani adresare
 LDX  ListDir~done
#debug bool ListDir.done
 LDX  ListDir~err
#debug bool ListDir.err
 OR  
 JMC  DeleteSurplusFiles_L35
#srcline 109 ;    TrgRqCheck( CLK := 0);
 LD   bool 0       ; false
 WRX  TrgRqCheck~CLK
#debug_left bool TrgRqCheck~CLK
 LEAX TrgRqCheck
 CAL  R_TRIG_L0
#srcline 110 ;    IF ListDir.done THEN                                    // vse dopadlo ok
 LDX  ListDir~done
#debug bool ListDir.done
 JMC  DeleteSurplusFiles_L37
#srcline 111 ;      IF usedSpace > maxSpace THEN                          // obsazene misto je prilis velke
 LDX  usedSpace
#debug udint usedSpace
 LDX  maxSpace
#debug udint maxSpace
 GT
 JMC  DeleteSurplusFiles_L39
#srcline 112 ;        tmpStr := oldestFile.pathName + oldestFile.fileName;
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LEAX oldestFile
 ADD  105  ; + offset 
#debug string oldestFile.pathName
 SCON 
 LEAX oldestFile
 ADD  24  ; + offset 
#debug string oldestFile.fileName
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAY tmpStr
 WRI  
 LEAY tmpStr
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string tmpStr
 PDST   ; Level 1
#srcline 113 ;        IF FileDelete( fileName := tmpStr) THEN             // smazat nejstarsi soubor
 NXT
 LEAY tmpStr
 WR   __Instance__FileDelete~fileName
#debug_left pointer __Instance__FileDelete.fileName
 PRV
 LEA  __Instance__FileDelete
 CAL  FileDelete_L0
 JMC  DeleteSurplusFiles_L41
#srcline 114 ;          isDeleted := 1;
 LD   bool -1      ; true
 WRX  isDeleted
#debug_left bool isDeleted
#srcline 115 ;          fileInfo := oldestFile;                           // zverejnime smazany soubor
 LEAX oldestFile
#debug pointer oldestFile
 SRC  %IB0
 LEAX fileInfo
#debug_left pointer fileInfo
 LD   266   ;SizeOf() 
 MOV  %IB0
#srcline 116 ;          usedSpace := usedSpace - fileInfo.fileSize;       // prepocitat obsazene misto
 LDX  usedSpace
#debug udint usedSpace
 LDX  fileInfo~fileSize
#debug udint fileInfo.fileSize
 SUB
 WRX  usedSpace
#debug_left udint usedSpace
#srcline 117 ;          IF usedSpace > maxSpace THEN                      // obsazene misto je stale prilis velke
 LDX  usedSpace
#debug udint usedSpace
 LDX  maxSpace
#debug udint maxSpace
 GT
 JMC  DeleteSurplusFiles_L43
#srcline 118 ;            ListDir( exec := 0);                            // najit dalsi soubor ke smazani
 LD   bool 0       ; false
 WRX  ListDir~exec
#debug_left bool ListDir~exec
 LEAX ListDir
 CAL  ListDirectories_L0
#srcline 119 ;            done := 0; busy := 1; nextRound := 1;           // pokracovat
 LD   bool 0       ; false
 WRX  done
#debug_left bool done
 LD   bool -1      ; true
 WRX  busy
#debug_left bool busy
 LD   bool -1      ; true
 WRX  nextRound
#debug_left bool nextRound
#srcline 120 ;          END_IF;
DeleteSurplusFiles_L43:
#srcline 121 ;        END_IF;
DeleteSurplusFiles_L41:
#srcline 122 ;      END_IF;
DeleteSurplusFiles_L39:
#srcline 123 ;    END_IF;
DeleteSurplusFiles_L37:
#srcline 124 ;  END_IF;
DeleteSurplusFiles_L35:
#srcline 125 ;END_FUNCTION_BLOCK
 ULNK
RET
E     61

; Initialize - variables
P     61
DeleteSurplusFiles__InstanceInit__:
 LINK 0
 LEAX ListDir
 CAL  ListDirectories__InstanceInit__
 ULNK
RET
E     61
; End initialize - variables
#endpou 

#pou DeleteSurplusFilesLog
#srcline 128 ;FUNCTION_BLOCK DeleteSurplusFilesLog

#struct DeleteSurplusFilesLog__temp__
  uint i,
  usint fmode,
  uint P0__st__,
  string[257] PS0__st__,
  string[82] PS1__st__
#data byte _str_DeleteSurplusFilesLog_0 = 
  '%','T','D','D','.','M','M','.','Y','Y','Y','Y',' ','h','h',':','m','m',':','s',
  's','.','z','z','z',' ',' ','L','i','s','t',' ','o','f',' ','f','i','l','e','s',
  ' ','d','e','l','e','t','e','d',' ','f','r','o','m',' ','d','i','r','e','c','t',
  'o','r','y',':',' ',0
#data byte _str_DeleteSurplusFilesLog_1 = 
  $0D,$0A,0
#data byte _str_DeleteSurplusFilesLog_2 = 
  ' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',
  ' ',' ',' ',' ',' ','F','i','l','e','M','a','s','k',':',' ','"',0
#data byte _str_DeleteSurplusFilesLog_3 = 
  '"',' ','|',' ','M','a','x','S','p','a','c','e',':',' ','%','d',' ','[','B',']',0
#data byte _str_DeleteSurplusFilesLog_4 = 
  ' ','|',' ','d','e','l','e','t','e',' ','e','m','p','t','y',' ','d','i','r',0
#data byte _str_DeleteSurplusFilesLog_5 = 
  ' ','|',' ','n','o',' ','s','u','b','d','i','r',0
#data byte _str_DeleteSurplusFilesLog_6 = 
  $0D,$0A,$0D,$0A,0
#data byte _str_DeleteSurplusFilesLog_7 = 
  ' ',0
#data byte _str_DeleteSurplusFilesLog_8 = 
  ' ',' ',' ',' ',' ','D','I','R',$0D,$0A,0
#data byte _str_DeleteSurplusFilesLog_9 = 
  '%','8','d',0
#data byte _str_DeleteSurplusFilesLog_10 = 
  ' ',' ','%','T','D','D','.','M','M','.','Y','Y','Y','Y',0
#data byte _str_DeleteSurplusFilesLog_11 = 
  ' ',' ','%','T','h','h',':','m','m',':','s','s',$0D,$0A,0
#data byte _str_DeleteSurplusFilesLog_12 = 
  $0D,$0A,'T','o','t','a','l',' ','i','t','e','m','s',':',' ','%','d',',',' ',' ',0
#data byte _str_DeleteSurplusFilesLog_13 = 
  'T','o','t','a','l',' ','d','e','l','e','t','e','d',':',' ','%','d',',',' ',' ',0
#data byte _str_DeleteSurplusFilesLog_14 = 
  'P','r','o','c','e','s','s','i','n','g',' ','t','i','m','e',':',' ','%','T','s',
  '.','z','z','z',' ','[','s','e','c',']',$0D,$0A,'-','-','-',$0D,$0A,0
P     61
DeleteSurplusFilesLog_L0:
 LINK __SizeOf(DeleteSurplusFilesLog__temp__)
; Initialize - dynamic variables
; End initialize - dynamic variables
#srcline 159 ;  TrgBusy(CLK := fbDeleteSurplusFiles.busy);
 LDX  fbDeleteSurplusFiles
 ADD  167  ; + offset 
 MUL  8   ; -> bool pointer 
 ADD  1   ; Bool offset 
 LDIB 
#debug bool fbDeleteSurplusFiles.busy
 WRX  TrgBusy~CLK
#debug_left bool TrgBusy~CLK
 LEAX TrgBusy
 CAL  R_TRIG_L0
#srcline 160 ;  IF TrgBusy.Q THEN                     // pruzkum adresare zahajen
 LDX  TrgBusy~Q
#debug bool TrgBusy.Q
 JMC  DeleteSurplusFilesLog_L1
#srcline 161 ;    cnt := 0; deletedSpace := 0;
 LD   uint 0
 WRX  cnt
#debug_left uint cnt
 LD   udint 0
 WRX  deletedSpace
#debug_left udint deletedSpace
#srcline 162 ;    startDT := GetDateTime();
 LEA  __Instance__GetDateTime
 CAL  GetDateTime_L0
 WRX  startDT
#debug_left dt startDT
#srcline 163 ;    IF hf <> INVALID_HANDLE_VALUE THEN
 LDX  hf
#debug udint hf
 LD   udint 0
 EQ
 NEG
 JMC  DeleteSurplusFilesLog_L3
#srcline 164 ;      FileClose(hFile := hf); hf := INVALID_HANDLE_VALUE;  // pro jistotu
 NXT
 LDX  hf
#debug udint hf
 WR   __Instance__FileClose~hFile
#debug_left udint __Instance__FileClose~hFile
 PRV
 LEA  __Instance__FileClose
 CAL  FileClose_L0
 LD   udint 0
 WRX  hf
#debug_left udint hf
#srcline 165 ;    END_IF;
DeleteSurplusFilesLog_L3:
#srcline 166 ;    IF append THEN fmode := F_APPEND; ELSE fmode := F_WRITE; END_IF;
 LDX  append
#debug bool append
 JMC  DeleteSurplusFilesLog_L5
 LD   udint 2  ; TF_MODE#F_APPEND
 WRY  fmode
#debug_left usint fmode
 JMP  DeleteSurplusFilesLog_L6
DeleteSurplusFilesLog_L5:
 LD   udint 1  ; TF_MODE#F_WRITE
 WRY  fmode
#debug_left usint fmode
DeleteSurplusFilesLog_L6:
#srcline 167 ;    hf := FileOpen( mode := fmode, fileName := logName);
 NXT
 LDY  fmode
#debug usint fmode
 WR   __Instance__FileOpen~mode
#debug_left usint __Instance__FileOpen~mode
 LEAX logName
 WR   __Instance__FileOpen~fileName
#debug_left pointer __Instance__FileOpen.fileName
 PRV
 LEA  __Instance__FileOpen
 CAL  FileOpen_L0
 WRX  hf
#debug_left udint hf
#srcline 168 ;    line := DT_TO_STRINGF( startDT, '%TDD.MM.YYYY$A0hh:mm:ss.zzz  List of files deleted from directory: ') + fbDeleteSurplusFiles.dirName + '$0D$0A';
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 NXT
 LDX  startDT
#debug dt startDT
 WR   __Instance__DT_TO_STRINGF~in
#debug_left dt __Instance__DT_TO_STRINGF~in
 LD   0   ; null string
 LEA  __Instance__DT_TO_STRINGF~format
 WRI 
 LEA  __Instance__DT_TO_STRINGF~format
 LD   80
 DST    ; Level 2
 LEA  _str_DeleteSurplusFilesLog_0
 SCON 
#debug_left string __Instance__DT_TO_STRINGF~format
 PDST   ; Level 2
 PRV
 LEA  __Instance__DT_TO_STRINGF
 CAL  DT_TO_STRINGF_L0

 SCON 
 LDX  fbDeleteSurplusFiles
 ADD  1  ; + offset 
#debug string fbDeleteSurplusFiles.dirName
 SCON 
 LEA  _str_DeleteSurplusFilesLog_1
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX line
 WRI  
 LEAX line
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string line
 PDST   ; Level 1
#srcline 169 ;    FileWrite( hFile := hf, adrBuf := PTR_TO_UDINT( ADR( line)), size := LEN(line));
 NXT
 LDX  hf
#debug udint hf
 WR   __Instance__FileWrite~hFile
#debug_left udint __Instance__FileWrite~hFile
 LEAX line
#debug pointer line
 WR   __Instance__FileWrite~adrBuf
#debug_left udint __Instance__FileWrite~adrBuf
 LEAX line
#debug string line
 SLEN 
 WR   __Instance__FileWrite~size
#debug_left udint __Instance__FileWrite~size
 PRV
 LEA  __Instance__FileWrite
 CAL  FileWrite_L0
#srcline 170 ;    line := '                         FileMask: "' + fbDeleteSurplusFiles.fileMask + UDINT_TO_STRINGF( fbDeleteSurplusFiles.maxSpace, '" | MaxSpace: %d [B]');
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LEA  _str_DeleteSurplusFilesLog_2
 SCON 
 LDX  fbDeleteSurplusFiles
 ADD  82  ; + offset 
#debug string fbDeleteSurplusFiles.fileMask
 SCON 
 NXT
 LDX  fbDeleteSurplusFiles
 ADD  163  ; + offset 
 LDIL 
#debug udint fbDeleteSurplusFiles.maxSpace
 WR   __Instance__UDINT_TO_STRINGF~in
#debug_left udint __Instance__UDINT_TO_STRINGF~in
 LD   0   ; null string
 LEA  __Instance__UDINT_TO_STRINGF~format
 WRI 
 LEA  __Instance__UDINT_TO_STRINGF~format
 LD   80
 DST    ; Level 2
 LEA  _str_DeleteSurplusFilesLog_3
 SCON 
#debug_left string __Instance__UDINT_TO_STRINGF~format
 PDST   ; Level 2
 PRV
 LEA  __Instance__UDINT_TO_STRINGF
 CAL  UDINT_TO_STRINGF_L0

 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX line
 WRI  
 LEAX line
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string line
 PDST   ; Level 1
#srcline 171 ;    IF fbDeleteSurplusFiles.delEmptyDir THEN
 LDX  fbDeleteSurplusFiles
 MUL  8   ; -> bool pointer 
 ADD  1   ; Bool offset 
 LDIB 
#debug bool fbDeleteSurplusFiles.delEmptyDir
 JMC  DeleteSurplusFilesLog_L7
#srcline 172 ;      line := line + ' | delete empty dir';
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LEAX line
#debug string line
 SCON 
 LEA  _str_DeleteSurplusFilesLog_4
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX line
 WRI  
 LEAX line
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string line
 PDST   ; Level 1
#srcline 173 ;    END_IF;
DeleteSurplusFilesLog_L7:
#srcline 174 ;    IF fbDeleteSurplusFiles.noSubDir THEN
 LDX  fbDeleteSurplusFiles
 MUL  8   ; -> bool pointer 
 ADD  2   ; Bool offset 
 LDIB 
#debug bool fbDeleteSurplusFiles.noSubDir
 JMC  DeleteSurplusFilesLog_L9
#srcline 175 ;      line := line + ' | no subdir';
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LEAX line
#debug string line
 SCON 
 LEA  _str_DeleteSurplusFilesLog_5
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX line
 WRI  
 LEAX line
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string line
 PDST   ; Level 1
#srcline 176 ;    END_IF;
DeleteSurplusFilesLog_L9:
#srcline 177 ;    line := line + '$0D$0A$0D$0A';
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LEAX line
#debug string line
 SCON 
 LEA  _str_DeleteSurplusFilesLog_6
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX line
 WRI  
 LEAX line
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string line
 PDST   ; Level 1
#srcline 178 ;    FileWrite( hFile := hf, adrBuf := PTR_TO_UDINT( ADR( line)), size := LEN(line));
 NXT
 LDX  hf
#debug udint hf
 WR   __Instance__FileWrite~hFile
#debug_left udint __Instance__FileWrite~hFile
 LEAX line
#debug pointer line
 WR   __Instance__FileWrite~adrBuf
#debug_left udint __Instance__FileWrite~adrBuf
 LEAX line
#debug string line
 SLEN 
 WR   __Instance__FileWrite~size
#debug_left udint __Instance__FileWrite~size
 PRV
 LEA  __Instance__FileWrite
 CAL  FileWrite_L0
#srcline 179 ;  END_IF;
DeleteSurplusFilesLog_L1:
#srcline 181 ;  IF fbDeleteSurplusFiles.isDeleted THEN             // smazana polozka v adresari
 LDX  fbDeleteSurplusFiles
 ADD  167  ; + offset 
 MUL  8   ; -> bool pointer 
 ADD  3   ; Bool offset 
 LDIB 
#debug bool fbDeleteSurplusFiles.isDeleted
 JMC  DeleteSurplusFilesLog_L11
#srcline 182 ;    cnt := cnt + 1;
 LDX  cnt
#debug uint cnt
 LD   uint 1
 ADD
 AND  $FFFF
 WRX  cnt
#debug_left uint cnt
#srcline 183 ;    line := fbDeleteSurplusFiles.fileInfo.pathName + fbDeleteSurplusFiles.fileInfo.fileName;      // jmeno souboru/adresare
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LDX  fbDeleteSurplusFiles
 ADD  273  ; + offset 
#debug string fbDeleteSurplusFiles.fileInfo.pathName
 SCON 
 LDX  fbDeleteSurplusFiles
 ADD  192  ; + offset 
#debug string fbDeleteSurplusFiles.fileInfo.fileName
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX line
 WRI  
 LEAX line
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string line
 PDST   ; Level 1
#srcline 184 ;    FOR i := LEN(line) TO 40 DO
 LEAX line
#debug string line
 SLEN 
 WRY  i
 LD   uint 40
 WRY  P0__st__
DeleteSurplusFilesLog_L13:
 LDY  i
 LDY  P0__st__
 GT   
 JMD  DeleteSurplusFilesLog_L14
 DBG  
#srcline 185 ;      line := line + ' ';                      // doplnit mezery
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LEAX line
#debug string line
 SCON 
 LEA  _str_DeleteSurplusFilesLog_7
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX line
 WRI  
 LEAX line
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string line
 PDST   ; Level 1
#srcline 186 ;    END_FOR;
 LDY  i
 LD   1
 ADD  
 WRY  i
 JMP  DeleteSurplusFilesLog_L13
DeleteSurplusFilesLog_L14:
 NOP  -1
#srcline 187 ;    IF (fbDeleteSurplusFiles.fileInfo.attrib AND AM_DIR) <> 0 THEN
 LDX  fbDeleteSurplusFiles
 ADD  188  ; + offset 
 LDIL 
#debug dword fbDeleteSurplusFiles.fileInfo.attrib
 LD   dword 16
 AND
 LD   dword 0
 EQ
 NEG
 JMC  DeleteSurplusFilesLog_L15
#srcline 188 ;      line := line + '     DIR$0D$0A';
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LEAX line
#debug string line
 SCON 
 LEA  _str_DeleteSurplusFilesLog_8
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX line
 WRI  
 LEAX line
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string line
 PDST   ; Level 1
#srcline 189 ;    ELSE
 JMP  DeleteSurplusFilesLog_L16
DeleteSurplusFilesLog_L15:
#srcline 190 ;      line := line + UDINT_TO_STRINGF( fbDeleteSurplusFiles.fileInfo.fileSize, '%8d') +        // velikost souboru
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LEAX line
#debug string line
 SCON 
 NXT
 LDX  fbDeleteSurplusFiles
 ADD  184  ; + offset 
 LDIL 
#debug udint fbDeleteSurplusFiles.fileInfo.fileSize
 WR   __Instance__UDINT_TO_STRINGF~in
#debug_left udint __Instance__UDINT_TO_STRINGF~in
 LD   0   ; null string
 LEA  __Instance__UDINT_TO_STRINGF~format
 WRI 
 LEA  __Instance__UDINT_TO_STRINGF~format
 LD   80
 DST    ; Level 2
 LEA  _str_DeleteSurplusFilesLog_9
 SCON 
#debug_left string __Instance__UDINT_TO_STRINGF~format
 PDST   ; Level 2
 PRV
 LEA  __Instance__UDINT_TO_STRINGF
 CAL  UDINT_TO_STRINGF_L0

 SCON 
#srcline 191 ;              DT_TO_STRINGF( fbDeleteSurplusFiles.fileInfo.modifyTime, '  %TDD.MM.YYYY') +     // datum
 NXT
 LDX  fbDeleteSurplusFiles
 ADD  176  ; + offset 
 LDIQ 
#debug dt fbDeleteSurplusFiles.fileInfo.modifyTime
 WR   __Instance__DT_TO_STRINGF~in
#debug_left dt __Instance__DT_TO_STRINGF~in
 LD   0   ; null string
 LEA  __Instance__DT_TO_STRINGF~format
 WRI 
 LEA  __Instance__DT_TO_STRINGF~format
 LD   80
 DST    ; Level 2
 LEA  _str_DeleteSurplusFilesLog_10
 SCON 
#debug_left string __Instance__DT_TO_STRINGF~format
 PDST   ; Level 2
 PRV
 LEA  __Instance__DT_TO_STRINGF
 CAL  DT_TO_STRINGF_L0

 SCON 
#srcline 192 ;              DT_TO_STRINGF( fbDeleteSurplusFiles.fileInfo.modifyTime, '  %Thh:mm:ss$0D$0A');  // cas (posledni modifikace)
 NXT
 LDX  fbDeleteSurplusFiles
 ADD  176  ; + offset 
 LDIQ 
#debug dt fbDeleteSurplusFiles.fileInfo.modifyTime
 WR   __Instance__DT_TO_STRINGF~in
#debug_left dt __Instance__DT_TO_STRINGF~in
 LD   0   ; null string
 LEA  __Instance__DT_TO_STRINGF~format
 WRI 
 LEA  __Instance__DT_TO_STRINGF~format
 LD   80
 DST    ; Level 2
 LEA  _str_DeleteSurplusFilesLog_11
 SCON 
#debug_left string __Instance__DT_TO_STRINGF~format
 PDST   ; Level 2
 PRV
 LEA  __Instance__DT_TO_STRINGF
 CAL  DT_TO_STRINGF_L0

 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX line
 WRI  
 LEAX line
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string line
 PDST   ; Level 1
#srcline 193 ;    END_IF;
DeleteSurplusFilesLog_L16:
#srcline 194 ;    deletedSpace := deletedSpace + fbDeleteSurplusFiles.fileInfo.fileSize;
 LDX  deletedSpace
#debug udint deletedSpace
 LDX  fbDeleteSurplusFiles
 ADD  184  ; + offset 
 LDIL 
#debug udint fbDeleteSurplusFiles.fileInfo.fileSize
 ADD
 WRX  deletedSpace
#debug_left udint deletedSpace
#srcline 195 ;    FileWrite( hFile := hf, adrBuf := PTR_TO_UDINT( ADR( line)), size := LEN(line));
 NXT
 LDX  hf
#debug udint hf
 WR   __Instance__FileWrite~hFile
#debug_left udint __Instance__FileWrite~hFile
 LEAX line
#debug pointer line
 WR   __Instance__FileWrite~adrBuf
#debug_left udint __Instance__FileWrite~adrBuf
 LEAX line
#debug string line
 SLEN 
 WR   __Instance__FileWrite~size
#debug_left udint __Instance__FileWrite~size
 PRV
 LEA  __Instance__FileWrite
 CAL  FileWrite_L0
#srcline 196 ;  END_IF;
DeleteSurplusFilesLog_L11:
#srcline 198 ;  IF (hf <> INVALID_HANDLE_VALUE) AND NOT fbDeleteSurplusFiles.busy THEN  // pruzkum adresare ukoncen
 LDX  hf
#debug udint hf
 LD   udint 0
 EQ
 NEG
 LDX  fbDeleteSurplusFiles
 ADD  167  ; + offset 
 MUL  8   ; -> bool pointer 
 ADD  1   ; Bool offset 
 LDIB 
#debug bool fbDeleteSurplusFiles.busy
 NEG
 AND
 JMC  DeleteSurplusFilesLog_L17
#srcline 199 ;    stopDT := GetDateTime();
 LEA  __Instance__GetDateTime
 CAL  GetDateTime_L0
 WRX  stopDT
#debug_left dt stopDT
#srcline 200 ;    line := UINT_TO_STRINGF( cnt, '$0D$0ATotal items: %d,  ') +
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 NXT
 LDX  cnt
#debug uint cnt
 WR   __Instance__UINT_TO_STRINGF~in
#debug_left uint __Instance__UINT_TO_STRINGF~in
 LD   0   ; null string
 LEA  __Instance__UINT_TO_STRINGF~format
 WRI 
 LEA  __Instance__UINT_TO_STRINGF~format
 LD   80
 DST    ; Level 2
 LEA  _str_DeleteSurplusFilesLog_12
 SCON 
#debug_left string __Instance__UINT_TO_STRINGF~format
 PDST   ; Level 2
 PRV
 LEA  __Instance__UINT_TO_STRINGF
 CAL  UINT_TO_STRINGF_L0

 SCON 
#srcline 201 ;            UDINT_TO_STRINGF( deletedSpace, 'Total deleted: %d,  ') +
 NXT
 LDX  deletedSpace
#debug udint deletedSpace
 WR   __Instance__UDINT_TO_STRINGF~in
#debug_left udint __Instance__UDINT_TO_STRINGF~in
 LD   0   ; null string
 LEA  __Instance__UDINT_TO_STRINGF~format
 WRI 
 LEA  __Instance__UDINT_TO_STRINGF~format
 LD   80
 DST    ; Level 2
 LEA  _str_DeleteSurplusFilesLog_13
 SCON 
#debug_left string __Instance__UDINT_TO_STRINGF~format
 PDST   ; Level 2
 PRV
 LEA  __Instance__UDINT_TO_STRINGF
 CAL  UDINT_TO_STRINGF_L0

 SCON 
#srcline 202 ;            TIME_TO_STRINGF( SUB_DT_DT( stopDT, startDT), 'Processing time: %Ts.zzz [sec]$0D$0A---$0D$0A');
 NXT
 NXT
 LDX  stopDT
#debug dt stopDT
 WR   __Instance__SUB_DT_DT~IN1
#debug_left dt __Instance__SUB_DT_DT~IN1
 LDX  startDT
#debug dt startDT
 WR   __Instance__SUB_DT_DT~IN2
#debug_left dt __Instance__SUB_DT_DT~IN2
 PRV
 LEA  __Instance__SUB_DT_DT
 CAL  SUB_DT_DT_L0
 WR   __Instance__TIME_TO_STRINGF~in
#debug_left time __Instance__TIME_TO_STRINGF~in
 LD   0   ; null string
 LEA  __Instance__TIME_TO_STRINGF~format
 WRI 
 LEA  __Instance__TIME_TO_STRINGF~format
 LD   80
 DST    ; Level 2
 LEA  _str_DeleteSurplusFilesLog_14
 SCON 
#debug_left string __Instance__TIME_TO_STRINGF~format
 PDST   ; Level 2
 PRV
 LEA  __Instance__TIME_TO_STRINGF
 CAL  TIME_TO_STRINGF_L0

 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX line
 WRI  
 LEAX line
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string line
 PDST   ; Level 1
#srcline 203 ;    FileWrite( hFile := hf, adrBuf := PTR_TO_UDINT( ADR( line)), size := LEN(line));
 NXT
 LDX  hf
#debug udint hf
 WR   __Instance__FileWrite~hFile
#debug_left udint __Instance__FileWrite~hFile
 LEAX line
#debug pointer line
 WR   __Instance__FileWrite~adrBuf
#debug_left udint __Instance__FileWrite~adrBuf
 LEAX line
#debug string line
 SLEN 
 WR   __Instance__FileWrite~size
#debug_left udint __Instance__FileWrite~size
 PRV
 LEA  __Instance__FileWrite
 CAL  FileWrite_L0
#srcline 204 ;    FileClose(hFile := hf); hf := INVALID_HANDLE_VALUE;
 NXT
 LDX  hf
#debug udint hf
 WR   __Instance__FileClose~hFile
#debug_left udint __Instance__FileClose~hFile
 PRV
 LEA  __Instance__FileClose
 CAL  FileClose_L0
 LD   udint 0
 WRX  hf
#debug_left udint hf
#srcline 205 ;  END_IF;
DeleteSurplusFilesLog_L17:
#srcline 206 ;END_FUNCTION_BLOCK
 ULNK
RET
E     61

; Initialize - variables
P     61
DeleteSurplusFilesLog__InstanceInit__:
 LINK 0
 ULNK
RET
E     61
; End initialize - variables
#endpou 



 

#srcfile ''
#srcfile 'C:\TECOLIBSRC\FILELIB\FILELIB\ZIPARCHIVE.ST'
#pou ZipArchive
#srcline 5 ;FUNCTION_BLOCK ZipArchive

#struct ZipArchive__temp__
  int lineLen,
  udint adrLine,
  udint fsize,
  usint fmode,
  dint tmp,
  int pos,
  bool exclude,
  string[256] options,
  string[257] PS0__st__,
  string[82] PS1__st__
#data byte _str_ZipArchive_0 = 
  '/',0
#data byte _str_ZipArchive_1 = 
  'W','W','W','/','L','O','G','S','/',0
#data byte _str_ZipArchive_2 = 
  '.','L','O','G',0
#data byte _str_ZipArchive_3 = 
  '',0
#data byte _str_ZipArchive_4 = 
  $0A,0
#data byte _str_ZipArchive_5 = 
  '%','T','D','D','.','M','M','.','Y','Y','Y','Y',' ','h','h',':','m','m',':','s',
  's','.','z','z','z',' ',' ','Z','i','p',' ','a','r','c','h','i','v','e',':',' ',0
#data byte _str_ZipArchive_6 = 
  $0A,0
#data byte _str_ZipArchive_7 = 
  ' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',
  ' ',' ',' ',' ',' ','d','i','r','N','a','m','e',':',' ','"',0
#data byte _str_ZipArchive_8 = 
  '"',$0A,0
#data byte _str_ZipArchive_9 = 
  ' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',
  ' ',' ',' ',' ',' ','e','x','c','l','u','d','e',' ','f','i','l','e','L','i','s',
  't',':',' ','"',0
#data byte _str_ZipArchive_10 = 
  ' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',
  ' ',' ',' ',' ',' ','i','n','c','l','u','d','e',' ','f','i','l','e','L','i','s',
  't',':',' ','"',0
#data byte _str_ZipArchive_11 = 
  '"',$0A,0
#data byte _str_ZipArchive_12 = 
  ' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',
  ' ',' ',' ',' ',' ','o','p','t','i','o','n','s',':',' ','c','r','e','a','t','e',
  'L','o','g',0
#data byte _str_ZipArchive_13 = 
  ' ','|',' ','i','n','c','S','u','b','D','i','r',0
#data byte _str_ZipArchive_14 = 
  ' ','|',' ','d','e','l','O','r','i','g','F','i','l','e','s',0
#data byte _str_ZipArchive_15 = 
  ' ','|',' ','j','u','n','k','D','i','r','N','a','m','e','s',0
#data byte _str_ZipArchive_16 = 
  ' ','|',' ','c','r','e','a','t','e','N','e','w','A','r','c','h',0
#data byte _str_ZipArchive_17 = 
  ' ','|',' ','u','p','d','a','t','e','A','r','c','h','i','v','e',0
#data byte _str_ZipArchive_18 = 
  $0A,$0A,0
#data byte _str_ZipArchive_19 = 
  '-','v',0
#data byte _str_ZipArchive_20 = 
  ' ','-','r',0
#data byte _str_ZipArchive_21 = 
  ' ','-','m',0
#data byte _str_ZipArchive_22 = 
  ' ','-','j',0
#data byte _str_ZipArchive_23 = 
  ' ','-','x',0
#data byte _str_ZipArchive_24 = 
  '',0
#data byte _str_ZipArchive_25 = 
  'I','n','v','a','l','i','d',' ','z','i','p','N','a','m','e',0
#data byte _str_ZipArchive_26 = 
  'I','n','v','a','l','i','d',' ','f','i','l','e','L','i','s','t',0
#data byte _str_ZipArchive_27 = 
  'E','x','t','e','n','s','i','o','n',' ','o','f',' ','z','i','p','N','a','m','e',
  ' ','m','u','s','t',' ','b','e',' ','.','z','i','p',0
#data byte _str_ZipArchive_28 = 
  'I','n','v','a','l','i','d',' ','d','i','r','N','a','m','e',0
#data byte _str_ZipArchive_29 = 
  'S','t','a','r','t',' ','o','f',' ','z','i','p',' ','f','a','i','l','e','d',0
#data byte _str_ZipArchive_30 = 
  'z','i','p',' ','f','a','i','l','e','d',0
#data byte _str_ZipArchive_31 = 
  $0A,0
#data byte _str_ZipArchive_32 = 
  'a','d','d','i','n','g',':',' ',0
#data byte _str_ZipArchive_33 = 
  'u','p','d','a','t','i','n','g',':',' ',0
#data byte _str_ZipArchive_34 = 
  'z','i','p',' ','e','r','r','o','r',':',' ',0
#data byte _str_ZipArchive_35 = 
  'Z','i','p',' ','f','i','n','i','s','h','e','d','.',0
P     61
ZipArchive_L0:
 LINK __SizeOf(ZipArchive__temp__)
; Initialize - dynamic variables
; End initialize - dynamic variables
; R_EDGE, F_EDGE 
 LDX  exec
 LETX __EDGE_R__exec
 WRX  exec
#srcline 48 ;  done := 0;
 LD   bool 0       ; false
 WRX  done
#debug_left bool done
#srcline 49 ;  IF NOT busy THEN
 LDX  busy
#debug bool busy
 NEG
 JMC  ZipArchive_L1
#srcline 50 ;    IF exec THEN
 LDX  exec
#debug bool exec
 JMC  ZipArchive_L3
#srcline 51 ;      zipLog := zipName; pos := 1; numItems := 0;
 LD   0   ; null string
 LEAX zipLog
 WRI  
 LEAX zipLog
 LD   80
 DST    ; Level 1
 LEAX zipName
#debug string zipName
 SCON 
#debug_left string zipLog
 PDST   ; Level 1
 LD   int 1
 WRY  pos
#debug_left int pos
 LD   udint 0
 WRX  numItems
#debug_left udint numItems
#srcline 52 ;      WHILE pos > 0 DO
ZipArchive_L5:
 LDY  pos
#debug int pos
 EXTW 
 LD   int 0
 GTS
 JMC  ZipArchive_L6
 DBG 
#srcline 53 ;        pos := FIND(IN1 := zipLog, IN2 := '/');
 LEAX zipLog
#debug string zipLog
 LEA  _str_ZipArchive_0
 SFND 
 WRY  pos
#debug_left int pos
#srcline 54 ;        IF pos > 0 THEN
 LDY  pos
#debug int pos
 EXTW 
 LD   int 0
 GTS
 JMC  ZipArchive_L7
#srcline 55 ;          zipLog := DELETE(IN := zipLog, L := pos, P := 1);
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   80
 DST    ; Level 1
 LEAX zipLog
#debug string zipLog
 LDY  pos
#debug int pos
 EXTW 
 LD   1
 SUB  1
 SDEL 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX zipLog
 WRI  
 LEAX zipLog
 LD   80
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string zipLog
 PDST   ; Level 1
#srcline 56 ;        END_IF;
ZipArchive_L7:
#srcline 57 ;      END_WHILE;
 JMP  ZipArchive_L5
ZipArchive_L6:
 NOP  -1
#srcline 58 ;      zipLog := 'WWW/LOGS/' + zipLog + '.LOG';
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   80
 DST    ; Level 1
 LEA  _str_ZipArchive_1
 SCON 
 LEAX zipLog
#debug string zipLog
 SCON 
 LEA  _str_ZipArchive_2
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX zipLog
 WRI  
 LEAX zipLog
 LD   80
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string zipLog
 PDST   ; Level 1
#srcline 60 ;      // zalozit hlavicku logu
#srcline 61 ;      IF createNewArch THEN fmode := F_WRITE;  line := '';
 LDX  createNewArch
#debug bool createNewArch
 JMC  ZipArchive_L9
 LD   udint 1  ; TF_MODE#F_WRITE
 WRY  fmode
#debug_left usint fmode
 LD   0   ; null string
 LEAX line
 WRI  
 LEAX line
 LD   255
 DST    ; Level 1
 LEA  _str_ZipArchive_3
 SCON 
#debug_left string line
 PDST   ; Level 1
#srcline 62 ;      ELSE                  fmode := F_APPEND; line := '$0A';
 JMP  ZipArchive_L10
ZipArchive_L9:
 LD   udint 2  ; TF_MODE#F_APPEND
 WRY  fmode
#debug_left usint fmode
 LD   0   ; null string
 LEAX line
 WRI  
 LEAX line
 LD   255
 DST    ; Level 1
 LEA  _str_ZipArchive_4
 SCON 
#debug_left string line
 PDST   ; Level 1
#srcline 63 ;      END_IF;
ZipArchive_L10:
#srcline 64 ;      exclude := listType = LIST_OF_EXCLUDE_FILES;
 LDX  listType
#debug usint listType
 LD   udint 1  ; T_ZIP_LIST_TYPE#LIST_OF_EXCLUDE_FILES
 EQ
 WRY  exclude
#debug_left bool exclude
#srcline 65 ;      hf := FileOpen( mode := fmode, fileName := zipLog);
 NXT
 LDY  fmode
#debug usint fmode
 WR   __Instance__FileOpen~mode
#debug_left usint __Instance__FileOpen~mode
 LEAX zipLog
 WR   __Instance__FileOpen~fileName
#debug_left pointer __Instance__FileOpen.fileName
 PRV
 LEA  __Instance__FileOpen
 CAL  FileOpen_L0
 WRX  hf
#debug_left udint hf
#srcline 66 ;      IF hf <> INVALID_HANDLE_VALUE THEN
 LDX  hf
#debug udint hf
 LD   udint 0
 EQ
 NEG
 JMC  ZipArchive_L11
#srcline 67 ;        line := line + DT_TO_STRINGF( GetDateTime(), '%TDD.MM.YYYY$A0hh:mm:ss.zzz  Zip archive: ') + zipName + '$0A';
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LEAX line
#debug string line
 SCON 
 NXT
 LEA  __Instance__GetDateTime
 CAL  GetDateTime_L0
 WR   __Instance__DT_TO_STRINGF~in
#debug_left dt __Instance__DT_TO_STRINGF~in
 LD   0   ; null string
 LEA  __Instance__DT_TO_STRINGF~format
 WRI 
 LEA  __Instance__DT_TO_STRINGF~format
 LD   80
 DST    ; Level 2
 LEA  _str_ZipArchive_5
 SCON 
#debug_left string __Instance__DT_TO_STRINGF~format
 PDST   ; Level 2
 PRV
 LEA  __Instance__DT_TO_STRINGF
 CAL  DT_TO_STRINGF_L0

 SCON 
 LEAX zipName
#debug string zipName
 SCON 
 LEA  _str_ZipArchive_6
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX line
 WRI  
 LEAX line
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string line
 PDST   ; Level 1
#srcline 68 ;        FileWrite( hFile := hf, adrBuf := PTR_TO_UDINT( ADR( line)), size := LEN(line));
 NXT
 LDX  hf
#debug udint hf
 WR   __Instance__FileWrite~hFile
#debug_left udint __Instance__FileWrite~hFile
 LEAX line
#debug pointer line
 WR   __Instance__FileWrite~adrBuf
#debug_left udint __Instance__FileWrite~adrBuf
 LEAX line
#debug string line
 SLEN 
 WR   __Instance__FileWrite~size
#debug_left udint __Instance__FileWrite~size
 PRV
 LEA  __Instance__FileWrite
 CAL  FileWrite_L0
#srcline 69 ;        line := '                         dirName: "' + dirName + '"$0A';
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LEA  _str_ZipArchive_7
 SCON 
 LEAX dirName
#debug string dirName
 SCON 
 LEA  _str_ZipArchive_8
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX line
 WRI  
 LEAX line
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string line
 PDST   ; Level 1
#srcline 70 ;        FileWrite( hFile := hf, adrBuf := PTR_TO_UDINT( ADR( line)), size := LEN(line));
 NXT
 LDX  hf
#debug udint hf
 WR   __Instance__FileWrite~hFile
#debug_left udint __Instance__FileWrite~hFile
 LEAX line
#debug pointer line
 WR   __Instance__FileWrite~adrBuf
#debug_left udint __Instance__FileWrite~adrBuf
 LEAX line
#debug string line
 SLEN 
 WR   __Instance__FileWrite~size
#debug_left udint __Instance__FileWrite~size
 PRV
 LEA  __Instance__FileWrite
 CAL  FileWrite_L0
#srcline 71 ;        IF exclude THEN line := '                         exclude fileList: "';
 LDY  exclude
#debug bool exclude
 JMC  ZipArchive_L13
 LD   0   ; null string
 LEAX line
 WRI  
 LEAX line
 LD   255
 DST    ; Level 1
 LEA  _str_ZipArchive_9
 SCON 
#debug_left string line
 PDST   ; Level 1
#srcline 72 ;        ELSE            line := '                         include fileList: "';
 JMP  ZipArchive_L14
ZipArchive_L13:
 LD   0   ; null string
 LEAX line
 WRI  
 LEAX line
 LD   255
 DST    ; Level 1
 LEA  _str_ZipArchive_10
 SCON 
#debug_left string line
 PDST   ; Level 1
#srcline 73 ;        END_IF;
ZipArchive_L14:
#srcline 74 ;        line := line + fileList + '"$0A';
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LEAX line
#debug string line
 SCON 
 LEAX fileList
#debug string fileList
 SCON 
 LEA  _str_ZipArchive_11
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX line
 WRI  
 LEAX line
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string line
 PDST   ; Level 1
#srcline 75 ;        FileWrite( hFile := hf, adrBuf := PTR_TO_UDINT( ADR( line)), size := LEN(line));
 NXT
 LDX  hf
#debug udint hf
 WR   __Instance__FileWrite~hFile
#debug_left udint __Instance__FileWrite~hFile
 LEAX line
#debug pointer line
 WR   __Instance__FileWrite~adrBuf
#debug_left udint __Instance__FileWrite~adrBuf
 LEAX line
#debug string line
 SLEN 
 WR   __Instance__FileWrite~size
#debug_left udint __Instance__FileWrite~size
 PRV
 LEA  __Instance__FileWrite
 CAL  FileWrite_L0
#srcline 76 ;        line := '                         options: createLog';
 LD   0   ; null string
 LEAX line
 WRI  
 LEAX line
 LD   255
 DST    ; Level 1
 LEA  _str_ZipArchive_12
 SCON 
#debug_left string line
 PDST   ; Level 1
#srcline 77 ;        IF incSubDir     THEN  line := line + ' | incSubDir';     END_IF;
 LDX  incSubDir
#debug bool incSubDir
 JMC  ZipArchive_L15
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LEAX line
#debug string line
 SCON 
 LEA  _str_ZipArchive_13
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX line
 WRI  
 LEAX line
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string line
 PDST   ; Level 1
ZipArchive_L15:
#srcline 78 ;        IF delOrigFiles  THEN  line := line + ' | delOrigFiles';  END_IF;
 LDX  delOrigFiles
#debug bool delOrigFiles
 JMC  ZipArchive_L17
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LEAX line
#debug string line
 SCON 
 LEA  _str_ZipArchive_14
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX line
 WRI  
 LEAX line
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string line
 PDST   ; Level 1
ZipArchive_L17:
#srcline 79 ;        IF junkDirNames  THEN  line := line + ' | junkDirNames';  END_IF;
 LDX  junkDirNames
#debug bool junkDirNames
 JMC  ZipArchive_L19
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LEAX line
#debug string line
 SCON 
 LEA  _str_ZipArchive_15
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX line
 WRI  
 LEAX line
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string line
 PDST   ; Level 1
ZipArchive_L19:
#srcline 80 ;        IF createNewArch THEN  line := line + ' | createNewArch';
 LDX  createNewArch
#debug bool createNewArch
 JMC  ZipArchive_L21
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LEAX line
#debug string line
 SCON 
 LEA  _str_ZipArchive_16
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX line
 WRI  
 LEAX line
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string line
 PDST   ; Level 1
#srcline 81 ;                         ELSE  line := line + ' | updateArchive'; END_IF;
 JMP  ZipArchive_L22
ZipArchive_L21:
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LEAX line
#debug string line
 SCON 
 LEA  _str_ZipArchive_17
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX line
 WRI  
 LEAX line
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string line
 PDST   ; Level 1
ZipArchive_L22:
#srcline 82 ;        line := line + '$0A$0A';
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LEAX line
#debug string line
 SCON 
 LEA  _str_ZipArchive_18
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX line
 WRI  
 LEAX line
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string line
 PDST   ; Level 1
#srcline 83 ;        FileWrite( hFile := hf, adrBuf := PTR_TO_UDINT( ADR( line)), size := LEN(line));
 NXT
 LDX  hf
#debug udint hf
 WR   __Instance__FileWrite~hFile
#debug_left udint __Instance__FileWrite~hFile
 LEAX line
#debug pointer line
 WR   __Instance__FileWrite~adrBuf
#debug_left udint __Instance__FileWrite~adrBuf
 LEAX line
#debug string line
 SLEN 
 WR   __Instance__FileWrite~size
#debug_left udint __Instance__FileWrite~size
 PRV
 LEA  __Instance__FileWrite
 CAL  FileWrite_L0
#srcline 84 ;        FileClose(hFile := hf);
 NXT
 LDX  hf
#debug udint hf
 WR   __Instance__FileClose~hFile
#debug_left udint __Instance__FileClose~hFile
 PRV
 LEA  __Instance__FileClose
 CAL  FileClose_L0
#srcline 85 ;      END_IF;
ZipArchive_L11:
#srcline 87 ;      // znovu otevrit pro cteni a postavit se za hlavicku
#srcline 88 ;      hf := FileOpen( mode := F_READ, fileName := zipLog);
 NXT
 LD   udint 0  ; TF_MODE#F_READ
 WR   __Instance__FileOpen~mode
#debug_left usint __Instance__FileOpen~mode
 LEAX zipLog
 WR   __Instance__FileOpen~fileName
#debug_left pointer __Instance__FileOpen.fileName
 PRV
 LEA  __Instance__FileOpen
 CAL  FileOpen_L0
 WRX  hf
#debug_left udint hf
#srcline 89 ;      IF hf <> INVALID_HANDLE_VALUE THEN
 LDX  hf
#debug udint hf
 LD   udint 0
 EQ
 NEG
 JMC  ZipArchive_L23
#srcline 90 ;        fsize := FileSize(hFile := hf);
 NXT
 LDX  hf
#debug udint hf
 WR   __Instance__FileSize~hFile
#debug_left udint __Instance__FileSize~hFile
 PRV
 LEA  __Instance__FileSize
 CAL  FileSize_L0
 WRY  fsize
#debug_left udint fsize
#srcline 91 ;        FileSetPos(hFile := hf, offset := fsize);
 NXT
 LDX  hf
#debug udint hf
 WR   __Instance__FileSetPos~hFile
#debug_left udint __Instance__FileSetPos~hFile
 LDY  fsize
#debug udint fsize
 WR   __Instance__FileSetPos~offset
#debug_left udint __Instance__FileSetPos~offset
 PRV
 LEA  __Instance__FileSetPos
 CAL  FileSetPos_L0
#srcline 92 ;      END_IF;
ZipArchive_L23:
#srcline 93 ;      Memset(val := 0, length := sizeof( line), dest := void( line));
 NXT
 LD   udint 0
 WR   __Instance__Memset~val
#debug_left udint __Instance__Memset~val
 LD   256  ; SizeOf()
 WR   __Instance__Memset~length
#debug_left uint __Instance__Memset~length
 LEAX line
 WR   __Instance__Memset~dest
#debug_left pointer __Instance__Memset.dest
 PRV
 LEA  __Instance__Memset
 CAL  Memset_L0
#srcline 95 ;      IF createNewArch THEN
 LDX  createNewArch
#debug bool createNewArch
 JMC  ZipArchive_L25
#srcline 96 ;        FileDelete( fileName := zipName);  // smazat predchozi zip
 NXT
 LEAX zipName
 WR   __Instance__FileDelete~fileName
#debug_left pointer __Instance__FileDelete.fileName
 PRV
 LEA  __Instance__FileDelete
 CAL  FileDelete_L0
#srcline 97 ;      END_IF;
ZipArchive_L25:
#srcline 99 ;      options := '-v';
 LD   0   ; null string
 LEAY options
 WRI  
 LEAY options
 LD   255
 DST    ; Level 1
 LEA  _str_ZipArchive_19
 SCON 
#debug_left string options
 PDST   ; Level 1
#srcline 100 ;      IF incSubDir    THEN  options := options + ' -r'; END_IF;
 LDX  incSubDir
#debug bool incSubDir
 JMC  ZipArchive_L27
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LEAY options
#debug string options
 SCON 
 LEA  _str_ZipArchive_20
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAY options
 WRI  
 LEAY options
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string options
 PDST   ; Level 1
ZipArchive_L27:
#srcline 101 ;      IF delOrigFiles THEN  options := options + ' -m'; END_IF;
 LDX  delOrigFiles
#debug bool delOrigFiles
 JMC  ZipArchive_L29
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LEAY options
#debug string options
 SCON 
 LEA  _str_ZipArchive_21
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAY options
 WRI  
 LEAY options
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string options
 PDST   ; Level 1
ZipArchive_L29:
#srcline 102 ;      IF junkDirNames THEN  options := options + ' -j'; END_IF;
 LDX  junkDirNames
#debug bool junkDirNames
 JMC  ZipArchive_L31
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LEAY options
#debug string options
 SCON 
 LEA  _str_ZipArchive_22
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAY options
 WRI  
 LEAY options
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string options
 PDST   ; Level 1
ZipArchive_L31:
#srcline 103 ;      IF exclude      THEN  options := options + ' -x'; END_IF;  // pozor !!! option '-x' msi byt posledni !!!
 LDY  exclude
#debug bool exclude
 JMC  ZipArchive_L33
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LEAY options
#debug string options
 SCON 
 LEA  _str_ZipArchive_23
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAY options
 WRI  
 LEAY options
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string options
 PDST   ; Level 1
ZipArchive_L33:
#srcline 105 ;      {asm}
#srcline 106
        LEAX  fileList
#srcline 107
        LEAX  dirName
#srcline 108
        LEAX  zipName
#srcline 109
        LEAY  options
#srcline 110
        LD    3
#srcline 111
        SYS   67          ;spustit zip
#srcline 112
        WRY   tmp
#srcline 113 ;      {end_asm}
#srcline 115 ;      IF tmp = 1 THEN
 LDY  tmp
#debug dint tmp
 LD   dint 1
 EQ
 JMC  ZipArchive_L35
#srcline 116 ;        busy := 1; err := 0; errTx := ''; zipTim(IN := 0);
 LD   bool -1      ; true
 WRX  busy
#debug_left bool busy
 LD   bool 0       ; false
 WRX  err
#debug_left bool err
 LD   0   ; null string
 LEAX errTx
 WRI  
 LEAX errTx
 LD   128
 DST    ; Level 1
 LEA  _str_ZipArchive_24
 SCON 
#debug_left string errTx
 PDST   ; Level 1
 LD   bool 0       ; false
 WRX  zipTim~IN
#debug_left bool zipTim~IN
 LEAX zipTim
 CAL  TON_L0
#srcline 117 ;      ELSE
 JMP  ZipArchive_L36
ZipArchive_L35:
#srcline 118 ;        IF tmp = -1 THEN
 LDY  tmp
#debug dint tmp
 LD   dint -1
 EQ
 JMC  ZipArchive_L37
#srcline 119 ;          busy := 0; err := 1; errTx := 'Invalid zipName';
 LD   bool 0       ; false
 WRX  busy
#debug_left bool busy
 LD   bool -1      ; true
 WRX  err
#debug_left bool err
 LD   0   ; null string
 LEAX errTx
 WRI  
 LEAX errTx
 LD   128
 DST    ; Level 1
 LEA  _str_ZipArchive_25
 SCON 
#debug_left string errTx
 PDST   ; Level 1
#srcline 120 ;        ELSIF tmp = -2 THEN
 JMP  ZipArchive_L38
ZipArchive_L37:
 LDY  tmp
#debug dint tmp
 LD   dint -2
 EQ
 JMC  ZipArchive_L39
#srcline 121 ;          busy := 0; err := 1; errTx := 'Invalid fileList';
 LD   bool 0       ; false
 WRX  busy
#debug_left bool busy
 LD   bool -1      ; true
 WRX  err
#debug_left bool err
 LD   0   ; null string
 LEAX errTx
 WRI  
 LEAX errTx
 LD   128
 DST    ; Level 1
 LEA  _str_ZipArchive_26
 SCON 
#debug_left string errTx
 PDST   ; Level 1
#srcline 122 ;        ELSIF tmp = -3 THEN
 JMP  ZipArchive_L38
ZipArchive_L39:
 LDY  tmp
#debug dint tmp
 LD   dint -3
 EQ
 JMC  ZipArchive_L40
#srcline 123 ;          busy := 0; err := 1; errTx := 'Extension of zipName must be .zip';
 LD   bool 0       ; false
 WRX  busy
#debug_left bool busy
 LD   bool -1      ; true
 WRX  err
#debug_left bool err
 LD   0   ; null string
 LEAX errTx
 WRI  
 LEAX errTx
 LD   128
 DST    ; Level 1
 LEA  _str_ZipArchive_27
 SCON 
#debug_left string errTx
 PDST   ; Level 1
#srcline 124 ;        ELSIF tmp = -4 THEN
 JMP  ZipArchive_L38
ZipArchive_L40:
 LDY  tmp
#debug dint tmp
 LD   dint -4
 EQ
 JMC  ZipArchive_L41
#srcline 125 ;          busy := 0; err := 1; errTx := 'Invalid dirName';
 LD   bool 0       ; false
 WRX  busy
#debug_left bool busy
 LD   bool -1      ; true
 WRX  err
#debug_left bool err
 LD   0   ; null string
 LEAX errTx
 WRI  
 LEAX errTx
 LD   128
 DST    ; Level 1
 LEA  _str_ZipArchive_28
 SCON 
#debug_left string errTx
 PDST   ; Level 1
#srcline 126 ;        ELSIF tmp = -5 THEN
 JMP  ZipArchive_L38
ZipArchive_L41:
 LDY  tmp
#debug dint tmp
 LD   dint -5
 EQ
 JMC  ZipArchive_L42
#srcline 127 ;          busy := 0; err := 1; errTx := 'Start of zip failed';
 LD   bool 0       ; false
 WRX  busy
#debug_left bool busy
 LD   bool -1      ; true
 WRX  err
#debug_left bool err
 LD   0   ; null string
 LEAX errTx
 WRI  
 LEAX errTx
 LD   128
 DST    ; Level 1
 LEA  _str_ZipArchive_29
 SCON 
#debug_left string errTx
 PDST   ; Level 1
#srcline 128 ;        END_IF;
 JMP  ZipArchive_L38
ZipArchive_L42:
ZipArchive_L38:
#srcline 129 ;        // a zavrit vse
#srcline 130 ;        FileClose(hFile := hf); hf := INVALID_HANDLE_VALUE;
 NXT
 LDX  hf
#debug udint hf
 WR   __Instance__FileClose~hFile
#debug_left udint __Instance__FileClose~hFile
 PRV
 LEA  __Instance__FileClose
 CAL  FileClose_L0
 LD   udint 0
 WRX  hf
#debug_left udint hf
#srcline 131 ;        IF NOT createLog THEN
 LDX  createLog
#debug bool createLog
 NEG
 JMC  ZipArchive_L43
#srcline 132 ;          FileDelete( fileName := zipLog);
 NXT
 LEAX zipLog
 WR   __Instance__FileDelete~fileName
#debug_left pointer __Instance__FileDelete.fileName
 PRV
 LEA  __Instance__FileDelete
 CAL  FileDelete_L0
#srcline 133 ;        END_IF;
ZipArchive_L43:
#srcline 134 ;      END_IF;
ZipArchive_L36:
#srcline 135 ;      return;
 JMP  ZipArchive_RET
#srcline 136 ;    END_IF;
ZipArchive_L3:
#srcline 137 ;  ELSE
 JMP  ZipArchive_L2
ZipArchive_L1:
#srcline 138 ;    IF lastCyc = System_S.CYCLE_COUNTER THEN return; END_IF;  // obrana proti vicenasobnemu volani v jednom cyklu
 LDX  lastCyc
#debug usint lastCyc
 LD   System_S~CYCLE_COUNTER
#debug usint System_S.CYCLE_COUNTER
 EQ
 JMC  ZipArchive_L45
 JMP  ZipArchive_RET
ZipArchive_L45:
#srcline 139 ;    lastCyc := System_S.CYCLE_COUNTER;
 LD   System_S~CYCLE_COUNTER
#debug usint System_S.CYCLE_COUNTER
 WRX  lastCyc
#debug_left usint lastCyc
#srcline 141 ;    // cekat jak zip dopadne
#srcline 142 ;    zipTim(IN := 1, PT := T#30s);  // max 10 sec
 LD   1
 WRX  zipTim~IN
#debug_left bool zipTim~IN
 LD   time 30000
 WRX  zipTim~PT
#debug_left time zipTim~PT
 LEAX zipTim
 CAL  TON_L0
#srcline 143 ;    IF zipTim.Q THEN
 LDX  zipTim~Q
#debug bool zipTim.Q
 JMC  ZipArchive_L47
#srcline 144 ;      busy := 0; err := 1; errTx := 'zip failed';
 LD   bool 0       ; false
 WRX  busy
#debug_left bool busy
 LD   bool -1      ; true
 WRX  err
#debug_left bool err
 LD   0   ; null string
 LEAX errTx
 WRI  
 LEAX errTx
 LD   128
 DST    ; Level 1
 LEA  _str_ZipArchive_30
 SCON 
#debug_left string errTx
 PDST   ; Level 1
#srcline 145 ;    ELSE
 JMP  ZipArchive_L48
ZipArchive_L47:
#srcline 146 ;      IF hf <> INVALID_HANDLE_VALUE THEN
 LDX  hf
#debug udint hf
 LD   udint 0
 EQ
 NEG
 JMC  ZipArchive_L49
#srcline 147 ;        lineLen := LEN(line);
 LEAX line
#debug string line
 SLEN 
 WRY  lineLen
#debug_left int lineLen
#srcline 148 ;        IF lineLen < sizeof(line) THEN                             // cist dalsi kousek log souboru
 LDY  lineLen
#debug int lineLen
 EXTW 
 LD   256  ; SizeOf()
 EXTW 
 LTS
 JMC  ZipArchive_L51
#srcline 149 ;          adrLine := PTR_TO_UDINT( ADR(line)) + INT_TO_UDINT(lineLen);
 LEAX line
#debug pointer line
 LDY  lineLen
#debug int lineLen
 EXTW 
 ADD
 WRY  adrLine
#debug_left udint adrLine
#srcline 150 ;          FileRead( hFile := hf, adrBuf := adrLine, size := sizeof(line)- INT_TO_UDINT(lineLen) -1);
 NXT
 LDX  hf
#debug udint hf
 WR   __Instance__FileRead~hFile
#debug_left udint __Instance__FileRead~hFile
 LDY  adrLine
#debug udint adrLine
 WR   __Instance__FileRead~adrBuf
#debug_left udint __Instance__FileRead~adrBuf
 LD   256  ; SizeOf()
 LDY  lineLen
#debug int lineLen
 EXTW 
 SUB
 LD   udint 1
 SUB
 WR   __Instance__FileRead~size
#debug_left udint __Instance__FileRead~size
 PRV
 LEA  __Instance__FileRead
 CAL  FileRead_L0
#srcline 151 ;        END_IF;
ZipArchive_L51:
#srcline 152 ;        IF LEN(line) > 0 THEN
 LEAX line
#debug string line
 SLEN 
 LD   int 0
 GTS
 JMC  ZipArchive_L53
#srcline 153 ;          pos := FIND( IN1 := line, IN2 := '$0A');                 // najit konec radku
 LEAX line
#debug string line
 LEA  _str_ZipArchive_31
 SFND 
 WRY  pos
#debug_left int pos
#srcline 154 ;          IF pos > 0 THEN
 LDY  pos
#debug int pos
 EXTW 
 LD   int 0
 GTS
 JMC  ZipArchive_L55
#srcline 155 ;            options := LEFT(IN := line, L := pos);                 // jeden radek z line
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LEAX line
#debug string line
 LDY  pos
#debug int pos
 EXTW 
 SLFT 
 PDST   ; Level 1
 LD   0   ; null string
 LEAY options
 WRI  
 LEAY options
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string options
 PDST   ; Level 1
#srcline 156 ;            line := DELETE(IN := line, L := pos, P := 1);          // posunout line
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LEAX line
#debug string line
 LDY  pos
#debug int pos
 EXTW 
 LD   1
 SUB  1
 SDEL 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX line
 WRI  
 LEAX line
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string line
 PDST   ; Level 1
#srcline 157 ;            lineLen := LEN(line);
 LEAX line
#debug string line
 SLEN 
 WRY  lineLen
#debug_left int lineLen
#srcline 158 ;            MemsetEx(val := 0, length := sizeof(line) - INT_TO_UDINT(lineLen), offDest := INT_TO_UDINT(lineLen), dest := void(line));
 NXT
 LD   udint 0
 WR   __Instance__MemsetEx~val
#debug_left udint __Instance__MemsetEx~val
 LD   256  ; SizeOf()
 LDY  lineLen
#debug int lineLen
 EXTW 
 SUB
 WR   __Instance__MemsetEx~length
#debug_left udint __Instance__MemsetEx~length
 LDY  lineLen
#debug int lineLen
 EXTW 
 WR   __Instance__MemsetEx~offDest
#debug_left udint __Instance__MemsetEx~offDest
 LEAX line
 WR   __Instance__MemsetEx~dest
#debug_left pointer __Instance__MemsetEx.dest
 PRV
 LEA  __Instance__MemsetEx
 CAL  MemsetEx_L0
#srcline 159 ;            // hledat klicova slova
#srcline 160 ;            pos := FIND(IN1 := options, IN2 := 'adding: ');
 LEAY options
#debug string options
 LEA  _str_ZipArchive_32
 SFND 
 WRY  pos
#debug_left int pos
#srcline 161 ;            IF pos = 0 THEN
 LDY  pos
#debug int pos
 EXTW 
 LD   int 0
 EQ
 JMC  ZipArchive_L57
#srcline 162 ;              pos := FIND(IN1 := options, IN2 := 'updating: ');
 LEAY options
#debug string options
 LEA  _str_ZipArchive_33
 SFND 
 WRY  pos
#debug_left int pos
#srcline 163 ;            END_IF;
ZipArchive_L57:
#srcline 164 ;            IF pos > 0 THEN
 LDY  pos
#debug int pos
 EXTW 
 LD   int 0
 GTS
 JMC  ZipArchive_L59
#srcline 165 ;              zipTim(IN := 0);                                     // postrkovat casovac
 LD   bool 0       ; false
 WRX  zipTim~IN
#debug_left bool zipTim~IN
 LEAX zipTim
 CAL  TON_L0
#srcline 166 ;              numItems := numItems + 1;                            // zvysit pocet zpracovanych souboru
 LDX  numItems
#debug udint numItems
 LD   udint 1
 ADD
 WRX  numItems
#debug_left udint numItems
#srcline 167 ;              // tady je mozne zverejnit posledni zpracovany soubor
#srcline 168 ;              ///files[numItems] := options;  /// ladeni
#srcline 169 ;            ELSE
 JMP  ZipArchive_L60
ZipArchive_L59:
#srcline 170 ;              pos := FIND(IN1 := options, IN2 := 'zip error: ');
 LEAY options
#debug string options
 LEA  _str_ZipArchive_34
 SFND 
 WRY  pos
#debug_left int pos
#srcline 171 ;              IF pos > 0 THEN
 LDY  pos
#debug int pos
 EXTW 
 LD   int 0
 GTS
 JMC  ZipArchive_L61
#srcline 172 ;                busy := 0; err := 1;                               // zip ERR
 LD   bool 0       ; false
 WRX  busy
#debug_left bool busy
 LD   bool -1      ; true
 WRX  err
#debug_left bool err
#srcline 173 ;                errTx := DELETE(IN := options, L := pos+10, P := 1);  // zkopirovat chybu
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   128
 DST    ; Level 1
 LEAY options
#debug string options
 LDY  pos
#debug int pos
 EXTW 
 LD   int 10
 ADD
 EXTW
 LD   1
 SUB  1
 SDEL 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX errTx
 WRI  
 LEAX errTx
 LD   128
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string errTx
 PDST   ; Level 1
#srcline 174 ;              ELSE
 JMP  ZipArchive_L62
ZipArchive_L61:
#srcline 175 ;                pos := FIND(IN1 := options, IN2 := 'Zip finished.');
 LEAY options
#debug string options
 LEA  _str_ZipArchive_35
 SFND 
 WRY  pos
#debug_left int pos
#srcline 176 ;                IF pos > 0 THEN
 LDY  pos
#debug int pos
 EXTW 
 LD   int 0
 GTS
 JMC  ZipArchive_L63
#srcline 177 ;                  done := 1; busy := 0;                            // zip OK
 LD   bool -1      ; true
 WRX  done
#debug_left bool done
 LD   bool 0       ; false
 WRX  busy
#debug_left bool busy
#srcline 178 ;                END_IF;
ZipArchive_L63:
#srcline 179 ;              END_IF;
ZipArchive_L62:
#srcline 180 ;            END_IF;
ZipArchive_L60:
#srcline 181 ;          END_IF;
ZipArchive_L55:
#srcline 182 ;        END_IF;
ZipArchive_L53:
#srcline 183 ;      END_IF;
ZipArchive_L49:
#srcline 184 ;    END_IF;
ZipArchive_L48:
#srcline 186 ;    IF err OR done THEN
 LDX  err
#debug bool err
 LDX  done
#debug bool done
 OR  
 JMC  ZipArchive_L65
#srcline 187 ;      IF hf <> INVALID_HANDLE_VALUE THEN
 LDX  hf
#debug udint hf
 LD   udint 0
 EQ
 NEG
 JMC  ZipArchive_L67
#srcline 188 ;        FileClose( hFile := hf); hf := INVALID_HANDLE_VALUE;
 NXT
 LDX  hf
#debug udint hf
 WR   __Instance__FileClose~hFile
#debug_left udint __Instance__FileClose~hFile
 PRV
 LEA  __Instance__FileClose
 CAL  FileClose_L0
 LD   udint 0
 WRX  hf
#debug_left udint hf
#srcline 189 ;      END_IF;
ZipArchive_L67:
#srcline 190 ;      IF NOT createLog THEN
 LDX  createLog
#debug bool createLog
 NEG
 JMC  ZipArchive_L69
#srcline 191 ;        FileDelete( fileName := zipLog);
 NXT
 LEAX zipLog
 WR   __Instance__FileDelete~fileName
#debug_left pointer __Instance__FileDelete.fileName
 PRV
 LEA  __Instance__FileDelete
 CAL  FileDelete_L0
#srcline 192 ;      END_IF;
ZipArchive_L69:
#srcline 193 ;    END_IF;
ZipArchive_L65:
#srcline 194 ;  END_IF;
ZipArchive_L2:
#srcline 195 ;END_FUNCTION_BLOCK
ZipArchive_RET:
 ULNK
RET
E     61
#endpou 



 

#srcfile ''
#srcfile 'C:\TECOLIBSRC\FILELIB\FILELIB\UNZIPARCHIVE.ST'
#pou UnzipArchive
#srcline 1 ;FUNCTION_BLOCK UnzipArchive

#struct UnzipArchive__temp__
  int lineLen,
  udint adrLine,
  udint fsize,
  dint tmp,
  int pos,
  string[256] options,
  string[257] PS0__st__,
  string[82] PS1__st__
#data byte _str_UnzipArchive_0 = 
  '/',0
#data byte _str_UnzipArchive_1 = 
  'W','W','W','/','L','O','G','S','/',0
#data byte _str_UnzipArchive_2 = 
  '.','L','O','G',0
#data byte _str_UnzipArchive_3 = 
  '%','T','D','D','.','M','M','.','Y','Y','Y','Y',' ','h','h',':','m','m',':','s',
  's','.','z','z','z',' ',' ','U','n','Z','i','p',' ','a','r','c','h','i','v','e',
  ':',' ',0
#data byte _str_UnzipArchive_4 = 
  $0A,0
#data byte _str_UnzipArchive_5 = 
  ' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',
  ' ',' ',' ',' ',' ','e','x','t','r','a','c','t','I','n','t','o','D','i','r',':',
  ' ','"',0
#data byte _str_UnzipArchive_6 = 
  '"',$0A,0
#data byte _str_UnzipArchive_7 = 
  ' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',
  ' ',' ',' ',' ',' ','o','p','t','i','o','n','s',':',' ','c','r','e','a','t','e',
  'L','o','g',0
#data byte _str_UnzipArchive_8 = 
  ' ','|',' ','o','v','e','r','w','r','i','t','e',0
#data byte _str_UnzipArchive_9 = 
  ' ','|',' ','n','o',' ','o','v','e','r','w','r','i','t','e',0
#data byte _str_UnzipArchive_10 = 
  $0A,$0A,0
#data byte _str_UnzipArchive_11 = 
  '',0
#data byte _str_UnzipArchive_12 = 
  ' ','-','o',0
#data byte _str_UnzipArchive_13 = 
  ' ','-','n',0
#data byte _str_UnzipArchive_14 = 
  '',0
#data byte _str_UnzipArchive_15 = 
  'I','n','v','a','l','i','d',' ','z','i','p','N','a','m','e',0
#data byte _str_UnzipArchive_16 = 
  'I','n','v','a','l','i','d',' ','e','x','t','r','a','c','t','I','n','t','o','D',
  'i','r',0
#data byte _str_UnzipArchive_17 = 
  'E','x','t','e','n','s','i','o','n',' ','o','f',' ','z','i','p','N','a','m','e',
  ' ','m','u','s','t',' ','b','e',' ','.','z','i','p',0
#data byte _str_UnzipArchive_18 = 
  'S','t','a','r','t',' ','o','f',' ','u','n','z','i','p',' ','f','a','i','l','e',
  'd',0
#data byte _str_UnzipArchive_19 = 
  'u','n','z','i','p',' ','f','a','i','l','e','d',0
#data byte _str_UnzipArchive_20 = 
  $0A,0
#data byte _str_UnzipArchive_21 = 
  ' ','i','n','f','l','a','t','i','n','g',':',' ',0
#data byte _str_UnzipArchive_22 = 
  't','e','s','t','i','n','g',':',' ',0
#data byte _str_UnzipArchive_23 = 
  'e','r','r','o','r',' ','[',0
#data byte _str_UnzipArchive_24 = 
  ']',':',' ',0
#data byte _str_UnzipArchive_25 = 
  'U','n','Z','i','p',' ','f','i','n','i','s','h','e','d','.',0
P     61
UnzipArchive_L0:
 LINK __SizeOf(UnzipArchive__temp__)
; Initialize - dynamic variables
; End initialize - dynamic variables
; R_EDGE, F_EDGE 
 LDX  exec
 LETX __EDGE_R__exec
 WRX  exec
#srcline 37 ;  done := 0;
 LD   bool 0       ; false
 WRX  done
#debug_left bool done
#srcline 38 ;  IF NOT busy THEN
 LDX  busy
#debug bool busy
 NEG
 JMC  UnzipArchive_L1
#srcline 39 ;    IF exec THEN
 LDX  exec
#debug bool exec
 JMC  UnzipArchive_L3
#srcline 40 ;      zipLog := zipName; pos := 1; numItems := 0;
 LD   0   ; null string
 LEAX zipLog
 WRI  
 LEAX zipLog
 LD   80
 DST    ; Level 1
 LEAX zipName
#debug string zipName
 SCON 
#debug_left string zipLog
 PDST   ; Level 1
 LD   int 1
 WRY  pos
#debug_left int pos
 LD   udint 0
 WRX  numItems
#debug_left udint numItems
#srcline 41 ;      WHILE pos > 0 DO
UnzipArchive_L5:
 LDY  pos
#debug int pos
 EXTW 
 LD   int 0
 GTS
 JMC  UnzipArchive_L6
 DBG 
#srcline 42 ;        pos := FIND(IN1 := zipLog, IN2 := '/');
 LEAX zipLog
#debug string zipLog
 LEA  _str_UnzipArchive_0
 SFND 
 WRY  pos
#debug_left int pos
#srcline 43 ;        IF pos > 0 THEN
 LDY  pos
#debug int pos
 EXTW 
 LD   int 0
 GTS
 JMC  UnzipArchive_L7
#srcline 44 ;          zipLog := DELETE(IN := zipLog, L := pos, P := 1);
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   80
 DST    ; Level 1
 LEAX zipLog
#debug string zipLog
 LDY  pos
#debug int pos
 EXTW 
 LD   1
 SUB  1
 SDEL 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX zipLog
 WRI  
 LEAX zipLog
 LD   80
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string zipLog
 PDST   ; Level 1
#srcline 45 ;        END_IF;
UnzipArchive_L7:
#srcline 46 ;      END_WHILE;
 JMP  UnzipArchive_L5
UnzipArchive_L6:
 NOP  -1
#srcline 47 ;      zipLog := 'WWW/LOGS/' + zipLog + '.LOG';
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   80
 DST    ; Level 1
 LEA  _str_UnzipArchive_1
 SCON 
 LEAX zipLog
#debug string zipLog
 SCON 
 LEA  _str_UnzipArchive_2
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX zipLog
 WRI  
 LEAX zipLog
 LD   80
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string zipLog
 PDST   ; Level 1
#srcline 49 ;      // zalozit hlavicku logu
#srcline 50 ;      hf := FileOpen( mode := F_WRITE, fileName := zipLog);
 NXT
 LD   udint 1  ; TF_MODE#F_WRITE
 WR   __Instance__FileOpen~mode
#debug_left usint __Instance__FileOpen~mode
 LEAX zipLog
 WR   __Instance__FileOpen~fileName
#debug_left pointer __Instance__FileOpen.fileName
 PRV
 LEA  __Instance__FileOpen
 CAL  FileOpen_L0
 WRX  hf
#debug_left udint hf
#srcline 51 ;      IF hf <> INVALID_HANDLE_VALUE THEN
 LDX  hf
#debug udint hf
 LD   udint 0
 EQ
 NEG
 JMC  UnzipArchive_L9
#srcline 52 ;        line := line + DT_TO_STRINGF( GetDateTime(), '%TDD.MM.YYYY$A0hh:mm:ss.zzz  UnZip archive: ') + zipName + '$0A';
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LEAX line
#debug string line
 SCON 
 NXT
 LEA  __Instance__GetDateTime
 CAL  GetDateTime_L0
 WR   __Instance__DT_TO_STRINGF~in
#debug_left dt __Instance__DT_TO_STRINGF~in
 LD   0   ; null string
 LEA  __Instance__DT_TO_STRINGF~format
 WRI 
 LEA  __Instance__DT_TO_STRINGF~format
 LD   80
 DST    ; Level 2
 LEA  _str_UnzipArchive_3
 SCON 
#debug_left string __Instance__DT_TO_STRINGF~format
 PDST   ; Level 2
 PRV
 LEA  __Instance__DT_TO_STRINGF
 CAL  DT_TO_STRINGF_L0

 SCON 
 LEAX zipName
#debug string zipName
 SCON 
 LEA  _str_UnzipArchive_4
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX line
 WRI  
 LEAX line
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string line
 PDST   ; Level 1
#srcline 53 ;        FileWrite( hFile := hf, adrBuf := PTR_TO_UDINT( ADR( line)), size := LEN(line));
 NXT
 LDX  hf
#debug udint hf
 WR   __Instance__FileWrite~hFile
#debug_left udint __Instance__FileWrite~hFile
 LEAX line
#debug pointer line
 WR   __Instance__FileWrite~adrBuf
#debug_left udint __Instance__FileWrite~adrBuf
 LEAX line
#debug string line
 SLEN 
 WR   __Instance__FileWrite~size
#debug_left udint __Instance__FileWrite~size
 PRV
 LEA  __Instance__FileWrite
 CAL  FileWrite_L0
#srcline 54 ;        line := '                         extractIntoDir: "' + extractIntoDir + '"$0A';
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LEA  _str_UnzipArchive_5
 SCON 
 LEAX extractIntoDir
#debug string extractIntoDir
 SCON 
 LEA  _str_UnzipArchive_6
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX line
 WRI  
 LEAX line
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string line
 PDST   ; Level 1
#srcline 55 ;        FileWrite( hFile := hf, adrBuf := PTR_TO_UDINT( ADR( line)), size := LEN(line));
 NXT
 LDX  hf
#debug udint hf
 WR   __Instance__FileWrite~hFile
#debug_left udint __Instance__FileWrite~hFile
 LEAX line
#debug pointer line
 WR   __Instance__FileWrite~adrBuf
#debug_left udint __Instance__FileWrite~adrBuf
 LEAX line
#debug string line
 SLEN 
 WR   __Instance__FileWrite~size
#debug_left udint __Instance__FileWrite~size
 PRV
 LEA  __Instance__FileWrite
 CAL  FileWrite_L0
#srcline 56 ;        line := '                         options: createLog';
 LD   0   ; null string
 LEAX line
 WRI  
 LEAX line
 LD   255
 DST    ; Level 1
 LEA  _str_UnzipArchive_7
 SCON 
#debug_left string line
 PDST   ; Level 1
#srcline 57 ;        IF overwrite    THEN  line := line + ' | overwrite';
 LDX  overwrite
#debug bool overwrite
 JMC  UnzipArchive_L11
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LEAX line
#debug string line
 SCON 
 LEA  _str_UnzipArchive_8
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX line
 WRI  
 LEAX line
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string line
 PDST   ; Level 1
#srcline 58 ;        ELSE                  line := line + ' | no overwrite'; END_IF;
 JMP  UnzipArchive_L12
UnzipArchive_L11:
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LEAX line
#debug string line
 SCON 
 LEA  _str_UnzipArchive_9
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX line
 WRI  
 LEAX line
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string line
 PDST   ; Level 1
UnzipArchive_L12:
#srcline 59 ;        line := line + '$0A$0A';
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LEAX line
#debug string line
 SCON 
 LEA  _str_UnzipArchive_10
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX line
 WRI  
 LEAX line
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string line
 PDST   ; Level 1
#srcline 60 ;        FileWrite( hFile := hf, adrBuf := PTR_TO_UDINT( ADR( line)), size := LEN(line));
 NXT
 LDX  hf
#debug udint hf
 WR   __Instance__FileWrite~hFile
#debug_left udint __Instance__FileWrite~hFile
 LEAX line
#debug pointer line
 WR   __Instance__FileWrite~adrBuf
#debug_left udint __Instance__FileWrite~adrBuf
 LEAX line
#debug string line
 SLEN 
 WR   __Instance__FileWrite~size
#debug_left udint __Instance__FileWrite~size
 PRV
 LEA  __Instance__FileWrite
 CAL  FileWrite_L0
#srcline 61 ;        FileClose(hFile := hf);
 NXT
 LDX  hf
#debug udint hf
 WR   __Instance__FileClose~hFile
#debug_left udint __Instance__FileClose~hFile
 PRV
 LEA  __Instance__FileClose
 CAL  FileClose_L0
#srcline 62 ;      END_IF;
UnzipArchive_L9:
#srcline 64 ;      // znovu otevrit pro cteni a postavit se za hlavicku
#srcline 65 ;      hf := FileOpen( mode := F_READ, fileName := zipLog);
 NXT
 LD   udint 0  ; TF_MODE#F_READ
 WR   __Instance__FileOpen~mode
#debug_left usint __Instance__FileOpen~mode
 LEAX zipLog
 WR   __Instance__FileOpen~fileName
#debug_left pointer __Instance__FileOpen.fileName
 PRV
 LEA  __Instance__FileOpen
 CAL  FileOpen_L0
 WRX  hf
#debug_left udint hf
#srcline 66 ;      IF hf <> INVALID_HANDLE_VALUE THEN
 LDX  hf
#debug udint hf
 LD   udint 0
 EQ
 NEG
 JMC  UnzipArchive_L13
#srcline 67 ;        fsize := FileSize(hFile := hf);
 NXT
 LDX  hf
#debug udint hf
 WR   __Instance__FileSize~hFile
#debug_left udint __Instance__FileSize~hFile
 PRV
 LEA  __Instance__FileSize
 CAL  FileSize_L0
 WRY  fsize
#debug_left udint fsize
#srcline 68 ;        FileSetPos(hFile := hf, offset := fsize);
 NXT
 LDX  hf
#debug udint hf
 WR   __Instance__FileSetPos~hFile
#debug_left udint __Instance__FileSetPos~hFile
 LDY  fsize
#debug udint fsize
 WR   __Instance__FileSetPos~offset
#debug_left udint __Instance__FileSetPos~offset
 PRV
 LEA  __Instance__FileSetPos
 CAL  FileSetPos_L0
#srcline 69 ;      END_IF;
UnzipArchive_L13:
#srcline 70 ;      Memset(val := 0, length := sizeof( line), dest := void( line));
 NXT
 LD   udint 0
 WR   __Instance__Memset~val
#debug_left udint __Instance__Memset~val
 LD   256  ; SizeOf()
 WR   __Instance__Memset~length
#debug_left uint __Instance__Memset~length
 LEAX line
 WR   __Instance__Memset~dest
#debug_left pointer __Instance__Memset.dest
 PRV
 LEA  __Instance__Memset
 CAL  Memset_L0
#srcline 72 ;      options := '';
 LD   0   ; null string
 LEAY options
 WRI  
 LEAY options
 LD   255
 DST    ; Level 1
 LEA  _str_UnzipArchive_11
 SCON 
#debug_left string options
 PDST   ; Level 1
#srcline 73 ;      IF overwrite THEN options := options + ' -o';            // neptat se pri prepisu souboru
 LDX  overwrite
#debug bool overwrite
 JMC  UnzipArchive_L15
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LEAY options
#debug string options
 SCON 
 LEA  _str_UnzipArchive_12
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAY options
 WRI  
 LEAY options
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string options
 PDST   ; Level 1
#srcline 74 ;      ELSE              options := options + ' -n'; END_IF;    // neprepisovat soubory
 JMP  UnzipArchive_L16
UnzipArchive_L15:
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LEAY options
#debug string options
 SCON 
 LEA  _str_UnzipArchive_13
 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAY options
 WRI  
 LEAY options
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string options
 PDST   ; Level 1
UnzipArchive_L16:
#srcline 76 ;      {asm}
#srcline 77
        LEAX  extractIntoDir
#srcline 78
        LEAX  zipName
#srcline 79
        LEAY  options
#srcline 80
        LD    4
#srcline 81
        SYS   67          ;spustit unzip
#srcline 82
        WRY   tmp
#srcline 83 ;      {end_asm}
#srcline 85 ;      IF tmp = 1 THEN
 LDY  tmp
#debug dint tmp
 LD   dint 1
 EQ
 JMC  UnzipArchive_L17
#srcline 86 ;        busy := 1; err := 0; errTx := ''; zipTim(IN := 0);
 LD   bool -1      ; true
 WRX  busy
#debug_left bool busy
 LD   bool 0       ; false
 WRX  err
#debug_left bool err
 LD   0   ; null string
 LEAX errTx
 WRI  
 LEAX errTx
 LD   128
 DST    ; Level 1
 LEA  _str_UnzipArchive_14
 SCON 
#debug_left string errTx
 PDST   ; Level 1
 LD   bool 0       ; false
 WRX  zipTim~IN
#debug_left bool zipTim~IN
 LEAX zipTim
 CAL  TON_L0
#srcline 87 ;      ELSE
 JMP  UnzipArchive_L18
UnzipArchive_L17:
#srcline 88 ;        IF tmp = -1 THEN
 LDY  tmp
#debug dint tmp
 LD   dint -1
 EQ
 JMC  UnzipArchive_L19
#srcline 89 ;          busy := 0; err := 1; errTx := 'Invalid zipName';
 LD   bool 0       ; false
 WRX  busy
#debug_left bool busy
 LD   bool -1      ; true
 WRX  err
#debug_left bool err
 LD   0   ; null string
 LEAX errTx
 WRI  
 LEAX errTx
 LD   128
 DST    ; Level 1
 LEA  _str_UnzipArchive_15
 SCON 
#debug_left string errTx
 PDST   ; Level 1
#srcline 90 ;        ELSIF tmp = -2 THEN
 JMP  UnzipArchive_L20
UnzipArchive_L19:
 LDY  tmp
#debug dint tmp
 LD   dint -2
 EQ
 JMC  UnzipArchive_L21
#srcline 91 ;          busy := 0; err := 1; errTx := 'Invalid extractIntoDir';
 LD   bool 0       ; false
 WRX  busy
#debug_left bool busy
 LD   bool -1      ; true
 WRX  err
#debug_left bool err
 LD   0   ; null string
 LEAX errTx
 WRI  
 LEAX errTx
 LD   128
 DST    ; Level 1
 LEA  _str_UnzipArchive_16
 SCON 
#debug_left string errTx
 PDST   ; Level 1
#srcline 92 ;        ELSIF tmp = -3 THEN
 JMP  UnzipArchive_L20
UnzipArchive_L21:
 LDY  tmp
#debug dint tmp
 LD   dint -3
 EQ
 JMC  UnzipArchive_L22
#srcline 93 ;          busy := 0; err := 1; errTx := 'Extension of zipName must be .zip';
 LD   bool 0       ; false
 WRX  busy
#debug_left bool busy
 LD   bool -1      ; true
 WRX  err
#debug_left bool err
 LD   0   ; null string
 LEAX errTx
 WRI  
 LEAX errTx
 LD   128
 DST    ; Level 1
 LEA  _str_UnzipArchive_17
 SCON 
#debug_left string errTx
 PDST   ; Level 1
#srcline 94 ;        ELSIF tmp = -4 THEN
 JMP  UnzipArchive_L20
UnzipArchive_L22:
 LDY  tmp
#debug dint tmp
 LD   dint -4
 EQ
 JMC  UnzipArchive_L23
#srcline 95 ;          busy := 0; err := 1; errTx := 'Start of unzip failed';
 LD   bool 0       ; false
 WRX  busy
#debug_left bool busy
 LD   bool -1      ; true
 WRX  err
#debug_left bool err
 LD   0   ; null string
 LEAX errTx
 WRI  
 LEAX errTx
 LD   128
 DST    ; Level 1
 LEA  _str_UnzipArchive_18
 SCON 
#debug_left string errTx
 PDST   ; Level 1
#srcline 96 ;        END_IF;
 JMP  UnzipArchive_L20
UnzipArchive_L23:
UnzipArchive_L20:
#srcline 97 ;        // a zavrit vse
#srcline 98 ;        FileClose(hFile := hf); hf := INVALID_HANDLE_VALUE;
 NXT
 LDX  hf
#debug udint hf
 WR   __Instance__FileClose~hFile
#debug_left udint __Instance__FileClose~hFile
 PRV
 LEA  __Instance__FileClose
 CAL  FileClose_L0
 LD   udint 0
 WRX  hf
#debug_left udint hf
#srcline 99 ;        IF NOT createLog THEN
 LDX  createLog
#debug bool createLog
 NEG
 JMC  UnzipArchive_L24
#srcline 100 ;          FileDelete( fileName := zipLog);
 NXT
 LEAX zipLog
 WR   __Instance__FileDelete~fileName
#debug_left pointer __Instance__FileDelete.fileName
 PRV
 LEA  __Instance__FileDelete
 CAL  FileDelete_L0
#srcline 101 ;        END_IF;
UnzipArchive_L24:
#srcline 102 ;      END_IF;
UnzipArchive_L18:
#srcline 103 ;      return;
 JMP  UnzipArchive_RET
#srcline 104 ;    END_IF;
UnzipArchive_L3:
#srcline 105 ;  ELSE
 JMP  UnzipArchive_L2
UnzipArchive_L1:
#srcline 106 ;    IF lastCyc = System_S.CYCLE_COUNTER THEN return; END_IF;  // obrana proti vicenasobnemu volani v jednom cyklu
 LDX  lastCyc
#debug usint lastCyc
 LD   System_S~CYCLE_COUNTER
#debug usint System_S.CYCLE_COUNTER
 EQ
 JMC  UnzipArchive_L26
 JMP  UnzipArchive_RET
UnzipArchive_L26:
#srcline 107 ;    lastCyc := System_S.CYCLE_COUNTER;
 LD   System_S~CYCLE_COUNTER
#debug usint System_S.CYCLE_COUNTER
 WRX  lastCyc
#debug_left usint lastCyc
#srcline 108 ;    // cekat jak unzip dopadne
#srcline 109 ;    zipTim(IN := 1, PT := T#30s);  // max 10 sec
 LD   1
 WRX  zipTim~IN
#debug_left bool zipTim~IN
 LD   time 30000
 WRX  zipTim~PT
#debug_left time zipTim~PT
 LEAX zipTim
 CAL  TON_L0
#srcline 110 ;    IF zipTim.Q THEN
 LDX  zipTim~Q
#debug bool zipTim.Q
 JMC  UnzipArchive_L28
#srcline 111 ;      busy := 0; err := 1; errTx := 'unzip failed';
 LD   bool 0       ; false
 WRX  busy
#debug_left bool busy
 LD   bool -1      ; true
 WRX  err
#debug_left bool err
 LD   0   ; null string
 LEAX errTx
 WRI  
 LEAX errTx
 LD   128
 DST    ; Level 1
 LEA  _str_UnzipArchive_19
 SCON 
#debug_left string errTx
 PDST   ; Level 1
#srcline 112 ;    ELSE
 JMP  UnzipArchive_L29
UnzipArchive_L28:
#srcline 113 ;      IF hf <> INVALID_HANDLE_VALUE THEN
 LDX  hf
#debug udint hf
 LD   udint 0
 EQ
 NEG
 JMC  UnzipArchive_L30
#srcline 114 ;        lineLen := LEN(line);
 LEAX line
#debug string line
 SLEN 
 WRY  lineLen
#debug_left int lineLen
#srcline 115 ;        IF lineLen < sizeof(line) THEN                             // cist dalsi kousek log souboru
 LDY  lineLen
#debug int lineLen
 EXTW 
 LD   256  ; SizeOf()
 EXTW 
 LTS
 JMC  UnzipArchive_L32
#srcline 116 ;          adrLine := PTR_TO_UDINT( ADR(line)) + INT_TO_UDINT(lineLen);
 LEAX line
#debug pointer line
 LDY  lineLen
#debug int lineLen
 EXTW 
 ADD
 WRY  adrLine
#debug_left udint adrLine
#srcline 117 ;          FileRead( hFile := hf, adrBuf := adrLine, size := sizeof(line)- INT_TO_UDINT(lineLen) -1);
 NXT
 LDX  hf
#debug udint hf
 WR   __Instance__FileRead~hFile
#debug_left udint __Instance__FileRead~hFile
 LDY  adrLine
#debug udint adrLine
 WR   __Instance__FileRead~adrBuf
#debug_left udint __Instance__FileRead~adrBuf
 LD   256  ; SizeOf()
 LDY  lineLen
#debug int lineLen
 EXTW 
 SUB
 LD   udint 1
 SUB
 WR   __Instance__FileRead~size
#debug_left udint __Instance__FileRead~size
 PRV
 LEA  __Instance__FileRead
 CAL  FileRead_L0
#srcline 118 ;        END_IF;
UnzipArchive_L32:
#srcline 119 ;        IF LEN(line) > 0 THEN
 LEAX line
#debug string line
 SLEN 
 LD   int 0
 GTS
 JMC  UnzipArchive_L34
#srcline 120 ;          pos := FIND( IN1 := line, IN2 := '$0A');                 // najit konec radku
 LEAX line
#debug string line
 LEA  _str_UnzipArchive_20
 SFND 
 WRY  pos
#debug_left int pos
#srcline 121 ;          IF pos > 0 THEN
 LDY  pos
#debug int pos
 EXTW 
 LD   int 0
 GTS
 JMC  UnzipArchive_L36
#srcline 122 ;            options := LEFT(IN := line, L := pos);                 // jeden radek z line
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LEAX line
#debug string line
 LDY  pos
#debug int pos
 EXTW 
 SLFT 
 PDST   ; Level 1
 LD   0   ; null string
 LEAY options
 WRI  
 LEAY options
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string options
 PDST   ; Level 1
#srcline 123 ;            line := DELETE(IN := line, L := pos, P := 1);          // posunout line
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   255
 DST    ; Level 1
 LEAX line
#debug string line
 LDY  pos
#debug int pos
 EXTW 
 LD   1
 SUB  1
 SDEL 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX line
 WRI  
 LEAX line
 LD   255
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string line
 PDST   ; Level 1
#srcline 124 ;            lineLen := LEN(line);
 LEAX line
#debug string line
 SLEN 
 WRY  lineLen
#debug_left int lineLen
#srcline 125 ;            MemsetEx(val := 0, length := sizeof(line) - INT_TO_UDINT(lineLen), offDest := INT_TO_UDINT(lineLen), dest := void(line));
 NXT
 LD   udint 0
 WR   __Instance__MemsetEx~val
#debug_left udint __Instance__MemsetEx~val
 LD   256  ; SizeOf()
 LDY  lineLen
#debug int lineLen
 EXTW 
 SUB
 WR   __Instance__MemsetEx~length
#debug_left udint __Instance__MemsetEx~length
 LDY  lineLen
#debug int lineLen
 EXTW 
 WR   __Instance__MemsetEx~offDest
#debug_left udint __Instance__MemsetEx~offDest
 LEAX line
 WR   __Instance__MemsetEx~dest
#debug_left pointer __Instance__MemsetEx.dest
 PRV
 LEA  __Instance__MemsetEx
 CAL  MemsetEx_L0
#srcline 126 ;            // hledat klicova slova
#srcline 127 ;            pos := FIND(IN1 := options, IN2 := ' inflating: ');
 LEAY options
#debug string options
 LEA  _str_UnzipArchive_21
 SFND 
 WRY  pos
#debug_left int pos
#srcline 128 ;            IF pos = 0 THEN
 LDY  pos
#debug int pos
 EXTW 
 LD   int 0
 EQ
 JMC  UnzipArchive_L38
#srcline 129 ;              pos := FIND(IN1 := options, IN2 := 'testing: ');
 LEAY options
#debug string options
 LEA  _str_UnzipArchive_22
 SFND 
 WRY  pos
#debug_left int pos
#srcline 130 ;            END_IF;
UnzipArchive_L38:
#srcline 131 ;            IF pos > 0 THEN
 LDY  pos
#debug int pos
 EXTW 
 LD   int 0
 GTS
 JMC  UnzipArchive_L40
#srcline 132 ;              zipTim(IN := 0);                                     // postrkovat casovac
 LD   bool 0       ; false
 WRX  zipTim~IN
#debug_left bool zipTim~IN
 LEAX zipTim
 CAL  TON_L0
#srcline 133 ;              numItems := numItems + 1;                            // zvysit pocet zpracovanych souboru
 LDX  numItems
#debug udint numItems
 LD   udint 1
 ADD
 WRX  numItems
#debug_left udint numItems
#srcline 134 ;              // tady je mozne zverejnit posledni zpracovany soubor
#srcline 135 ;              ///files[numItems] := options;  /// ladeni
#srcline 136 ;            ELSE
 JMP  UnzipArchive_L41
UnzipArchive_L40:
#srcline 137 ;              pos := FIND(IN1 := options, IN2 := 'error [');
 LEAY options
#debug string options
 LEA  _str_UnzipArchive_23
 SFND 
 WRY  pos
#debug_left int pos
#srcline 138 ;              IF pos > 0 THEN
 LDY  pos
#debug int pos
 EXTW 
 LD   int 0
 GTS
 JMC  UnzipArchive_L42
#srcline 139 ;                pos := FIND(IN1 := options, IN2 := ']: ');
 LEAY options
#debug string options
 LEA  _str_UnzipArchive_24
 SFND 
 WRY  pos
#debug_left int pos
#srcline 140 ;                busy := 0; err := 1;                                  // unzip ERR
 LD   bool 0       ; false
 WRX  busy
#debug_left bool busy
 LD   bool -1      ; true
 WRX  err
#debug_left bool err
#srcline 141 ;                errTx := DELETE(IN := options, L := pos+3, P := 1);   // zkopirovat chybu
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   128
 DST    ; Level 1
 LEAY options
#debug string options
 LDY  pos
#debug int pos
 EXTW 
 LD   int 3
 ADD
 EXTW
 LD   1
 SUB  1
 SDEL 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX errTx
 WRI  
 LEAX errTx
 LD   128
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string errTx
 PDST   ; Level 1
#srcline 142 ;              ELSE
 JMP  UnzipArchive_L43
UnzipArchive_L42:
#srcline 143 ;                pos := FIND(IN1 := options, IN2 := 'UnZip finished.');
 LEAY options
#debug string options
 LEA  _str_UnzipArchive_25
 SFND 
 WRY  pos
#debug_left int pos
#srcline 144 ;                IF pos > 0 THEN
 LDY  pos
#debug int pos
 EXTW 
 LD   int 0
 GTS
 JMC  UnzipArchive_L44
#srcline 145 ;                  done := 1; busy := 0;                            // unzip OK
 LD   bool -1      ; true
 WRX  done
#debug_left bool done
 LD   bool 0       ; false
 WRX  busy
#debug_left bool busy
#srcline 146 ;                END_IF;
UnzipArchive_L44:
#srcline 147 ;              END_IF;
UnzipArchive_L43:
#srcline 148 ;            END_IF;
UnzipArchive_L41:
#srcline 149 ;          END_IF;
UnzipArchive_L36:
#srcline 150 ;        END_IF;
UnzipArchive_L34:
#srcline 151 ;      END_IF;
UnzipArchive_L30:
#srcline 152 ;    END_IF;
UnzipArchive_L29:
#srcline 154 ;    IF err OR done THEN
 LDX  err
#debug bool err
 LDX  done
#debug bool done
 OR  
 JMC  UnzipArchive_L46
#srcline 155 ;      IF hf <> INVALID_HANDLE_VALUE THEN
 LDX  hf
#debug udint hf
 LD   udint 0
 EQ
 NEG
 JMC  UnzipArchive_L48
#srcline 156 ;        FileClose( hFile := hf); hf := INVALID_HANDLE_VALUE;
 NXT
 LDX  hf
#debug udint hf
 WR   __Instance__FileClose~hFile
#debug_left udint __Instance__FileClose~hFile
 PRV
 LEA  __Instance__FileClose
 CAL  FileClose_L0
 LD   udint 0
 WRX  hf
#debug_left udint hf
#srcline 157 ;      END_IF;
UnzipArchive_L48:
#srcline 158 ;      IF NOT createLog THEN
 LDX  createLog
#debug bool createLog
 NEG
 JMC  UnzipArchive_L50
#srcline 159 ;        FileDelete( fileName := zipLog);
 NXT
 LEAX zipLog
 WR   __Instance__FileDelete~fileName
#debug_left pointer __Instance__FileDelete.fileName
 PRV
 LEA  __Instance__FileDelete
 CAL  FileDelete_L0
#srcline 160 ;      END_IF;
UnzipArchive_L50:
#srcline 161 ;    END_IF;
UnzipArchive_L46:
#srcline 162 ;  END_IF;
UnzipArchive_L2:
#srcline 163 ;END_FUNCTION_BLOCK
UnzipArchive_RET:
 ULNK
RET
E     61
#endpou 



 

#srcfile ''
ò  ]  _