(*` {CSY}Knihovna vývojového systému Mosaic{ENU}Mosaic IDE library *)
(*` {CSY}Jméno souboru{ENU}File name{} : D:\MosaicLib\MQTTLib_V13_20180815.mlb *)
(*` {CSY}Knihovna : MQTTLib{ENU}Library : MQTTLib{} 1.3 *)
(*` {CSY}Autor{ENU}Author{} : Teco a.s. *)
(*` {CSY}Autorská práva{ENU}Copyright{} : (c) 2019 Teco a.s. *)
(*` {CSY}Verze IEC pøekladaèe{ENU}IEC compiler version{} : 4.2.4.0 *)
(*` {CSY}Verze assembleru{ENU}Assembler version{} : 4.3.00 *)

//{Knihovna : MQTTLib 1.3  }
(*` {CSY}Historie{ENU}History{}: *)
(*`
{CSY}
v1.0 03.08.2017 zis - první verze knihovny 
v1.1 16.01.2018 nem - úprava fce fSwapWORD() 
v1.2 15.08.2018 zis - Pridáni nové fb "fbMQTTPublisherEx" a "fbMQTTSubscriberEx" pro dlouhé MQTT zprávy až 512 bajtu
v1.3 10.04.2019 zis - Oprava "fbMQTTPublisher" a "fbMQTTPublisherEx" pro com_param.qos > 0

{ENU}
v1.0 2017.08.03 zis - first version of library 
v1.1 2018.01.16 nem - fSwapWORD() corrected
v1.2 15.08.2018 zis - Added new fb "fbMQTTPublisherEx" and "fbMQTTSubscriberEx" for long MQTT payload messages up 512 bytes
v1.3 10.04.2019 zis - Correction "fbMQTTPublisher" a "fbMQTTPublisherEx" for com_param.qos > 0
*)

(*----------------------------------------------------------------------------*)
{LIBRARY="LOCALLIB\STDLIB_V21_20140514.MLB"}
{LIBRARY="LOCALLIB\SYSLIB_V37_20160627.MLB"}
{LIBRARY="LOCALLIB\TOSTRINGLIB_V13_20110203.MLB"}
{LIBRARY="LOCALLIB\TIMELIB_V15_20170216.MLB"}
{LIBRARY="LOCALLIB\COMLIB_V24_20161019.MLB"}
{LIBRARY="LOCALLIB\ENCRYPTLIB_V12_20160923.MLB"}
{LIBRARY="LOCALLIB\INTERNETLIB_V40_20170216.MLB"}

TYPE T_MQTT_COM_PARAM :
  STRUCT
    willRetain       : bool :=  FALSE;  (*`{ENU} Duplicate delivery of a PUBLISH Control Packet*)
    qos              : usint;  (*`{ENU} PUBLISH Quality of Service (value:0,1,2)*)
    cleanSession     : bool :=  true;
    dup              : bool;  (*`{ENU} Duplicate delivery of a PUBLISH Control Packet*)
  END_STRUCT;
END_TYPE

TYPE  MQTT_EX_PUBLISHER_BUFFER : ARRAY [0..512] OF usint;
END_TYPE

TYPE  MQTT_EX_SUBSCRIBER_BUFFER : ARRAY [0..512] OF usint;
END_TYPE

VAR_GLOBAL CONSTANT
 MQTT_COMM_TIMEOUT {HIDDEN} : time :=  T#5s;
 MQTT_COMM_PORT : uint :=  1883;
 MQTT_CLIENT_TYPE_PUBLISHER : bool :=  FALSE;
 MQTT_CLIENT_TYPE_SUBSCRIBER : bool :=  TRUE;
 MQTT_CONTROL_PACK_CONNECT : usint :=  16#10;  (*`Client request to connect to Server*)
 MQTT_CONTROL_PACK_CONNACK : usint :=  16#20;  (*`Connect acknowledgment*)
 MQTT_CONTROL_PACK_PUBLISH : usint :=  16#30;  (*`Publish message ( Client to Server or Server to Client)*)
 MQTT_CONTROL_PACK_PUBACK : usint :=  16#40;  (*`Publish acknowledgment ( Client to Server or Server to Client)*)
 MQTT_CONTROL_PACK_PUBREC : usint :=  16#50;  (*`Publish received (assured delivery part 1) ( Client to Server or Server to Client)*)
 MQTT_CONTROL_PACK_PUBREL : usint :=  16#60;  (*`Publish release (assured delivery part 2)*)
 MQTT_CONTROL_PACK_PUBCOMP : usint :=  16#70;  (*`Publish complete (assured delivery part 3)*)
 MQTT_CONTROL_PACK_SUBSCRIBE : usint :=  16#80;  (*`Client subscribe request (Client to Server)*)
 MQTT_CONTROL_PACK_SUBACK : usint :=  16#90;  (*`Subscribe acknowledgment ( Server to Client)*)
 MQTT_CONTROL_PACK_UNSUBSCRIBE : usint :=  16#A0;  (*`Unsubscribe request (Client to Server)*)
 MQTT_CONTROL_PACK_UNSUBACK : usint :=  16#B0;  (*`Unsubscribe acknowledgment ( Server to Client)*)
 MQTT_CONTROL_PACK_PINGREQ : usint :=  16#C0;  (*`PING request (Client to Server)*)
 MQTT_CONTROL_PACK_PINGRESP : usint :=  16#D0;  (*`PING response ( Server to Client)*)
 MQTT_CONTROL_PACK_DISCONNECT : usint :=  16#E0;  (*`Client is disconnecting (Client to Server)*)
 MQTT_CONTROL_ERROR_CODE_OK : usint :=  0;
 MQTT_CONTROL_ERROR_CODE_BROKER_ANSWER_TIME_OUT : usint :=  1;
 MQTT_CONTROL_ERROR_CODE_SUBSCRIBE_FAILED : usint :=  2;
 MQTT_CONTROL_ERROR_CODE_BROKER_DISCONNECTED : usint :=  3;
 MQTT_CONTROL_ERROR_CODE_ANSWER_LENGTH_TO_LONG : usint :=  4;
 MQTT_CONTROL_ERRORS_CODE_AP_MISSING : usint :=  200;

END_VAR

__DECL FUNCTION MQTT_Lib_support {HIDDEN} : bool
  VAR_INPUT
    code             : udint;
    tim              : udint;
  END_VAR
END_FUNCTION

__DECL FUNCTION fSwapUINT {HIDDEN} : uint
  VAR_INPUT
    input            : uint;
  END_VAR
END_FUNCTION

__DECL FUNCTION_BLOCK fbMQTT_Comm_Init {HIDDEN}
  VAR_INPUT
    connect          : bool;
    keepAlive        : bool :=  true;
    chanCode         : uint;
    remoteIP         : TIPadr;
    remotePort       : uint;
    localPort        : uint;
  END_VAR
  VAR_OUTPUT
    status           : bool;
    error            : usint;
  END_VAR
  VAR
    ethAdr           : TRemoteEthAdr;
    KeepAliveTCP     : fbKeepAliveTCP;
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION_BLOCK fbMQTTPublisher
(*`{ENG} FB client sending a data to the broker, using a topic name.
  {CSY} FB klient posila data brokru pomocí názvu tématu (topic).*)
  VAR_INPUT
    connect          : bool;  (*`{CSY} {ENU} Connect or disconnect command*)
    chanCode         : uint;  (*`{CSY} {ENU} Communication channel for MQTT commands and states*)
    brokerIP         : TIPadr;  (*`{CSY} IP adresa MQTT zarízení {ENU} IP address of MQTT broker*)
    brokerPort       : uint :=  1883;  (*`{CSY} port MQTT brokru (výchozí hodnota je 1883) {ENU} port of MQTT broker (default value is 1883)*)
    localPort        : uint :=  6000;  (*`{CSY} PLC lokální port {ENU} PLC local port*)
    keepAlive        : bool :=  true;  (*`{CSY} {ENU} FB keep comm channel opened during communication session (Brocker keeps all settings)*)
    keepAliveInterval : time :=  T#60s;  (*`{CSY} {ENU} maximum time when broker close session and clear all settings of publisher*)
    connTimeOut      : time :=  T#10s;  (*`{CSY} {ENU} maximum timeout of response from broker*)
    pingInterval     : time :=  T#15s;  (*`{CSY} {ENU} Interval for keep alive comm session between publisher and broker MUST BE: keepAliveInterval > pingInterval*)
    clientId_auto    : bool :=  true;  (*`{CSY} {ENU} client ID will be generated automatically and append timestamp to MQTT client id*)
    clientId         : string [32];  (*`{CSY} {ENU} static client ID, relevant when clientId_auto = false*)
    loginName        : string [32];  (*`{CSY} {ENU} log in name, using when required atherization*)
    loginPass        : string [32];  (*`{CSY} {ENU} password, using when required atherization*)
    com_param        : T_MQTT_COM_PARAM;  (*`{CSY} {ENU} parametrs of MQTT session*)
    dataTxt          : string [255];  (*`{CSY} {ENU} data to transmitt*)
    topicTxt         : string [80];  (*`{CSY} {ENU} topic where published sends data*)
    sendCom          : bool R_EDGE;  (*`{CSY} {ENU} command to send data*)
  END_VAR
  VAR_OUTPUT
    conn_status      : bool;  (*`{CSY} {ENU} TCP connection state*)
    connected_to_broker : bool;  (*`{CSY} {ENU} Connection state to MQTT broker*)
    client_id        : string [32];  (*`{CSY} {ENU} Client ID used in communication session*)
    local_port       : uint;  (*`{CSY} {ENU} current local port*)
    rxCounter        : uint;  (*`{CSY} {ENU} incomming messages counter*)
    txCounter        : uint;  (*`{CSY} {ENU} outgoing messages counter*)
    messageID        : uint;  (*`{CSY} {ENU} message id, used when QOS > 0*)
    busy             : bool;  (*`{CSY} {ENU} broadcasting data state*)
    ok               : bool;  (*`{CSY} {ENU} ready to broadcast new data*)
    err              : bool;  (*`{CSY} {ENU} error occurred*)
    errCode          : usint;  (*`{CSY} {ENU} code of error*)
  END_VAR
  VAR
    MQTT_Comm_Init   : fbMQTT_Comm_Init;
    MQTT_ping_timer  : fbTick;
    MQTT_com_intervat : fbTick;
    MQTT_com_responce_timeout : TON;
    SendTo           : fbSendTo;
    RecvFrom         : fbRecvFrom;
    txData           : ARRAY [0..300] OF usint;
    rxData           : ARRAY [0..100] OF usint;
    payloadLengthArrayTemp : ARRAY [1..4] OF usint;
    MQTT_PROTOCOL    : string [4] :=  'MQTT';
    txMsgLength      : uint;
    payloadLength    : uint;
    txMsgLengthTemp  : uint;
    encodedByte      : byte;
    tx_data_request  : bool;
    localPortExtension : uint;
    idle_time        : usint;
    payloadLengthSize : usint;
    reconnect_counter : usint;
    wait_response    : bool;
    connectFlags     : byte;
    aliveTime        : uint;
    pubReleaseRq     : bool;
    messageIDpubRel  : uint;
    messageIDpubRel_ptr : PTR_TO uint;
    index            : usint;
    responce_recived : bool;  (*`{CSY} {ENU} code of error*)
    messageIDlast    : uint;
  END_VAR
  VAR CONSTANT
    MQTT_PROTOCOL_VERSION : usint :=  4;
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION_BLOCK fbMQTTPublisherEx
(*`{ENG} FB client sending a data to the broker, using a topic name.
  {CSY} FB klient posila data brokru pomocí názvu tématu (topic).*)
  VAR_INPUT
    connect          : bool;  (*`{CSY} {ENU} Connect or disconnect command*)
    chanCode         : uint;  (*`{CSY} {ENU} Communication channel for MQTT commands and states*)
    brokerIP         : TIPadr;  (*`{CSY} IP adresa MQTT zarízení {ENU} IP address of MQTT broker*)
    brokerPort       : uint :=  1883;  (*`{CSY} port MQTT brokru (výchozí hodnota je 1883) {ENU} port of MQTT broker (default value is 1883)*)
    localPort        : uint :=  6000;  (*`{CSY} PLC lokální port {ENU} PLC local port*)
    keepAlive        : bool :=  true;  (*`{CSY} {ENU} FB keep comm channel opened during communication session (Brocker keeps all settings)*)
    keepAliveInterval : time :=  T#60s;  (*`{CSY} {ENU} maximum time when broker close session and clear all settings of publisher*)
    connTimeOut      : time :=  T#10s;  (*`{CSY} {ENU} maximum timeout of response from broker*)
    pingInterval     : time :=  T#15s;  (*`{CSY} {ENU} Interval for keep alive comm session between publisher and broker MUST BE: keepAliveInterval > pingInterval*)
    clientId_auto    : bool :=  true;  (*`{CSY} {ENU} client ID will be generated automatically and append timestamp to MQTT client id*)
    clientId         : string [32];  (*`{CSY} {ENU} static client ID, relevant when clientId_auto = false*)
    loginName        : string [32];  (*`{CSY} {ENU} log in name, using when required atherization*)
    loginPass        : string [32];  (*`{CSY} {ENU} password, using when required atherization*)
    com_param        : T_MQTT_COM_PARAM;  (*`{CSY} {ENU} parametrs of MQTT session*)
    topicTxt         : string [80];  (*`{CSY} {ENU} topic where published sends data*)
    sendCom          : bool R_EDGE;  (*`{CSY} {ENU} command to send data*)
    pData            : PTR_TO usint;
    dataLength       : uint;
  END_VAR
  VAR_OUTPUT
    conn_status      : bool;  (*`{CSY} {ENU} TCP connection state*)
    connected_to_broker : bool;  (*`{CSY} {ENU} Connection state to MQTT broker*)
    client_id        : string [32];  (*`{CSY} {ENU} Client ID used in communication session*)
    local_port       : uint;  (*`{CSY} {ENU} current local port*)
    rxCounter        : uint;  (*`{CSY} {ENU} incomming messages counter*)
    txCounter        : uint;  (*`{CSY} {ENU} outgoing messages counter*)
    messageID        : uint;  (*`{CSY} {ENU} message id, used when QOS > 0*)
    busy             : bool;  (*`{CSY} {ENU} broadcasting data state*)
    ok               : bool;  (*`{CSY} {ENU} ready to broadcast new data*)
    err              : bool;  (*`{CSY} {ENU} error occurred*)
    errCode          : usint;  (*`{CSY} {ENU} code of error*)
  END_VAR
  VAR
    MQTT_Comm_Init   : fbMQTT_Comm_Init;
    MQTT_ping_timer  : fbTick;
    MQTT_com_intervat : fbTick;
    MQTT_com_responce_timeout : TON;
    SendTo           : fbSendTo;
    RecvFrom         : fbRecvFrom;
    txData           : ARRAY [0..512] OF usint;
    rxData           : ARRAY [0..512] OF usint;
    payloadLengthArrayTemp : ARRAY [1..4] OF usint;
    MQTT_PROTOCOL    : string [4] :=  'MQTT';
    txMsgLength      : uint;
    payloadLength    : uint;
    txMsgLengthTemp  : uint;
    encodedByte      : byte;
    tx_data_request  : bool;
    localPortExtension : uint;
    idle_time        : usint;
    payloadLengthSize : uint;
    reconnect_counter : usint;
    wait_response    : bool;
    connectFlags     : byte;
    aliveTime        : uint;
    pubReleaseRq     : bool;
    messageIDpubRel  : uint;
    messageIDpubRel_ptr : PTR_TO uint;
    index            : uint;
    responce_recived : bool;  (*`{CSY} {ENU} code of error*)
    errorCounter     : usint;
    messageIDlast    : uint;
  END_VAR
  VAR CONSTANT
    MQTT_PROTOCOL_VERSION : usint :=  4;
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION_BLOCK fbMQTTSubscriber
(*`{ENG} A client tells the broker which topics interest it.
        Once subscribed, the broker sends messages published to that topic.
        (In some configurations the broker sends “missed” messages.) A client can subscribe to multiple topics.
  {CSY}*)
  VAR_INPUT
    connect          : bool;  (*`{CSY} {ENU} Connect or disconnect command*)
    chanCode         : uint;  (*`{CSY} {ENU} Communication channel for MQTT commands and states*)
    brokerIP         : TIPadr;  (*`{CSY} IP adresa MQTT zarízení {ENU} IP address of MQTT broker*)
    brokerPort       : uint :=  1883;  (*`{CSY} port MQTT brokru (výchozí hodnota je 1883) {ENU} port of MQTT broker (default value is 1883)*)
    localPort        : uint :=  5000;  (*`{CSY} lokální port PLC {ENU} local port PLC*)
    keepAlive        : bool :=  true;  (*`{CSY} {ENU} FB keep comm channel opened during communication session (Brocker keeps all settings)*)
    keepAliveInterval : time :=  T#20s;  (*`{CSY} {ENU} maximum time when broker close session and clear all settings of publisher*)
    connTimeOut      : time :=  T#10s;  (*`{CSY} {ENU} maximum timeout of response from broker*)
    pingInterval     : time :=  T#15s;  (*`{CSY} {ENU} Interval for keep alive comm session between publisher and broker MUST BE: keepAliveInterval > pingInterval*)
    clientId_auto    : bool :=  true;  (*`{CSY} {ENU} client ID will be generated automatically and append timestamp to MQTT client id*)
    clientId         : string [32];  (*`{CSY} {ENU} static client ID, relevant when clientId_auto = false*)
    loginName        : string [32];  (*`{CSY} {ENU} log in name, using when required atherization*)
    loginPass        : string [32];  (*`{CSY} {ENU} password, using when required atherization*)
    com_param        : T_MQTT_COM_PARAM;  (*`{CSY} {ENU} parametrs of MQTT session*)
    subRq            : bool R_EDGE;  (*`{CSY} {ENU} Subscribe request*)
    unSubRq          : bool R_EDGE;  (*`{CSY} {ENU} Unsubscribe request*)
    subTopicTxt      : string [80];  (*`{CSY} {ENU} Topic to subscribe or unsubscribe*)
  END_VAR
  VAR_OUTPUT
    conn_status      : bool;  (*`{CSY} {ENU} TCP connection state*)
    connected_to_broker : bool;  (*`{CSY} {ENU} Connection state to MQTT broker*)
    client_id        : string [32];  (*`{CSY} {ENU} Client ID used in communication session*)
    local_port       : uint;  (*`{CSY} {ENU} Current PLC local port*)
    rxCounter        : uint;  (*`{CSY} {ENU} incomming messages counter*)
    txCounter        : uint;  (*`{CSY} {ENU} outgoing messages counter*)
    messageID        : uint;  (*`{CSY} {ENU} message id, used when QOS > 0*)
    busy             : bool;  (*`{CSY} {ENU} broadcasting data state*)
    ok               : bool;  (*`{CSY} {ENU} ready to broadcast new data*)
    err              : bool;  (*`{CSY} {ENU} error occurred*)
    errCode          : usint;  (*`{CSY} {ENU} code of error*)
    dataRec          : bool;  (*`{CSY} {ENU} Data recieved*)
    dataRecDT        : dt;  (*`{CSY} {ENU} Date and time of last recieved data*)
    dataTopicTxt     : string [80];  (*`{CSY} {ENU} Recieved topic*)
    dataTxt          : string [255];  (*`{CSY} {ENU} Recieved data*)
    responce_recived : bool;  (*`{CSY} {ENU} Responce of last command recieved*)
  END_VAR
  VAR
    MQTT_Comm_Init   : fbMQTT_Comm_Init;
    MQTT_ping_timer  : fbTick;
    MQTT_com_intervat : fbTick;
    MQTT_com_responce_timeout : TON;
    index            : usint;
    SendTo           : fbSendTo;
    RecvFrom         : fbRecvFrom;
    txData           : ARRAY [0..100] OF usint;
    rxData           : ARRAY [0..300] OF usint;
    txMsgLength      : usint;
    payloadLength    : usint;
    MQTT_PROTOCOL    : string [4] :=  'MQTT';
    tx_data_request  : bool;
    localPortExtension : uint;
    idle_time        : usint;
    reconnect_counter : usint;
    wait_response    : bool;
    connectFlags     : byte;
    aliveTime        : uint;
    inDataCom_param  : T_MQTT_COM_PARAM;
    inTopicLen       : uint;
    inMsgLen         : uint;
    pubAckRq         : bool;
    messageIDpubAck_ptr : PTR_TO uint;
    messageIDpubAck  : uint;
    pubRecRq         : bool;
    pubCompRq        : bool;
    payloadLengthSize : uint;
    payloadLengthBytes : uint;
  END_VAR
  VAR CONSTANT
    MQTT_PROTOCOL_VERSION : usint :=  4;
  END_VAR
END_FUNCTION_BLOCK

__DECL FUNCTION_BLOCK fbMQTTSubscriberEx
(*`{ENG} A client tells the broker which topics interest it.
        Once subscribed, the broker sends messages published to that topic.
        (In some configurations the broker sends “missed” messages.) A client can subscribe to multiple topics.
  {CSY}*)
  VAR_INPUT
    connect          : bool;  (*`{CSY} {ENU} Connect or disconnect command*)
    chanCode         : uint;  (*`{CSY} {ENU} Communication channel for MQTT commands and states*)
    brokerIP         : TIPadr;  (*`{CSY} IP adresa MQTT zarízení {ENU} IP address of MQTT broker*)
    brokerPort       : uint :=  1883;  (*`{CSY} port MQTT brokru (výchozí hodnota je 1883) {ENU} port of MQTT broker (default value is 1883)*)
    localPort        : uint :=  5000;  (*`{CSY} lokální port PLC {ENU} local port PLC*)
    keepAlive        : bool :=  true;  (*`{CSY} {ENU} FB keep comm channel opened during communication session (Brocker keeps all settings)*)
    keepAliveInterval : time :=  T#20s;  (*`{CSY} {ENU} maximum time when broker close session and clear all settings of publisher*)
    connTimeOut      : time :=  T#10s;  (*`{CSY} {ENU} maximum timeout of response from broker*)
    pingInterval     : time :=  T#15s;  (*`{CSY} {ENU} Interval for keep alive comm session between publisher and broker MUST BE: keepAliveInterval > pingInterval*)
    clientId_auto    : bool :=  true;  (*`{CSY} {ENU} client ID will be generated automatically and append timestamp to MQTT client id*)
    clientId         : string [32];  (*`{CSY} {ENU} static client ID, relevant when clientId_auto = false*)
    loginName        : string [32];  (*`{CSY} {ENU} log in name, using when required atherization*)
    loginPass        : string [32];  (*`{CSY} {ENU} password, using when required atherization*)
    com_param        : T_MQTT_COM_PARAM;  (*`{CSY} {ENU} parametrs of MQTT session*)
    subRq            : bool R_EDGE;  (*`{CSY} {ENU} Subscribe request*)
    unSubRq          : bool R_EDGE;  (*`{CSY} {ENU} Unsubscribe request*)
    subTopicTxt      : string [80];  (*`{CSY} {ENU} Topic to subscribe or unsubscribe*)
    pData            : PTR_TO usint;
  END_VAR
  VAR_OUTPUT
    conn_status      : bool;  (*`{CSY} {ENU} TCP connection state*)
    connected_to_broker : bool;  (*`{CSY} {ENU} Connection state to MQTT broker*)
    client_id        : string [32];  (*`{CSY} {ENU} Client ID used in communication session*)
    local_port       : uint;  (*`{CSY} {ENU} Current PLC local port*)
    rxCounter        : uint;  (*`{CSY} {ENU} incomming messages counter*)
    txCounter        : uint;  (*`{CSY} {ENU} outgoing messages counter*)
    messageID        : uint;  (*`{CSY} {ENU} message id, used when QOS > 0*)
    busy             : bool;  (*`{CSY} {ENU} broadcasting data state*)
    ok               : bool;  (*`{CSY} {ENU} ready to broadcast new data*)
    err              : bool;  (*`{CSY} {ENU} error occurred*)
    errCode          : usint;  (*`{CSY} {ENU} code of error*)
    dataRec          : bool;  (*`{CSY} {ENU} Data recieved*)
    dataRecDT        : dt;  (*`{CSY} {ENU} Date and time of last recieved data*)
    dataTopicTxt     : string [80];  (*`{CSY} {ENU} Recieved topic*)
    responce_recived : bool;  (*`{CSY} {ENU} Responce of last command recieved*)
  END_VAR
  VAR
    MQTT_Comm_Init   : fbMQTT_Comm_Init;
    MQTT_ping_timer  : fbTick;
    MQTT_com_intervat : fbTick;
    MQTT_com_responce_timeout : TON;
    index            : usint;
    SendTo           : fbSendTo;
    RecvFrom         : fbRecvFrom;
    txData           : ARRAY [0..100] OF usint;
    rxData           : ARRAY [0..512] OF usint;
    txMsgLength      : usint;
    payloadLength    : usint;
    MQTT_PROTOCOL    : string [4] :=  'MQTT';
    tx_data_request  : bool;
    localPortExtension : uint;
    idle_time        : usint;
    reconnect_counter : usint;
    wait_response    : bool;
    connectFlags     : byte;
    aliveTime        : uint;
    inDataCom_param  : T_MQTT_COM_PARAM;
    inTopicLen       : uint;
    inMsgLen         : uint;
    pubAckRq         : bool;
    messageIDpubAck_ptr : PTR_TO uint;
    messageIDpubAck  : uint;
    pubRecRq         : bool;
    pubCompRq        : bool;
    payloadLengthSize : uint;
    payloadLengthBytes : uint;
  END_VAR
  VAR CONSTANT
    MQTT_PROTOCOL_VERSION : usint :=  4;
  END_VAR
END_FUNCTION_BLOCK



{USES=fbMQTT_Comm_Init:GetRemoteIPaddress,CloseTCPconnection,IsEstabTCPconnection,SetRemoteIPaddress,EstabTCPconnection}
{USES=fbMQTTPublisher:GetRTC,MSEC_OF_DT,MemcpyPtr,fSwapUINT}
{USES=fbMQTTPublisherEx:GetRTC,MSEC_OF_DT,MemcpyPtr,fSwapUINT}
{USES=fbMQTTSubscriber:GetRTC,MSEC_OF_DT,MemcpyPtr,fSwapUINT,GetDateTime}
{USES=fbMQTTSubscriberEx:GetRTC,MSEC_OF_DT,MemcpyPtr,fSwapUINT,GetDateTime}
#srcfile 'D:\TECOLIBSRC\MQTT_LIB\MQTT_LIB\FBMQTTCONTROL.ST'
#pou MQTT_Lib_support
#srcline 57 ;FUNCTION MQTT_Lib_support {HIDDEN} : bool

#struct MQTT_Lib_support__temp__
  bool tmp
P     61
MQTT_Lib_support_L0:
 LINK __SizeOf(MQTT_Lib_support__temp__)
 NXT
; Initialize - dynamic variables
; End initialize - dynamic variables
#srcline 68 ;begin
#srcline 69 ;  {asm}
#srcline 70
     LD     0
#srcline 71
     LEAY   tmp
#srcline 72
     LDX    code      ;napr. TXF 689 22
#srcline 73
     SYS    1         ;testovat existenci AP
#srcline 74
     LD    -1
#srcline 75
     EQ
#srcline 76
     LD    %S43
#srcline 77
     AND   $F0
#srcline 78
     EQ    $10        ;simulator, nekontrolovat
#srcline 79
     OR
#srcline 80
     WRY    tmp       ;tmp = -1 ... AP existuje nebo bezi simulator
#srcline 81 ;  {end_asm}
#srcline 82 ;  MQTT_Lib_support := tmp OR (tim > %SL52);
 LDY  tmp
#debug bool tmp
 LDX  tim
#debug udint tim
 LD   %SL52
 GT
 OR  
 WRX  __fc__MQTT_Lib_support
#debug_left bool MQTT_Lib_support
#srcline 83 ;END_FUNCTION
 PRV  
 LDX  __fc__MQTT_Lib_support
 ULNK
RET
E     61
#endpou 

#pou fSwapUINT
#srcline 86 ;FUNCTION fSwapUINT {HIDDEN} : UINT
P     61
fSwapUINT_L0:
 LINK 0
 NXT
; Initialize - variables
 LD   0
 WRX  __fc__fSwapUINT
; End initialize - variables
#srcline 92 ;begin
#srcline 93 ;  {asm}
#srcline 94
	  ldx    input             ;nacist 2 byty
#srcline 95
	  swp				               ;prohodit spodni horni byte
#srcline 96
	  wrx    __fc__fSwapUINT   ;zapsat zpet
#srcline 97 ;  {end_asm}
#srcline 99 ;END_FUNCTION
 PRV  
 LDX  __fc__fSwapUINT
 ULNK
RET
E     61
#endpou 

#pou fbMQTT_Comm_Init
#srcline 103 ;FUNCTION_BLOCK fbMQTT_Comm_Init {HIDDEN}
P     61
fbMQTT_Comm_Init_L0:
 LINK 0
#srcline 123 ;  status := true;
 LD   bool -1       ; true
 WRX  status
#debug_left bool status
#srcline 125 ;  GetRemoteIPaddress(chanCode, ethAdr);
 NXT
 LDX  chanCode
#debug uint chanCode
 WR   __Instance__GetRemoteIPaddress~chanCode
#debug_left uint __Instance__GetRemoteIPaddress~chanCode
 LEAX ethAdr
 WR   __Instance__GetRemoteIPaddress~ethAdr
#debug_left pointer __Instance__GetRemoteIPaddress.ethAdr
 PRV
 LEA  __Instance__GetRemoteIPaddress
 CAL  GetRemoteIPaddress_L0
#srcline 127 ;  if (ethAdr.localPort <> localPort) OR connect = false then
 LDX  ethAdr~localPort
#debug uint ethAdr.localPort
 LDX  localPort
#debug uint localPort
 EQ
 NEG
 LDX  connect
#debug bool connect
 LD   bool 0       ; false
 XOR
 NEG
 OR  
 JMC  fbMQTT_Comm_Init_L1
#srcline 128 ;       CloseTCPConnection(chanCode);
 NXT
 LDX  chanCode
#debug uint chanCode
 WR   __Instance__CloseTCPconnection~chanCode
#debug_left uint __Instance__CloseTCPconnection~chanCode
 PRV
 LEA  __Instance__CloseTCPconnection
 CAL  CloseTCPconnection_L0
#srcline 129 ;       status := false;
 LD   bool 0       ; false
 WRX  status
#debug_left bool status
#srcline 130 ;  end_if;
fbMQTT_Comm_Init_L1:
#srcline 131 ;  if connect = true  then
 LDX  connect
#debug bool connect
 LD   bool -1       ; true
 XOR
 NEG
 JMC  fbMQTT_Comm_Init_L3
#srcline 132 ;      if IsEstabTCPconnection(chanCode) = false then
 NXT
 LDX  chanCode
#debug uint chanCode
 WR   __Instance__IsEstabTCPconnection~chanCode
#debug_left uint __Instance__IsEstabTCPconnection~chanCode
 PRV
 LEA  __Instance__IsEstabTCPconnection
 CAL  IsEstabTCPconnection_L0
 LD   bool 0       ; false
 XOR
 NEG
 JMC  fbMQTT_Comm_Init_L5
#srcline 133 ;           status := false;
 LD   bool 0       ; false
 WRX  status
#debug_left bool status
#srcline 134 ;          ethAdr.remoteIP   := remoteIP;
 LEAX remoteIP
#debug pointer remoteIP
 SRC  %IB0
 LEAX ethAdr~remoteIP
#debug_left pointer ethAdr.remoteIP
 LD   4   ;SizeOf() 
 MOV  %IB0
#srcline 135 ;          ethAdr.remotePort := remotePort;
 LDX  remotePort
#debug uint remotePort
 WRX  ethAdr~remotePort
#debug_left uint ethAdr.remotePort
#srcline 136 ;          ethAdr.localPort  := localPort;
 LDX  localPort
#debug uint localPort
 WRX  ethAdr~localPort
#debug_left uint ethAdr.localPort
#srcline 138 ;          SetRemoteIPaddress( true, chanCode, ethAdr );
 NXT
 LD   bool -1       ; true
 WR   __Instance__SetRemoteIPaddress~rq
#debug_left bool __Instance__SetRemoteIPaddress~rq
 LDX  chanCode
#debug uint chanCode
 WR   __Instance__SetRemoteIPaddress~chanCode
#debug_left uint __Instance__SetRemoteIPaddress~chanCode
 LEAX ethAdr
 WR   __Instance__SetRemoteIPaddress~ethAdr
#debug_left pointer __Instance__SetRemoteIPaddress.ethAdr
 PRV
 LEA  __Instance__SetRemoteIPaddress
 CAL  SetRemoteIPaddress_L0
#srcline 139 ;          EstabTCPconnection( chanCode );
 NXT
 LDX  chanCode
#debug uint chanCode
 WR   __Instance__EstabTCPconnection~chanCode
#debug_left uint __Instance__EstabTCPconnection~chanCode
 PRV
 LEA  __Instance__EstabTCPconnection
 CAL  EstabTCPconnection_L0
#srcline 140 ;          KeepAliveTCP(rq := keepAlive,chanCode := chanCode, PT := T#5s, error => error);
 LDX  keepAlive
#debug bool keepAlive
 WRX  KeepAliveTCP~rq
#debug_left bool KeepAliveTCP~rq
 LDX  chanCode
#debug uint chanCode
 WRX  KeepAliveTCP~chanCode
#debug_left uint KeepAliveTCP~chanCode
 LD   time 5000
 WRX  KeepAliveTCP~PT
#debug_left time KeepAliveTCP~PT
 LEAX KeepAliveTCP
 CAL  fbKeepAliveTCP_L0
; output assigment 
 LDX  KeepAliveTCP~error
#debug usint KeepAliveTCP~error
 WRX  error
#debug_left usint error
#srcline 141 ;      end_if;
fbMQTT_Comm_Init_L5:
#srcline 142 ;  else
 JMP  fbMQTT_Comm_Init_L4
fbMQTT_Comm_Init_L3:
#srcline 143 ;    status := false;
 LD   bool 0       ; false
 WRX  status
#debug_left bool status
#srcline 144 ;  end_if;
fbMQTT_Comm_Init_L4:
#srcline 145 ;END_FUNCTION_BLOCK
 ULNK
RET
E     61

; Initialize - variables
P     61
fbMQTT_Comm_Init__InstanceInit__:
 LINK 0
 LD   bool -1   ; true
 WRX  keepAlive
 ULNK
RET
E     61
; End initialize - variables
#endpou 

#pou fbMQTTPublisher
#srcline 149 ;FUNCTION_BLOCK fbMQTTPublisher
#table byte __Init___fbMQTTPublisher_com_param = 
      0,  0,  1;
#table byte __Init___fbMQTTPublisher_MQTT_PROTOCOL = 
    'M','Q','T','T';

#struct fbMQTTPublisher__temp__
  usint P0__st__,
  string[34] PS0__st__,
  string[34] PSC__st__
#data byte _str_fbMQTTPublisher_0 = 
  '',0
#data byte _str_fbMQTTPublisher_1 = 
  '',0
P     61
fbMQTTPublisher_L0:
 LINK __SizeOf(fbMQTTPublisher__temp__)
; Initialize - dynamic variables
; End initialize - dynamic variables
; R_EDGE, F_EDGE 
 LDX  sendCom
 LETX __EDGE_R__sendCom
 WRX  sendCom
#srcline 240 ;    if MQTT_com_responce_timeout.Q then
 LDX  MQTT_com_responce_timeout~Q
#debug bool MQTT_com_responce_timeout.Q
 JMC  fbMQTTPublisher_L1
#srcline 241 ;      if responce_recived = false then
 LDX  responce_recived
#debug bool responce_recived
 LD   bool 0       ; false
 XOR
 NEG
 JMC  fbMQTTPublisher_L3
#srcline 242 ;          connected_to_broker := false;
 LD   bool 0       ; false
 WRX  connected_to_broker
#debug_left bool connected_to_broker
#srcline 243 ;      end_if;
fbMQTTPublisher_L3:
#srcline 244 ;      wait_response := false;
 LD   bool 0       ; false
 WRX  wait_response
#debug_left bool wait_response
#srcline 245 ;      busy    := false;
 LD   bool 0       ; false
 WRX  busy
#debug_left bool busy
#srcline 246 ;      ok      := false;
 LD   bool 0       ; false
 WRX  ok
#debug_left bool ok
#srcline 247 ;      err     := true;
 LD   bool -1       ; true
 WRX  err
#debug_left bool err
#srcline 248 ;      errCode := MQTT_CONTROL_ERROR_CODE_BROKER_ANSWER_TIME_OUT;
 LD   usint 1
 WRX  errCode
#debug_left usint errCode
#srcline 249 ;   end_if;
fbMQTTPublisher_L1:
#srcline 251 ;   local_port := localPort + localPortExtension;
 LDX  localPort
#debug uint localPort
 LDX  localPortExtension
#debug uint localPortExtension
 ADD
 AND  $FFFF
 WRX  local_port
#debug_left uint local_port
#srcline 252 ;   MQTT_Comm_Init( connect := connect, chanCode := chanCode, remoteIP := brokerIP, remotePort := brokerPort, localPort := localPort + localPortExtension,
 LDX  connect
#debug bool connect
 WRX  MQTT_Comm_Init~connect
#debug_left bool MQTT_Comm_Init~connect
 LDX  chanCode
#debug uint chanCode
 WRX  MQTT_Comm_Init~chanCode
#debug_left uint MQTT_Comm_Init~chanCode
 LEAX brokerIP
#debug pointer brokerIP
 SRC  %IB0
 LEAX MQTT_Comm_Init~remoteIP
 LD   4   ;SizeOf() 
 MOV  %IB0
 LDX  brokerPort
#debug uint brokerPort
 WRX  MQTT_Comm_Init~remotePort
#debug_left uint MQTT_Comm_Init~remotePort
 LDX  localPort
#debug uint localPort
 LDX  localPortExtension
#debug uint localPortExtension
 ADD
 AND  $FFFF
 WRX  MQTT_Comm_Init~localPort
#debug_left uint MQTT_Comm_Init~localPort
#srcline 253 ;                  status       => conn_status);
 LEAX MQTT_Comm_Init
 CAL  fbMQTT_Comm_Init_L0
; output assigment 
 LDX  MQTT_Comm_Init~status
#debug bool MQTT_Comm_Init~status
 WRX  conn_status
#debug_left bool conn_status
#srcline 255 ;   MQTT_com_responce_timeout(IN := wait_response,PT := connTimeOut);
 LDX  wait_response
#debug bool wait_response
 WRX  MQTT_com_responce_timeout~IN
#debug_left bool MQTT_com_responce_timeout~IN
 LDX  connTimeOut
#debug time connTimeOut
 WRX  MQTT_com_responce_timeout~PT
#debug_left time MQTT_com_responce_timeout~PT
 LEAX MQTT_com_responce_timeout
 CAL  TON_L0
#srcline 256 ;   MQTT_ping_timer(IN := connect AND keepAlive, PT := pingInterval);
 LDX  connect
#debug bool connect
 LDX  keepAlive
#debug bool keepAlive
 AND
 WRX  MQTT_ping_timer~IN
#debug_left bool MQTT_ping_timer~IN
 LDX  pingInterval
#debug time pingInterval
 WRX  MQTT_ping_timer~PT
#debug_left time MQTT_ping_timer~PT
 LEAX MQTT_ping_timer
 CAL  fbTick_L0
#srcline 257 ;   MQTT_com_intervat(IN := connect, PT := T#2s);
 LDX  connect
#debug bool connect
 WRX  MQTT_com_intervat~IN
#debug_left bool MQTT_com_intervat~IN
 LD   time 2000
 WRX  MQTT_com_intervat~PT
#debug_left time MQTT_com_intervat~PT
 LEAX MQTT_com_intervat
 CAL  fbTick_L0
#srcline 259 ;   if connect then
 LDX  connect
#debug bool connect
 JMC  fbMQTTPublisher_L5
#srcline 260 ;       if MQTT_com_intervat.Q OR sendCom OR pubReleaseRq then
 LDX  MQTT_com_intervat~Q
#debug bool MQTT_com_intervat.Q
 LDX  sendCom
#debug bool sendCom
 OR  
 LDX  pubReleaseRq
#debug bool pubReleaseRq
 OR  
 JMC  fbMQTTPublisher_L7
#srcline 261 ;           if connected_to_broker = false then
 LDX  connected_to_broker
#debug bool connected_to_broker
 LD   bool 0       ; false
 XOR
 NEG
 JMC  fbMQTTPublisher_L9
#srcline 262 ;                 if clientId_auto then
 LDX  clientId_auto
#debug bool clientId_auto
 JMC  fbMQTTPublisher_L11
#srcline 263 ;                     client_id := DWORD_TO_STRING(DT_TO_DWORD(GetRTC())) + UINT_TO_STRING(MSEC_OF_DT(GetRTC()));
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   32
 DST    ; Level 1
 LD   0   ; null string
 WRY  PSC__st__[0]
 LEAY PSC__st__[0]
 LD   32
 DST    ; Level 2
 LEA  __Instance__GetRTC
 CAL  GetRTC_L0
 RNDD
 UDFL
 SCNV $2C30;  IEC_DWORD _TO_ IEC_STRING
 PDST   ; Level 2
 LEAY PSC__st__[0]

 SCON 
 LD   0   ; null string
 WRY  PSC__st__[0]
 LEAY PSC__st__[0]
 LD   32
 DST    ; Level 2
 NXT
 LEA  __Instance__GetRTC
 CAL  GetRTC_L0
 WR   __Instance__MSEC_OF_DT~in
#debug_left dt __Instance__MSEC_OF_DT~in
 PRV
 LEA  __Instance__MSEC_OF_DT
 CAL  MSEC_OF_DT_L0
 SCNV $0A30;  IEC_UINT _TO_ IEC_STRING
 PDST   ; Level 2
 LEAY PSC__st__[0]

 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX client_id
 WRI  
 LEAX client_id
 LD   32
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string client_id
 PDST   ; Level 1
#srcline 264 ;                 else
 JMP  fbMQTTPublisher_L12
fbMQTTPublisher_L11:
#srcline 265 ;                     client_id := clientId;
 LD   0   ; null string
 LEAX client_id
 WRI  
 LEAX client_id
 LD   32
 DST    ; Level 1
 LEAX clientId
#debug string clientId
 SCON 
#debug_left string client_id
 PDST   ; Level 1
#srcline 266 ;                 end_if;
fbMQTTPublisher_L12:
#srcline 268 ;                // Fixed header of control packet
#srcline 269 ;                // Fixed header
#srcline 270 ;                txData[0] := MQTT_CONTROL_PACK_CONNECT; // flag bits are cleared
 LD   usint 16
 WRX  txData[0]
#debug_left usint txData[0]
#srcline 271 ;                // Variable header
#srcline 272 ;                txData[2] := 0;
 LD   usint 0
 WRX  txData[2]
#debug_left usint txData[2]
#srcline 273 ;                txData[3] := 4;
 LD   usint 4
 WRX  txData[3]
#debug_left usint txData[3]
#srcline 274 ;                MemcpyPtr(source := ADR(MQTT_PROTOCOL),dest := ADR(txData[4]),length := 4);
 NXT
 LEAX MQTT_PROTOCOL
#debug pointer MQTT_PROTOCOL
 LEA  __Instance__MemcpyPtr~source
 WRIL 
#debug_left udint __Instance__MemcpyPtr~source
 LEAX txData
 ADD  4  ; + offset 
#debug pointer txData[4]
 LEA  __Instance__MemcpyPtr~dest
 WRIL 
#debug_left udint __Instance__MemcpyPtr~dest
 LD   udint 4
 WR   __Instance__MemcpyPtr~length
#debug_left udint __Instance__MemcpyPtr~length
 PRV
 LEA  __Instance__MemcpyPtr
 CAL  MemcpyPtr_L0
#srcline 275 ;                txData[8]   := MQTT_PROTOCOL_VERSION;
 LD   usint 4
 WRX  txData[8]
#debug_left usint txData[8]
#srcline 276 ;                // Protocol Level byte
#srcline 277 ;                //Set connection flags
#srcline 278 ;                connectFlags := 0;
 LD   byte 0
 WRX  connectFlags
#debug_left byte connectFlags
#srcline 279 ;                if loginName <> ''        then connectFlags := 16#80; end_if;
 LEAX loginName
#debug string loginName
 LEA  _str_fbMQTTPublisher_0
 SCMP 
 EQ   0
 NEG
 JMC  fbMQTTPublisher_L13
 LD   byte $80
 WRX  connectFlags
#debug_left byte connectFlags
fbMQTTPublisher_L13:
#srcline 280 ;                if loginPass <> ''        then connectFlags := connectFlags OR 16#40; end_if;
 LEAX loginPass
#debug string loginPass
 LEA  _str_fbMQTTPublisher_1
 SCMP 
 EQ   0
 NEG
 JMC  fbMQTTPublisher_L15
 LDX  connectFlags
#debug byte connectFlags
 LD   byte $40
 OR  
 WRX  connectFlags
#debug_left byte connectFlags
fbMQTTPublisher_L15:
#srcline 281 ;                //if com_param.willRetain   then connectFlags := connectFlags OR 16#20; end_if;
#srcline 282 ;               // connectFlags := connectFlags OR SHL(IN := USINT_TO_BYTE(com_param.qos),N := 3);
#srcline 283 ;                if com_param.cleanSession then connectFlags := connectFlags OR 16#2;  end_if;
 LDX  com_param~cleanSession
#debug bool com_param.cleanSession
 JMC  fbMQTTPublisher_L17
 LDX  connectFlags
#debug byte connectFlags
 LD   byte $2
 OR  
 WRX  connectFlags
#debug_left byte connectFlags
fbMQTTPublisher_L17:
#srcline 285 ;                txData[9]   := BYTE_TO_USINT(connectFlags);//For connect set clean session
 LDX  connectFlags
#debug byte connectFlags
 WRX  txData[9]
#debug_left usint txData[9]
#srcline 286 ;                //keep alive 2 bytes, MSB+LSB
#srcline 287 ;                aliveTime := TIME_TO_UINT(keepAliveInterval)/1000;
 LDX  keepAliveInterval
#debug time keepAliveInterval
AND  $FFFF
 LD   uint 1000
 DIVL
 AND  $FFFF
 WRX  aliveTime
#debug_left uint aliveTime
#srcline 289 ;                txData[10]  := 0;
 LD   usint 0
 WRX  txData[10]
#debug_left usint txData[10]
#srcline 290 ;                txData[11]  := UINT_TO_USINT(aliveTime);
 LDX  aliveTime
#debug uint aliveTime
 AND  $FF
 WRX  txData[11]
#debug_left usint txData[11]
#srcline 291 ;                //Payload
#srcline 292 ;                payloadLength := LEN(IN := client_id);
 LEAX client_id
#debug string client_id
 SLEN 
 WRX  payloadLength
#debug_left uint payloadLength
#srcline 293 ;                txData[12]  := WORD_TO_USINT(SHR(IN := UINT_TO_WORD(payloadLength),N := 8));
 LDX  payloadLength
#debug uint payloadLength
 LD   uint 8
 SHR
 AND  $FFFF
 AND  $FF
 WRX  txData[12]
#debug_left usint txData[12]
#srcline 294 ;                txData[13]  := UINT_TO_USINT(payloadLength);
 LDX  payloadLength
#debug uint payloadLength
 AND  $FF
 WRX  txData[13]
#debug_left usint txData[13]
#srcline 296 ;                txMsgLength := 14;
 LD   uint 14
 WRX  txMsgLength
#debug_left uint txMsgLength
#srcline 297 ;                //Copy client ID
#srcline 298 ;                MemcpyPtr(source := ADR(client_id),dest := ADR(txData[14]), length := UINT_TO_UDINT(payloadLength));
 NXT
 LEAX client_id
#debug pointer client_id
 LEA  __Instance__MemcpyPtr~source
 WRIL 
#debug_left udint __Instance__MemcpyPtr~source
 LEAX txData
 ADD  14  ; + offset 
#debug pointer txData[14]
 LEA  __Instance__MemcpyPtr~dest
 WRIL 
#debug_left udint __Instance__MemcpyPtr~dest
 LDX  payloadLength
#debug uint payloadLength
 WR   __Instance__MemcpyPtr~length
#debug_left udint __Instance__MemcpyPtr~length
 PRV
 LEA  __Instance__MemcpyPtr
 CAL  MemcpyPtr_L0
#srcline 299 ;                txMsgLength := txMsgLength + payloadLength;
 LDX  txMsgLength
#debug uint txMsgLength
 LDX  payloadLength
#debug uint payloadLength
 ADD
 AND  $FFFF
 WRX  txMsgLength
#debug_left uint txMsgLength
#srcline 300 ;                //Copy user name
#srcline 301 ;                if (connectFlags AND 16#80) > 0 then
 LDX  connectFlags
#debug byte connectFlags
 LD   byte $80
 AND
 LD   byte 0
 GT
 JMC  fbMQTTPublisher_L19
#srcline 302 ;                     txData[txMsgLength]     := 0;
 LD   usint 0
 LEAX txData
 LDX  txMsgLength
#debug uint txMsgLength
 RCHK 300   ; Range Check
 ADD     ; + offset 
 WRI 
#debug_left usint txData[txMsgLength]
#srcline 303 ;                     txData[txMsgLength + 1] := LEN(IN := loginName);
 LEAX loginName
#debug string loginName
 SLEN 
 LEAX txData
 LDX  txMsgLength
#debug uint txMsgLength
 LD   uint 1
 ADD
 AND  $FFFF
 RCHK 300   ; Range Check
 ADD     ; + offset 
 WRI 
#debug_left usint txData[txMsgLength+1]
#srcline 304 ;                     payloadLength := LEN(IN := loginName);
 LEAX loginName
#debug string loginName
 SLEN 
 WRX  payloadLength
#debug_left uint payloadLength
#srcline 305 ;                     MemcpyPtr(source := ADR(loginName),dest := ADR(txData[txMsgLength + 2]),length := UINT_TO_UDINT(payloadLength));
 NXT
 LEAX loginName
#debug pointer loginName
 LEA  __Instance__MemcpyPtr~source
 WRIL 
#debug_left udint __Instance__MemcpyPtr~source
 LEAX txData
 LDX  txMsgLength
#debug uint txMsgLength
 LD   uint 2
 ADD
 AND  $FFFF
 RCHK 300   ; Range Check
 ADD     ; + offset 
#debug pointer txData[txMsgLength+2]
 LEA  __Instance__MemcpyPtr~dest
 WRIL 
#debug_left udint __Instance__MemcpyPtr~dest
 LDX  payloadLength
#debug uint payloadLength
 WR   __Instance__MemcpyPtr~length
#debug_left udint __Instance__MemcpyPtr~length
 PRV
 LEA  __Instance__MemcpyPtr
 CAL  MemcpyPtr_L0
#srcline 306 ;                     txMsgLength := txMsgLength + payloadLength + 2;
 LDX  txMsgLength
#debug uint txMsgLength
 LDX  payloadLength
#debug uint payloadLength
 ADD
 AND  $FFFF
 LD   uint 2
 ADD
 AND  $FFFF
 WRX  txMsgLength
#debug_left uint txMsgLength
#srcline 307 ;                end_if;
fbMQTTPublisher_L19:
#srcline 308 ;                //Copy password
#srcline 309 ;                if (connectFlags AND 16#40) > 0 then
 LDX  connectFlags
#debug byte connectFlags
 LD   byte $40
 AND
 LD   byte 0
 GT
 JMC  fbMQTTPublisher_L21
#srcline 310 ;                     txData[txMsgLength]     := 0;
 LD   usint 0
 LEAX txData
 LDX  txMsgLength
#debug uint txMsgLength
 RCHK 300   ; Range Check
 ADD     ; + offset 
 WRI 
#debug_left usint txData[txMsgLength]
#srcline 311 ;                     txData[txMsgLength + 1] := LEN(IN := loginPass);
 LEAX loginPass
#debug string loginPass
 SLEN 
 LEAX txData
 LDX  txMsgLength
#debug uint txMsgLength
 LD   uint 1
 ADD
 AND  $FFFF
 RCHK 300   ; Range Check
 ADD     ; + offset 
 WRI 
#debug_left usint txData[txMsgLength+1]
#srcline 312 ;                     payloadLength := LEN(IN := loginPass);
 LEAX loginPass
#debug string loginPass
 SLEN 
 WRX  payloadLength
#debug_left uint payloadLength
#srcline 313 ;                     MemcpyPtr(source := ADR(loginPass),dest := ADR(txData[txMsgLength + 2]),length := UINT_TO_UDINT(payloadLength));
 NXT
 LEAX loginPass
#debug pointer loginPass
 LEA  __Instance__MemcpyPtr~source
 WRIL 
#debug_left udint __Instance__MemcpyPtr~source
 LEAX txData
 LDX  txMsgLength
#debug uint txMsgLength
 LD   uint 2
 ADD
 AND  $FFFF
 RCHK 300   ; Range Check
 ADD     ; + offset 
#debug pointer txData[txMsgLength+2]
 LEA  __Instance__MemcpyPtr~dest
 WRIL 
#debug_left udint __Instance__MemcpyPtr~dest
 LDX  payloadLength
#debug uint payloadLength
 WR   __Instance__MemcpyPtr~length
#debug_left udint __Instance__MemcpyPtr~length
 PRV
 LEA  __Instance__MemcpyPtr
 CAL  MemcpyPtr_L0
#srcline 314 ;                     txMsgLength := txMsgLength + payloadLength + 2;
 LDX  txMsgLength
#debug uint txMsgLength
 LDX  payloadLength
#debug uint payloadLength
 ADD
 AND  $FFFF
 LD   uint 2
 ADD
 AND  $FFFF
 WRX  txMsgLength
#debug_left uint txMsgLength
#srcline 315 ;                end_if;
fbMQTTPublisher_L21:
#srcline 318 ;                // length of package
#srcline 319 ;                txData[1]       := UINT_TO_USINT(txMsgLength);
 LDX  txMsgLength
#debug uint txMsgLength
 AND  $FF
 WRX  txData[1]
#debug_left usint txData[1]
#srcline 320 ;                txMsgLength     := txMsgLength + 2;
 LDX  txMsgLength
#debug uint txMsgLength
 LD   uint 2
 ADD
 AND  $FFFF
 WRX  txMsgLength
#debug_left uint txMsgLength
#srcline 321 ;                tx_data_request := true;
 LD   bool -1       ; true
 WRX  tx_data_request
#debug_left bool tx_data_request
#srcline 323 ;                localPortExtension := USINT_TO_UINT(reconnect_counter);
 LDX  reconnect_counter
#debug usint reconnect_counter
 AND  $FFFF
 WRX  localPortExtension
#debug_left uint localPortExtension
#srcline 324 ;                idle_time := 2;
 LD   usint 2
 WRX  idle_time
#debug_left usint idle_time
#srcline 325 ;                // required to change port on each reconnect
#srcline 326 ;                if reconnect_counter < 100 then
 LDX  reconnect_counter
#debug usint reconnect_counter
 LD   usint 100
 LT
 JMC  fbMQTTPublisher_L23
#srcline 327 ;                    reconnect_counter := reconnect_counter + 1; //
 LDX  reconnect_counter
#debug usint reconnect_counter
 LD   usint 1
 ADD
 AND  $FF
 WRX  reconnect_counter
#debug_left usint reconnect_counter
#srcline 328 ;                else
 JMP  fbMQTTPublisher_L24
fbMQTTPublisher_L23:
#srcline 329 ;                    reconnect_counter := 0;
 LD   usint 0
 WRX  reconnect_counter
#debug_left usint reconnect_counter
#srcline 330 ;                end_if;
fbMQTTPublisher_L24:
#srcline 331 ;                responce_recived := false;
 LD   bool 0       ; false
 WRX  responce_recived
#debug_left bool responce_recived
#srcline 332 ;                
#srcline 333 ;                busy := true;
 LD   bool -1       ; true
 WRX  busy
#debug_left bool busy
#srcline 334 ;                ok   := false;
 LD   bool 0       ; false
 WRX  ok
#debug_left bool ok
#srcline 335 ;                err  := false;
 LD   bool 0       ; false
 WRX  err
#debug_left bool err
#srcline 336 ;                return;
 JMP  fbMQTTPublisher_RET
#srcline 337 ;           //-------------------- Connected to broker -------------------------------------------------
#srcline 338 ;           else
 JMP  fbMQTTPublisher_L10
fbMQTTPublisher_L9:
#srcline 339 ;                if sendCom then
 LDX  sendCom
#debug bool sendCom
 JMC  fbMQTTPublisher_L25
#srcline 340 ;                    sendCom := false;
 LD   bool 0       ; false
 WRX  sendCom
#debug_left bool sendCom
#srcline 341 ;                     connectFlags := USINT_TO_BYTE(MQTT_CONTROL_PACK_PUBLISH);
 LD   usint 48
 AND  $FF
 WRX  connectFlags
#debug_left byte connectFlags
#srcline 342 ;                     if com_param.dup then connectFlags := connectFlags OR 16#8;  end_if;
 LDX  com_param~dup
#debug bool com_param.dup
 JMC  fbMQTTPublisher_L27
 LDX  connectFlags
#debug byte connectFlags
 LD   byte $8
 OR  
 WRX  connectFlags
#debug_left byte connectFlags
fbMQTTPublisher_L27:
#srcline 343 ;                     connectFlags := connectFlags OR SHL(IN := USINT_TO_BYTE(com_param.qos),N := 1);
 LDX  connectFlags
#debug byte connectFlags
 LDX  com_param~qos
#debug usint com_param.qos
 AND  $FF
 LD   uint 1
 SHL
 AND  $FF
 OR  
 WRX  connectFlags
#debug_left byte connectFlags
#srcline 344 ;                     if com_param.willRetain   then connectFlags := connectFlags OR 16#1; end_if;
 LDX  com_param~willRetain
#debug bool com_param.willRetain
 JMC  fbMQTTPublisher_L29
 LDX  connectFlags
#debug byte connectFlags
 LD   byte $1
 OR  
 WRX  connectFlags
#debug_left byte connectFlags
fbMQTTPublisher_L29:
#srcline 346 ;                     txData[0]     := BYTE_TO_USINT(connectFlags);
 LDX  connectFlags
#debug byte connectFlags
 WRX  txData[0]
#debug_left usint txData[0]
#srcline 348 ;                     payloadLength := LEN(IN := topicTxt);
 LEAX topicTxt
#debug string topicTxt
 SLEN 
 WRX  payloadLength
#debug_left uint payloadLength
#srcline 349 ;                   //  txData[2]     := 0;
#srcline 350 ;                   //  txData[3]     := payloadLength;
#srcline 352 ;                     txData[2]  := WORD_TO_USINT(SHR(IN := UINT_TO_WORD(payloadLength),N := 8));
 LDX  payloadLength
#debug uint payloadLength
 LD   uint 8
 SHR
 AND  $FFFF
 AND  $FF
 WRX  txData[2]
#debug_left usint txData[2]
#srcline 353 ;                     txData[3]  := UINT_TO_USINT(payloadLength);
 LDX  payloadLength
#debug uint payloadLength
 AND  $FF
 WRX  txData[3]
#debug_left usint txData[3]
#srcline 355 ;                     MemcpyPtr(source := ADR(topicTxt),dest := ADR(txData[4]),length := UINT_TO_UDINT(payloadLength));
 NXT
 LEAX topicTxt
#debug pointer topicTxt
 LEA  __Instance__MemcpyPtr~source
 WRIL 
#debug_left udint __Instance__MemcpyPtr~source
 LEAX txData
 ADD  4  ; + offset 
#debug pointer txData[4]
 LEA  __Instance__MemcpyPtr~dest
 WRIL 
#debug_left udint __Instance__MemcpyPtr~dest
 LDX  payloadLength
#debug uint payloadLength
 WR   __Instance__MemcpyPtr~length
#debug_left udint __Instance__MemcpyPtr~length
 PRV
 LEA  __Instance__MemcpyPtr
 CAL  MemcpyPtr_L0
#srcline 356 ;                     if com_param.qos > 0 then
 LDX  com_param~qos
#debug usint com_param.qos
 LD   usint 0
 GT
 JMC  fbMQTTPublisher_L31
#srcline 357 ;                          messageID                    := messageID + 1;
 LDX  messageID
#debug uint messageID
 LD   uint 1
 ADD
 AND  $FFFF
 WRX  messageID
#debug_left uint messageID
#srcline 358 ;                         txData[payloadLength + 4]     := WORD_TO_USINT(SHR(IN := UINT_TO_WORD(messageID), N := 8));
 LDX  messageID
#debug uint messageID
 LD   uint 8
 SHR
 AND  $FFFF
 AND  $FF
 LEAX txData
 LDX  payloadLength
#debug uint payloadLength
 LD   uint 4
 ADD
 AND  $FFFF
 RCHK 300   ; Range Check
 ADD     ; + offset 
 WRI 
#debug_left usint txData[payloadLength+4]
#srcline 359 ;                         txData[payloadLength + 4 + 1] := UINT_TO_USINT(messageID);
 LDX  messageID
#debug uint messageID
 AND  $FF
 LEAX txData
 LDX  payloadLength
#debug uint payloadLength
 LD   uint 4
 ADD
 AND  $FFFF
 LD   uint 1
 ADD
 AND  $FFFF
 RCHK 300   ; Range Check
 ADD     ; + offset 
 WRI 
#debug_left usint txData[payloadLength+4+1]
#srcline 360 ;                         payloadLength                 := payloadLength + 2;
 LDX  payloadLength
#debug uint payloadLength
 LD   uint 2
 ADD
 AND  $FFFF
 WRX  payloadLength
#debug_left uint payloadLength
#srcline 361 ;                     end_if;
fbMQTTPublisher_L31:
#srcline 362 ;                     MemcpyPtr(source := ADR(dataTxt),dest := ADR(txData[payloadLength+4]),length := LEN(dataTxt));
 NXT
 LEAX dataTxt
#debug pointer dataTxt
 LEA  __Instance__MemcpyPtr~source
 WRIL 
#debug_left udint __Instance__MemcpyPtr~source
 LEAX txData
 LDX  payloadLength
#debug uint payloadLength
 LD   uint 4
 ADD
 AND  $FFFF
 RCHK 300   ; Range Check
 ADD     ; + offset 
#debug pointer txData[payloadLength+4]
 LEA  __Instance__MemcpyPtr~dest
 WRIL 
#debug_left udint __Instance__MemcpyPtr~dest
 LEAX dataTxt
#debug string dataTxt
 SLEN 
 WR   __Instance__MemcpyPtr~length
#debug_left udint __Instance__MemcpyPtr~length
 PRV
 LEA  __Instance__MemcpyPtr
 CAL  MemcpyPtr_L0
#srcline 363 ;                     payloadLength    := payloadLength + LEN(dataTxt);
 LDX  payloadLength
#debug uint payloadLength
 LEAX dataTxt
#debug string dataTxt
 SLEN 
 ADD
 AND  $FFFF
 WRX  payloadLength
#debug_left uint payloadLength
#srcline 364 ;                     txMsgLength      := 2 + payloadLength;
 LD   uint 2
 LDX  payloadLength
#debug uint payloadLength
 ADD
 AND  $FFFF
 WRX  txMsgLength
#debug_left uint txMsgLength
#srcline 365 ;                     
#srcline 366 ;                     txMsgLengthTemp   := txMsgLength;
 LDX  txMsgLength
#debug uint txMsgLength
 WRX  txMsgLengthTemp
#debug_left uint txMsgLengthTemp
#srcline 367 ;                     payloadLengthSize := 1;
 LD   usint 1
 WRX  payloadLengthSize
#debug_left usint payloadLengthSize
#srcline 368 ;                     
#srcline 369 ;                     while txMsgLengthTemp > 0 do
fbMQTTPublisher_L33:
 LDX  txMsgLengthTemp
#debug uint txMsgLengthTemp
 LD   uint 0
 GT
 JMC  fbMQTTPublisher_L34
 DBG 
#srcline 370 ;                           encodedByte := UINT_TO_BYTE(txMsgLengthTemp MOD 128);
 LDX  txMsgLengthTemp
#debug uint txMsgLengthTemp
 LD   uint 128
 MOD
 AND  $FFFF
 AND  $FF
 WRX  encodedByte
#debug_left byte encodedByte
#srcline 371 ;                           txMsgLengthTemp := txMsgLengthTemp / 128;
 LDX  txMsgLengthTemp
#debug uint txMsgLengthTemp
 LD   uint 128
 DIVL
 AND  $FFFF
 WRX  txMsgLengthTemp
#debug_left uint txMsgLengthTemp
#srcline 372 ;                           if txMsgLengthTemp > 0 then
 LDX  txMsgLengthTemp
#debug uint txMsgLengthTemp
 LD   uint 0
 GT
 JMC  fbMQTTPublisher_L35
#srcline 373 ;                               payloadLengthArrayTemp[payloadLengthSize] := BYTE_TO_USINT(encodedByte OR 128);
 LDX  encodedByte
#debug byte encodedByte
 LD   byte 128
 OR  
 LEAX payloadLengthArrayTemp
 LDX  payloadLengthSize
#debug usint payloadLengthSize
 SUB  1   ; Low range[1]
 RCHK 3   ; Range Check
 ADD     ; + offset 
 WRI 
#debug_left usint payloadLengthArrayTemp[payloadLengthSize]
#srcline 374 ;                               payloadLengthSize := payloadLengthSize + 1;
 LDX  payloadLengthSize
#debug usint payloadLengthSize
 LD   usint 1
 ADD
 AND  $FF
 WRX  payloadLengthSize
#debug_left usint payloadLengthSize
#srcline 375 ;                           else
 JMP  fbMQTTPublisher_L36
fbMQTTPublisher_L35:
#srcline 376 ;                               payloadLengthArrayTemp[payloadLengthSize] := BYTE_TO_USINT(encodedByte);
 LDX  encodedByte
#debug byte encodedByte
 LEAX payloadLengthArrayTemp
 LDX  payloadLengthSize
#debug usint payloadLengthSize
 SUB  1   ; Low range[1]
 RCHK 3   ; Range Check
 ADD     ; + offset 
 WRI 
#debug_left usint payloadLengthArrayTemp[payloadLengthSize]
#srcline 377 ;                           end_if;
fbMQTTPublisher_L36:
#srcline 378 ;                           if payloadLengthSize > 4 then
 LDX  payloadLengthSize
#debug usint payloadLengthSize
 LD   usint 4
 GT
 JMC  fbMQTTPublisher_L37
#srcline 379 ;                               busy := false;
 LD   bool 0       ; false
 WRX  busy
#debug_left bool busy
#srcline 380 ;                               ok   := false;
 LD   bool 0       ; false
 WRX  ok
#debug_left bool ok
#srcline 381 ;                               err  := true;
 LD   bool -1       ; true
 WRX  err
#debug_left bool err
#srcline 382 ;                               //FIXME: Add error code "Payload length is out of range"
#srcline 383 ;                               return;
 JMP  fbMQTTPublisher_RET
#srcline 384 ;                           end_if;
fbMQTTPublisher_L37:
#srcline 385 ;                     end_while;
 JMP  fbMQTTPublisher_L33
fbMQTTPublisher_L34:
 NOP  -1
#srcline 386 ;                     
#srcline 387 ;                     if payloadLengthSize = 1 then
 LDX  payloadLengthSize
#debug usint payloadLengthSize
 LD   usint 1
 EQ
 JMC  fbMQTTPublisher_L39
#srcline 388 ;                         txData[1] := UINT_TO_USINT(txMsgLength);
 LDX  txMsgLength
#debug uint txMsgLength
 AND  $FF
 WRX  txData[1]
#debug_left usint txData[1]
#srcline 389 ;                     else
 JMP  fbMQTTPublisher_L40
fbMQTTPublisher_L39:
#srcline 390 ;                         txMsgLength     := txMsgLength + USINT_TO_UINT(payloadLengthSize) - 1;
 LDX  txMsgLength
#debug uint txMsgLength
 LDX  payloadLengthSize
#debug usint payloadLengthSize
 AND  $FFFF
 ADD
 AND  $FFFF
 LD   uint 1
 SUB
 AND  $FFFF
 WRX  txMsgLength
#debug_left uint txMsgLength
#srcline 391 ;                         txMsgLengthTemp := txMsgLength;
 LDX  txMsgLength
#debug uint txMsgLength
 WRX  txMsgLengthTemp
#debug_left uint txMsgLengthTemp
#srcline 392 ;                         
#srcline 393 ;                         while txMsgLengthTemp >= USINT_TO_UINT(payloadLengthSize) do
fbMQTTPublisher_L41:
 LDX  txMsgLengthTemp
#debug uint txMsgLengthTemp
 LDX  payloadLengthSize
#debug usint payloadLengthSize
 AND  $FFFF
 LT
 NEG
 JMC  fbMQTTPublisher_L42
 DBG 
#srcline 394 ;                           txData[txMsgLengthTemp + 1] := txData[txMsgLengthTemp];
 LEAX txData
 LDX  txMsgLengthTemp
#debug uint txMsgLengthTemp
 RCHK 300   ; Range Check
 ADD     ; + offset 
 LDI  
#debug usint txData[txMsgLengthTemp]
 LEAX txData
 LDX  txMsgLengthTemp
#debug uint txMsgLengthTemp
 LD   uint 1
 ADD
 AND  $FFFF
 RCHK 300   ; Range Check
 ADD     ; + offset 
 WRI 
#debug_left usint txData[txMsgLengthTemp+1]
#srcline 395 ;                           txMsgLengthTemp := txMsgLengthTemp - 1;
 LDX  txMsgLengthTemp
#debug uint txMsgLengthTemp
 LD   uint 1
 SUB
 AND  $FFFF
 WRX  txMsgLengthTemp
#debug_left uint txMsgLengthTemp
#srcline 396 ;                         end_while;
 JMP  fbMQTTPublisher_L41
fbMQTTPublisher_L42:
 NOP  -1
#srcline 397 ;                         for index := 1 to payloadLengthSize do
 LD   usint 1
 WRX  index
 LDX  payloadLengthSize
#debug usint payloadLengthSize
 WRY  P0__st__
fbMQTTPublisher_L43:
 LDX  index
 LDY  P0__st__
 GT   
 JMD  fbMQTTPublisher_L44
 DBG  
#srcline 398 ;                              txData[index] := payloadLengthArrayTemp[index];
 LEAX payloadLengthArrayTemp
 LDX  index
#debug usint index
 SUB  1   ; Low range[1]
 RCHK 3   ; Range Check
 ADD     ; + offset 
 LDI  
#debug usint payloadLengthArrayTemp[index]
 LEAX txData
 LDX  index
#debug usint index
 RCHK 300   ; Range Check
 ADD     ; + offset 
 WRI 
#debug_left usint txData[index]
#srcline 399 ;                         end_for;
 LDX  index
 LD   1
 ADD  
 WRX  index
 JMP  fbMQTTPublisher_L43
fbMQTTPublisher_L44:
 NOP  -1
#srcline 400 ;                     end_if;
fbMQTTPublisher_L40:
#srcline 401 ;                     
#srcline 402 ;                     
#srcline 403 ;                     txMsgLength      := txMsgLength + 2;
 LDX  txMsgLength
#debug uint txMsgLength
 LD   uint 2
 ADD
 AND  $FFFF
 WRX  txMsgLength
#debug_left uint txMsgLength
#srcline 404 ;                     tx_data_request  := true;
 LD   bool -1       ; true
 WRX  tx_data_request
#debug_left bool tx_data_request
#srcline 405 ;                     busy := true;
 LD   bool -1       ; true
 WRX  busy
#debug_left bool busy
#srcline 406 ;                     ok   := false;
 LD   bool 0       ; false
 WRX  ok
#debug_left bool ok
#srcline 407 ;                     err  := false;
 LD   bool 0       ; false
 WRX  err
#debug_left bool err
#srcline 408 ;                    return;
 JMP  fbMQTTPublisher_RET
#srcline 409 ;                end_if;
fbMQTTPublisher_L25:
#srcline 411 ;                if pubReleaseRq then
 LDX  pubReleaseRq
#debug bool pubReleaseRq
 JMC  fbMQTTPublisher_L45
#srcline 412 ;                    pubReleaseRq := false;
 LD   bool 0       ; false
 WRX  pubReleaseRq
#debug_left bool pubReleaseRq
#srcline 413 ;                    txData[0]        := MQTT_CONTROL_PACK_PUBREL + 2; // flag bits are cleared
 LD   usint 96
 LD   usint 2
 ADD
 AND  $FF
 WRX  txData[0]
#debug_left usint txData[0]
#srcline 414 ;                    txData[1]        := 2;
 LD   usint 2
 WRX  txData[1]
#debug_left usint txData[1]
#srcline 415 ;                    txData[2]        := WORD_TO_USINT(SHR(IN := UINT_TO_WORD(messageIDpubRel), N := 8));
 LDX  messageIDpubRel
#debug uint messageIDpubRel
 LD   uint 8
 SHR
 AND  $FFFF
 AND  $FF
 WRX  txData[2]
#debug_left usint txData[2]
#srcline 416 ;                    txData[3]        := UINT_TO_USINT(messageIDpubRel);
 LDX  messageIDpubRel
#debug uint messageIDpubRel
 AND  $FF
 WRX  txData[3]
#debug_left usint txData[3]
#srcline 417 ;                    txMsgLength      := 4;
 LD   uint 4
 WRX  txMsgLength
#debug_left uint txMsgLength
#srcline 418 ;                    tx_data_request  := true;
 LD   bool -1       ; true
 WRX  tx_data_request
#debug_left bool tx_data_request
#srcline 419 ;                    responce_recived := false;
 LD   bool 0       ; false
 WRX  responce_recived
#debug_left bool responce_recived
#srcline 420 ;                    busy             := true;
 LD   bool -1       ; true
 WRX  busy
#debug_left bool busy
#srcline 421 ;                    ok               := false;
 LD   bool 0       ; false
 WRX  ok
#debug_left bool ok
#srcline 422 ;                    err              := false;
 LD   bool 0       ; false
 WRX  err
#debug_left bool err
#srcline 423 ;                    return;
 JMP  fbMQTTPublisher_RET
#srcline 424 ;                end_if;
fbMQTTPublisher_L45:
#srcline 425 ;                //---------------------------------------------
#srcline 426 ;                if MQTT_ping_timer.Q then
 LDX  MQTT_ping_timer~Q
#debug bool MQTT_ping_timer.Q
 JMC  fbMQTTPublisher_L47
#srcline 427 ;                    //Ping request
#srcline 428 ;                     txData[0]        := MQTT_CONTROL_PACK_PINGREQ; // flag bits are cleared
 LD   usint 192
 WRX  txData[0]
#debug_left usint txData[0]
#srcline 429 ;                     txData[1]        := 0;
 LD   usint 0
 WRX  txData[1]
#debug_left usint txData[1]
#srcline 430 ;                     txMsgLength      := 2;
 LD   uint 2
 WRX  txMsgLength
#debug_left uint txMsgLength
#srcline 431 ;                     tx_data_request  := true;
 LD   bool -1       ; true
 WRX  tx_data_request
#debug_left bool tx_data_request
#srcline 432 ;                     responce_recived := false;
 LD   bool 0       ; false
 WRX  responce_recived
#debug_left bool responce_recived
#srcline 433 ;                     busy             := true;
 LD   bool -1       ; true
 WRX  busy
#debug_left bool busy
#srcline 434 ;                     ok               := false;
 LD   bool 0       ; false
 WRX  ok
#debug_left bool ok
#srcline 435 ;                     err              := false;
 LD   bool 0       ; false
 WRX  err
#debug_left bool err
#srcline 436 ;                     return;
 JMP  fbMQTTPublisher_RET
#srcline 437 ;                end_if;
fbMQTTPublisher_L47:
#srcline 439 ;           end_if;
fbMQTTPublisher_L10:
#srcline 440 ;       end_if;
fbMQTTPublisher_L7:
#srcline 442 ;      if conn_status then
 LDX  conn_status
#debug bool conn_status
 JMC  fbMQTTPublisher_L49
#srcline 443 ;           SendTo( rq := tx_data_request, chanCode := chanCode, lenTx := txMsgLength , data := void(txData));
 LDX  tx_data_request
#debug bool tx_data_request
 WRX  SendTo~rq
#debug_left bool SendTo~rq
 LDX  chanCode
#debug uint chanCode
 WRX  SendTo~chanCode
#debug_left uint SendTo~chanCode
 LDX  txMsgLength
#debug uint txMsgLength
 WRX  SendTo~lenTx
#debug_left uint SendTo~lenTx
 LEAX txData
 WRX  SendTo~data
#debug_left pointer SendTo.data
 LEAX SendTo
 CAL  fbSendTo_L0
#srcline 444 ;           if SendTo.mesSent then
 LDX  SendTo~mesSent
#debug bool SendTo.mesSent
 JMC  fbMQTTPublisher_L51
#srcline 445 ;               tx_data_request  := false;
 LD   bool 0       ; false
 WRX  tx_data_request
#debug_left bool tx_data_request
#srcline 446 ;               txCounter        := txCounter + 1;
 LDX  txCounter
#debug uint txCounter
 LD   uint 1
 ADD
 AND  $FFFF
 WRX  txCounter
#debug_left uint txCounter
#srcline 447 ;               messageIDlast    := messageID;
 LDX  messageID
#debug uint messageID
 WRX  messageIDlast
#debug_left uint messageIDlast
#srcline 448 ;               responce_recived := false;
 LD   bool 0       ; false
 WRX  responce_recived
#debug_left bool responce_recived
#srcline 450 ;               if com_param.qos = 0 then
 LDX  com_param~qos
#debug usint com_param.qos
 LD   usint 0
 EQ
 JMC  fbMQTTPublisher_L53
#srcline 451 ;                  busy := false;
 LD   bool 0       ; false
 WRX  busy
#debug_left bool busy
#srcline 452 ;                  ok   := true;
 LD   bool -1       ; true
 WRX  ok
#debug_left bool ok
#srcline 453 ;                  err  := false;
 LD   bool 0       ; false
 WRX  err
#debug_left bool err
#srcline 454 ;                  wait_response := false;
 LD   bool 0       ; false
 WRX  wait_response
#debug_left bool wait_response
#srcline 455 ;               else
 JMP  fbMQTTPublisher_L54
fbMQTTPublisher_L53:
#srcline 456 ;                  wait_response := true;
 LD   bool -1       ; true
 WRX  wait_response
#debug_left bool wait_response
#srcline 457 ;               end_if;
fbMQTTPublisher_L54:
#srcline 458 ;          end_if;
fbMQTTPublisher_L51:
#srcline 460 ;          RecvFrom( rq := true, chanCode := chanCode, lenRx := 100, data := void(rxData));
 LD   bool -1       ; true
 WRX  RecvFrom~rq
#debug_left bool RecvFrom~rq
 LDX  chanCode
#debug uint chanCode
 WRX  RecvFrom~chanCode
#debug_left uint RecvFrom~chanCode
 LD   uint 100
 WRX  RecvFrom~lenRx
#debug_left uint RecvFrom~lenRx
 LEAX rxData
 WRX  RecvFrom~data
#debug_left pointer RecvFrom.data
 LEAX RecvFrom
 CAL  fbRecvFrom_L0
#srcline 462 ;          if RecvFrom.mesRec then
 LDX  RecvFrom~mesRec
#debug bool RecvFrom.mesRec
 JMC  fbMQTTPublisher_L55
#srcline 463 ;              if RecvFrom.error = 0 then
 LDX  RecvFrom~error
#debug usint RecvFrom.error
 LD   usint 0
 EQ
 JMC  fbMQTTPublisher_L57
#srcline 464 ;              
#srcline 465 ;                  messageIDpubRel_ptr := ADR(rxData[2]);
 LEAX rxData
 ADD  2  ; + offset 
#debug pointer rxData[2]
 LEAX messageIDpubRel_ptr
 WRIL 
#debug_left pointer messageIDpubRel_ptr
#srcline 466 ;                  messageIDpubRel     := messageIDpubRel_ptr^;
 LEAX messageIDpubRel_ptr
 LDIL    ; dereference 
 LDIW 
#debug uint messageIDpubRel_ptr^
 WRX  messageIDpubRel
#debug_left uint messageIDpubRel
#srcline 467 ;                  messageIDpubRel     := fSwapUINT(messageIDpubRel);
 NXT
 LDX  messageIDpubRel
#debug uint messageIDpubRel
 WR   __Instance__fSwapUINT~input
#debug_left uint __Instance__fSwapUINT~input
 PRV
 LEA  __Instance__fSwapUINT
 CAL  fSwapUINT_L0
 WRX  messageIDpubRel
#debug_left uint messageIDpubRel
#srcline 468 ;                  
#srcline 469 ;                  if messageIDlast = messageIDpubRel AND rxData[1] = 2 AND (rxData[0] = MQTT_CONTROL_PACK_CONNACK OR (rxData[0] = MQTT_CONTROL_PACK_PUBACK  AND com_param.qos = 1)
 LDX  messageIDlast
#debug uint messageIDlast
 LDX  messageIDpubRel
#debug uint messageIDpubRel
 EQ
 LDX  rxData[1]
#debug usint rxData[1]
 LD   usint 2
 EQ
 AND
 LDX  rxData[0]
#debug usint rxData[0]
 LD   usint 32
 EQ
 LDX  rxData[0]
#debug usint rxData[0]
 LD   usint 64
 EQ
 LDX  com_param~qos
#debug usint com_param.qos
 LD   usint 1
 EQ
 AND
#srcline 470 ;                                                                                                                  OR (rxData[0] = MQTT_CONTROL_PACK_PUBCOMP AND com_param.qos = 2) ) then // responce to connect command
 OR  
 LDX  rxData[0]
#debug usint rxData[0]
 LD   usint 112
 EQ
 LDX  com_param~qos
#debug usint com_param.qos
 LD   usint 2
 EQ
 AND
 OR  
 AND
 JMC  fbMQTTPublisher_L59
#srcline 471 ;                      connected_to_broker := true;
 LD   bool -1       ; true
 WRX  connected_to_broker
#debug_left bool connected_to_broker
#srcline 472 ;                      responce_recived    := true;
 LD   bool -1       ; true
 WRX  responce_recived
#debug_left bool responce_recived
#srcline 473 ;                      wait_response       := false;
 LD   bool 0       ; false
 WRX  wait_response
#debug_left bool wait_response
#srcline 474 ;                      busy                := false;
 LD   bool 0       ; false
 WRX  busy
#debug_left bool busy
#srcline 475 ;                      ok                  := true;
 LD   bool -1       ; true
 WRX  ok
#debug_left bool ok
#srcline 476 ;                      err                 := false;
 LD   bool 0       ; false
 WRX  err
#debug_left bool err
#srcline 477 ;                  elsif RecvFrom.lenData = 4 AND com_param.qos = 2 AND rxData[0] = MQTT_CONTROL_PACK_PUBREC then
 JMP  fbMQTTPublisher_L60
fbMQTTPublisher_L59:
 LDX  RecvFrom~lenData
#debug uint RecvFrom.lenData
 LD   uint 4
 EQ
 LDX  com_param~qos
#debug usint com_param.qos
 LD   usint 2
 EQ
 AND
 LDX  rxData[0]
#debug usint rxData[0]
 LD   usint 80
 EQ
 AND
 JMC  fbMQTTPublisher_L61
#srcline 478 ;                          messageIDpubRel_ptr := ADR(rxData[2]);
 LEAX rxData
 ADD  2  ; + offset 
#debug pointer rxData[2]
 LEAX messageIDpubRel_ptr
 WRIL 
#debug_left pointer messageIDpubRel_ptr
#srcline 479 ;                          messageIDpubRel     := messageIDpubRel_ptr^;
 LEAX messageIDpubRel_ptr
 LDIL    ; dereference 
 LDIW 
#debug uint messageIDpubRel_ptr^
 WRX  messageIDpubRel
#debug_left uint messageIDpubRel
#srcline 480 ;                          messageIDpubRel     := fSwapUINT( messageIDpubRel_ptr^);
 NXT
 LEAX messageIDpubRel_ptr
 LDIL    ; dereference 
 LDIW 
#debug uint messageIDpubRel_ptr^
 WR   __Instance__fSwapUINT~input
#debug_left uint __Instance__fSwapUINT~input
 PRV
 LEA  __Instance__fSwapUINT
 CAL  fSwapUINT_L0
 WRX  messageIDpubRel
#debug_left uint messageIDpubRel
#srcline 481 ;                          messageIDlast       := messageIDpubRel;
 LDX  messageIDpubRel
#debug uint messageIDpubRel
 WRX  messageIDlast
#debug_left uint messageIDlast
#srcline 482 ;                          connected_to_broker := true;
 LD   bool -1       ; true
 WRX  connected_to_broker
#debug_left bool connected_to_broker
#srcline 483 ;                          responce_recived    := true;
 LD   bool -1       ; true
 WRX  responce_recived
#debug_left bool responce_recived
#srcline 484 ;                          wait_response       := false;
 LD   bool 0       ; false
 WRX  wait_response
#debug_left bool wait_response
#srcline 485 ;                          pubReleaseRq        := true;
 LD   bool -1       ; true
 WRX  pubReleaseRq
#debug_left bool pubReleaseRq
#srcline 486 ;                  elsif RecvFrom.lenData = 2 AND rxData[0] = MQTT_CONTROL_PACK_PINGRESP then
 JMP  fbMQTTPublisher_L60
fbMQTTPublisher_L61:
 LDX  RecvFrom~lenData
#debug uint RecvFrom.lenData
 LD   uint 2
 EQ
 LDX  rxData[0]
#debug usint rxData[0]
 LD   usint 208
 EQ
 AND
 JMC  fbMQTTPublisher_L62
#srcline 487 ;                         responce_recived := true;
 LD   bool -1       ; true
 WRX  responce_recived
#debug_left bool responce_recived
#srcline 488 ;                         wait_response    := false;
 LD   bool 0       ; false
 WRX  wait_response
#debug_left bool wait_response
#srcline 489 ;                         busy             := false;
 LD   bool 0       ; false
 WRX  busy
#debug_left bool busy
#srcline 490 ;                         ok               := true;
 LD   bool -1       ; true
 WRX  ok
#debug_left bool ok
#srcline 491 ;                         err              := false;
 LD   bool 0       ; false
 WRX  err
#debug_left bool err
#srcline 492 ;                  end_if;
 JMP  fbMQTTPublisher_L60
fbMQTTPublisher_L62:
fbMQTTPublisher_L60:
#srcline 493 ;                  rxCounter := rxCounter + 1;
 LDX  rxCounter
#debug uint rxCounter
 LD   uint 1
 ADD
 AND  $FFFF
 WRX  rxCounter
#debug_left uint rxCounter
#srcline 494 ;              end_if;
fbMQTTPublisher_L57:
#srcline 495 ;          end_if;
fbMQTTPublisher_L55:
#srcline 496 ;      else
 JMP  fbMQTTPublisher_L50
fbMQTTPublisher_L49:
#srcline 497 ;         connected_to_broker := false;
 LD   bool 0       ; false
 WRX  connected_to_broker
#debug_left bool connected_to_broker
#srcline 498 ;         wait_response       := false;
 LD   bool 0       ; false
 WRX  wait_response
#debug_left bool wait_response
#srcline 499 ;         pubReleaseRq        := false;
 LD   bool 0       ; false
 WRX  pubReleaseRq
#debug_left bool pubReleaseRq
#srcline 500 ;         busy                := false;
 LD   bool 0       ; false
 WRX  busy
#debug_left bool busy
#srcline 501 ;         ok                  := false;
 LD   bool 0       ; false
 WRX  ok
#debug_left bool ok
#srcline 502 ;         err                 := true;
 LD   bool -1       ; true
 WRX  err
#debug_left bool err
#srcline 503 ;         errCode             := MQTT_CONTROL_ERROR_CODE_BROKER_DISCONNECTED;
 LD   usint 3
 WRX  errCode
#debug_left usint errCode
#srcline 504 ;      end_if;
fbMQTTPublisher_L50:
#srcline 506 ;   else
 JMP  fbMQTTPublisher_L6
fbMQTTPublisher_L5:
#srcline 507 ;     connected_to_broker := false;
 LD   bool 0       ; false
 WRX  connected_to_broker
#debug_left bool connected_to_broker
#srcline 508 ;     wait_response       := false;
 LD   bool 0       ; false
 WRX  wait_response
#debug_left bool wait_response
#srcline 509 ;     pubReleaseRq        := false;
 LD   bool 0       ; false
 WRX  pubReleaseRq
#debug_left bool pubReleaseRq
#srcline 510 ;     busy                := false;
 LD   bool 0       ; false
 WRX  busy
#debug_left bool busy
#srcline 511 ;     ok                  := false;
 LD   bool 0       ; false
 WRX  ok
#debug_left bool ok
#srcline 512 ;     err                 := true;
 LD   bool -1       ; true
 WRX  err
#debug_left bool err
#srcline 513 ;     errCode             := MQTT_CONTROL_ERROR_CODE_BROKER_DISCONNECTED;
 LD   usint 3
 WRX  errCode
#debug_left usint errCode
#srcline 514 ;   end_if;
fbMQTTPublisher_L6:
#srcline 515 ;   
#srcline 516 ;END_FUNCTION_BLOCK
fbMQTTPublisher_RET:
 ULNK
RET
E     61

; Initialize - variables
P     61
fbMQTTPublisher__InstanceInit__:
 LINK 0
 LD   uint 1883
 WRX  brokerPort
 LD   uint 6000
 WRX  localPort
 LD   bool -1   ; true
 WRX  keepAlive
 LD   time 60000
 WRX  keepAliveInterval
 LD   time 10000
 WRX  connTimeOut
 LD   time 15000
 WRX  pingInterval
 LD   bool -1   ; true
 WRX  clientId_auto
 LD   0
 SRC  byte __Init___fbMQTTPublisher_com_param
 LEAX byte com_param
 LD   3
 MOV  %X0
 LEAX MQTT_Comm_Init
 CAL  fbMQTT_Comm_Init__InstanceInit__
 LEAX SendTo
 CAL  fbSendTo__InstanceInit__
 LEAX RecvFrom
 CAL  fbRecvFrom__InstanceInit__
 LD   0
 SRC  byte __Init___fbMQTTPublisher_MQTT_PROTOCOL
 LEAX byte MQTT_PROTOCOL
 LD   5
 MOV  %X0
 LD   udint $FFFFFFFF    ; nil
 WRX  messageIDpubRel_ptr
 ULNK
RET
E     61
; End initialize - variables
#endpou 

#pou fbMQTTPublisherEx
#srcline 522 ;FUNCTION_BLOCK fbMQTTPublisherEx
#table byte __Init___fbMQTTPublisherEx_com_param = 
      0,  0,  1;
#table byte __Init___fbMQTTPublisherEx_MQTT_PROTOCOL = 
    'M','Q','T','T';

#struct fbMQTTPublisherEx__temp__
  uint P0__st__,
  string[34] PS0__st__,
  string[34] PSC__st__
#data byte _str_fbMQTTPublisherEx_0 = 
  '',0
#data byte _str_fbMQTTPublisherEx_1 = 
  '',0
P     61
fbMQTTPublisherEx_L0:
 LINK __SizeOf(fbMQTTPublisherEx__temp__)
; Initialize - dynamic variables
; End initialize - dynamic variables
; R_EDGE, F_EDGE 
 LDX  sendCom
 LETX __EDGE_R__sendCom
 WRX  sendCom
#srcline 616 ;    if MQTT_com_responce_timeout.Q then
 LDX  MQTT_com_responce_timeout~Q
#debug bool MQTT_com_responce_timeout.Q
 JMC  fbMQTTPublisherEx_L1
#srcline 617 ;      if responce_recived = false then
 LDX  responce_recived
#debug bool responce_recived
 LD   bool 0       ; false
 XOR
 NEG
 JMC  fbMQTTPublisherEx_L3
#srcline 618 ;          connected_to_broker := false;
 LD   bool 0       ; false
 WRX  connected_to_broker
#debug_left bool connected_to_broker
#srcline 619 ;      end_if;
fbMQTTPublisherEx_L3:
#srcline 620 ;      wait_response := false;
 LD   bool 0       ; false
 WRX  wait_response
#debug_left bool wait_response
#srcline 621 ;      busy    := false;
 LD   bool 0       ; false
 WRX  busy
#debug_left bool busy
#srcline 622 ;      ok      := false;
 LD   bool 0       ; false
 WRX  ok
#debug_left bool ok
#srcline 623 ;      err     := true;
 LD   bool -1       ; true
 WRX  err
#debug_left bool err
#srcline 624 ;      errCode := MQTT_CONTROL_ERROR_CODE_BROKER_ANSWER_TIME_OUT;
 LD   usint 1
 WRX  errCode
#debug_left usint errCode
#srcline 625 ;      errorCounter := errorCounter + 1;
 LDX  errorCounter
#debug usint errorCounter
 LD   usint 1
 ADD
 AND  $FF
 WRX  errorCounter
#debug_left usint errorCounter
#srcline 626 ;   end_if;
fbMQTTPublisherEx_L1:
#srcline 628 ;   local_port := localPort + localPortExtension;
 LDX  localPort
#debug uint localPort
 LDX  localPortExtension
#debug uint localPortExtension
 ADD
 AND  $FFFF
 WRX  local_port
#debug_left uint local_port
#srcline 629 ;   MQTT_Comm_Init( connect := connect, chanCode := chanCode, remoteIP := brokerIP, remotePort := brokerPort, localPort := localPort + localPortExtension,
 LDX  connect
#debug bool connect
 WRX  MQTT_Comm_Init~connect
#debug_left bool MQTT_Comm_Init~connect
 LDX  chanCode
#debug uint chanCode
 WRX  MQTT_Comm_Init~chanCode
#debug_left uint MQTT_Comm_Init~chanCode
 LEAX brokerIP
#debug pointer brokerIP
 SRC  %IB0
 LEAX MQTT_Comm_Init~remoteIP
 LD   4   ;SizeOf() 
 MOV  %IB0
 LDX  brokerPort
#debug uint brokerPort
 WRX  MQTT_Comm_Init~remotePort
#debug_left uint MQTT_Comm_Init~remotePort
 LDX  localPort
#debug uint localPort
 LDX  localPortExtension
#debug uint localPortExtension
 ADD
 AND  $FFFF
 WRX  MQTT_Comm_Init~localPort
#debug_left uint MQTT_Comm_Init~localPort
#srcline 630 ;                  status       => conn_status);
 LEAX MQTT_Comm_Init
 CAL  fbMQTT_Comm_Init_L0
; output assigment 
 LDX  MQTT_Comm_Init~status
#debug bool MQTT_Comm_Init~status
 WRX  conn_status
#debug_left bool conn_status
#srcline 632 ;   MQTT_com_responce_timeout(IN := wait_response,PT := connTimeOut);
 LDX  wait_response
#debug bool wait_response
 WRX  MQTT_com_responce_timeout~IN
#debug_left bool MQTT_com_responce_timeout~IN
 LDX  connTimeOut
#debug time connTimeOut
 WRX  MQTT_com_responce_timeout~PT
#debug_left time MQTT_com_responce_timeout~PT
 LEAX MQTT_com_responce_timeout
 CAL  TON_L0
#srcline 633 ;   MQTT_ping_timer(IN := connect AND keepAlive, PT := pingInterval);
 LDX  connect
#debug bool connect
 LDX  keepAlive
#debug bool keepAlive
 AND
 WRX  MQTT_ping_timer~IN
#debug_left bool MQTT_ping_timer~IN
 LDX  pingInterval
#debug time pingInterval
 WRX  MQTT_ping_timer~PT
#debug_left time MQTT_ping_timer~PT
 LEAX MQTT_ping_timer
 CAL  fbTick_L0
#srcline 634 ;   MQTT_com_intervat(IN := connect, PT := T#2s);
 LDX  connect
#debug bool connect
 WRX  MQTT_com_intervat~IN
#debug_left bool MQTT_com_intervat~IN
 LD   time 2000
 WRX  MQTT_com_intervat~PT
#debug_left time MQTT_com_intervat~PT
 LEAX MQTT_com_intervat
 CAL  fbTick_L0
#srcline 636 ;   if connect then
 LDX  connect
#debug bool connect
 JMC  fbMQTTPublisherEx_L5
#srcline 637 ;       if MQTT_com_intervat.Q OR sendCom OR pubReleaseRq then
 LDX  MQTT_com_intervat~Q
#debug bool MQTT_com_intervat.Q
 LDX  sendCom
#debug bool sendCom
 OR  
 LDX  pubReleaseRq
#debug bool pubReleaseRq
 OR  
 JMC  fbMQTTPublisherEx_L7
#srcline 638 ;           if connected_to_broker = false then
 LDX  connected_to_broker
#debug bool connected_to_broker
 LD   bool 0       ; false
 XOR
 NEG
 JMC  fbMQTTPublisherEx_L9
#srcline 639 ;                 if clientId_auto then
 LDX  clientId_auto
#debug bool clientId_auto
 JMC  fbMQTTPublisherEx_L11
#srcline 640 ;                     client_id := DWORD_TO_STRING(DT_TO_DWORD(GetRTC())) + UINT_TO_STRING(MSEC_OF_DT(GetRTC()));
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   32
 DST    ; Level 1
 LD   0   ; null string
 WRY  PSC__st__[0]
 LEAY PSC__st__[0]
 LD   32
 DST    ; Level 2
 LEA  __Instance__GetRTC
 CAL  GetRTC_L0
 RNDD
 UDFL
 SCNV $2C30;  IEC_DWORD _TO_ IEC_STRING
 PDST   ; Level 2
 LEAY PSC__st__[0]

 SCON 
 LD   0   ; null string
 WRY  PSC__st__[0]
 LEAY PSC__st__[0]
 LD   32
 DST    ; Level 2
 NXT
 LEA  __Instance__GetRTC
 CAL  GetRTC_L0
 WR   __Instance__MSEC_OF_DT~in
#debug_left dt __Instance__MSEC_OF_DT~in
 PRV
 LEA  __Instance__MSEC_OF_DT
 CAL  MSEC_OF_DT_L0
 SCNV $0A30;  IEC_UINT _TO_ IEC_STRING
 PDST   ; Level 2
 LEAY PSC__st__[0]

 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX client_id
 WRI  
 LEAX client_id
 LD   32
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string client_id
 PDST   ; Level 1
#srcline 641 ;                 else
 JMP  fbMQTTPublisherEx_L12
fbMQTTPublisherEx_L11:
#srcline 642 ;                     client_id := clientId;
 LD   0   ; null string
 LEAX client_id
 WRI  
 LEAX client_id
 LD   32
 DST    ; Level 1
 LEAX clientId
#debug string clientId
 SCON 
#debug_left string client_id
 PDST   ; Level 1
#srcline 643 ;                 end_if;
fbMQTTPublisherEx_L12:
#srcline 645 ;                // Fixed header of control packet
#srcline 646 ;                // Fixed header
#srcline 647 ;                txData[0] := MQTT_CONTROL_PACK_CONNECT; // flag bits are cleared
 LD   usint 16
 WRX  txData[0]
#debug_left usint txData[0]
#srcline 648 ;                // Variable header
#srcline 649 ;                txData[2] := 0;
 LD   usint 0
 WRX  txData[2]
#debug_left usint txData[2]
#srcline 650 ;                txData[3] := 4;
 LD   usint 4
 WRX  txData[3]
#debug_left usint txData[3]
#srcline 651 ;                MemcpyPtr(source := ADR(MQTT_PROTOCOL),dest := ADR(txData[4]),length := 4);
 NXT
 LEAX MQTT_PROTOCOL
#debug pointer MQTT_PROTOCOL
 LEA  __Instance__MemcpyPtr~source
 WRIL 
#debug_left udint __Instance__MemcpyPtr~source
 LEAX txData
 ADD  4  ; + offset 
#debug pointer txData[4]
 LEA  __Instance__MemcpyPtr~dest
 WRIL 
#debug_left udint __Instance__MemcpyPtr~dest
 LD   udint 4
 WR   __Instance__MemcpyPtr~length
#debug_left udint __Instance__MemcpyPtr~length
 PRV
 LEA  __Instance__MemcpyPtr
 CAL  MemcpyPtr_L0
#srcline 652 ;                txData[8]   := MQTT_PROTOCOL_VERSION;
 LD   usint 4
 WRX  txData[8]
#debug_left usint txData[8]
#srcline 653 ;                // Protocol Level byte
#srcline 654 ;                //Set connection flags
#srcline 655 ;                connectFlags := 0;
 LD   byte 0
 WRX  connectFlags
#debug_left byte connectFlags
#srcline 656 ;                if loginName <> ''        then connectFlags := 16#80; end_if;
 LEAX loginName
#debug string loginName
 LEA  _str_fbMQTTPublisherEx_0
 SCMP 
 EQ   0
 NEG
 JMC  fbMQTTPublisherEx_L13
 LD   byte $80
 WRX  connectFlags
#debug_left byte connectFlags
fbMQTTPublisherEx_L13:
#srcline 657 ;                if loginPass <> ''        then connectFlags := connectFlags OR 16#40; end_if;
 LEAX loginPass
#debug string loginPass
 LEA  _str_fbMQTTPublisherEx_1
 SCMP 
 EQ   0
 NEG
 JMC  fbMQTTPublisherEx_L15
 LDX  connectFlags
#debug byte connectFlags
 LD   byte $40
 OR  
 WRX  connectFlags
#debug_left byte connectFlags
fbMQTTPublisherEx_L15:
#srcline 658 ;                //if com_param.willRetain   then connectFlags := connectFlags OR 16#20; end_if;
#srcline 659 ;               // connectFlags := connectFlags OR SHL(IN := USINT_TO_BYTE(com_param.qos),N := 3);
#srcline 660 ;                if com_param.cleanSession then connectFlags := connectFlags OR 16#2;  end_if;
 LDX  com_param~cleanSession
#debug bool com_param.cleanSession
 JMC  fbMQTTPublisherEx_L17
 LDX  connectFlags
#debug byte connectFlags
 LD   byte $2
 OR  
 WRX  connectFlags
#debug_left byte connectFlags
fbMQTTPublisherEx_L17:
#srcline 662 ;                txData[9]   := BYTE_TO_USINT(connectFlags);//For connect set clean session
 LDX  connectFlags
#debug byte connectFlags
 WRX  txData[9]
#debug_left usint txData[9]
#srcline 663 ;                //keep alive 2 bytes, MSB+LSB
#srcline 664 ;                aliveTime := TIME_TO_UINT(keepAliveInterval)/1000;
 LDX  keepAliveInterval
#debug time keepAliveInterval
AND  $FFFF
 LD   uint 1000
 DIVL
 AND  $FFFF
 WRX  aliveTime
#debug_left uint aliveTime
#srcline 666 ;                txData[10]  := 0;
 LD   usint 0
 WRX  txData[10]
#debug_left usint txData[10]
#srcline 667 ;                txData[11]  := UINT_TO_USINT(aliveTime);
 LDX  aliveTime
#debug uint aliveTime
 AND  $FF
 WRX  txData[11]
#debug_left usint txData[11]
#srcline 668 ;                //Payload
#srcline 669 ;                payloadLength := LEN(IN := client_id);
 LEAX client_id
#debug string client_id
 SLEN 
 WRX  payloadLength
#debug_left uint payloadLength
#srcline 670 ;                txData[12]  := WORD_TO_USINT(SHR(IN := UINT_TO_WORD(payloadLength),N := 8));
 LDX  payloadLength
#debug uint payloadLength
 LD   uint 8
 SHR
 AND  $FFFF
 AND  $FF
 WRX  txData[12]
#debug_left usint txData[12]
#srcline 671 ;                txData[13]  := UINT_TO_USINT(payloadLength);
 LDX  payloadLength
#debug uint payloadLength
 AND  $FF
 WRX  txData[13]
#debug_left usint txData[13]
#srcline 673 ;                txMsgLength := 14;
 LD   uint 14
 WRX  txMsgLength
#debug_left uint txMsgLength
#srcline 674 ;                //Copy client ID
#srcline 675 ;                MemcpyPtr(source := ADR(client_id),dest := ADR(txData[14]),length := UINT_TO_UDINT(payloadLength));
 NXT
 LEAX client_id
#debug pointer client_id
 LEA  __Instance__MemcpyPtr~source
 WRIL 
#debug_left udint __Instance__MemcpyPtr~source
 LEAX txData
 ADD  14  ; + offset 
#debug pointer txData[14]
 LEA  __Instance__MemcpyPtr~dest
 WRIL 
#debug_left udint __Instance__MemcpyPtr~dest
 LDX  payloadLength
#debug uint payloadLength
 WR   __Instance__MemcpyPtr~length
#debug_left udint __Instance__MemcpyPtr~length
 PRV
 LEA  __Instance__MemcpyPtr
 CAL  MemcpyPtr_L0
#srcline 676 ;                txMsgLength := txMsgLength + payloadLength;
 LDX  txMsgLength
#debug uint txMsgLength
 LDX  payloadLength
#debug uint payloadLength
 ADD
 AND  $FFFF
 WRX  txMsgLength
#debug_left uint txMsgLength
#srcline 677 ;                //Copy user name
#srcline 678 ;                if (connectFlags AND 16#80) > 0 then
 LDX  connectFlags
#debug byte connectFlags
 LD   byte $80
 AND
 LD   byte 0
 GT
 JMC  fbMQTTPublisherEx_L19
#srcline 679 ;                     txData[txMsgLength]     := 0;
 LD   usint 0
 LEAX txData
 LDX  txMsgLength
#debug uint txMsgLength
 RCHK 512   ; Range Check
 ADD     ; + offset 
 WRI 
#debug_left usint txData[txMsgLength]
#srcline 680 ;                     txData[txMsgLength + 1] := LEN(IN := loginName);
 LEAX loginName
#debug string loginName
 SLEN 
 LEAX txData
 LDX  txMsgLength
#debug uint txMsgLength
 LD   uint 1
 ADD
 AND  $FFFF
 RCHK 512   ; Range Check
 ADD     ; + offset 
 WRI 
#debug_left usint txData[txMsgLength+1]
#srcline 681 ;                     payloadLength := LEN(IN := loginName);
 LEAX loginName
#debug string loginName
 SLEN 
 WRX  payloadLength
#debug_left uint payloadLength
#srcline 682 ;                     MemcpyPtr(source := ADR(loginName),dest := ADR(txData[txMsgLength + 2]),length := UINT_TO_UDINT(payloadLength));
 NXT
 LEAX loginName
#debug pointer loginName
 LEA  __Instance__MemcpyPtr~source
 WRIL 
#debug_left udint __Instance__MemcpyPtr~source
 LEAX txData
 LDX  txMsgLength
#debug uint txMsgLength
 LD   uint 2
 ADD
 AND  $FFFF
 RCHK 512   ; Range Check
 ADD     ; + offset 
#debug pointer txData[txMsgLength+2]
 LEA  __Instance__MemcpyPtr~dest
 WRIL 
#debug_left udint __Instance__MemcpyPtr~dest
 LDX  payloadLength
#debug uint payloadLength
 WR   __Instance__MemcpyPtr~length
#debug_left udint __Instance__MemcpyPtr~length
 PRV
 LEA  __Instance__MemcpyPtr
 CAL  MemcpyPtr_L0
#srcline 683 ;                     txMsgLength := txMsgLength + payloadLength + 2;
 LDX  txMsgLength
#debug uint txMsgLength
 LDX  payloadLength
#debug uint payloadLength
 ADD
 AND  $FFFF
 LD   uint 2
 ADD
 AND  $FFFF
 WRX  txMsgLength
#debug_left uint txMsgLength
#srcline 684 ;                end_if;
fbMQTTPublisherEx_L19:
#srcline 685 ;                //Copy password
#srcline 686 ;                if (connectFlags AND 16#40) > 0 then
 LDX  connectFlags
#debug byte connectFlags
 LD   byte $40
 AND
 LD   byte 0
 GT
 JMC  fbMQTTPublisherEx_L21
#srcline 687 ;                     txData[txMsgLength]     := 0;
 LD   usint 0
 LEAX txData
 LDX  txMsgLength
#debug uint txMsgLength
 RCHK 512   ; Range Check
 ADD     ; + offset 
 WRI 
#debug_left usint txData[txMsgLength]
#srcline 688 ;                     txData[txMsgLength + 1] := LEN(IN := loginPass);
 LEAX loginPass
#debug string loginPass
 SLEN 
 LEAX txData
 LDX  txMsgLength
#debug uint txMsgLength
 LD   uint 1
 ADD
 AND  $FFFF
 RCHK 512   ; Range Check
 ADD     ; + offset 
 WRI 
#debug_left usint txData[txMsgLength+1]
#srcline 689 ;                     payloadLength := LEN(IN := loginPass);
 LEAX loginPass
#debug string loginPass
 SLEN 
 WRX  payloadLength
#debug_left uint payloadLength
#srcline 690 ;                     MemcpyPtr(source := ADR(loginPass),dest := ADR(txData[txMsgLength + 2]),length := UINT_TO_UDINT(payloadLength));
 NXT
 LEAX loginPass
#debug pointer loginPass
 LEA  __Instance__MemcpyPtr~source
 WRIL 
#debug_left udint __Instance__MemcpyPtr~source
 LEAX txData
 LDX  txMsgLength
#debug uint txMsgLength
 LD   uint 2
 ADD
 AND  $FFFF
 RCHK 512   ; Range Check
 ADD     ; + offset 
#debug pointer txData[txMsgLength+2]
 LEA  __Instance__MemcpyPtr~dest
 WRIL 
#debug_left udint __Instance__MemcpyPtr~dest
 LDX  payloadLength
#debug uint payloadLength
 WR   __Instance__MemcpyPtr~length
#debug_left udint __Instance__MemcpyPtr~length
 PRV
 LEA  __Instance__MemcpyPtr
 CAL  MemcpyPtr_L0
#srcline 691 ;                     txMsgLength := txMsgLength + payloadLength + 2;
 LDX  txMsgLength
#debug uint txMsgLength
 LDX  payloadLength
#debug uint payloadLength
 ADD
 AND  $FFFF
 LD   uint 2
 ADD
 AND  $FFFF
 WRX  txMsgLength
#debug_left uint txMsgLength
#srcline 692 ;                end_if;
fbMQTTPublisherEx_L21:
#srcline 695 ;                // length of package
#srcline 696 ;                txData[1]       := UINT_TO_USINT(txMsgLength);
 LDX  txMsgLength
#debug uint txMsgLength
 AND  $FF
 WRX  txData[1]
#debug_left usint txData[1]
#srcline 697 ;                txMsgLength     := txMsgLength + 2;
 LDX  txMsgLength
#debug uint txMsgLength
 LD   uint 2
 ADD
 AND  $FFFF
 WRX  txMsgLength
#debug_left uint txMsgLength
#srcline 698 ;                tx_data_request := true;
 LD   bool -1       ; true
 WRX  tx_data_request
#debug_left bool tx_data_request
#srcline 700 ;                localPortExtension := USINT_TO_UINT(reconnect_counter);
 LDX  reconnect_counter
#debug usint reconnect_counter
 AND  $FFFF
 WRX  localPortExtension
#debug_left uint localPortExtension
#srcline 701 ;                idle_time := 2;
 LD   usint 2
 WRX  idle_time
#debug_left usint idle_time
#srcline 702 ;                // required to change port on each reconnect
#srcline 703 ;                if reconnect_counter < 100 then
 LDX  reconnect_counter
#debug usint reconnect_counter
 LD   usint 100
 LT
 JMC  fbMQTTPublisherEx_L23
#srcline 704 ;                    reconnect_counter := reconnect_counter + 1; //
 LDX  reconnect_counter
#debug usint reconnect_counter
 LD   usint 1
 ADD
 AND  $FF
 WRX  reconnect_counter
#debug_left usint reconnect_counter
#srcline 705 ;                else
 JMP  fbMQTTPublisherEx_L24
fbMQTTPublisherEx_L23:
#srcline 706 ;                    reconnect_counter := 0;
 LD   usint 0
 WRX  reconnect_counter
#debug_left usint reconnect_counter
#srcline 707 ;                end_if;
fbMQTTPublisherEx_L24:
#srcline 708 ;                responce_recived := false;
 LD   bool 0       ; false
 WRX  responce_recived
#debug_left bool responce_recived
#srcline 710 ;                busy := true;
 LD   bool -1       ; true
 WRX  busy
#debug_left bool busy
#srcline 711 ;                ok   := false;
 LD   bool 0       ; false
 WRX  ok
#debug_left bool ok
#srcline 712 ;                err  := false;
 LD   bool 0       ; false
 WRX  err
#debug_left bool err
#srcline 713 ;                return;
 JMP  fbMQTTPublisherEx_RET
#srcline 714 ;           //-------------------- Connected to broker -------------------------------------------------
#srcline 715 ;           else
 JMP  fbMQTTPublisherEx_L10
fbMQTTPublisherEx_L9:
#srcline 716 ;                if sendCom then
 LDX  sendCom
#debug bool sendCom
 JMC  fbMQTTPublisherEx_L25
#srcline 717 ;                    sendCom := false;
 LD   bool 0       ; false
 WRX  sendCom
#debug_left bool sendCom
#srcline 718 ;                     connectFlags := USINT_TO_BYTE(MQTT_CONTROL_PACK_PUBLISH);
 LD   usint 48
 AND  $FF
 WRX  connectFlags
#debug_left byte connectFlags
#srcline 719 ;                     if com_param.dup then connectFlags := connectFlags OR 16#8;  end_if;
 LDX  com_param~dup
#debug bool com_param.dup
 JMC  fbMQTTPublisherEx_L27
 LDX  connectFlags
#debug byte connectFlags
 LD   byte $8
 OR  
 WRX  connectFlags
#debug_left byte connectFlags
fbMQTTPublisherEx_L27:
#srcline 720 ;                     connectFlags := connectFlags OR SHL(IN := USINT_TO_BYTE(com_param.qos),N := 1);
 LDX  connectFlags
#debug byte connectFlags
 LDX  com_param~qos
#debug usint com_param.qos
 AND  $FF
 LD   uint 1
 SHL
 AND  $FF
 OR  
 WRX  connectFlags
#debug_left byte connectFlags
#srcline 721 ;                     if com_param.willRetain   then connectFlags := connectFlags OR 16#1; end_if;
 LDX  com_param~willRetain
#debug bool com_param.willRetain
 JMC  fbMQTTPublisherEx_L29
 LDX  connectFlags
#debug byte connectFlags
 LD   byte $1
 OR  
 WRX  connectFlags
#debug_left byte connectFlags
fbMQTTPublisherEx_L29:
#srcline 723 ;                     txData[0]     := BYTE_TO_USINT(connectFlags);
 LDX  connectFlags
#debug byte connectFlags
 WRX  txData[0]
#debug_left usint txData[0]
#srcline 725 ;                     payloadLength := LEN(IN := topicTxt);
 LEAX topicTxt
#debug string topicTxt
 SLEN 
 WRX  payloadLength
#debug_left uint payloadLength
#srcline 726 ;                   //  txData[2]     := 0;
#srcline 727 ;                   //  txData[3]     := payloadLength;
#srcline 729 ;                     txData[2]  := WORD_TO_USINT(SHR(IN := UINT_TO_WORD(payloadLength),N := 8));
 LDX  payloadLength
#debug uint payloadLength
 LD   uint 8
 SHR
 AND  $FFFF
 AND  $FF
 WRX  txData[2]
#debug_left usint txData[2]
#srcline 730 ;                     txData[3]  := UINT_TO_USINT(payloadLength);
 LDX  payloadLength
#debug uint payloadLength
 AND  $FF
 WRX  txData[3]
#debug_left usint txData[3]
#srcline 732 ;                     MemcpyPtr(source := ADR(topicTxt),dest := ADR(txData[4]),length := UINT_TO_UDINT(payloadLength));
 NXT
 LEAX topicTxt
#debug pointer topicTxt
 LEA  __Instance__MemcpyPtr~source
 WRIL 
#debug_left udint __Instance__MemcpyPtr~source
 LEAX txData
 ADD  4  ; + offset 
#debug pointer txData[4]
 LEA  __Instance__MemcpyPtr~dest
 WRIL 
#debug_left udint __Instance__MemcpyPtr~dest
 LDX  payloadLength
#debug uint payloadLength
 WR   __Instance__MemcpyPtr~length
#debug_left udint __Instance__MemcpyPtr~length
 PRV
 LEA  __Instance__MemcpyPtr
 CAL  MemcpyPtr_L0
#srcline 733 ;                     if com_param.qos > 0 then
 LDX  com_param~qos
#debug usint com_param.qos
 LD   usint 0
 GT
 JMC  fbMQTTPublisherEx_L31
#srcline 734 ;                         messageID        := messageID + 1;
 LDX  messageID
#debug uint messageID
 LD   uint 1
 ADD
 AND  $FFFF
 WRX  messageID
#debug_left uint messageID
#srcline 735 ;                         txData[payloadLength + 4]     := WORD_TO_USINT(SHR(IN := UINT_TO_WORD(messageID), N := 8));
 LDX  messageID
#debug uint messageID
 LD   uint 8
 SHR
 AND  $FFFF
 AND  $FF
 LEAX txData
 LDX  payloadLength
#debug uint payloadLength
 LD   uint 4
 ADD
 AND  $FFFF
 RCHK 512   ; Range Check
 ADD     ; + offset 
 WRI 
#debug_left usint txData[payloadLength+4]
#srcline 736 ;                         txData[payloadLength + 4 + 1] := UINT_TO_USINT(messageID);
 LDX  messageID
#debug uint messageID
 AND  $FF
 LEAX txData
 LDX  payloadLength
#debug uint payloadLength
 LD   uint 4
 ADD
 AND  $FFFF
 LD   uint 1
 ADD
 AND  $FFFF
 RCHK 512   ; Range Check
 ADD     ; + offset 
 WRI 
#debug_left usint txData[payloadLength+4+1]
#srcline 737 ;                         payloadLength                 := payloadLength + 2;
 LDX  payloadLength
#debug uint payloadLength
 LD   uint 2
 ADD
 AND  $FFFF
 WRX  payloadLength
#debug_left uint payloadLength
#srcline 738 ;                     end_if;
fbMQTTPublisherEx_L31:
#srcline 739 ;                    // MemcpyPtr(source := ADR(dataTxt),dest := ADR(txData[payloadLength+4]),length := LEN(dataTxt));
#srcline 740 ;                     MemcpyPtr(source := pData, dest := ADR(txData[payloadLength + 4]),length := UINT_TO_UDINT(dataLength));  //NEW
 NXT
 LEAX pData
 LDIL 
#debug pointer pData
 LEA  __Instance__MemcpyPtr~source
 WRIL 
#debug_left udint __Instance__MemcpyPtr~source
 LEAX txData
 LDX  payloadLength
#debug uint payloadLength
 LD   uint 4
 ADD
 AND  $FFFF
 RCHK 512   ; Range Check
 ADD     ; + offset 
#debug pointer txData[payloadLength+4]
 LEA  __Instance__MemcpyPtr~dest
 WRIL 
#debug_left udint __Instance__MemcpyPtr~dest
 LDX  dataLength
#debug uint dataLength
 WR   __Instance__MemcpyPtr~length
#debug_left udint __Instance__MemcpyPtr~length
 PRV
 LEA  __Instance__MemcpyPtr
 CAL  MemcpyPtr_L0
#srcline 741 ;                    // payloadLength    := payloadLength + LEN(dataTxt);
#srcline 742 ;                     payloadLength    := payloadLength + dataLength; //NEW
 LDX  payloadLength
#debug uint payloadLength
 LDX  dataLength
#debug uint dataLength
 ADD
 AND  $FFFF
 WRX  payloadLength
#debug_left uint payloadLength
#srcline 743 ;                     txMsgLength      := 2 + payloadLength;
 LD   uint 2
 LDX  payloadLength
#debug uint payloadLength
 ADD
 AND  $FFFF
 WRX  txMsgLength
#debug_left uint txMsgLength
#srcline 745 ;                     txMsgLengthTemp   := txMsgLength;
 LDX  txMsgLength
#debug uint txMsgLength
 WRX  txMsgLengthTemp
#debug_left uint txMsgLengthTemp
#srcline 746 ;                     payloadLengthSize := 1;
 LD   uint 1
 WRX  payloadLengthSize
#debug_left uint payloadLengthSize
#srcline 748 ;                     while txMsgLengthTemp > 0 do
fbMQTTPublisherEx_L33:
 LDX  txMsgLengthTemp
#debug uint txMsgLengthTemp
 LD   uint 0
 GT
 JMC  fbMQTTPublisherEx_L34
 DBG 
#srcline 749 ;                           encodedByte := UINT_TO_BYTE(txMsgLengthTemp MOD 128);
 LDX  txMsgLengthTemp
#debug uint txMsgLengthTemp
 LD   uint 128
 MOD
 AND  $FFFF
 AND  $FF
 WRX  encodedByte
#debug_left byte encodedByte
#srcline 750 ;                           txMsgLengthTemp := txMsgLengthTemp / 128;
 LDX  txMsgLengthTemp
#debug uint txMsgLengthTemp
 LD   uint 128
 DIVL
 AND  $FFFF
 WRX  txMsgLengthTemp
#debug_left uint txMsgLengthTemp
#srcline 751 ;                           if txMsgLengthTemp > 0 then
 LDX  txMsgLengthTemp
#debug uint txMsgLengthTemp
 LD   uint 0
 GT
 JMC  fbMQTTPublisherEx_L35
#srcline 752 ;                               payloadLengthArrayTemp[payloadLengthSize] := BYTE_TO_USINT(encodedByte OR 128);
 LDX  encodedByte
#debug byte encodedByte
 LD   byte 128
 OR  
 LEAX payloadLengthArrayTemp
 LDX  payloadLengthSize
#debug uint payloadLengthSize
 SUB  1   ; Low range[1]
 RCHK 3   ; Range Check
 ADD     ; + offset 
 WRI 
#debug_left usint payloadLengthArrayTemp[payloadLengthSize]
#srcline 753 ;                               payloadLengthSize := payloadLengthSize + 1;
 LDX  payloadLengthSize
#debug uint payloadLengthSize
 LD   uint 1
 ADD
 AND  $FFFF
 WRX  payloadLengthSize
#debug_left uint payloadLengthSize
#srcline 754 ;                           else
 JMP  fbMQTTPublisherEx_L36
fbMQTTPublisherEx_L35:
#srcline 755 ;                               payloadLengthArrayTemp[payloadLengthSize] := BYTE_TO_USINT(encodedByte);
 LDX  encodedByte
#debug byte encodedByte
 LEAX payloadLengthArrayTemp
 LDX  payloadLengthSize
#debug uint payloadLengthSize
 SUB  1   ; Low range[1]
 RCHK 3   ; Range Check
 ADD     ; + offset 
 WRI 
#debug_left usint payloadLengthArrayTemp[payloadLengthSize]
#srcline 756 ;                           end_if;
fbMQTTPublisherEx_L36:
#srcline 757 ;                           if payloadLengthSize > 4 then
 LDX  payloadLengthSize
#debug uint payloadLengthSize
 LD   uint 4
 GT
 JMC  fbMQTTPublisherEx_L37
#srcline 758 ;                               busy := false;
 LD   bool 0       ; false
 WRX  busy
#debug_left bool busy
#srcline 759 ;                               ok   := false;
 LD   bool 0       ; false
 WRX  ok
#debug_left bool ok
#srcline 760 ;                               err  := true;
 LD   bool -1       ; true
 WRX  err
#debug_left bool err
#srcline 761 ;                               //FIXME: Add error code "Payload length is out of range"
#srcline 762 ;                               return;
 JMP  fbMQTTPublisherEx_RET
#srcline 763 ;                           end_if;
fbMQTTPublisherEx_L37:
#srcline 764 ;                     end_while;
 JMP  fbMQTTPublisherEx_L33
fbMQTTPublisherEx_L34:
 NOP  -1
#srcline 766 ;                     if payloadLengthSize = 1 then
 LDX  payloadLengthSize
#debug uint payloadLengthSize
 LD   uint 1
 EQ
 JMC  fbMQTTPublisherEx_L39
#srcline 767 ;                         txData[1] := UINT_TO_USINT(txMsgLength);
 LDX  txMsgLength
#debug uint txMsgLength
 AND  $FF
 WRX  txData[1]
#debug_left usint txData[1]
#srcline 768 ;                     else
 JMP  fbMQTTPublisherEx_L40
fbMQTTPublisherEx_L39:
#srcline 769 ;                         txMsgLength     := txMsgLength + payloadLengthSize - 1;
 LDX  txMsgLength
#debug uint txMsgLength
 LDX  payloadLengthSize
#debug uint payloadLengthSize
 ADD
 AND  $FFFF
 LD   uint 1
 SUB
 AND  $FFFF
 WRX  txMsgLength
#debug_left uint txMsgLength
#srcline 770 ;                         txMsgLengthTemp := txMsgLength;
 LDX  txMsgLength
#debug uint txMsgLength
 WRX  txMsgLengthTemp
#debug_left uint txMsgLengthTemp
#srcline 772 ;                         while txMsgLengthTemp >= payloadLengthSize do
fbMQTTPublisherEx_L41:
 LDX  txMsgLengthTemp
#debug uint txMsgLengthTemp
 LDX  payloadLengthSize
#debug uint payloadLengthSize
 LT
 NEG
 JMC  fbMQTTPublisherEx_L42
 DBG 
#srcline 773 ;                           txData[txMsgLengthTemp + 1] := txData[txMsgLengthTemp];
 LEAX txData
 LDX  txMsgLengthTemp
#debug uint txMsgLengthTemp
 RCHK 512   ; Range Check
 ADD     ; + offset 
 LDI  
#debug usint txData[txMsgLengthTemp]
 LEAX txData
 LDX  txMsgLengthTemp
#debug uint txMsgLengthTemp
 LD   uint 1
 ADD
 AND  $FFFF
 RCHK 512   ; Range Check
 ADD     ; + offset 
 WRI 
#debug_left usint txData[txMsgLengthTemp+1]
#srcline 774 ;                           txMsgLengthTemp := txMsgLengthTemp - 1;
 LDX  txMsgLengthTemp
#debug uint txMsgLengthTemp
 LD   uint 1
 SUB
 AND  $FFFF
 WRX  txMsgLengthTemp
#debug_left uint txMsgLengthTemp
#srcline 775 ;                         end_while;
 JMP  fbMQTTPublisherEx_L41
fbMQTTPublisherEx_L42:
 NOP  -1
#srcline 776 ;                         for index := 1 to payloadLengthSize do
 LD   uint 1
 WRX  index
 LDX  payloadLengthSize
#debug uint payloadLengthSize
 WRY  P0__st__
fbMQTTPublisherEx_L43:
 LDX  index
 LDY  P0__st__
 GT   
 JMD  fbMQTTPublisherEx_L44
 DBG  
#srcline 777 ;                              txData[index] := payloadLengthArrayTemp[index];
 LEAX payloadLengthArrayTemp
 LDX  index
#debug uint index
 SUB  1   ; Low range[1]
 RCHK 3   ; Range Check
 ADD     ; + offset 
 LDI  
#debug usint payloadLengthArrayTemp[index]
 LEAX txData
 LDX  index
#debug uint index
 RCHK 512   ; Range Check
 ADD     ; + offset 
 WRI 
#debug_left usint txData[index]
#srcline 778 ;                         end_for;
 LDX  index
 LD   1
 ADD  
 WRX  index
 JMP  fbMQTTPublisherEx_L43
fbMQTTPublisherEx_L44:
 NOP  -1
#srcline 779 ;                     end_if;
fbMQTTPublisherEx_L40:
#srcline 782 ;                     txMsgLength      := txMsgLength + 2;
 LDX  txMsgLength
#debug uint txMsgLength
 LD   uint 2
 ADD
 AND  $FFFF
 WRX  txMsgLength
#debug_left uint txMsgLength
#srcline 783 ;                     tx_data_request  := true;
 LD   bool -1       ; true
 WRX  tx_data_request
#debug_left bool tx_data_request
#srcline 784 ;                     busy := true;
 LD   bool -1       ; true
 WRX  busy
#debug_left bool busy
#srcline 785 ;                     ok   := false;
 LD   bool 0       ; false
 WRX  ok
#debug_left bool ok
#srcline 786 ;                     err  := false;
 LD   bool 0       ; false
 WRX  err
#debug_left bool err
#srcline 787 ;                    return;
 JMP  fbMQTTPublisherEx_RET
#srcline 788 ;                end_if;
fbMQTTPublisherEx_L25:
#srcline 790 ;                if pubReleaseRq then
 LDX  pubReleaseRq
#debug bool pubReleaseRq
 JMC  fbMQTTPublisherEx_L45
#srcline 791 ;                    pubReleaseRq := false;
 LD   bool 0       ; false
 WRX  pubReleaseRq
#debug_left bool pubReleaseRq
#srcline 792 ;                    txData[0]        := MQTT_CONTROL_PACK_PUBREL + 2; // flag bits are cleared
 LD   usint 96
 LD   usint 2
 ADD
 AND  $FF
 WRX  txData[0]
#debug_left usint txData[0]
#srcline 793 ;                    txData[1]        := 2;
 LD   usint 2
 WRX  txData[1]
#debug_left usint txData[1]
#srcline 794 ;                    txData[2]        := WORD_TO_USINT(SHR(IN := UINT_TO_WORD(messageIDpubRel), N := 8));
 LDX  messageIDpubRel
#debug uint messageIDpubRel
 LD   uint 8
 SHR
 AND  $FFFF
 AND  $FF
 WRX  txData[2]
#debug_left usint txData[2]
#srcline 795 ;                    txData[3]        := UINT_TO_USINT(messageIDpubRel);
 LDX  messageIDpubRel
#debug uint messageIDpubRel
 AND  $FF
 WRX  txData[3]
#debug_left usint txData[3]
#srcline 796 ;                    txMsgLength      := 4;
 LD   uint 4
 WRX  txMsgLength
#debug_left uint txMsgLength
#srcline 797 ;                    tx_data_request  := true;
 LD   bool -1       ; true
 WRX  tx_data_request
#debug_left bool tx_data_request
#srcline 798 ;                    responce_recived := false;
 LD   bool 0       ; false
 WRX  responce_recived
#debug_left bool responce_recived
#srcline 799 ;                    busy             := true;
 LD   bool -1       ; true
 WRX  busy
#debug_left bool busy
#srcline 800 ;                    ok               := false;
 LD   bool 0       ; false
 WRX  ok
#debug_left bool ok
#srcline 801 ;                    err              := false;
 LD   bool 0       ; false
 WRX  err
#debug_left bool err
#srcline 802 ;                    return;
 JMP  fbMQTTPublisherEx_RET
#srcline 803 ;                end_if;
fbMQTTPublisherEx_L45:
#srcline 804 ;                //---------------------------------------------
#srcline 805 ;                if MQTT_ping_timer.Q then
 LDX  MQTT_ping_timer~Q
#debug bool MQTT_ping_timer.Q
 JMC  fbMQTTPublisherEx_L47
#srcline 806 ;                    //Ping request
#srcline 807 ;                     txData[0]        := MQTT_CONTROL_PACK_PINGREQ; // flag bits are cleared
 LD   usint 192
 WRX  txData[0]
#debug_left usint txData[0]
#srcline 808 ;                     txData[1]        := 0;
 LD   usint 0
 WRX  txData[1]
#debug_left usint txData[1]
#srcline 809 ;                     txMsgLength      := 2;
 LD   uint 2
 WRX  txMsgLength
#debug_left uint txMsgLength
#srcline 810 ;                     tx_data_request  := true;
 LD   bool -1       ; true
 WRX  tx_data_request
#debug_left bool tx_data_request
#srcline 811 ;                     responce_recived := false;
 LD   bool 0       ; false
 WRX  responce_recived
#debug_left bool responce_recived
#srcline 812 ;                     busy             := true;
 LD   bool -1       ; true
 WRX  busy
#debug_left bool busy
#srcline 813 ;                     ok               := false;
 LD   bool 0       ; false
 WRX  ok
#debug_left bool ok
#srcline 814 ;                     err              := false;
 LD   bool 0       ; false
 WRX  err
#debug_left bool err
#srcline 815 ;                     return;
 JMP  fbMQTTPublisherEx_RET
#srcline 816 ;                end_if;
fbMQTTPublisherEx_L47:
#srcline 818 ;           end_if;
fbMQTTPublisherEx_L10:
#srcline 819 ;       end_if;
fbMQTTPublisherEx_L7:
#srcline 821 ;      if conn_status then
 LDX  conn_status
#debug bool conn_status
 JMC  fbMQTTPublisherEx_L49
#srcline 822 ;           SendTo( rq := tx_data_request, chanCode := chanCode, lenTx := txMsgLength , data := void(txData));
 LDX  tx_data_request
#debug bool tx_data_request
 WRX  SendTo~rq
#debug_left bool SendTo~rq
 LDX  chanCode
#debug uint chanCode
 WRX  SendTo~chanCode
#debug_left uint SendTo~chanCode
 LDX  txMsgLength
#debug uint txMsgLength
 WRX  SendTo~lenTx
#debug_left uint SendTo~lenTx
 LEAX txData
 WRX  SendTo~data
#debug_left pointer SendTo.data
 LEAX SendTo
 CAL  fbSendTo_L0
#srcline 823 ;           if SendTo.mesSent then
 LDX  SendTo~mesSent
#debug bool SendTo.mesSent
 JMC  fbMQTTPublisherEx_L51
#srcline 824 ;               tx_data_request  := false;
 LD   bool 0       ; false
 WRX  tx_data_request
#debug_left bool tx_data_request
#srcline 825 ;               txCounter        := txCounter + 1;
 LDX  txCounter
#debug uint txCounter
 LD   uint 1
 ADD
 AND  $FFFF
 WRX  txCounter
#debug_left uint txCounter
#srcline 826 ;               messageIDlast    := messageID;
 LDX  messageID
#debug uint messageID
 WRX  messageIDlast
#debug_left uint messageIDlast
#srcline 827 ;             //  messageID        := messageID + 1;
#srcline 828 ;               responce_recived := false;
 LD   bool 0       ; false
 WRX  responce_recived
#debug_left bool responce_recived
#srcline 830 ;               if com_param.qos = 0 then
 LDX  com_param~qos
#debug usint com_param.qos
 LD   usint 0
 EQ
 JMC  fbMQTTPublisherEx_L53
#srcline 831 ;                  busy := false;
 LD   bool 0       ; false
 WRX  busy
#debug_left bool busy
#srcline 832 ;                  ok   := true;
 LD   bool -1       ; true
 WRX  ok
#debug_left bool ok
#srcline 833 ;                  err  := false;
 LD   bool 0       ; false
 WRX  err
#debug_left bool err
#srcline 834 ;                  wait_response := false;
 LD   bool 0       ; false
 WRX  wait_response
#debug_left bool wait_response
#srcline 835 ;               else
 JMP  fbMQTTPublisherEx_L54
fbMQTTPublisherEx_L53:
#srcline 836 ;                  wait_response := true;
 LD   bool -1       ; true
 WRX  wait_response
#debug_left bool wait_response
#srcline 837 ;               end_if;
fbMQTTPublisherEx_L54:
#srcline 838 ;          end_if;
fbMQTTPublisherEx_L51:
#srcline 840 ;          RecvFrom( rq := true, chanCode := chanCode, lenRx := 100, data := void(rxData));
 LD   bool -1       ; true
 WRX  RecvFrom~rq
#debug_left bool RecvFrom~rq
 LDX  chanCode
#debug uint chanCode
 WRX  RecvFrom~chanCode
#debug_left uint RecvFrom~chanCode
 LD   uint 100
 WRX  RecvFrom~lenRx
#debug_left uint RecvFrom~lenRx
 LEAX rxData
 WRX  RecvFrom~data
#debug_left pointer RecvFrom.data
 LEAX RecvFrom
 CAL  fbRecvFrom_L0
#srcline 842 ;          if RecvFrom.mesRec then
 LDX  RecvFrom~mesRec
#debug bool RecvFrom.mesRec
 JMC  fbMQTTPublisherEx_L55
#srcline 843 ;              if RecvFrom.error = 0 then
 LDX  RecvFrom~error
#debug usint RecvFrom.error
 LD   usint 0
 EQ
 JMC  fbMQTTPublisherEx_L57
#srcline 844 ;                  messageIDpubRel_ptr := ADR(rxData[2]);
 LEAX rxData
 ADD  2  ; + offset 
#debug pointer rxData[2]
 LEAX messageIDpubRel_ptr
 WRIL 
#debug_left pointer messageIDpubRel_ptr
#srcline 845 ;                  messageIDpubRel     := messageIDpubRel_ptr^;
 LEAX messageIDpubRel_ptr
 LDIL    ; dereference 
 LDIW 
#debug uint messageIDpubRel_ptr^
 WRX  messageIDpubRel
#debug_left uint messageIDpubRel
#srcline 846 ;                  messageIDpubRel     := fSwapUINT( messageIDpubRel);
 NXT
 LDX  messageIDpubRel
#debug uint messageIDpubRel
 WR   __Instance__fSwapUINT~input
#debug_left uint __Instance__fSwapUINT~input
 PRV
 LEA  __Instance__fSwapUINT
 CAL  fSwapUINT_L0
 WRX  messageIDpubRel
#debug_left uint messageIDpubRel
#srcline 847 ;                  if messageIDlast = messageIDpubRel AND rxData[1] = 2 AND (rxData[0] = MQTT_CONTROL_PACK_CONNACK OR (rxData[0] = MQTT_CONTROL_PACK_PUBACK  AND com_param.qos = 1)
 LDX  messageIDlast
#debug uint messageIDlast
 LDX  messageIDpubRel
#debug uint messageIDpubRel
 EQ
 LDX  rxData[1]
#debug usint rxData[1]
 LD   usint 2
 EQ
 AND
 LDX  rxData[0]
#debug usint rxData[0]
 LD   usint 32
 EQ
 LDX  rxData[0]
#debug usint rxData[0]
 LD   usint 64
 EQ
 LDX  com_param~qos
#debug usint com_param.qos
 LD   usint 1
 EQ
 AND
#srcline 848 ;                                                                                                                  OR (rxData[0] = MQTT_CONTROL_PACK_PUBCOMP AND com_param.qos = 2) ) then // responce to connect command
 OR  
 LDX  rxData[0]
#debug usint rxData[0]
 LD   usint 112
 EQ
 LDX  com_param~qos
#debug usint com_param.qos
 LD   usint 2
 EQ
 AND
 OR  
 AND
 JMC  fbMQTTPublisherEx_L59
#srcline 849 ;                      connected_to_broker := true;
 LD   bool -1       ; true
 WRX  connected_to_broker
#debug_left bool connected_to_broker
#srcline 850 ;                      responce_recived    := true;
 LD   bool -1       ; true
 WRX  responce_recived
#debug_left bool responce_recived
#srcline 851 ;                      wait_response       := false;
 LD   bool 0       ; false
 WRX  wait_response
#debug_left bool wait_response
#srcline 852 ;                      busy                := false;
 LD   bool 0       ; false
 WRX  busy
#debug_left bool busy
#srcline 853 ;                      ok                  := true;
 LD   bool -1       ; true
 WRX  ok
#debug_left bool ok
#srcline 854 ;                      err                 := false;
 LD   bool 0       ; false
 WRX  err
#debug_left bool err
#srcline 855 ;                  elsif RecvFrom.lenData = 4 AND com_param.qos = 2 AND rxData[0] = MQTT_CONTROL_PACK_PUBREC then
 JMP  fbMQTTPublisherEx_L60
fbMQTTPublisherEx_L59:
 LDX  RecvFrom~lenData
#debug uint RecvFrom.lenData
 LD   uint 4
 EQ
 LDX  com_param~qos
#debug usint com_param.qos
 LD   usint 2
 EQ
 AND
 LDX  rxData[0]
#debug usint rxData[0]
 LD   usint 80
 EQ
 AND
 JMC  fbMQTTPublisherEx_L61
#srcline 856 ;                          messageIDpubRel     := fSwapUINT( messageIDpubRel_ptr^);
 NXT
 LEAX messageIDpubRel_ptr
 LDIL    ; dereference 
 LDIW 
#debug uint messageIDpubRel_ptr^
 WR   __Instance__fSwapUINT~input
#debug_left uint __Instance__fSwapUINT~input
 PRV
 LEA  __Instance__fSwapUINT
 CAL  fSwapUINT_L0
 WRX  messageIDpubRel
#debug_left uint messageIDpubRel
#srcline 857 ;                          connected_to_broker := true;
 LD   bool -1       ; true
 WRX  connected_to_broker
#debug_left bool connected_to_broker
#srcline 858 ;                          responce_recived    := true;
 LD   bool -1       ; true
 WRX  responce_recived
#debug_left bool responce_recived
#srcline 859 ;                          wait_response       := false;
 LD   bool 0       ; false
 WRX  wait_response
#debug_left bool wait_response
#srcline 860 ;                          pubReleaseRq        := true;
 LD   bool -1       ; true
 WRX  pubReleaseRq
#debug_left bool pubReleaseRq
#srcline 861 ;                  elsif RecvFrom.lenData = 2 AND rxData[0] = MQTT_CONTROL_PACK_PINGRESP then
 JMP  fbMQTTPublisherEx_L60
fbMQTTPublisherEx_L61:
 LDX  RecvFrom~lenData
#debug uint RecvFrom.lenData
 LD   uint 2
 EQ
 LDX  rxData[0]
#debug usint rxData[0]
 LD   usint 208
 EQ
 AND
 JMC  fbMQTTPublisherEx_L62
#srcline 862 ;                         responce_recived := true;
 LD   bool -1       ; true
 WRX  responce_recived
#debug_left bool responce_recived
#srcline 863 ;                         wait_response    := false;
 LD   bool 0       ; false
 WRX  wait_response
#debug_left bool wait_response
#srcline 864 ;                         busy             := false;
 LD   bool 0       ; false
 WRX  busy
#debug_left bool busy
#srcline 865 ;                         ok               := true;
 LD   bool -1       ; true
 WRX  ok
#debug_left bool ok
#srcline 866 ;                         err              := false;
 LD   bool 0       ; false
 WRX  err
#debug_left bool err
#srcline 867 ;                  end_if;
 JMP  fbMQTTPublisherEx_L60
fbMQTTPublisherEx_L62:
fbMQTTPublisherEx_L60:
#srcline 868 ;                  rxCounter := rxCounter + 1;
 LDX  rxCounter
#debug uint rxCounter
 LD   uint 1
 ADD
 AND  $FFFF
 WRX  rxCounter
#debug_left uint rxCounter
#srcline 869 ;              end_if;
fbMQTTPublisherEx_L57:
#srcline 870 ;          end_if;
fbMQTTPublisherEx_L55:
#srcline 871 ;      else
 JMP  fbMQTTPublisherEx_L50
fbMQTTPublisherEx_L49:
#srcline 872 ;         connected_to_broker := false;
 LD   bool 0       ; false
 WRX  connected_to_broker
#debug_left bool connected_to_broker
#srcline 873 ;         wait_response       := false;
 LD   bool 0       ; false
 WRX  wait_response
#debug_left bool wait_response
#srcline 874 ;         pubReleaseRq        := false;
 LD   bool 0       ; false
 WRX  pubReleaseRq
#debug_left bool pubReleaseRq
#srcline 875 ;         busy                := false;
 LD   bool 0       ; false
 WRX  busy
#debug_left bool busy
#srcline 876 ;         ok                  := false;
 LD   bool 0       ; false
 WRX  ok
#debug_left bool ok
#srcline 877 ;         err                 := true;
 LD   bool -1       ; true
 WRX  err
#debug_left bool err
#srcline 878 ;         errCode             := MQTT_CONTROL_ERROR_CODE_BROKER_DISCONNECTED;
 LD   usint 3
 WRX  errCode
#debug_left usint errCode
#srcline 879 ;      end_if;
fbMQTTPublisherEx_L50:
#srcline 881 ;   else
 JMP  fbMQTTPublisherEx_L6
fbMQTTPublisherEx_L5:
#srcline 882 ;     connected_to_broker := false;
 LD   bool 0       ; false
 WRX  connected_to_broker
#debug_left bool connected_to_broker
#srcline 883 ;     wait_response       := false;
 LD   bool 0       ; false
 WRX  wait_response
#debug_left bool wait_response
#srcline 884 ;     pubReleaseRq        := false;
 LD   bool 0       ; false
 WRX  pubReleaseRq
#debug_left bool pubReleaseRq
#srcline 885 ;     busy                := false;
 LD   bool 0       ; false
 WRX  busy
#debug_left bool busy
#srcline 886 ;     ok                  := false;
 LD   bool 0       ; false
 WRX  ok
#debug_left bool ok
#srcline 887 ;     err                 := true;
 LD   bool -1       ; true
 WRX  err
#debug_left bool err
#srcline 888 ;     errCode             := MQTT_CONTROL_ERROR_CODE_BROKER_DISCONNECTED;
 LD   usint 3
 WRX  errCode
#debug_left usint errCode
#srcline 889 ;   end_if;
fbMQTTPublisherEx_L6:
#srcline 892 ;END_FUNCTION_BLOCK
fbMQTTPublisherEx_RET:
 ULNK
RET
E     61

; Initialize - variables
P     61
fbMQTTPublisherEx__InstanceInit__:
 LINK 0
 LD   uint 1883
 WRX  brokerPort
 LD   uint 6000
 WRX  localPort
 LD   bool -1   ; true
 WRX  keepAlive
 LD   time 60000
 WRX  keepAliveInterval
 LD   time 10000
 WRX  connTimeOut
 LD   time 15000
 WRX  pingInterval
 LD   bool -1   ; true
 WRX  clientId_auto
 LD   0
 SRC  byte __Init___fbMQTTPublisherEx_com_param
 LEAX byte com_param
 LD   3
 MOV  %X0
 LD   udint $FFFFFFFF    ; nil
 WRX  pData
 LEAX MQTT_Comm_Init
 CAL  fbMQTT_Comm_Init__InstanceInit__
 LEAX SendTo
 CAL  fbSendTo__InstanceInit__
 LEAX RecvFrom
 CAL  fbRecvFrom__InstanceInit__
 LD   0
 SRC  byte __Init___fbMQTTPublisherEx_MQTT_PROTOCOL
 LEAX byte MQTT_PROTOCOL
 LD   5
 MOV  %X0
 LD   udint $FFFFFFFF    ; nil
 WRX  messageIDpubRel_ptr
 ULNK
RET
E     61
; End initialize - variables
#endpou 



 

#srcfile ''
#srcfile 'D:\TECOLIBSRC\MQTT_LIB\MQTT_LIB\FBMQTTSUBSCRIBER.ST'
#pou fbMQTTSubscriber
#srcline 3 ;FUNCTION_BLOCK fbMQTTSubscriber
#table byte __Init___fbMQTTSubscriber_com_param = 
      0,  0,  1;
#table byte __Init___fbMQTTSubscriber_MQTT_PROTOCOL = 
    'M','Q','T','T';
#table byte __Init___fbMQTTSubscriber_inDataCom_param = 
      0,  0,  1;

#struct fbMQTTSubscriber__temp__
  string[257] PS0__st__,
  string[34] PSC__st__
#data byte _str_fbMQTTSubscriber_0 = 
  '',0
#data byte _str_fbMQTTSubscriber_1 = 
  '',0
#data byte _str_fbMQTTSubscriber_2 = 
  '',0
#data byte _str_fbMQTTSubscriber_3 = 
  '',0
P     61
fbMQTTSubscriber_L0:
 LINK __SizeOf(fbMQTTSubscriber__temp__)
; R_EDGE, F_EDGE 
 LDX  subRq
 LETX __EDGE_R__subRq
 WRX  subRq
 LDX  unSubRq
 LETX __EDGE_R__unSubRq
 WRX  unSubRq
#srcline 109 ;  dataRec := false;
 LD   bool 0       ; false
 WRX  dataRec
#debug_left bool dataRec
#srcline 110 ;  
#srcline 111 ;  if MQTT_com_responce_timeout.Q then
 LDX  MQTT_com_responce_timeout~Q
#debug bool MQTT_com_responce_timeout.Q
 JMC  fbMQTTSubscriber_L1
#srcline 112 ;      if responce_recived = false then
 LDX  responce_recived
#debug bool responce_recived
 LD   bool 0       ; false
 XOR
 NEG
 JMC  fbMQTTSubscriber_L3
#srcline 113 ;          connected_to_broker := false;
 LD   bool 0       ; false
 WRX  connected_to_broker
#debug_left bool connected_to_broker
#srcline 114 ;      end_if;
fbMQTTSubscriber_L3:
#srcline 115 ;      wait_response := false;
 LD   bool 0       ; false
 WRX  wait_response
#debug_left bool wait_response
#srcline 116 ;      busy := false;
 LD   bool 0       ; false
 WRX  busy
#debug_left bool busy
#srcline 117 ;      ok   := false;
 LD   bool 0       ; false
 WRX  ok
#debug_left bool ok
#srcline 118 ;      err  := true;
 LD   bool -1       ; true
 WRX  err
#debug_left bool err
#srcline 119 ;      errCode := MQTT_CONTROL_ERROR_CODE_BROKER_ANSWER_TIME_OUT;
 LD   usint 1
 WRX  errCode
#debug_left usint errCode
#srcline 120 ;  end_if;
fbMQTTSubscriber_L1:
#srcline 121 ;  local_port := localPort + localPortExtension;
 LDX  localPort
#debug uint localPort
 LDX  localPortExtension
#debug uint localPortExtension
 ADD
 AND  $FFFF
 WRX  local_port
#debug_left uint local_port
#srcline 122 ;  MQTT_Comm_Init( connect := connect, chanCode := chanCode, remoteIP := brokerIP, remotePort := brokerPort, localPort := localPort + localPortExtension,
 LDX  connect
#debug bool connect
 WRX  MQTT_Comm_Init~connect
#debug_left bool MQTT_Comm_Init~connect
 LDX  chanCode
#debug uint chanCode
 WRX  MQTT_Comm_Init~chanCode
#debug_left uint MQTT_Comm_Init~chanCode
 LEAX brokerIP
#debug pointer brokerIP
 SRC  %IB0
 LEAX MQTT_Comm_Init~remoteIP
 LD   4   ;SizeOf() 
 MOV  %IB0
 LDX  brokerPort
#debug uint brokerPort
 WRX  MQTT_Comm_Init~remotePort
#debug_left uint MQTT_Comm_Init~remotePort
 LDX  localPort
#debug uint localPort
 LDX  localPortExtension
#debug uint localPortExtension
 ADD
 AND  $FFFF
 WRX  MQTT_Comm_Init~localPort
#debug_left uint MQTT_Comm_Init~localPort
#srcline 123 ;                  status       => conn_status);
 LEAX MQTT_Comm_Init
 CAL  fbMQTT_Comm_Init_L0
; output assigment 
 LDX  MQTT_Comm_Init~status
#debug bool MQTT_Comm_Init~status
 WRX  conn_status
#debug_left bool conn_status
#srcline 125 ;   MQTT_com_responce_timeout(IN := wait_response,PT := connTimeOut);
 LDX  wait_response
#debug bool wait_response
 WRX  MQTT_com_responce_timeout~IN
#debug_left bool MQTT_com_responce_timeout~IN
 LDX  connTimeOut
#debug time connTimeOut
 WRX  MQTT_com_responce_timeout~PT
#debug_left time MQTT_com_responce_timeout~PT
 LEAX MQTT_com_responce_timeout
 CAL  TON_L0
#srcline 126 ;   MQTT_ping_timer(IN := connect AND keepAlive, PT := pingInterval);
 LDX  connect
#debug bool connect
 LDX  keepAlive
#debug bool keepAlive
 AND
 WRX  MQTT_ping_timer~IN
#debug_left bool MQTT_ping_timer~IN
 LDX  pingInterval
#debug time pingInterval
 WRX  MQTT_ping_timer~PT
#debug_left time MQTT_ping_timer~PT
 LEAX MQTT_ping_timer
 CAL  fbTick_L0
#srcline 127 ;   MQTT_com_intervat(IN := connect, PT := T#2s);
 LDX  connect
#debug bool connect
 WRX  MQTT_com_intervat~IN
#debug_left bool MQTT_com_intervat~IN
 LD   time 2000
 WRX  MQTT_com_intervat~PT
#debug_left time MQTT_com_intervat~PT
 LEAX MQTT_com_intervat
 CAL  fbTick_L0
#srcline 129 ;   if connect then
 LDX  connect
#debug bool connect
 JMC  fbMQTTSubscriber_L5
#srcline 130 ;       if MQTT_com_intervat.Q OR subRq OR unSubRq OR pubAckRq OR pubRecRq OR pubCompRq then
 LDX  MQTT_com_intervat~Q
#debug bool MQTT_com_intervat.Q
 LDX  subRq
#debug bool subRq
 OR  
 LDX  unSubRq
#debug bool unSubRq
 OR  
 LDX  pubAckRq
#debug bool pubAckRq
 OR  
 LDX  pubRecRq
#debug bool pubRecRq
 OR  
 LDX  pubCompRq
#debug bool pubCompRq
 OR  
 JMC  fbMQTTSubscriber_L7
#srcline 131 ;           if connected_to_broker = false then
 LDX  connected_to_broker
#debug bool connected_to_broker
 LD   bool 0       ; false
 XOR
 NEG
 JMC  fbMQTTSubscriber_L9
#srcline 132 ;                 if clientId_auto then
 LDX  clientId_auto
#debug bool clientId_auto
 JMC  fbMQTTSubscriber_L11
#srcline 133 ;                     client_id := DWORD_TO_STRING(DT_TO_DWORD(GetRTC())) + UINT_TO_STRING(MSEC_OF_DT(GetRTC()));
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   32
 DST    ; Level 1
 LD   0   ; null string
 WRY  PSC__st__[0]
 LEAY PSC__st__[0]
 LD   32
 DST    ; Level 2
 LEA  __Instance__GetRTC
 CAL  GetRTC_L0
 RNDD
 UDFL
 SCNV $2C30;  IEC_DWORD _TO_ IEC_STRING
 PDST   ; Level 2
 LEAY PSC__st__[0]

 SCON 
 LD   0   ; null string
 WRY  PSC__st__[0]
 LEAY PSC__st__[0]
 LD   32
 DST    ; Level 2
 NXT
 LEA  __Instance__GetRTC
 CAL  GetRTC_L0
 WR   __Instance__MSEC_OF_DT~in
#debug_left dt __Instance__MSEC_OF_DT~in
 PRV
 LEA  __Instance__MSEC_OF_DT
 CAL  MSEC_OF_DT_L0
 SCNV $0A30;  IEC_UINT _TO_ IEC_STRING
 PDST   ; Level 2
 LEAY PSC__st__[0]

 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX client_id
 WRI  
 LEAX client_id
 LD   32
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string client_id
 PDST   ; Level 1
#srcline 134 ;                 else
 JMP  fbMQTTSubscriber_L12
fbMQTTSubscriber_L11:
#srcline 135 ;                     client_id := clientId;
 LD   0   ; null string
 LEAX client_id
 WRI  
 LEAX client_id
 LD   32
 DST    ; Level 1
 LEAX clientId
#debug string clientId
 SCON 
#debug_left string client_id
 PDST   ; Level 1
#srcline 136 ;                 end_if;
fbMQTTSubscriber_L12:
#srcline 138 ;                // Fixed header of control packet
#srcline 139 ;                // Fixed header
#srcline 140 ;                txData[0] := MQTT_CONTROL_PACK_CONNECT; // flag bits are cleared
 LD   usint 16
 WRX  txData[0]
#debug_left usint txData[0]
#srcline 141 ;                // Variable header
#srcline 142 ;                txData[2] := 0;
 LD   usint 0
 WRX  txData[2]
#debug_left usint txData[2]
#srcline 143 ;                txData[3] := 4;
 LD   usint 4
 WRX  txData[3]
#debug_left usint txData[3]
#srcline 144 ;                MemcpyPtr(source := ADR(MQTT_PROTOCOL),dest := ADR(txData[4]),length := 4);
 NXT
 LEAX MQTT_PROTOCOL
#debug pointer MQTT_PROTOCOL
 LEA  __Instance__MemcpyPtr~source
 WRIL 
#debug_left udint __Instance__MemcpyPtr~source
 LEAX txData
 ADD  4  ; + offset 
#debug pointer txData[4]
 LEA  __Instance__MemcpyPtr~dest
 WRIL 
#debug_left udint __Instance__MemcpyPtr~dest
 LD   udint 4
 WR   __Instance__MemcpyPtr~length
#debug_left udint __Instance__MemcpyPtr~length
 PRV
 LEA  __Instance__MemcpyPtr
 CAL  MemcpyPtr_L0
#srcline 145 ;                txData[8]   := MQTT_PROTOCOL_VERSION;
 LD   usint 4
 WRX  txData[8]
#debug_left usint txData[8]
#srcline 146 ;                // Protocol Level byte
#srcline 147 ;                //Set connection flags
#srcline 148 ;                connectFlags := 0;
 LD   byte 0
 WRX  connectFlags
#debug_left byte connectFlags
#srcline 149 ;                if loginName <> ''        then connectFlags := 16#80; end_if;
 LEAX loginName
#debug string loginName
 LEA  _str_fbMQTTSubscriber_0
 SCMP 
 EQ   0
 NEG
 JMC  fbMQTTSubscriber_L13
 LD   byte $80
 WRX  connectFlags
#debug_left byte connectFlags
fbMQTTSubscriber_L13:
#srcline 150 ;                if loginPass <> ''        then connectFlags := connectFlags OR 16#40; end_if;
 LEAX loginPass
#debug string loginPass
 LEA  _str_fbMQTTSubscriber_1
 SCMP 
 EQ   0
 NEG
 JMC  fbMQTTSubscriber_L15
 LDX  connectFlags
#debug byte connectFlags
 LD   byte $40
 OR  
 WRX  connectFlags
#debug_left byte connectFlags
fbMQTTSubscriber_L15:
#srcline 151 ;               // if com_param.willRetain   then connectFlags := connectFlags OR 16#20; end_if;
#srcline 152 ;               // connectFlags := connectFlags OR SHL(IN := USINT_TO_BYTE(com_param.qos),N := 3);
#srcline 153 ;                if com_param.cleanSession then connectFlags := connectFlags OR 16#2;  end_if;
 LDX  com_param~cleanSession
#debug bool com_param.cleanSession
 JMC  fbMQTTSubscriber_L17
 LDX  connectFlags
#debug byte connectFlags
 LD   byte $2
 OR  
 WRX  connectFlags
#debug_left byte connectFlags
fbMQTTSubscriber_L17:
#srcline 155 ;                txData[9]   := BYTE_TO_USINT(connectFlags);//For connect set clean session
 LDX  connectFlags
#debug byte connectFlags
 WRX  txData[9]
#debug_left usint txData[9]
#srcline 156 ;                //keep alive 2 bytes, MSB+LSB
#srcline 157 ;                aliveTime := TIME_TO_UINT(keepAliveInterval)/1000;
 LDX  keepAliveInterval
#debug time keepAliveInterval
AND  $FFFF
 LD   uint 1000
 DIVL
 AND  $FFFF
 WRX  aliveTime
#debug_left uint aliveTime
#srcline 159 ;                txData[10]  := 0;
 LD   usint 0
 WRX  txData[10]
#debug_left usint txData[10]
#srcline 160 ;                txData[11]  := UINT_TO_USINT(aliveTime);
 LDX  aliveTime
#debug uint aliveTime
 AND  $FF
 WRX  txData[11]
#debug_left usint txData[11]
#srcline 161 ;                //Payload
#srcline 162 ;                payloadLength := LEN(IN := client_id);
 LEAX client_id
#debug string client_id
 SLEN 
 WRX  payloadLength
#debug_left usint payloadLength
#srcline 163 ;                txData[12]  := 0;
 LD   usint 0
 WRX  txData[12]
#debug_left usint txData[12]
#srcline 164 ;                txData[13]  := payloadLength;
 LDX  payloadLength
#debug usint payloadLength
 WRX  txData[13]
#debug_left usint txData[13]
#srcline 166 ;                txMsgLength := 14;
 LD   usint 14
 WRX  txMsgLength
#debug_left usint txMsgLength
#srcline 167 ;                //Copy client ID
#srcline 168 ;                MemcpyPtr(source := ADR(client_id),dest := ADR(txData[14]),length := USINT_TO_UDINT(payloadLength));
 NXT
 LEAX client_id
#debug pointer client_id
 LEA  __Instance__MemcpyPtr~source
 WRIL 
#debug_left udint __Instance__MemcpyPtr~source
 LEAX txData
 ADD  14  ; + offset 
#debug pointer txData[14]
 LEA  __Instance__MemcpyPtr~dest
 WRIL 
#debug_left udint __Instance__MemcpyPtr~dest
 LDX  payloadLength
#debug usint payloadLength
 WR   __Instance__MemcpyPtr~length
#debug_left udint __Instance__MemcpyPtr~length
 PRV
 LEA  __Instance__MemcpyPtr
 CAL  MemcpyPtr_L0
#srcline 169 ;                txMsgLength := txMsgLength + payloadLength;
 LDX  txMsgLength
#debug usint txMsgLength
 LDX  payloadLength
#debug usint payloadLength
 ADD
 AND  $FF
 WRX  txMsgLength
#debug_left usint txMsgLength
#srcline 170 ;                //Copy user name
#srcline 171 ;                if (connectFlags AND 16#80) > 0 then
 LDX  connectFlags
#debug byte connectFlags
 LD   byte $80
 AND
 LD   byte 0
 GT
 JMC  fbMQTTSubscriber_L19
#srcline 172 ;                     txData[txMsgLength]     := 0;
 LD   usint 0
 LEAX txData
 LDX  txMsgLength
#debug usint txMsgLength
 RCHK 100   ; Range Check
 ADD     ; + offset 
 WRI 
#debug_left usint txData[txMsgLength]
#srcline 173 ;                     txData[txMsgLength + 1] := LEN(IN := loginName);
 LEAX loginName
#debug string loginName
 SLEN 
 LEAX txData
 LDX  txMsgLength
#debug usint txMsgLength
 LD   usint 1
 ADD
 AND  $FF
 RCHK 100   ; Range Check
 ADD     ; + offset 
 WRI 
#debug_left usint txData[txMsgLength+1]
#srcline 174 ;                     payloadLength := LEN(IN := loginName);
 LEAX loginName
#debug string loginName
 SLEN 
 WRX  payloadLength
#debug_left usint payloadLength
#srcline 175 ;                     MemcpyPtr(source := ADR(loginName),dest := ADR(txData[txMsgLength + 2]),length := USINT_TO_UDINT(payloadLength));
 NXT
 LEAX loginName
#debug pointer loginName
 LEA  __Instance__MemcpyPtr~source
 WRIL 
#debug_left udint __Instance__MemcpyPtr~source
 LEAX txData
 LDX  txMsgLength
#debug usint txMsgLength
 LD   usint 2
 ADD
 AND  $FF
 RCHK 100   ; Range Check
 ADD     ; + offset 
#debug pointer txData[txMsgLength+2]
 LEA  __Instance__MemcpyPtr~dest
 WRIL 
#debug_left udint __Instance__MemcpyPtr~dest
 LDX  payloadLength
#debug usint payloadLength
 WR   __Instance__MemcpyPtr~length
#debug_left udint __Instance__MemcpyPtr~length
 PRV
 LEA  __Instance__MemcpyPtr
 CAL  MemcpyPtr_L0
#srcline 176 ;                     txMsgLength := txMsgLength + payloadLength + 2;
 LDX  txMsgLength
#debug usint txMsgLength
 LDX  payloadLength
#debug usint payloadLength
 ADD
 AND  $FF
 LD   usint 2
 ADD
 AND  $FF
 WRX  txMsgLength
#debug_left usint txMsgLength
#srcline 177 ;                end_if;
fbMQTTSubscriber_L19:
#srcline 178 ;                //Copy password
#srcline 179 ;                if (connectFlags AND 16#40) > 0 then
 LDX  connectFlags
#debug byte connectFlags
 LD   byte $40
 AND
 LD   byte 0
 GT
 JMC  fbMQTTSubscriber_L21
#srcline 180 ;                     txData[txMsgLength]     := 0;
 LD   usint 0
 LEAX txData
 LDX  txMsgLength
#debug usint txMsgLength
 RCHK 100   ; Range Check
 ADD     ; + offset 
 WRI 
#debug_left usint txData[txMsgLength]
#srcline 181 ;                     txData[txMsgLength + 1] := LEN(IN := loginPass);
 LEAX loginPass
#debug string loginPass
 SLEN 
 LEAX txData
 LDX  txMsgLength
#debug usint txMsgLength
 LD   usint 1
 ADD
 AND  $FF
 RCHK 100   ; Range Check
 ADD     ; + offset 
 WRI 
#debug_left usint txData[txMsgLength+1]
#srcline 182 ;                     payloadLength := LEN(IN := loginPass);
 LEAX loginPass
#debug string loginPass
 SLEN 
 WRX  payloadLength
#debug_left usint payloadLength
#srcline 183 ;                     MemcpyPtr(source := ADR(loginPass),dest := ADR(txData[txMsgLength + 2]),length := USINT_TO_UDINT(payloadLength));
 NXT
 LEAX loginPass
#debug pointer loginPass
 LEA  __Instance__MemcpyPtr~source
 WRIL 
#debug_left udint __Instance__MemcpyPtr~source
 LEAX txData
 LDX  txMsgLength
#debug usint txMsgLength
 LD   usint 2
 ADD
 AND  $FF
 RCHK 100   ; Range Check
 ADD     ; + offset 
#debug pointer txData[txMsgLength+2]
 LEA  __Instance__MemcpyPtr~dest
 WRIL 
#debug_left udint __Instance__MemcpyPtr~dest
 LDX  payloadLength
#debug usint payloadLength
 WR   __Instance__MemcpyPtr~length
#debug_left udint __Instance__MemcpyPtr~length
 PRV
 LEA  __Instance__MemcpyPtr
 CAL  MemcpyPtr_L0
#srcline 184 ;                     txMsgLength := txMsgLength + payloadLength + 2;
 LDX  txMsgLength
#debug usint txMsgLength
 LDX  payloadLength
#debug usint payloadLength
 ADD
 AND  $FF
 LD   usint 2
 ADD
 AND  $FF
 WRX  txMsgLength
#debug_left usint txMsgLength
#srcline 185 ;                end_if;
fbMQTTSubscriber_L21:
#srcline 187 ;                // length of package
#srcline 188 ;                txData[1]   := txMsgLength;
 LDX  txMsgLength
#debug usint txMsgLength
 WRX  txData[1]
#debug_left usint txData[1]
#srcline 189 ;                txMsgLength := txMsgLength + 2;
 LDX  txMsgLength
#debug usint txMsgLength
 LD   usint 2
 ADD
 AND  $FF
 WRX  txMsgLength
#debug_left usint txMsgLength
#srcline 191 ;                tx_data_request    := true;
 LD   bool -1       ; true
 WRX  tx_data_request
#debug_left bool tx_data_request
#srcline 192 ;                localPortExtension := USINT_TO_UINT(reconnect_counter);
 LDX  reconnect_counter
#debug usint reconnect_counter
 AND  $FFFF
 WRX  localPortExtension
#debug_left uint localPortExtension
#srcline 193 ;              //  connect_rq := true;
#srcline 194 ;                idle_time := 2;
 LD   usint 2
 WRX  idle_time
#debug_left usint idle_time
#srcline 195 ;                // required to change port on each reconnect
#srcline 196 ;                if reconnect_counter < 100 then
 LDX  reconnect_counter
#debug usint reconnect_counter
 LD   usint 100
 LT
 JMC  fbMQTTSubscriber_L23
#srcline 197 ;                    reconnect_counter := reconnect_counter + 1; //
 LDX  reconnect_counter
#debug usint reconnect_counter
 LD   usint 1
 ADD
 AND  $FF
 WRX  reconnect_counter
#debug_left usint reconnect_counter
#srcline 198 ;                else
 JMP  fbMQTTSubscriber_L24
fbMQTTSubscriber_L23:
#srcline 199 ;                    reconnect_counter := 0;
 LD   usint 0
 WRX  reconnect_counter
#debug_left usint reconnect_counter
#srcline 200 ;                end_if;
fbMQTTSubscriber_L24:
#srcline 201 ;                responce_recived := false;
 LD   bool 0       ; false
 WRX  responce_recived
#debug_left bool responce_recived
#srcline 202 ;                return;
 JMP  fbMQTTSubscriber_RET
#srcline 203 ;           //--------- Connected to brocker -------------------
#srcline 204 ;           else
 JMP  fbMQTTSubscriber_L10
fbMQTTSubscriber_L9:
#srcline 205 ;               if subRq OR unSubRq then //Subscribe or unsubsribe command from user program
 LDX  subRq
#debug bool subRq
 LDX  unSubRq
#debug bool unSubRq
 OR  
 JMC  fbMQTTSubscriber_L25
#srcline 206 ;                   if subRq then
 LDX  subRq
#debug bool subRq
 JMC  fbMQTTSubscriber_L27
#srcline 207 ;                       txData[0] := MQTT_CONTROL_PACK_SUBSCRIBE + 2;
 LD   usint 128
 LD   usint 2
 ADD
 AND  $FF
 WRX  txData[0]
#debug_left usint txData[0]
#srcline 208 ;                   else
 JMP  fbMQTTSubscriber_L28
fbMQTTSubscriber_L27:
#srcline 209 ;                       txData[0] := MQTT_CONTROL_PACK_UNSUBSCRIBE + 2;
 LD   usint 160
 LD   usint 2
 ADD
 AND  $FF
 WRX  txData[0]
#debug_left usint txData[0]
#srcline 210 ;                   end_if;
fbMQTTSubscriber_L28:
#srcline 211 ;                   //The variable header contains a Packet Identifier
#srcline 212 ;                   txData[2]        := WORD_TO_USINT(SHR(IN := UINT_TO_WORD(messageID), N := 8));
 LDX  messageID
#debug uint messageID
 LD   uint 8
 SHR
 AND  $FFFF
 AND  $FF
 WRX  txData[2]
#debug_left usint txData[2]
#srcline 213 ;                   txData[3]        := UINT_TO_USINT(messageID);
 LDX  messageID
#debug uint messageID
 AND  $FF
 WRX  txData[3]
#debug_left usint txData[3]
#srcline 214 ;                   
#srcline 215 ;                   // Payload
#srcline 216 ;                   payloadLength := LEN(IN := subTopicTxt);
 LEAX subTopicTxt
#debug string subTopicTxt
 SLEN 
 WRX  payloadLength
#debug_left usint payloadLength
#srcline 217 ;                   txData[4] := 0;
 LD   usint 0
 WRX  txData[4]
#debug_left usint txData[4]
#srcline 218 ;                   txData[5] := payloadLength;
 LDX  payloadLength
#debug usint payloadLength
 WRX  txData[5]
#debug_left usint txData[5]
#srcline 219 ;                   MemcpyPtr(source := ADR(subTopicTxt),dest := ADR(txData[6]),length := USINT_TO_UDINT(payloadLength));
 NXT
 LEAX subTopicTxt
#debug pointer subTopicTxt
 LEA  __Instance__MemcpyPtr~source
 WRIL 
#debug_left udint __Instance__MemcpyPtr~source
 LEAX txData
 ADD  6  ; + offset 
#debug pointer txData[6]
 LEA  __Instance__MemcpyPtr~dest
 WRIL 
#debug_left udint __Instance__MemcpyPtr~dest
 LDX  payloadLength
#debug usint payloadLength
 WR   __Instance__MemcpyPtr~length
#debug_left udint __Instance__MemcpyPtr~length
 PRV
 LEA  __Instance__MemcpyPtr
 CAL  MemcpyPtr_L0
#srcline 220 ;                   txMsgLength := payloadLength + 4;
 LDX  payloadLength
#debug usint payloadLength
 LD   usint 4
 ADD
 AND  $FF
 WRX  txMsgLength
#debug_left usint txMsgLength
#srcline 221 ;                   if subRq then
 LDX  subRq
#debug bool subRq
 JMC  fbMQTTSubscriber_L29
#srcline 222 ;                       txData[txMsgLength + 2] := com_param.qos;
 LDX  com_param~qos
#debug usint com_param.qos
 LEAX txData
 LDX  txMsgLength
#debug usint txMsgLength
 LD   usint 2
 ADD
 AND  $FF
 RCHK 100   ; Range Check
 ADD     ; + offset 
 WRI 
#debug_left usint txData[txMsgLength+2]
#srcline 223 ;                       txMsgLength := txMsgLength + 1;
 LDX  txMsgLength
#debug usint txMsgLength
 LD   usint 1
 ADD
 AND  $FF
 WRX  txMsgLength
#debug_left usint txMsgLength
#srcline 224 ;                   end_if;
fbMQTTSubscriber_L29:
#srcline 225 ;                   
#srcline 226 ;                   txData[1]        := txMsgLength;
 LDX  txMsgLength
#debug usint txMsgLength
 WRX  txData[1]
#debug_left usint txData[1]
#srcline 227 ;                   txMsgLength      := txMsgLength + 2;
 LDX  txMsgLength
#debug usint txMsgLength
 LD   usint 2
 ADD
 AND  $FF
 WRX  txMsgLength
#debug_left usint txMsgLength
#srcline 228 ;                   tx_data_request  := true;
 LD   bool -1       ; true
 WRX  tx_data_request
#debug_left bool tx_data_request
#srcline 229 ;                   
#srcline 230 ;                   busy    := true;
 LD   bool -1       ; true
 WRX  busy
#debug_left bool busy
#srcline 231 ;                   ok      := false;
 LD   bool 0       ; false
 WRX  ok
#debug_left bool ok
#srcline 232 ;                   err     := false;
 LD   bool 0       ; false
 WRX  err
#debug_left bool err
#srcline 233 ;                   errCode := MQTT_CONTROL_ERROR_CODE_OK;
 LD   usint 0
 WRX  errCode
#debug_left usint errCode
#srcline 234 ;                   
#srcline 235 ;                   subRq   := false;
 LD   bool 0       ; false
 WRX  subRq
#debug_left bool subRq
#srcline 236 ;                   unSubRq := false;
 LD   bool 0       ; false
 WRX  unSubRq
#debug_left bool unSubRq
#srcline 237 ;               end_if;
fbMQTTSubscriber_L25:
#srcline 239 ;               if pubAckRq OR pubRecRq OR pubCompRq then
 LDX  pubAckRq
#debug bool pubAckRq
 LDX  pubRecRq
#debug bool pubRecRq
 OR  
 LDX  pubCompRq
#debug bool pubCompRq
 OR  
 JMC  fbMQTTSubscriber_L31
#srcline 240 ;                   if pubAckRq then
 LDX  pubAckRq
#debug bool pubAckRq
 JMC  fbMQTTSubscriber_L33
#srcline 241 ;                       txData[0]        := MQTT_CONTROL_PACK_PUBACK;  // Publish acknowledge                      QOS=1
 LD   usint 64
 WRX  txData[0]
#debug_left usint txData[0]
#srcline 242 ;                   elsif pubRecRq then
 JMP  fbMQTTSubscriber_L34
fbMQTTSubscriber_L33:
 LDX  pubRecRq
#debug bool pubRecRq
 JMC  fbMQTTSubscriber_L35
#srcline 243 ;                       txData[0]        := MQTT_CONTROL_PACK_PUBREC;  // Publish acknowledge "Publish recived"    QOS=2
 LD   usint 80
 WRX  txData[0]
#debug_left usint txData[0]
#srcline 244 ;                   else
 JMP  fbMQTTSubscriber_L34
fbMQTTSubscriber_L35:
#srcline 245 ;                       txData[0]        := MQTT_CONTROL_PACK_PUBCOMP; // Publish acknowledge "Publish completed"  QOS=2
 LD   usint 112
 WRX  txData[0]
#debug_left usint txData[0]
#srcline 246 ;                   end_if;
fbMQTTSubscriber_L34:
#srcline 247 ;                   
#srcline 248 ;                   txData[1]        := 2;
 LD   usint 2
 WRX  txData[1]
#debug_left usint txData[1]
#srcline 249 ;                   txData[2]        := WORD_TO_USINT(SHR(IN := UINT_TO_WORD(messageIDpubAck), N := 8));
 LDX  messageIDpubAck
#debug uint messageIDpubAck
 LD   uint 8
 SHR
 AND  $FFFF
 AND  $FF
 WRX  txData[2]
#debug_left usint txData[2]
#srcline 250 ;                   txData[3]        := UINT_TO_USINT(messageIDpubAck);
 LDX  messageIDpubAck
#debug uint messageIDpubAck
 AND  $FF
 WRX  txData[3]
#debug_left usint txData[3]
#srcline 251 ;                   txMsgLength      := 4;
 LD   usint 4
 WRX  txMsgLength
#debug_left usint txMsgLength
#srcline 252 ;                   tx_data_request  := true;
 LD   bool -1       ; true
 WRX  tx_data_request
#debug_left bool tx_data_request
#srcline 253 ;                   busy             := false;
 LD   bool 0       ; false
 WRX  busy
#debug_left bool busy
#srcline 254 ;                   ok               := true;
 LD   bool -1       ; true
 WRX  ok
#debug_left bool ok
#srcline 255 ;                   err              := false;
 LD   bool 0       ; false
 WRX  err
#debug_left bool err
#srcline 256 ;                   errCode          := MQTT_CONTROL_ERROR_CODE_OK;
 LD   usint 0
 WRX  errCode
#debug_left usint errCode
#srcline 257 ;                   
#srcline 258 ;                   pubAckRq         := false;
 LD   bool 0       ; false
 WRX  pubAckRq
#debug_left bool pubAckRq
#srcline 259 ;                   pubRecRq         := false;
 LD   bool 0       ; false
 WRX  pubRecRq
#debug_left bool pubRecRq
#srcline 260 ;                   pubCompRq        := false;
 LD   bool 0       ; false
 WRX  pubCompRq
#debug_left bool pubCompRq
#srcline 261 ;                   return;
 JMP  fbMQTTSubscriber_RET
#srcline 262 ;               end_if;
fbMQTTSubscriber_L31:
#srcline 263 ;               
#srcline 264 ;                //---------------------------------------------
#srcline 265 ;                if MQTT_ping_timer.Q then
 LDX  MQTT_ping_timer~Q
#debug bool MQTT_ping_timer.Q
 JMC  fbMQTTSubscriber_L36
#srcline 266 ;                    //Ping request
#srcline 267 ;                     txData[0]        := MQTT_CONTROL_PACK_PINGREQ; // flag bits are cleared
 LD   usint 192
 WRX  txData[0]
#debug_left usint txData[0]
#srcline 268 ;                     txData[1]        := 0;
 LD   usint 0
 WRX  txData[1]
#debug_left usint txData[1]
#srcline 269 ;                     txMsgLength      := 2;
 LD   usint 2
 WRX  txMsgLength
#debug_left usint txMsgLength
#srcline 270 ;                     tx_data_request  := true;
 LD   bool -1       ; true
 WRX  tx_data_request
#debug_left bool tx_data_request
#srcline 271 ;                     responce_recived := false;
 LD   bool 0       ; false
 WRX  responce_recived
#debug_left bool responce_recived
#srcline 272 ;                     busy             := false;
 LD   bool 0       ; false
 WRX  busy
#debug_left bool busy
#srcline 273 ;                     ok               := true;
 LD   bool -1       ; true
 WRX  ok
#debug_left bool ok
#srcline 274 ;                     err              := false;
 LD   bool 0       ; false
 WRX  err
#debug_left bool err
#srcline 275 ;                     errCode          := MQTT_CONTROL_ERROR_CODE_OK;
 LD   usint 0
 WRX  errCode
#debug_left usint errCode
#srcline 276 ;                     return;
 JMP  fbMQTTSubscriber_RET
#srcline 277 ;                end_if;
fbMQTTSubscriber_L36:
#srcline 278 ;           end_if;
fbMQTTSubscriber_L10:
#srcline 279 ;       end_if;
fbMQTTSubscriber_L7:
#srcline 281 ;      if conn_status then
 LDX  conn_status
#debug bool conn_status
 JMC  fbMQTTSubscriber_L38
#srcline 282 ;          SendTo( rq := tx_data_request, chanCode := chanCode, lenTx := USINT_TO_UINT(txMsgLength) , data := void(txData));
 LDX  tx_data_request
#debug bool tx_data_request
 WRX  SendTo~rq
#debug_left bool SendTo~rq
 LDX  chanCode
#debug uint chanCode
 WRX  SendTo~chanCode
#debug_left uint SendTo~chanCode
 LDX  txMsgLength
#debug usint txMsgLength
 AND  $FFFF
 WRX  SendTo~lenTx
#debug_left uint SendTo~lenTx
 LEAX txData
 WRX  SendTo~data
#debug_left pointer SendTo.data
 LEAX SendTo
 CAL  fbSendTo_L0
#srcline 283 ;          if SendTo.mesSent then
 LDX  SendTo~mesSent
#debug bool SendTo.mesSent
 JMC  fbMQTTSubscriber_L40
#srcline 284 ;              tx_data_request := false;
 LD   bool 0       ; false
 WRX  tx_data_request
#debug_left bool tx_data_request
#srcline 285 ;              txCounter := txCounter + 1;
 LDX  txCounter
#debug uint txCounter
 LD   uint 1
 ADD
 AND  $FFFF
 WRX  txCounter
#debug_left uint txCounter
#srcline 286 ;              messageID := messageID + 1;
 LDX  messageID
#debug uint messageID
 LD   uint 1
 ADD
 AND  $FFFF
 WRX  messageID
#debug_left uint messageID
#srcline 287 ;              if com_param.qos = 1 then wait_response := true; end_if;
 LDX  com_param~qos
#debug usint com_param.qos
 LD   usint 1
 EQ
 JMC  fbMQTTSubscriber_L42
 LD   bool -1       ; true
 WRX  wait_response
#debug_left bool wait_response
fbMQTTSubscriber_L42:
#srcline 288 ;          end_if;
fbMQTTSubscriber_L40:
#srcline 290 ;          RecvFrom( rq := true, chanCode := chanCode, lenRx := 300, data := void(rxData));
 LD   bool -1       ; true
 WRX  RecvFrom~rq
#debug_left bool RecvFrom~rq
 LDX  chanCode
#debug uint chanCode
 WRX  RecvFrom~chanCode
#debug_left uint RecvFrom~chanCode
 LD   uint 300
 WRX  RecvFrom~lenRx
#debug_left uint RecvFrom~lenRx
 LEAX rxData
 WRX  RecvFrom~data
#debug_left pointer RecvFrom.data
 LEAX RecvFrom
 CAL  fbRecvFrom_L0
#srcline 292 ;          if RecvFrom.mesRec then
 LDX  RecvFrom~mesRec
#debug bool RecvFrom.mesRec
 JMC  fbMQTTSubscriber_L44
#srcline 293 ;              if RecvFrom.error = 0 then
 LDX  RecvFrom~error
#debug usint RecvFrom.error
 LD   usint 0
 EQ
 JMC  fbMQTTSubscriber_L46
#srcline 294 ;                   busy     := false;
 LD   bool 0       ; false
 WRX  busy
#debug_left bool busy
#srcline 295 ;                   ok       := true;
 LD   bool -1       ; true
 WRX  ok
#debug_left bool ok
#srcline 296 ;                   err      := false;
 LD   bool 0       ; false
 WRX  err
#debug_left bool err
#srcline 297 ;                   errCode  := MQTT_CONTROL_ERROR_CODE_OK;
 LD   usint 0
 WRX  errCode
#debug_left usint errCode
#srcline 298 ;                   
#srcline 299 ;                  if (RecvFrom.lenData = 4  AND (rxData[0] = MQTT_CONTROL_PACK_CONNACK OR rxData[0] = MQTT_CONTROL_PACK_UNSUBACK)) OR  // responce to connect command
 LDX  RecvFrom~lenData
#debug uint RecvFrom.lenData
 LD   uint 4
 EQ
 LDX  rxData[0]
#debug usint rxData[0]
 LD   usint 32
 EQ
 LDX  rxData[0]
#debug usint rxData[0]
 LD   usint 176
 EQ
 OR  
 AND
#srcline 300 ;                      RecvFrom.lenData = 2  AND  rxData[0] = MQTT_CONTROL_PACK_PINGRESP  then
 LDX  RecvFrom~lenData
#debug uint RecvFrom.lenData
 LD   uint 2
 EQ
 LDX  rxData[0]
#debug usint rxData[0]
 LD   usint 208
 EQ
 AND
 OR  
 JMC  fbMQTTSubscriber_L48
#srcline 301 ;                        connected_to_broker  := true;
 LD   bool -1       ; true
 WRX  connected_to_broker
#debug_left bool connected_to_broker
#srcline 302 ;                        responce_recived     := true;
 LD   bool -1       ; true
 WRX  responce_recived
#debug_left bool responce_recived
#srcline 303 ;                        wait_response        := false;
 LD   bool 0       ; false
 WRX  wait_response
#debug_left bool wait_response
#srcline 304 ;                  elsif (RecvFrom.lenData = 4  AND (AND(IN1 := USINT_TO_BYTE(rxData[0]),IN2 := USINT_TO_BYTE(MQTT_CONTROL_PACK_PUBREL)) = USINT_TO_BYTE(MQTT_CONTROL_PACK_PUBREL))) then
 JMP  fbMQTTSubscriber_L49
fbMQTTSubscriber_L48:
 LDX  RecvFrom~lenData
#debug uint RecvFrom.lenData
 LD   uint 4
 EQ
 LDX  rxData[0]
#debug usint rxData[0]
 AND  $FF
 LD   usint 96
 AND  $FF
 AND
 LD   usint 96
 AND  $FF
 EQ
 AND
 JMC  fbMQTTSubscriber_L50
#srcline 305 ;                          pubCompRq           := true;
 LD   bool -1       ; true
 WRX  pubCompRq
#debug_left bool pubCompRq
#srcline 306 ;                          connected_to_broker := true;
 LD   bool -1       ; true
 WRX  connected_to_broker
#debug_left bool connected_to_broker
#srcline 307 ;                          responce_recived    := true;
 LD   bool -1       ; true
 WRX  responce_recived
#debug_left bool responce_recived
#srcline 308 ;                          wait_response       := false;
 LD   bool 0       ; false
 WRX  wait_response
#debug_left bool wait_response
#srcline 310 ;                          messageIDpubAck_ptr := ADR(rxData[2]);
 LEAX rxData
 ADD  2  ; + offset 
#debug pointer rxData[2]
 LEAX messageIDpubAck_ptr
 WRIL 
#debug_left pointer messageIDpubAck_ptr
#srcline 311 ;                          messageIDpubAck     := fSwapUINT( messageIDpubAck_ptr^);
 NXT
 LEAX messageIDpubAck_ptr
 LDIL    ; dereference 
 LDIW 
#debug uint messageIDpubAck_ptr^
 WR   __Instance__fSwapUINT~input
#debug_left uint __Instance__fSwapUINT~input
 PRV
 LEA  __Instance__fSwapUINT
 CAL  fSwapUINT_L0
 WRX  messageIDpubAck
#debug_left uint messageIDpubAck
#srcline 313 ;                  elsif RecvFrom.lenData = 5 AND rxData[0] = MQTT_CONTROL_PACK_SUBACK then // responce to subscribe command
 JMP  fbMQTTSubscriber_L49
fbMQTTSubscriber_L50:
 LDX  RecvFrom~lenData
#debug uint RecvFrom.lenData
 LD   uint 5
 EQ
 LDX  rxData[0]
#debug usint rxData[0]
 LD   usint 144
 EQ
 AND
 JMC  fbMQTTSubscriber_L51
#srcline 314 ;                         connected_to_broker := true;
 LD   bool -1       ; true
 WRX  connected_to_broker
#debug_left bool connected_to_broker
#srcline 315 ;                         responce_recived    := true;
 LD   bool -1       ; true
 WRX  responce_recived
#debug_left bool responce_recived
#srcline 316 ;                         wait_response       := false;
 LD   bool 0       ; false
 WRX  wait_response
#debug_left bool wait_response
#srcline 317 ;                         if rxData[4] = 16#80 then
 LDX  rxData[4]
#debug usint rxData[4]
 LD   usint $80
 EQ
 JMC  fbMQTTSubscriber_L52
#srcline 318 ;                             ok              := false;
 LD   bool 0       ; false
 WRX  ok
#debug_left bool ok
#srcline 319 ;                             err             := true;
 LD   bool -1       ; true
 WRX  err
#debug_left bool err
#srcline 320 ;                             errCode         := MQTT_CONTROL_ERROR_CODE_SUBSCRIBE_FAILED;
 LD   usint 2
 WRX  errCode
#debug_left usint errCode
#srcline 321 ;                         end_if;
fbMQTTSubscriber_L52:
#srcline 322 ;                  else // Incomming data from broker
 JMP  fbMQTTSubscriber_L49
fbMQTTSubscriber_L51:
#srcline 323 ;                       if  (AND(IN1 := USINT_TO_BYTE(rxData[0]),IN2 := USINT_TO_BYTE(MQTT_CONTROL_PACK_PUBLISH))) > 0 then
 LDX  rxData[0]
#debug usint rxData[0]
 AND  $FF
 LD   usint 48
 AND  $FF
 AND
 LD   byte 0
 GT
 JMC  fbMQTTSubscriber_L54
#srcline 324 ;                             connected_to_broker := true;
 LD   bool -1       ; true
 WRX  connected_to_broker
#debug_left bool connected_to_broker
#srcline 325 ;                             responce_recived    := true;
 LD   bool -1       ; true
 WRX  responce_recived
#debug_left bool responce_recived
#srcline 326 ;                             wait_response       := false;
 LD   bool 0       ; false
 WRX  wait_response
#debug_left bool wait_response
#srcline 328 ;                             index               := 1;
 LD   usint 1
 WRX  index
#debug_left usint index
#srcline 329 ;                             payloadLengthSize   := 0;
 LD   uint 0
 WRX  payloadLengthSize
#debug_left uint payloadLengthSize
#srcline 330 ;                             payloadLengthBytes  := 1;
 LD   uint 1
 WRX  payloadLengthBytes
#debug_left uint payloadLengthBytes
#srcline 331 ;                             
#srcline 332 ;                             while index <= 4 do
fbMQTTSubscriber_L56:
 LDX  index
#debug usint index
 LD   usint 4
 GT
 NEG
 JMC  fbMQTTSubscriber_L57
 DBG 
#srcline 333 ;                                if rxData[index] > 16#80 then
 LEAX rxData
 LDX  index
#debug usint index
 RCHK 300   ; Range Check
 ADD     ; + offset 
 LDI  
#debug usint rxData[index]
 LD   usint $80
 GT
 JMC  fbMQTTSubscriber_L58
#srcline 334 ;                                     payloadLengthSize := payloadLengthSize + BYTE_TO_UINT(USINT_TO_BYTE(rxData[index]) AND 16#7F);
 LDX  payloadLengthSize
#debug uint payloadLengthSize
 LEAX rxData
 LDX  index
#debug usint index
 RCHK 300   ; Range Check
 ADD     ; + offset 
 LDI  
#debug usint rxData[index]
 AND  $FF
 LD   byte $7F
 AND
 ADD
 AND  $FFFF
 WRX  payloadLengthSize
#debug_left uint payloadLengthSize
#srcline 335 ;                                     payloadLengthBytes := payloadLengthBytes + 1;
 LDX  payloadLengthBytes
#debug uint payloadLengthBytes
 LD   uint 1
 ADD
 AND  $FFFF
 WRX  payloadLengthBytes
#debug_left uint payloadLengthBytes
#srcline 336 ;                                else
 JMP  fbMQTTSubscriber_L59
fbMQTTSubscriber_L58:
#srcline 337 ;                                     if payloadLengthBytes > 1 then
 LDX  payloadLengthBytes
#debug uint payloadLengthBytes
 LD   uint 1
 GT
 JMC  fbMQTTSubscriber_L60
#srcline 338 ;                                         payloadLengthSize := payloadLengthSize + (USINT_TO_UINT(rxData[index]) * 128);
 LDX  payloadLengthSize
#debug uint payloadLengthSize
 LEAX rxData
 LDX  index
#debug usint index
 RCHK 300   ; Range Check
 ADD     ; + offset 
 LDI  
#debug usint rxData[index]
 AND  $FFFF
 LD   uint 128
 MUL
 AND  $FFFF
 ADD
 AND  $FFFF
 WRX  payloadLengthSize
#debug_left uint payloadLengthSize
#srcline 339 ;                                     else
 JMP  fbMQTTSubscriber_L61
fbMQTTSubscriber_L60:
#srcline 340 ;                                         payloadLengthSize := USINT_TO_UINT(rxData[index]);
 LEAX rxData
 LDX  index
#debug usint index
 RCHK 300   ; Range Check
 ADD     ; + offset 
 LDI  
#debug usint rxData[index]
 AND  $FFFF
 WRX  payloadLengthSize
#debug_left uint payloadLengthSize
#srcline 341 ;                                     end_if;
fbMQTTSubscriber_L61:
#srcline 342 ;                                     exit;
 JMP  fbMQTTSubscriber_L57
#srcline 343 ;                                end_if;
fbMQTTSubscriber_L59:
#srcline 344 ;                                index := index + 1;
 LDX  index
#debug usint index
 LD   usint 1
 ADD
 AND  $FF
 WRX  index
#debug_left usint index
#srcline 345 ;                             end_while;
 JMP  fbMQTTSubscriber_L56
fbMQTTSubscriber_L57:
 NOP  -1
#srcline 347 ;                             inDataCom_param.qos := BYTE_TO_USINT(SHR(IN := USINT_TO_BYTE(rxData[0]),N := 1) AND 16#3);
 LDX  rxData[0]
#debug usint rxData[0]
 AND  $FF
 LD   uint 1
 SHR
 AND  $FF
 LD   byte $3
 AND
 WRX  inDataCom_param~qos
#debug_left usint inDataCom_param.qos
#srcline 348 ;                             inTopicLen          := USINT_TO_UINT(rxData[payloadLengthBytes + 2]);
 LEAX rxData
 LDX  payloadLengthBytes
#debug uint payloadLengthBytes
 LD   uint 2
 ADD
 AND  $FFFF
 RCHK 300   ; Range Check
 ADD     ; + offset 
 LDI  
#debug usint rxData[payloadLengthBytes+2]
 AND  $FFFF
 WRX  inTopicLen
#debug_left uint inTopicLen
#srcline 351 ;                               if (RecvFrom.lenData - payloadLengthBytes - 1) = payloadLengthSize then
 LDX  RecvFrom~lenData
#debug uint RecvFrom.lenData
 LDX  payloadLengthBytes
#debug uint payloadLengthBytes
 SUB
 AND  $FFFF
 LD   uint 1
 SUB
 AND  $FFFF
 LDX  payloadLengthSize
#debug uint payloadLengthSize
 EQ
 JMC  fbMQTTSubscriber_L62
#srcline 352 ;                                  dataRec          := true;
 LD   bool -1       ; true
 WRX  dataRec
#debug_left bool dataRec
#srcline 353 ;                                  dataRecDT        := GetDateTime();
 LEA  __Instance__GetDateTime
 CAL  GetDateTime_L0
 WRX  dataRecDT
#debug_left dt dataRecDT
#srcline 354 ;                                  dataTxt          := '';
 LD   0   ; null string
 LEAX dataTxt
 WRI  
 LEAX dataTxt
 LD   255
 DST    ; Level 1
 LEA  _str_fbMQTTSubscriber_2
 SCON 
#debug_left string dataTxt
 PDST   ; Level 1
#srcline 355 ;                                  dataTopicTxt     := '';
 LD   0   ; null string
 LEAX dataTopicTxt
 WRI  
 LEAX dataTopicTxt
 LD   80
 DST    ; Level 1
 LEA  _str_fbMQTTSubscriber_3
 SCON 
#debug_left string dataTopicTxt
 PDST   ; Level 1
#srcline 356 ;                                  MemcpyPtr(source := ADR(rxData[payloadLengthBytes + 3]), dest := ADR(dataTopicTxt),length := UINT_TO_UDINT(inTopicLen));
 NXT
 LEAX rxData
 LDX  payloadLengthBytes
#debug uint payloadLengthBytes
 LD   uint 3
 ADD
 AND  $FFFF
 RCHK 300   ; Range Check
 ADD     ; + offset 
#debug pointer rxData[payloadLengthBytes+3]
 LEA  __Instance__MemcpyPtr~source
 WRIL 
#debug_left udint __Instance__MemcpyPtr~source
 LEAX dataTopicTxt
#debug pointer dataTopicTxt
 LEA  __Instance__MemcpyPtr~dest
 WRIL 
#debug_left udint __Instance__MemcpyPtr~dest
 LDX  inTopicLen
#debug uint inTopicLen
 WR   __Instance__MemcpyPtr~length
#debug_left udint __Instance__MemcpyPtr~length
 PRV
 LEA  __Instance__MemcpyPtr
 CAL  MemcpyPtr_L0
#srcline 357 ;                                  
#srcline 358 ;                                  if inDataCom_param.qos > 0 then
 LDX  inDataCom_param~qos
#debug usint inDataCom_param.qos
 LD   usint 0
 GT
 JMC  fbMQTTSubscriber_L64
#srcline 359 ;                                      if inDataCom_param.qos = 1 then
 LDX  inDataCom_param~qos
#debug usint inDataCom_param.qos
 LD   usint 1
 EQ
 JMC  fbMQTTSubscriber_L66
#srcline 360 ;                                          pubAckRq  := true; // Request to answer to publish command from broker when QOS=1
 LD   bool -1       ; true
 WRX  pubAckRq
#debug_left bool pubAckRq
#srcline 361 ;                                      else
 JMP  fbMQTTSubscriber_L67
fbMQTTSubscriber_L66:
#srcline 362 ;                                          pubRecRq  := true; // Request to answer to publish command from broker when QOS=2
 LD   bool -1       ; true
 WRX  pubRecRq
#debug_left bool pubRecRq
#srcline 363 ;                                      end_if;
fbMQTTSubscriber_L67:
#srcline 364 ;                                      messageIDpubAck_ptr := ADR(rxData[inTopicLen + payloadLengthBytes + 3]);
 LEAX rxData
 LDX  inTopicLen
#debug uint inTopicLen
 LDX  payloadLengthBytes
#debug uint payloadLengthBytes
 ADD
 AND  $FFFF
 LD   uint 3
 ADD
 AND  $FFFF
 RCHK 300   ; Range Check
 ADD     ; + offset 
#debug pointer rxData[inTopicLen+payloadLengthBytes+3]
 LEAX messageIDpubAck_ptr
 WRIL 
#debug_left pointer messageIDpubAck_ptr
#srcline 365 ;                                      messageIDpubAck     := fSwapUINT( messageIDpubAck_ptr^);
 NXT
 LEAX messageIDpubAck_ptr
 LDIL    ; dereference 
 LDIW 
#debug uint messageIDpubAck_ptr^
 WR   __Instance__fSwapUINT~input
#debug_left uint __Instance__fSwapUINT~input
 PRV
 LEA  __Instance__fSwapUINT
 CAL  fSwapUINT_L0
 WRX  messageIDpubAck
#debug_left uint messageIDpubAck
#srcline 367 ;                                     // inMsgLen := rxData[1] - inTopicLen - 4;
#srcline 368 ;                                      inMsgLen := payloadLengthSize - inTopicLen - 4;
 LDX  payloadLengthSize
#debug uint payloadLengthSize
 LDX  inTopicLen
#debug uint inTopicLen
 SUB
 AND  $FFFF
 LD   uint 4
 SUB
 AND  $FFFF
 WRX  inMsgLen
#debug_left uint inMsgLen
#srcline 369 ;                                    //  MemcpyPtr(source := ADR(rxData[inTopicLen + 6]),dest := ADR(dataTxt),   length := inMsgLen);
#srcline 370 ;                                        MemcpyPtr(source := ADR(rxData[inTopicLen + payloadLengthBytes + 5]),dest := ADR(dataTxt),   length := UINT_TO_UDINT(inMsgLen));
 NXT
 LEAX rxData
 LDX  inTopicLen
#debug uint inTopicLen
 LDX  payloadLengthBytes
#debug uint payloadLengthBytes
 ADD
 AND  $FFFF
 LD   uint 5
 ADD
 AND  $FFFF
 RCHK 300   ; Range Check
 ADD     ; + offset 
#debug pointer rxData[inTopicLen+payloadLengthBytes+5]
 LEA  __Instance__MemcpyPtr~source
 WRIL 
#debug_left udint __Instance__MemcpyPtr~source
 LEAX dataTxt
#debug pointer dataTxt
 LEA  __Instance__MemcpyPtr~dest
 WRIL 
#debug_left udint __Instance__MemcpyPtr~dest
 LDX  inMsgLen
#debug uint inMsgLen
 WR   __Instance__MemcpyPtr~length
#debug_left udint __Instance__MemcpyPtr~length
 PRV
 LEA  __Instance__MemcpyPtr
 CAL  MemcpyPtr_L0
#srcline 371 ;                                  else
 JMP  fbMQTTSubscriber_L65
fbMQTTSubscriber_L64:
#srcline 372 ;                                   // inMsgLen := rxData[1] - inTopicLen - 2;
#srcline 373 ;                                    inMsgLen := payloadLengthSize-inTopicLen;
 LDX  payloadLengthSize
#debug uint payloadLengthSize
 LDX  inTopicLen
#debug uint inTopicLen
 SUB
 AND  $FFFF
 WRX  inMsgLen
#debug_left uint inMsgLen
#srcline 374 ;                                    inMsgLen := inMsgLen - 2;
 LDX  inMsgLen
#debug uint inMsgLen
 LD   uint 2
 SUB
 AND  $FFFF
 WRX  inMsgLen
#debug_left uint inMsgLen
#srcline 375 ;                                    MemcpyPtr(source := ADR(rxData[inTopicLen + payloadLengthBytes + 3]),dest := ADR(dataTxt),length := UINT_TO_UDINT(inMsgLen));
 NXT
 LEAX rxData
 LDX  inTopicLen
#debug uint inTopicLen
 LDX  payloadLengthBytes
#debug uint payloadLengthBytes
 ADD
 AND  $FFFF
 LD   uint 3
 ADD
 AND  $FFFF
 RCHK 300   ; Range Check
 ADD     ; + offset 
#debug pointer rxData[inTopicLen+payloadLengthBytes+3]
 LEA  __Instance__MemcpyPtr~source
 WRIL 
#debug_left udint __Instance__MemcpyPtr~source
 LEAX dataTxt
#debug pointer dataTxt
 LEA  __Instance__MemcpyPtr~dest
 WRIL 
#debug_left udint __Instance__MemcpyPtr~dest
 LDX  inMsgLen
#debug uint inMsgLen
 WR   __Instance__MemcpyPtr~length
#debug_left udint __Instance__MemcpyPtr~length
 PRV
 LEA  __Instance__MemcpyPtr
 CAL  MemcpyPtr_L0
#srcline 376 ;                                  end_if;
fbMQTTSubscriber_L65:
#srcline 377 ;                             else
 JMP  fbMQTTSubscriber_L63
fbMQTTSubscriber_L62:
#srcline 378 ;                                ok       := false;
 LD   bool 0       ; false
 WRX  ok
#debug_left bool ok
#srcline 379 ;                                err      := true;
 LD   bool -1       ; true
 WRX  err
#debug_left bool err
#srcline 380 ;                                errCode  := MQTT_CONTROL_ERROR_CODE_ANSWER_LENGTH_TO_LONG;
 LD   usint 4
 WRX  errCode
#debug_left usint errCode
#srcline 381 ;                             end_if;
fbMQTTSubscriber_L63:
#srcline 382 ;                       end_if;
fbMQTTSubscriber_L54:
#srcline 383 ;                  end_if;
fbMQTTSubscriber_L49:
#srcline 384 ;                  rxCounter := rxCounter + 1;
 LDX  rxCounter
#debug uint rxCounter
 LD   uint 1
 ADD
 AND  $FFFF
 WRX  rxCounter
#debug_left uint rxCounter
#srcline 385 ;              end_if;
fbMQTTSubscriber_L46:
#srcline 386 ;          end_if;
fbMQTTSubscriber_L44:
#srcline 387 ;       else
 JMP  fbMQTTSubscriber_L39
fbMQTTSubscriber_L38:
#srcline 388 ;         connected_to_broker := false;
 LD   bool 0       ; false
 WRX  connected_to_broker
#debug_left bool connected_to_broker
#srcline 389 ;         wait_response       := false;
 LD   bool 0       ; false
 WRX  wait_response
#debug_left bool wait_response
#srcline 390 ;         ok                  := false;
 LD   bool 0       ; false
 WRX  ok
#debug_left bool ok
#srcline 391 ;         err                 := true;
 LD   bool -1       ; true
 WRX  err
#debug_left bool err
#srcline 392 ;         errCode             := MQTT_CONTROL_ERROR_CODE_BROKER_DISCONNECTED;
 LD   usint 3
 WRX  errCode
#debug_left usint errCode
#srcline 393 ;       end_if;
fbMQTTSubscriber_L39:
#srcline 394 ;   else
 JMP  fbMQTTSubscriber_L6
fbMQTTSubscriber_L5:
#srcline 395 ;     connected_to_broker := false;
 LD   bool 0       ; false
 WRX  connected_to_broker
#debug_left bool connected_to_broker
#srcline 396 ;     wait_response       := false;
 LD   bool 0       ; false
 WRX  wait_response
#debug_left bool wait_response
#srcline 397 ;     ok                  := false;
 LD   bool 0       ; false
 WRX  ok
#debug_left bool ok
#srcline 398 ;     err                 := true;
 LD   bool -1       ; true
 WRX  err
#debug_left bool err
#srcline 399 ;     errCode             := MQTT_CONTROL_ERROR_CODE_BROKER_DISCONNECTED;
 LD   usint 3
 WRX  errCode
#debug_left usint errCode
#srcline 400 ;   end_if;
fbMQTTSubscriber_L6:
#srcline 403 ;END_FUNCTION_BLOCK
fbMQTTSubscriber_RET:
 ULNK
RET
E     61

; Initialize - variables
P     61
fbMQTTSubscriber__InstanceInit__:
 LINK 0
 LD   uint 1883
 WRX  brokerPort
 LD   uint 5000
 WRX  localPort
 LD   bool -1   ; true
 WRX  keepAlive
 LD   time 20000
 WRX  keepAliveInterval
 LD   time 10000
 WRX  connTimeOut
 LD   time 15000
 WRX  pingInterval
 LD   bool -1   ; true
 WRX  clientId_auto
 LD   0
 SRC  byte __Init___fbMQTTSubscriber_com_param
 LEAX byte com_param
 LD   3
 MOV  %X0
 LEAX MQTT_Comm_Init
 CAL  fbMQTT_Comm_Init__InstanceInit__
 LEAX SendTo
 CAL  fbSendTo__InstanceInit__
 LEAX RecvFrom
 CAL  fbRecvFrom__InstanceInit__
 LD   0
 SRC  byte __Init___fbMQTTSubscriber_MQTT_PROTOCOL
 LEAX byte MQTT_PROTOCOL
 LD   5
 MOV  %X0
 LD   0
 SRC  byte __Init___fbMQTTSubscriber_inDataCom_param
 LEAX byte inDataCom_param
 LD   3
 MOV  %X0
 LD   udint $FFFFFFFF    ; nil
 WRX  messageIDpubAck_ptr
 ULNK
RET
E     61
; End initialize - variables
#endpou 

#pou fbMQTTSubscriberEx
#srcline 406 ;FUNCTION_BLOCK fbMQTTSubscriberEx
#table byte __Init___fbMQTTSubscriberEx_com_param = 
      0,  0,  1;
#table byte __Init___fbMQTTSubscriberEx_MQTT_PROTOCOL = 
    'M','Q','T','T';
#table byte __Init___fbMQTTSubscriberEx_inDataCom_param = 
      0,  0,  1;

#struct fbMQTTSubscriberEx__temp__
  string[82] PS0__st__,
  string[34] PSC__st__
#data byte _str_fbMQTTSubscriberEx_0 = 
  '',0
#data byte _str_fbMQTTSubscriberEx_1 = 
  '',0
#data byte _str_fbMQTTSubscriberEx_2 = 
  '',0
P     61
fbMQTTSubscriberEx_L0:
 LINK __SizeOf(fbMQTTSubscriberEx__temp__)
; R_EDGE, F_EDGE 
 LDX  subRq
 LETX __EDGE_R__subRq
 WRX  subRq
 LDX  unSubRq
 LETX __EDGE_R__unSubRq
 WRX  unSubRq
#srcline 514 ;  dataRec := false;
 LD   bool 0       ; false
 WRX  dataRec
#debug_left bool dataRec
#srcline 516 ;  if MQTT_com_responce_timeout.Q then
 LDX  MQTT_com_responce_timeout~Q
#debug bool MQTT_com_responce_timeout.Q
 JMC  fbMQTTSubscriberEx_L1
#srcline 517 ;      if responce_recived = false then
 LDX  responce_recived
#debug bool responce_recived
 LD   bool 0       ; false
 XOR
 NEG
 JMC  fbMQTTSubscriberEx_L3
#srcline 518 ;          connected_to_broker := false;
 LD   bool 0       ; false
 WRX  connected_to_broker
#debug_left bool connected_to_broker
#srcline 519 ;      end_if;
fbMQTTSubscriberEx_L3:
#srcline 520 ;      wait_response := false;
 LD   bool 0       ; false
 WRX  wait_response
#debug_left bool wait_response
#srcline 521 ;      busy := false;
 LD   bool 0       ; false
 WRX  busy
#debug_left bool busy
#srcline 522 ;      ok   := false;
 LD   bool 0       ; false
 WRX  ok
#debug_left bool ok
#srcline 523 ;      err  := true;
 LD   bool -1       ; true
 WRX  err
#debug_left bool err
#srcline 524 ;      errCode := MQTT_CONTROL_ERROR_CODE_BROKER_ANSWER_TIME_OUT;
 LD   usint 1
 WRX  errCode
#debug_left usint errCode
#srcline 525 ;  end_if;
fbMQTTSubscriberEx_L1:
#srcline 526 ;  local_port := localPort + localPortExtension;
 LDX  localPort
#debug uint localPort
 LDX  localPortExtension
#debug uint localPortExtension
 ADD
 AND  $FFFF
 WRX  local_port
#debug_left uint local_port
#srcline 527 ;  MQTT_Comm_Init( connect := connect, chanCode := chanCode, remoteIP := brokerIP, remotePort := brokerPort, localPort := localPort + localPortExtension,
 LDX  connect
#debug bool connect
 WRX  MQTT_Comm_Init~connect
#debug_left bool MQTT_Comm_Init~connect
 LDX  chanCode
#debug uint chanCode
 WRX  MQTT_Comm_Init~chanCode
#debug_left uint MQTT_Comm_Init~chanCode
 LEAX brokerIP
#debug pointer brokerIP
 SRC  %IB0
 LEAX MQTT_Comm_Init~remoteIP
 LD   4   ;SizeOf() 
 MOV  %IB0
 LDX  brokerPort
#debug uint brokerPort
 WRX  MQTT_Comm_Init~remotePort
#debug_left uint MQTT_Comm_Init~remotePort
 LDX  localPort
#debug uint localPort
 LDX  localPortExtension
#debug uint localPortExtension
 ADD
 AND  $FFFF
 WRX  MQTT_Comm_Init~localPort
#debug_left uint MQTT_Comm_Init~localPort
#srcline 528 ;                  status       => conn_status);
 LEAX MQTT_Comm_Init
 CAL  fbMQTT_Comm_Init_L0
; output assigment 
 LDX  MQTT_Comm_Init~status
#debug bool MQTT_Comm_Init~status
 WRX  conn_status
#debug_left bool conn_status
#srcline 530 ;   MQTT_com_responce_timeout(IN := wait_response,PT := connTimeOut);
 LDX  wait_response
#debug bool wait_response
 WRX  MQTT_com_responce_timeout~IN
#debug_left bool MQTT_com_responce_timeout~IN
 LDX  connTimeOut
#debug time connTimeOut
 WRX  MQTT_com_responce_timeout~PT
#debug_left time MQTT_com_responce_timeout~PT
 LEAX MQTT_com_responce_timeout
 CAL  TON_L0
#srcline 531 ;   MQTT_ping_timer(IN := connect AND keepAlive, PT := pingInterval);
 LDX  connect
#debug bool connect
 LDX  keepAlive
#debug bool keepAlive
 AND
 WRX  MQTT_ping_timer~IN
#debug_left bool MQTT_ping_timer~IN
 LDX  pingInterval
#debug time pingInterval
 WRX  MQTT_ping_timer~PT
#debug_left time MQTT_ping_timer~PT
 LEAX MQTT_ping_timer
 CAL  fbTick_L0
#srcline 532 ;   MQTT_com_intervat(IN := connect, PT := T#2s);
 LDX  connect
#debug bool connect
 WRX  MQTT_com_intervat~IN
#debug_left bool MQTT_com_intervat~IN
 LD   time 2000
 WRX  MQTT_com_intervat~PT
#debug_left time MQTT_com_intervat~PT
 LEAX MQTT_com_intervat
 CAL  fbTick_L0
#srcline 534 ;   if connect then
 LDX  connect
#debug bool connect
 JMC  fbMQTTSubscriberEx_L5
#srcline 535 ;       if MQTT_com_intervat.Q OR subRq OR unSubRq OR pubAckRq OR pubRecRq OR pubCompRq then
 LDX  MQTT_com_intervat~Q
#debug bool MQTT_com_intervat.Q
 LDX  subRq
#debug bool subRq
 OR  
 LDX  unSubRq
#debug bool unSubRq
 OR  
 LDX  pubAckRq
#debug bool pubAckRq
 OR  
 LDX  pubRecRq
#debug bool pubRecRq
 OR  
 LDX  pubCompRq
#debug bool pubCompRq
 OR  
 JMC  fbMQTTSubscriberEx_L7
#srcline 536 ;           if connected_to_broker = false then
 LDX  connected_to_broker
#debug bool connected_to_broker
 LD   bool 0       ; false
 XOR
 NEG
 JMC  fbMQTTSubscriberEx_L9
#srcline 537 ;                 if clientId_auto then
 LDX  clientId_auto
#debug bool clientId_auto
 JMC  fbMQTTSubscriberEx_L11
#srcline 538 ;                     client_id := DWORD_TO_STRING(DT_TO_DWORD(GetRTC())) + UINT_TO_STRING(MSEC_OF_DT(GetRTC()));
 LD   0   ; null string
 WRY  PS0__st__[0]
 LEAY PS0__st__[0]
 LD   32
 DST    ; Level 1
 LD   0   ; null string
 WRY  PSC__st__[0]
 LEAY PSC__st__[0]
 LD   32
 DST    ; Level 2
 LEA  __Instance__GetRTC
 CAL  GetRTC_L0
 RNDD
 UDFL
 SCNV $2C30;  IEC_DWORD _TO_ IEC_STRING
 PDST   ; Level 2
 LEAY PSC__st__[0]

 SCON 
 LD   0   ; null string
 WRY  PSC__st__[0]
 LEAY PSC__st__[0]
 LD   32
 DST    ; Level 2
 NXT
 LEA  __Instance__GetRTC
 CAL  GetRTC_L0
 WR   __Instance__MSEC_OF_DT~in
#debug_left dt __Instance__MSEC_OF_DT~in
 PRV
 LEA  __Instance__MSEC_OF_DT
 CAL  MSEC_OF_DT_L0
 SCNV $0A30;  IEC_UINT _TO_ IEC_STRING
 PDST   ; Level 2
 LEAY PSC__st__[0]

 SCON 
 PDST   ; Level 1
 LD   0   ; null string
 LEAX client_id
 WRI  
 LEAX client_id
 LD   32
 DST    ; Level 1
 LEAY PS0__st__[0]
 SCON 
#debug_left string client_id
 PDST   ; Level 1
#srcline 539 ;                 else
 JMP  fbMQTTSubscriberEx_L12
fbMQTTSubscriberEx_L11:
#srcline 540 ;                     client_id := clientId;
 LD   0   ; null string
 LEAX client_id
 WRI  
 LEAX client_id
 LD   32
 DST    ; Level 1
 LEAX clientId
#debug string clientId
 SCON 
#debug_left string client_id
 PDST   ; Level 1
#srcline 541 ;                 end_if;
fbMQTTSubscriberEx_L12:
#srcline 543 ;                // Fixed header of control packet
#srcline 544 ;                // Fixed header
#srcline 545 ;                txData[0] := MQTT_CONTROL_PACK_CONNECT; // flag bits are cleared
 LD   usint 16
 WRX  txData[0]
#debug_left usint txData[0]
#srcline 546 ;                // Variable header
#srcline 547 ;                txData[2] := 0;
 LD   usint 0
 WRX  txData[2]
#debug_left usint txData[2]
#srcline 548 ;                txData[3] := 4;
 LD   usint 4
 WRX  txData[3]
#debug_left usint txData[3]
#srcline 549 ;                MemcpyPtr(source := ADR(MQTT_PROTOCOL),dest := ADR(txData[4]),length := 4);
 NXT
 LEAX MQTT_PROTOCOL
#debug pointer MQTT_PROTOCOL
 LEA  __Instance__MemcpyPtr~source
 WRIL 
#debug_left udint __Instance__MemcpyPtr~source
 LEAX txData
 ADD  4  ; + offset 
#debug pointer txData[4]
 LEA  __Instance__MemcpyPtr~dest
 WRIL 
#debug_left udint __Instance__MemcpyPtr~dest
 LD   udint 4
 WR   __Instance__MemcpyPtr~length
#debug_left udint __Instance__MemcpyPtr~length
 PRV
 LEA  __Instance__MemcpyPtr
 CAL  MemcpyPtr_L0
#srcline 550 ;                txData[8]   := MQTT_PROTOCOL_VERSION;
 LD   usint 4
 WRX  txData[8]
#debug_left usint txData[8]
#srcline 551 ;                // Protocol Level byte
#srcline 552 ;                //Set connection flags
#srcline 553 ;                connectFlags := 0;
 LD   byte 0
 WRX  connectFlags
#debug_left byte connectFlags
#srcline 554 ;                if loginName <> ''        then connectFlags := 16#80; end_if;
 LEAX loginName
#debug string loginName
 LEA  _str_fbMQTTSubscriberEx_0
 SCMP 
 EQ   0
 NEG
 JMC  fbMQTTSubscriberEx_L13
 LD   byte $80
 WRX  connectFlags
#debug_left byte connectFlags
fbMQTTSubscriberEx_L13:
#srcline 555 ;                if loginPass <> ''        then connectFlags := connectFlags OR 16#40; end_if;
 LEAX loginPass
#debug string loginPass
 LEA  _str_fbMQTTSubscriberEx_1
 SCMP 
 EQ   0
 NEG
 JMC  fbMQTTSubscriberEx_L15
 LDX  connectFlags
#debug byte connectFlags
 LD   byte $40
 OR  
 WRX  connectFlags
#debug_left byte connectFlags
fbMQTTSubscriberEx_L15:
#srcline 556 ;               // if com_param.willRetain   then connectFlags := connectFlags OR 16#20; end_if;
#srcline 557 ;               // connectFlags := connectFlags OR SHL(IN := USINT_TO_BYTE(com_param.qos),N := 3);
#srcline 558 ;                if com_param.cleanSession then connectFlags := connectFlags OR 16#2;  end_if;
 LDX  com_param~cleanSession
#debug bool com_param.cleanSession
 JMC  fbMQTTSubscriberEx_L17
 LDX  connectFlags
#debug byte connectFlags
 LD   byte $2
 OR  
 WRX  connectFlags
#debug_left byte connectFlags
fbMQTTSubscriberEx_L17:
#srcline 560 ;                txData[9]   := BYTE_TO_USINT(connectFlags);//For connect set clean session
 LDX  connectFlags
#debug byte connectFlags
 WRX  txData[9]
#debug_left usint txData[9]
#srcline 561 ;                //keep alive 2 bytes, MSB+LSB
#srcline 562 ;                aliveTime := TIME_TO_UINT(keepAliveInterval)/1000;
 LDX  keepAliveInterval
#debug time keepAliveInterval
AND  $FFFF
 LD   uint 1000
 DIVL
 AND  $FFFF
 WRX  aliveTime
#debug_left uint aliveTime
#srcline 564 ;                txData[10]  := 0;
 LD   usint 0
 WRX  txData[10]
#debug_left usint txData[10]
#srcline 565 ;                txData[11]  := UINT_TO_USINT(aliveTime);
 LDX  aliveTime
#debug uint aliveTime
 AND  $FF
 WRX  txData[11]
#debug_left usint txData[11]
#srcline 566 ;                //Payload
#srcline 567 ;                payloadLength := LEN(IN := client_id);
 LEAX client_id
#debug string client_id
 SLEN 
 WRX  payloadLength
#debug_left usint payloadLength
#srcline 568 ;                txData[12]  := 0;
 LD   usint 0
 WRX  txData[12]
#debug_left usint txData[12]
#srcline 569 ;                txData[13]  := payloadLength;
 LDX  payloadLength
#debug usint payloadLength
 WRX  txData[13]
#debug_left usint txData[13]
#srcline 571 ;                txMsgLength := 14;
 LD   usint 14
 WRX  txMsgLength
#debug_left usint txMsgLength
#srcline 572 ;                //Copy client ID
#srcline 573 ;                MemcpyPtr(source := ADR(client_id),dest := ADR(txData[14]),length := USINT_TO_UDINT(payloadLength));
 NXT
 LEAX client_id
#debug pointer client_id
 LEA  __Instance__MemcpyPtr~source
 WRIL 
#debug_left udint __Instance__MemcpyPtr~source
 LEAX txData
 ADD  14  ; + offset 
#debug pointer txData[14]
 LEA  __Instance__MemcpyPtr~dest
 WRIL 
#debug_left udint __Instance__MemcpyPtr~dest
 LDX  payloadLength
#debug usint payloadLength
 WR   __Instance__MemcpyPtr~length
#debug_left udint __Instance__MemcpyPtr~length
 PRV
 LEA  __Instance__MemcpyPtr
 CAL  MemcpyPtr_L0
#srcline 574 ;                txMsgLength := txMsgLength + payloadLength;
 LDX  txMsgLength
#debug usint txMsgLength
 LDX  payloadLength
#debug usint payloadLength
 ADD
 AND  $FF
 WRX  txMsgLength
#debug_left usint txMsgLength
#srcline 575 ;                //Copy user name
#srcline 576 ;                if (connectFlags AND 16#80) > 0 then
 LDX  connectFlags
#debug byte connectFlags
 LD   byte $80
 AND
 LD   byte 0
 GT
 JMC  fbMQTTSubscriberEx_L19
#srcline 577 ;                     txData[txMsgLength]     := 0;
 LD   usint 0
 LEAX txData
 LDX  txMsgLength
#debug usint txMsgLength
 RCHK 100   ; Range Check
 ADD     ; + offset 
 WRI 
#debug_left usint txData[txMsgLength]
#srcline 578 ;                     txData[txMsgLength + 1] := LEN(IN := loginName);
 LEAX loginName
#debug string loginName
 SLEN 
 LEAX txData
 LDX  txMsgLength
#debug usint txMsgLength
 LD   usint 1
 ADD
 AND  $FF
 RCHK 100   ; Range Check
 ADD     ; + offset 
 WRI 
#debug_left usint txData[txMsgLength+1]
#srcline 579 ;                     payloadLength := LEN(IN := loginName);
 LEAX loginName
#debug string loginName
 SLEN 
 WRX  payloadLength
#debug_left usint payloadLength
#srcline 580 ;                     MemcpyPtr(source := ADR(loginName),dest := ADR(txData[txMsgLength + 2]),length := USINT_TO_UDINT(payloadLength));
 NXT
 LEAX loginName
#debug pointer loginName
 LEA  __Instance__MemcpyPtr~source
 WRIL 
#debug_left udint __Instance__MemcpyPtr~source
 LEAX txData
 LDX  txMsgLength
#debug usint txMsgLength
 LD   usint 2
 ADD
 AND  $FF
 RCHK 100   ; Range Check
 ADD     ; + offset 
#debug pointer txData[txMsgLength+2]
 LEA  __Instance__MemcpyPtr~dest
 WRIL 
#debug_left udint __Instance__MemcpyPtr~dest
 LDX  payloadLength
#debug usint payloadLength
 WR   __Instance__MemcpyPtr~length
#debug_left udint __Instance__MemcpyPtr~length
 PRV
 LEA  __Instance__MemcpyPtr
 CAL  MemcpyPtr_L0
#srcline 581 ;                     txMsgLength := txMsgLength + payloadLength + 2;
 LDX  txMsgLength
#debug usint txMsgLength
 LDX  payloadLength
#debug usint payloadLength
 ADD
 AND  $FF
 LD   usint 2
 ADD
 AND  $FF
 WRX  txMsgLength
#debug_left usint txMsgLength
#srcline 582 ;                end_if;
fbMQTTSubscriberEx_L19:
#srcline 583 ;                //Copy password
#srcline 584 ;                if (connectFlags AND 16#40) > 0 then
 LDX  connectFlags
#debug byte connectFlags
 LD   byte $40
 AND
 LD   byte 0
 GT
 JMC  fbMQTTSubscriberEx_L21
#srcline 585 ;                     txData[txMsgLength]     := 0;
 LD   usint 0
 LEAX txData
 LDX  txMsgLength
#debug usint txMsgLength
 RCHK 100   ; Range Check
 ADD     ; + offset 
 WRI 
#debug_left usint txData[txMsgLength]
#srcline 586 ;                     txData[txMsgLength + 1] := LEN(IN := loginPass);
 LEAX loginPass
#debug string loginPass
 SLEN 
 LEAX txData
 LDX  txMsgLength
#debug usint txMsgLength
 LD   usint 1
 ADD
 AND  $FF
 RCHK 100   ; Range Check
 ADD     ; + offset 
 WRI 
#debug_left usint txData[txMsgLength+1]
#srcline 587 ;                     payloadLength := LEN(IN := loginPass);
 LEAX loginPass
#debug string loginPass
 SLEN 
 WRX  payloadLength
#debug_left usint payloadLength
#srcline 588 ;                     MemcpyPtr(source := ADR(loginPass),dest := ADR(txData[txMsgLength + 2]),length := USINT_TO_UDINT(payloadLength));
 NXT
 LEAX loginPass
#debug pointer loginPass
 LEA  __Instance__MemcpyPtr~source
 WRIL 
#debug_left udint __Instance__MemcpyPtr~source
 LEAX txData
 LDX  txMsgLength
#debug usint txMsgLength
 LD   usint 2
 ADD
 AND  $FF
 RCHK 100   ; Range Check
 ADD     ; + offset 
#debug pointer txData[txMsgLength+2]
 LEA  __Instance__MemcpyPtr~dest
 WRIL 
#debug_left udint __Instance__MemcpyPtr~dest
 LDX  payloadLength
#debug usint payloadLength
 WR   __Instance__MemcpyPtr~length
#debug_left udint __Instance__MemcpyPtr~length
 PRV
 LEA  __Instance__MemcpyPtr
 CAL  MemcpyPtr_L0
#srcline 589 ;                     txMsgLength := txMsgLength + payloadLength + 2;
 LDX  txMsgLength
#debug usint txMsgLength
 LDX  payloadLength
#debug usint payloadLength
 ADD
 AND  $FF
 LD   usint 2
 ADD
 AND  $FF
 WRX  txMsgLength
#debug_left usint txMsgLength
#srcline 590 ;                end_if;
fbMQTTSubscriberEx_L21:
#srcline 592 ;                // length of package
#srcline 593 ;                txData[1]   := txMsgLength;
 LDX  txMsgLength
#debug usint txMsgLength
 WRX  txData[1]
#debug_left usint txData[1]
#srcline 594 ;                txMsgLength := txMsgLength + 2;
 LDX  txMsgLength
#debug usint txMsgLength
 LD   usint 2
 ADD
 AND  $FF
 WRX  txMsgLength
#debug_left usint txMsgLength
#srcline 596 ;                tx_data_request    := true;
 LD   bool -1       ; true
 WRX  tx_data_request
#debug_left bool tx_data_request
#srcline 597 ;                localPortExtension := USINT_TO_UINT(reconnect_counter);
 LDX  reconnect_counter
#debug usint reconnect_counter
 AND  $FFFF
 WRX  localPortExtension
#debug_left uint localPortExtension
#srcline 598 ;              //  connect_rq := true;
#srcline 599 ;                idle_time := 2;
 LD   usint 2
 WRX  idle_time
#debug_left usint idle_time
#srcline 600 ;                // required to change port on each reconnect
#srcline 601 ;                if reconnect_counter < 100 then
 LDX  reconnect_counter
#debug usint reconnect_counter
 LD   usint 100
 LT
 JMC  fbMQTTSubscriberEx_L23
#srcline 602 ;                    reconnect_counter := reconnect_counter + 1; //
 LDX  reconnect_counter
#debug usint reconnect_counter
 LD   usint 1
 ADD
 AND  $FF
 WRX  reconnect_counter
#debug_left usint reconnect_counter
#srcline 603 ;                else
 JMP  fbMQTTSubscriberEx_L24
fbMQTTSubscriberEx_L23:
#srcline 604 ;                    reconnect_counter := 0;
 LD   usint 0
 WRX  reconnect_counter
#debug_left usint reconnect_counter
#srcline 605 ;                end_if;
fbMQTTSubscriberEx_L24:
#srcline 606 ;                responce_recived := false;
 LD   bool 0       ; false
 WRX  responce_recived
#debug_left bool responce_recived
#srcline 607 ;                return;
 JMP  fbMQTTSubscriberEx_RET
#srcline 608 ;           //--------- Connected to brocker -------------------
#srcline 609 ;           else
 JMP  fbMQTTSubscriberEx_L10
fbMQTTSubscriberEx_L9:
#srcline 610 ;               if subRq OR unSubRq then //Subscribe or unsubsribe command from user program
 LDX  subRq
#debug bool subRq
 LDX  unSubRq
#debug bool unSubRq
 OR  
 JMC  fbMQTTSubscriberEx_L25
#srcline 611 ;                   if subRq then
 LDX  subRq
#debug bool subRq
 JMC  fbMQTTSubscriberEx_L27
#srcline 612 ;                       txData[0] := MQTT_CONTROL_PACK_SUBSCRIBE + 2;
 LD   usint 128
 LD   usint 2
 ADD
 AND  $FF
 WRX  txData[0]
#debug_left usint txData[0]
#srcline 613 ;                   else
 JMP  fbMQTTSubscriberEx_L28
fbMQTTSubscriberEx_L27:
#srcline 614 ;                       txData[0] := MQTT_CONTROL_PACK_UNSUBSCRIBE + 2;
 LD   usint 160
 LD   usint 2
 ADD
 AND  $FF
 WRX  txData[0]
#debug_left usint txData[0]
#srcline 615 ;                   end_if;
fbMQTTSubscriberEx_L28:
#srcline 616 ;                   //The variable header contains a Packet Identifier
#srcline 617 ;                   txData[2]        := WORD_TO_USINT(SHR(IN := UINT_TO_WORD(messageID), N := 8));
 LDX  messageID
#debug uint messageID
 LD   uint 8
 SHR
 AND  $FFFF
 AND  $FF
 WRX  txData[2]
#debug_left usint txData[2]
#srcline 618 ;                   txData[3]        := UINT_TO_USINT(messageID);
 LDX  messageID
#debug uint messageID
 AND  $FF
 WRX  txData[3]
#debug_left usint txData[3]
#srcline 620 ;                   // Payload
#srcline 621 ;                   payloadLength := LEN(IN := subTopicTxt);
 LEAX subTopicTxt
#debug string subTopicTxt
 SLEN 
 WRX  payloadLength
#debug_left usint payloadLength
#srcline 622 ;                   txData[4] := 0;
 LD   usint 0
 WRX  txData[4]
#debug_left usint txData[4]
#srcline 623 ;                   txData[5] := payloadLength;
 LDX  payloadLength
#debug usint payloadLength
 WRX  txData[5]
#debug_left usint txData[5]
#srcline 624 ;                   MemcpyPtr(source := ADR(subTopicTxt),dest := ADR(txData[6]),length := USINT_TO_UDINT(payloadLength));
 NXT
 LEAX subTopicTxt
#debug pointer subTopicTxt
 LEA  __Instance__MemcpyPtr~source
 WRIL 
#debug_left udint __Instance__MemcpyPtr~source
 LEAX txData
 ADD  6  ; + offset 
#debug pointer txData[6]
 LEA  __Instance__MemcpyPtr~dest
 WRIL 
#debug_left udint __Instance__MemcpyPtr~dest
 LDX  payloadLength
#debug usint payloadLength
 WR   __Instance__MemcpyPtr~length
#debug_left udint __Instance__MemcpyPtr~length
 PRV
 LEA  __Instance__MemcpyPtr
 CAL  MemcpyPtr_L0
#srcline 625 ;                   txMsgLength := payloadLength + 4;
 LDX  payloadLength
#debug usint payloadLength
 LD   usint 4
 ADD
 AND  $FF
 WRX  txMsgLength
#debug_left usint txMsgLength
#srcline 626 ;                   if subRq then
 LDX  subRq
#debug bool subRq
 JMC  fbMQTTSubscriberEx_L29
#srcline 627 ;                       txData[txMsgLength + 2] := com_param.qos;
 LDX  com_param~qos
#debug usint com_param.qos
 LEAX txData
 LDX  txMsgLength
#debug usint txMsgLength
 LD   usint 2
 ADD
 AND  $FF
 RCHK 100   ; Range Check
 ADD     ; + offset 
 WRI 
#debug_left usint txData[txMsgLength+2]
#srcline 628 ;                       txMsgLength := txMsgLength + 1;
 LDX  txMsgLength
#debug usint txMsgLength
 LD   usint 1
 ADD
 AND  $FF
 WRX  txMsgLength
#debug_left usint txMsgLength
#srcline 629 ;                   end_if;
fbMQTTSubscriberEx_L29:
#srcline 631 ;                   txData[1]        := txMsgLength;
 LDX  txMsgLength
#debug usint txMsgLength
 WRX  txData[1]
#debug_left usint txData[1]
#srcline 632 ;                   txMsgLength      := txMsgLength + 2;
 LDX  txMsgLength
#debug usint txMsgLength
 LD   usint 2
 ADD
 AND  $FF
 WRX  txMsgLength
#debug_left usint txMsgLength
#srcline 633 ;                   tx_data_request  := true;
 LD   bool -1       ; true
 WRX  tx_data_request
#debug_left bool tx_data_request
#srcline 635 ;                   busy    := true;
 LD   bool -1       ; true
 WRX  busy
#debug_left bool busy
#srcline 636 ;                   ok      := false;
 LD   bool 0       ; false
 WRX  ok
#debug_left bool ok
#srcline 637 ;                   err     := false;
 LD   bool 0       ; false
 WRX  err
#debug_left bool err
#srcline 638 ;                   errCode := MQTT_CONTROL_ERROR_CODE_OK;
 LD   usint 0
 WRX  errCode
#debug_left usint errCode
#srcline 640 ;                   subRq   := false;
 LD   bool 0       ; false
 WRX  subRq
#debug_left bool subRq
#srcline 641 ;                   unSubRq := false;
 LD   bool 0       ; false
 WRX  unSubRq
#debug_left bool unSubRq
#srcline 642 ;               end_if;
fbMQTTSubscriberEx_L25:
#srcline 644 ;               if pubAckRq OR pubRecRq OR pubCompRq then
 LDX  pubAckRq
#debug bool pubAckRq
 LDX  pubRecRq
#debug bool pubRecRq
 OR  
 LDX  pubCompRq
#debug bool pubCompRq
 OR  
 JMC  fbMQTTSubscriberEx_L31
#srcline 645 ;                   if pubAckRq then
 LDX  pubAckRq
#debug bool pubAckRq
 JMC  fbMQTTSubscriberEx_L33
#srcline 646 ;                       txData[0]        := MQTT_CONTROL_PACK_PUBACK;  // Publish acknowledge                      QOS=1
 LD   usint 64
 WRX  txData[0]
#debug_left usint txData[0]
#srcline 647 ;                   elsif pubRecRq then
 JMP  fbMQTTSubscriberEx_L34
fbMQTTSubscriberEx_L33:
 LDX  pubRecRq
#debug bool pubRecRq
 JMC  fbMQTTSubscriberEx_L35
#srcline 648 ;                       txData[0]        := MQTT_CONTROL_PACK_PUBREC;  // Publish acknowledge "Publish recived"    QOS=2
 LD   usint 80
 WRX  txData[0]
#debug_left usint txData[0]
#srcline 649 ;                   else
 JMP  fbMQTTSubscriberEx_L34
fbMQTTSubscriberEx_L35:
#srcline 650 ;                       txData[0]        := MQTT_CONTROL_PACK_PUBCOMP; // Publish acknowledge "Publish completed"  QOS=2
 LD   usint 112
 WRX  txData[0]
#debug_left usint txData[0]
#srcline 651 ;                   end_if;
fbMQTTSubscriberEx_L34:
#srcline 653 ;                   txData[1]        := 2;
 LD   usint 2
 WRX  txData[1]
#debug_left usint txData[1]
#srcline 654 ;                   txData[2]        := WORD_TO_USINT(SHR(IN := UINT_TO_WORD(messageIDpubAck), N := 8));
 LDX  messageIDpubAck
#debug uint messageIDpubAck
 LD   uint 8
 SHR
 AND  $FFFF
 AND  $FF
 WRX  txData[2]
#debug_left usint txData[2]
#srcline 655 ;                   txData[3]        := UINT_TO_USINT(messageIDpubAck);
 LDX  messageIDpubAck
#debug uint messageIDpubAck
 AND  $FF
 WRX  txData[3]
#debug_left usint txData[3]
#srcline 656 ;                   txMsgLength      := 4;
 LD   usint 4
 WRX  txMsgLength
#debug_left usint txMsgLength
#srcline 657 ;                   tx_data_request  := true;
 LD   bool -1       ; true
 WRX  tx_data_request
#debug_left bool tx_data_request
#srcline 658 ;                   busy             := false;
 LD   bool 0       ; false
 WRX  busy
#debug_left bool busy
#srcline 659 ;                   ok               := true;
 LD   bool -1       ; true
 WRX  ok
#debug_left bool ok
#srcline 660 ;                   err              := false;
 LD   bool 0       ; false
 WRX  err
#debug_left bool err
#srcline 661 ;                   errCode          := MQTT_CONTROL_ERROR_CODE_OK;
 LD   usint 0
 WRX  errCode
#debug_left usint errCode
#srcline 663 ;                   pubAckRq         := false;
 LD   bool 0       ; false
 WRX  pubAckRq
#debug_left bool pubAckRq
#srcline 664 ;                   pubRecRq         := false;
 LD   bool 0       ; false
 WRX  pubRecRq
#debug_left bool pubRecRq
#srcline 665 ;                   pubCompRq        := false;
 LD   bool 0       ; false
 WRX  pubCompRq
#debug_left bool pubCompRq
#srcline 666 ;                   return;
 JMP  fbMQTTSubscriberEx_RET
#srcline 667 ;               end_if;
fbMQTTSubscriberEx_L31:
#srcline 669 ;                //---------------------------------------------
#srcline 670 ;                if MQTT_ping_timer.Q then
 LDX  MQTT_ping_timer~Q
#debug bool MQTT_ping_timer.Q
 JMC  fbMQTTSubscriberEx_L36
#srcline 671 ;                    //Ping request
#srcline 672 ;                     txData[0]        := MQTT_CONTROL_PACK_PINGREQ; // flag bits are cleared
 LD   usint 192
 WRX  txData[0]
#debug_left usint txData[0]
#srcline 673 ;                     txData[1]        := 0;
 LD   usint 0
 WRX  txData[1]
#debug_left usint txData[1]
#srcline 674 ;                     txMsgLength      := 2;
 LD   usint 2
 WRX  txMsgLength
#debug_left usint txMsgLength
#srcline 675 ;                     tx_data_request  := true;
 LD   bool -1       ; true
 WRX  tx_data_request
#debug_left bool tx_data_request
#srcline 676 ;                     responce_recived := false;
 LD   bool 0       ; false
 WRX  responce_recived
#debug_left bool responce_recived
#srcline 677 ;                     busy             := false;
 LD   bool 0       ; false
 WRX  busy
#debug_left bool busy
#srcline 678 ;                     ok               := true;
 LD   bool -1       ; true
 WRX  ok
#debug_left bool ok
#srcline 679 ;                     err              := false;
 LD   bool 0       ; false
 WRX  err
#debug_left bool err
#srcline 680 ;                     errCode          := MQTT_CONTROL_ERROR_CODE_OK;
 LD   usint 0
 WRX  errCode
#debug_left usint errCode
#srcline 681 ;                     return;
 JMP  fbMQTTSubscriberEx_RET
#srcline 682 ;                end_if;
fbMQTTSubscriberEx_L36:
#srcline 683 ;           end_if;
fbMQTTSubscriberEx_L10:
#srcline 684 ;       end_if;
fbMQTTSubscriberEx_L7:
#srcline 686 ;      if conn_status then
 LDX  conn_status
#debug bool conn_status
 JMC  fbMQTTSubscriberEx_L38
#srcline 687 ;          SendTo( rq := tx_data_request, chanCode := chanCode, lenTx := USINT_TO_UINT(txMsgLength) , data := void(txData));
 LDX  tx_data_request
#debug bool tx_data_request
 WRX  SendTo~rq
#debug_left bool SendTo~rq
 LDX  chanCode
#debug uint chanCode
 WRX  SendTo~chanCode
#debug_left uint SendTo~chanCode
 LDX  txMsgLength
#debug usint txMsgLength
 AND  $FFFF
 WRX  SendTo~lenTx
#debug_left uint SendTo~lenTx
 LEAX txData
 WRX  SendTo~data
#debug_left pointer SendTo.data
 LEAX SendTo
 CAL  fbSendTo_L0
#srcline 688 ;          if SendTo.mesSent then
 LDX  SendTo~mesSent
#debug bool SendTo.mesSent
 JMC  fbMQTTSubscriberEx_L40
#srcline 689 ;              tx_data_request := false;
 LD   bool 0       ; false
 WRX  tx_data_request
#debug_left bool tx_data_request
#srcline 690 ;              txCounter := txCounter + 1;
 LDX  txCounter
#debug uint txCounter
 LD   uint 1
 ADD
 AND  $FFFF
 WRX  txCounter
#debug_left uint txCounter
#srcline 691 ;              messageID := messageID + 1;
 LDX  messageID
#debug uint messageID
 LD   uint 1
 ADD
 AND  $FFFF
 WRX  messageID
#debug_left uint messageID
#srcline 692 ;              if com_param.qos = 1 then wait_response := true; end_if;
 LDX  com_param~qos
#debug usint com_param.qos
 LD   usint 1
 EQ
 JMC  fbMQTTSubscriberEx_L42
 LD   bool -1       ; true
 WRX  wait_response
#debug_left bool wait_response
fbMQTTSubscriberEx_L42:
#srcline 693 ;          end_if;
fbMQTTSubscriberEx_L40:
#srcline 695 ;          RecvFrom( rq := true, chanCode := chanCode, lenRx := 512, data := void(rxData));
 LD   bool -1       ; true
 WRX  RecvFrom~rq
#debug_left bool RecvFrom~rq
 LDX  chanCode
#debug uint chanCode
 WRX  RecvFrom~chanCode
#debug_left uint RecvFrom~chanCode
 LD   uint 512
 WRX  RecvFrom~lenRx
#debug_left uint RecvFrom~lenRx
 LEAX rxData
 WRX  RecvFrom~data
#debug_left pointer RecvFrom.data
 LEAX RecvFrom
 CAL  fbRecvFrom_L0
#srcline 697 ;          if RecvFrom.mesRec then
 LDX  RecvFrom~mesRec
#debug bool RecvFrom.mesRec
 JMC  fbMQTTSubscriberEx_L44
#srcline 698 ;              if RecvFrom.error = 0 then
 LDX  RecvFrom~error
#debug usint RecvFrom.error
 LD   usint 0
 EQ
 JMC  fbMQTTSubscriberEx_L46
#srcline 699 ;                   busy     := false;
 LD   bool 0       ; false
 WRX  busy
#debug_left bool busy
#srcline 700 ;                   ok       := true;
 LD   bool -1       ; true
 WRX  ok
#debug_left bool ok
#srcline 701 ;                   err      := false;
 LD   bool 0       ; false
 WRX  err
#debug_left bool err
#srcline 702 ;                   errCode  := MQTT_CONTROL_ERROR_CODE_OK;
 LD   usint 0
 WRX  errCode
#debug_left usint errCode
#srcline 704 ;                  if (RecvFrom.lenData = 4  AND (rxData[0] = MQTT_CONTROL_PACK_CONNACK OR rxData[0] = MQTT_CONTROL_PACK_UNSUBACK)) OR  // responce to connect command
 LDX  RecvFrom~lenData
#debug uint RecvFrom.lenData
 LD   uint 4
 EQ
 LDX  rxData[0]
#debug usint rxData[0]
 LD   usint 32
 EQ
 LDX  rxData[0]
#debug usint rxData[0]
 LD   usint 176
 EQ
 OR  
 AND
#srcline 705 ;                      RecvFrom.lenData = 2  AND  rxData[0] = MQTT_CONTROL_PACK_PINGRESP  then
 LDX  RecvFrom~lenData
#debug uint RecvFrom.lenData
 LD   uint 2
 EQ
 LDX  rxData[0]
#debug usint rxData[0]
 LD   usint 208
 EQ
 AND
 OR  
 JMC  fbMQTTSubscriberEx_L48
#srcline 706 ;                        connected_to_broker  := true;
 LD   bool -1       ; true
 WRX  connected_to_broker
#debug_left bool connected_to_broker
#srcline 707 ;                        responce_recived     := true;
 LD   bool -1       ; true
 WRX  responce_recived
#debug_left bool responce_recived
#srcline 708 ;                        wait_response        := false;
 LD   bool 0       ; false
 WRX  wait_response
#debug_left bool wait_response
#srcline 709 ;                  elsif (RecvFrom.lenData = 4  AND (AND(IN1 := USINT_TO_BYTE(rxData[0]),IN2 := USINT_TO_BYTE(MQTT_CONTROL_PACK_PUBREL)) = USINT_TO_BYTE(MQTT_CONTROL_PACK_PUBREL))) then
 JMP  fbMQTTSubscriberEx_L49
fbMQTTSubscriberEx_L48:
 LDX  RecvFrom~lenData
#debug uint RecvFrom.lenData
 LD   uint 4
 EQ
 LDX  rxData[0]
#debug usint rxData[0]
 AND  $FF
 LD   usint 96
 AND  $FF
 AND
 LD   usint 96
 AND  $FF
 EQ
 AND
 JMC  fbMQTTSubscriberEx_L50
#srcline 710 ;                          pubCompRq           := true;
 LD   bool -1       ; true
 WRX  pubCompRq
#debug_left bool pubCompRq
#srcline 711 ;                          connected_to_broker := true;
 LD   bool -1       ; true
 WRX  connected_to_broker
#debug_left bool connected_to_broker
#srcline 712 ;                          responce_recived    := true;
 LD   bool -1       ; true
 WRX  responce_recived
#debug_left bool responce_recived
#srcline 713 ;                          wait_response       := false;
 LD   bool 0       ; false
 WRX  wait_response
#debug_left bool wait_response
#srcline 715 ;                          messageIDpubAck_ptr := ADR(rxData[2]);
 LEAX rxData
 ADD  2  ; + offset 
#debug pointer rxData[2]
 LEAX messageIDpubAck_ptr
 WRIL 
#debug_left pointer messageIDpubAck_ptr
#srcline 716 ;                          messageIDpubAck     := fSwapUINT( messageIDpubAck_ptr^);
 NXT
 LEAX messageIDpubAck_ptr
 LDIL    ; dereference 
 LDIW 
#debug uint messageIDpubAck_ptr^
 WR   __Instance__fSwapUINT~input
#debug_left uint __Instance__fSwapUINT~input
 PRV
 LEA  __Instance__fSwapUINT
 CAL  fSwapUINT_L0
 WRX  messageIDpubAck
#debug_left uint messageIDpubAck
#srcline 718 ;                  elsif RecvFrom.lenData = 5 AND rxData[0] = MQTT_CONTROL_PACK_SUBACK then // responce to subscribe command
 JMP  fbMQTTSubscriberEx_L49
fbMQTTSubscriberEx_L50:
 LDX  RecvFrom~lenData
#debug uint RecvFrom.lenData
 LD   uint 5
 EQ
 LDX  rxData[0]
#debug usint rxData[0]
 LD   usint 144
 EQ
 AND
 JMC  fbMQTTSubscriberEx_L51
#srcline 719 ;                         connected_to_broker := true;
 LD   bool -1       ; true
 WRX  connected_to_broker
#debug_left bool connected_to_broker
#srcline 720 ;                         responce_recived    := true;
 LD   bool -1       ; true
 WRX  responce_recived
#debug_left bool responce_recived
#srcline 721 ;                         wait_response       := false;
 LD   bool 0       ; false
 WRX  wait_response
#debug_left bool wait_response
#srcline 722 ;                         if rxData[4] = 16#80 then
 LDX  rxData[4]
#debug usint rxData[4]
 LD   usint $80
 EQ
 JMC  fbMQTTSubscriberEx_L52
#srcline 723 ;                             ok              := false;
 LD   bool 0       ; false
 WRX  ok
#debug_left bool ok
#srcline 724 ;                             err             := true;
 LD   bool -1       ; true
 WRX  err
#debug_left bool err
#srcline 725 ;                             errCode         := MQTT_CONTROL_ERROR_CODE_SUBSCRIBE_FAILED;
 LD   usint 2
 WRX  errCode
#debug_left usint errCode
#srcline 726 ;                         end_if;
fbMQTTSubscriberEx_L52:
#srcline 727 ;                  else // Incomming data from broker
 JMP  fbMQTTSubscriberEx_L49
fbMQTTSubscriberEx_L51:
#srcline 728 ;                       if  (AND(IN1 := USINT_TO_BYTE(rxData[0]),IN2 := USINT_TO_BYTE(MQTT_CONTROL_PACK_PUBLISH))) > 0 then
 LDX  rxData[0]
#debug usint rxData[0]
 AND  $FF
 LD   usint 48
 AND  $FF
 AND
 LD   byte 0
 GT
 JMC  fbMQTTSubscriberEx_L54
#srcline 729 ;                             connected_to_broker := true;
 LD   bool -1       ; true
 WRX  connected_to_broker
#debug_left bool connected_to_broker
#srcline 730 ;                             responce_recived    := true;
 LD   bool -1       ; true
 WRX  responce_recived
#debug_left bool responce_recived
#srcline 731 ;                             wait_response       := false;
 LD   bool 0       ; false
 WRX  wait_response
#debug_left bool wait_response
#srcline 733 ;                             index               := 1;
 LD   usint 1
 WRX  index
#debug_left usint index
#srcline 734 ;                             payloadLengthSize   := 0;
 LD   uint 0
 WRX  payloadLengthSize
#debug_left uint payloadLengthSize
#srcline 735 ;                             payloadLengthBytes  := 1;
 LD   uint 1
 WRX  payloadLengthBytes
#debug_left uint payloadLengthBytes
#srcline 737 ;                             while index <= 4 do
fbMQTTSubscriberEx_L56:
 LDX  index
#debug usint index
 LD   usint 4
 GT
 NEG
 JMC  fbMQTTSubscriberEx_L57
 DBG 
#srcline 738 ;                                if rxData[index] > 16#80 then
 LEAX rxData
 LDX  index
#debug usint index
 RCHK 512   ; Range Check
 ADD     ; + offset 
 LDI  
#debug usint rxData[index]
 LD   usint $80
 GT
 JMC  fbMQTTSubscriberEx_L58
#srcline 739 ;                                     payloadLengthSize := payloadLengthSize + BYTE_TO_UINT(USINT_TO_BYTE(rxData[index]) AND 16#7F);
 LDX  payloadLengthSize
#debug uint payloadLengthSize
 LEAX rxData
 LDX  index
#debug usint index
 RCHK 512   ; Range Check
 ADD     ; + offset 
 LDI  
#debug usint rxData[index]
 AND  $FF
 LD   byte $7F
 AND
 ADD
 AND  $FFFF
 WRX  payloadLengthSize
#debug_left uint payloadLengthSize
#srcline 740 ;                                     payloadLengthBytes := payloadLengthBytes + 1;
 LDX  payloadLengthBytes
#debug uint payloadLengthBytes
 LD   uint 1
 ADD
 AND  $FFFF
 WRX  payloadLengthBytes
#debug_left uint payloadLengthBytes
#srcline 741 ;                                else
 JMP  fbMQTTSubscriberEx_L59
fbMQTTSubscriberEx_L58:
#srcline 742 ;                                     if payloadLengthBytes > 1 then
 LDX  payloadLengthBytes
#debug uint payloadLengthBytes
 LD   uint 1
 GT
 JMC  fbMQTTSubscriberEx_L60
#srcline 743 ;                                         payloadLengthSize := payloadLengthSize + (USINT_TO_UINT(rxData[index]) * 128);
 LDX  payloadLengthSize
#debug uint payloadLengthSize
 LEAX rxData
 LDX  index
#debug usint index
 RCHK 512   ; Range Check
 ADD     ; + offset 
 LDI  
#debug usint rxData[index]
 AND  $FFFF
 LD   uint 128
 MUL
 AND  $FFFF
 ADD
 AND  $FFFF
 WRX  payloadLengthSize
#debug_left uint payloadLengthSize
#srcline 744 ;                                     else
 JMP  fbMQTTSubscriberEx_L61
fbMQTTSubscriberEx_L60:
#srcline 745 ;                                         payloadLengthSize := USINT_TO_UINT(rxData[index]);
 LEAX rxData
 LDX  index
#debug usint index
 RCHK 512   ; Range Check
 ADD     ; + offset 
 LDI  
#debug usint rxData[index]
 AND  $FFFF
 WRX  payloadLengthSize
#debug_left uint payloadLengthSize
#srcline 746 ;                                     end_if;
fbMQTTSubscriberEx_L61:
#srcline 747 ;                                     exit;
 JMP  fbMQTTSubscriberEx_L57
#srcline 748 ;                                end_if;
fbMQTTSubscriberEx_L59:
#srcline 749 ;                                index := index + 1;
 LDX  index
#debug usint index
 LD   usint 1
 ADD
 AND  $FF
 WRX  index
#debug_left usint index
#srcline 750 ;                             end_while;
 JMP  fbMQTTSubscriberEx_L56
fbMQTTSubscriberEx_L57:
 NOP  -1
#srcline 752 ;                             inDataCom_param.qos := BYTE_TO_USINT(SHR(IN := USINT_TO_BYTE(rxData[0]),N := 1) AND 16#3);
 LDX  rxData[0]
#debug usint rxData[0]
 AND  $FF
 LD   uint 1
 SHR
 AND  $FF
 LD   byte $3
 AND
 WRX  inDataCom_param~qos
#debug_left usint inDataCom_param.qos
#srcline 753 ;                             inTopicLen          := USINT_TO_UINT(rxData[payloadLengthBytes + 2]);
 LEAX rxData
 LDX  payloadLengthBytes
#debug uint payloadLengthBytes
 LD   uint 2
 ADD
 AND  $FFFF
 RCHK 512   ; Range Check
 ADD     ; + offset 
 LDI  
#debug usint rxData[payloadLengthBytes+2]
 AND  $FFFF
 WRX  inTopicLen
#debug_left uint inTopicLen
#srcline 756 ;                               if (RecvFrom.lenData - payloadLengthBytes - 1) = payloadLengthSize then
 LDX  RecvFrom~lenData
#debug uint RecvFrom.lenData
 LDX  payloadLengthBytes
#debug uint payloadLengthBytes
 SUB
 AND  $FFFF
 LD   uint 1
 SUB
 AND  $FFFF
 LDX  payloadLengthSize
#debug uint payloadLengthSize
 EQ
 JMC  fbMQTTSubscriberEx_L62
#srcline 757 ;                                  dataRec          := true;
 LD   bool -1       ; true
 WRX  dataRec
#debug_left bool dataRec
#srcline 758 ;                                  dataRecDT        := GetDateTime();
 LEA  __Instance__GetDateTime
 CAL  GetDateTime_L0
 WRX  dataRecDT
#debug_left dt dataRecDT
#srcline 759 ;                                 // dataTxt          := '';
#srcline 760 ;                                  dataTopicTxt     := '';
 LD   0   ; null string
 LEAX dataTopicTxt
 WRI  
 LEAX dataTopicTxt
 LD   80
 DST    ; Level 1
 LEA  _str_fbMQTTSubscriberEx_2
 SCON 
#debug_left string dataTopicTxt
 PDST   ; Level 1
#srcline 761 ;                                  MemcpyPtr(source := ADR(rxData[payloadLengthBytes + 3]), dest := ADR(dataTopicTxt),length := UINT_TO_UDINT(inTopicLen));
 NXT
 LEAX rxData
 LDX  payloadLengthBytes
#debug uint payloadLengthBytes
 LD   uint 3
 ADD
 AND  $FFFF
 RCHK 512   ; Range Check
 ADD     ; + offset 
#debug pointer rxData[payloadLengthBytes+3]
 LEA  __Instance__MemcpyPtr~source
 WRIL 
#debug_left udint __Instance__MemcpyPtr~source
 LEAX dataTopicTxt
#debug pointer dataTopicTxt
 LEA  __Instance__MemcpyPtr~dest
 WRIL 
#debug_left udint __Instance__MemcpyPtr~dest
 LDX  inTopicLen
#debug uint inTopicLen
 WR   __Instance__MemcpyPtr~length
#debug_left udint __Instance__MemcpyPtr~length
 PRV
 LEA  __Instance__MemcpyPtr
 CAL  MemcpyPtr_L0
#srcline 763 ;                                  if inDataCom_param.qos > 0 then
 LDX  inDataCom_param~qos
#debug usint inDataCom_param.qos
 LD   usint 0
 GT
 JMC  fbMQTTSubscriberEx_L64
#srcline 764 ;                                      if inDataCom_param.qos = 1 then
 LDX  inDataCom_param~qos
#debug usint inDataCom_param.qos
 LD   usint 1
 EQ
 JMC  fbMQTTSubscriberEx_L66
#srcline 765 ;                                          pubAckRq  := true; // Request to answer to publish command from broker when QOS=1
 LD   bool -1       ; true
 WRX  pubAckRq
#debug_left bool pubAckRq
#srcline 766 ;                                      else
 JMP  fbMQTTSubscriberEx_L67
fbMQTTSubscriberEx_L66:
#srcline 767 ;                                          pubRecRq  := true; // Request to answer to publish command from broker when QOS=2
 LD   bool -1       ; true
 WRX  pubRecRq
#debug_left bool pubRecRq
#srcline 768 ;                                      end_if;
fbMQTTSubscriberEx_L67:
#srcline 769 ;                                      messageIDpubAck_ptr := ADR(rxData[inTopicLen + payloadLengthBytes + 3]);
 LEAX rxData
 LDX  inTopicLen
#debug uint inTopicLen
 LDX  payloadLengthBytes
#debug uint payloadLengthBytes
 ADD
 AND  $FFFF
 LD   uint 3
 ADD
 AND  $FFFF
 RCHK 512   ; Range Check
 ADD     ; + offset 
#debug pointer rxData[inTopicLen+payloadLengthBytes+3]
 LEAX messageIDpubAck_ptr
 WRIL 
#debug_left pointer messageIDpubAck_ptr
#srcline 770 ;                                      messageIDpubAck     := fSwapUINT( messageIDpubAck_ptr^);
 NXT
 LEAX messageIDpubAck_ptr
 LDIL    ; dereference 
 LDIW 
#debug uint messageIDpubAck_ptr^
 WR   __Instance__fSwapUINT~input
#debug_left uint __Instance__fSwapUINT~input
 PRV
 LEA  __Instance__fSwapUINT
 CAL  fSwapUINT_L0
 WRX  messageIDpubAck
#debug_left uint messageIDpubAck
#srcline 772 ;                                     // inMsgLen := rxData[1] - inTopicLen - 4;
#srcline 773 ;                                      inMsgLen := payloadLengthSize - inTopicLen - 4;
 LDX  payloadLengthSize
#debug uint payloadLengthSize
 LDX  inTopicLen
#debug uint inTopicLen
 SUB
 AND  $FFFF
 LD   uint 4
 SUB
 AND  $FFFF
 WRX  inMsgLen
#debug_left uint inMsgLen
#srcline 774 ;                                    //  MemcpyPtr(source := ADR(rxData[inTopicLen + 6]),dest := ADR(dataTxt),   length := inMsgLen);
#srcline 775 ;                                    //  MemcpyPtr(source := ADR(rxData[inTopicLen + payloadLengthBytes + 5]),dest := ADR(dataTxt),   length := UINT_TO_UDINT(inMsgLen));
#srcline 776 ;                                        
#srcline 777 ;                                        MemcpyPtr(source := ADR(rxData[inTopicLen + payloadLengthBytes + 5]),dest := pData,   length := UINT_TO_UDINT(inMsgLen));
 NXT
 LEAX rxData
 LDX  inTopicLen
#debug uint inTopicLen
 LDX  payloadLengthBytes
#debug uint payloadLengthBytes
 ADD
 AND  $FFFF
 LD   uint 5
 ADD
 AND  $FFFF
 RCHK 512   ; Range Check
 ADD     ; + offset 
#debug pointer rxData[inTopicLen+payloadLengthBytes+5]
 LEA  __Instance__MemcpyPtr~source
 WRIL 
#debug_left udint __Instance__MemcpyPtr~source
 LEAX pData
 LDIL 
#debug pointer pData
 LEA  __Instance__MemcpyPtr~dest
 WRIL 
#debug_left udint __Instance__MemcpyPtr~dest
 LDX  inMsgLen
#debug uint inMsgLen
 WR   __Instance__MemcpyPtr~length
#debug_left udint __Instance__MemcpyPtr~length
 PRV
 LEA  __Instance__MemcpyPtr
 CAL  MemcpyPtr_L0
#srcline 778 ;                                  else
 JMP  fbMQTTSubscriberEx_L65
fbMQTTSubscriberEx_L64:
#srcline 779 ;                                   // inMsgLen := rxData[1] - inTopicLen - 2;
#srcline 780 ;                                    inMsgLen := payloadLengthSize-inTopicLen;
 LDX  payloadLengthSize
#debug uint payloadLengthSize
 LDX  inTopicLen
#debug uint inTopicLen
 SUB
 AND  $FFFF
 WRX  inMsgLen
#debug_left uint inMsgLen
#srcline 781 ;                                    inMsgLen := inMsgLen - 2;
 LDX  inMsgLen
#debug uint inMsgLen
 LD   uint 2
 SUB
 AND  $FFFF
 WRX  inMsgLen
#debug_left uint inMsgLen
#srcline 782 ;                                    //MemcpyPtr(source := ADR(rxData[inTopicLen + payloadLengthBytes + 3]),dest := ADR(dataTxt),length := UINT_TO_UDINT(inMsgLen));
#srcline 783 ;                                    MemcpyPtr(source := ADR(rxData[inTopicLen + payloadLengthBytes + 3]),dest := pData,length := UINT_TO_UDINT(inMsgLen));
 NXT
 LEAX rxData
 LDX  inTopicLen
#debug uint inTopicLen
 LDX  payloadLengthBytes
#debug uint payloadLengthBytes
 ADD
 AND  $FFFF
 LD   uint 3
 ADD
 AND  $FFFF
 RCHK 512   ; Range Check
 ADD     ; + offset 
#debug pointer rxData[inTopicLen+payloadLengthBytes+3]
 LEA  __Instance__MemcpyPtr~source
 WRIL 
#debug_left udint __Instance__MemcpyPtr~source
 LEAX pData
 LDIL 
#debug pointer pData
 LEA  __Instance__MemcpyPtr~dest
 WRIL 
#debug_left udint __Instance__MemcpyPtr~dest
 LDX  inMsgLen
#debug uint inMsgLen
 WR   __Instance__MemcpyPtr~length
#debug_left udint __Instance__MemcpyPtr~length
 PRV
 LEA  __Instance__MemcpyPtr
 CAL  MemcpyPtr_L0
#srcline 784 ;                                  end_if;
fbMQTTSubscriberEx_L65:
#srcline 785 ;                             else
 JMP  fbMQTTSubscriberEx_L63
fbMQTTSubscriberEx_L62:
#srcline 786 ;                                ok       := false;
 LD   bool 0       ; false
 WRX  ok
#debug_left bool ok
#srcline 787 ;                                err      := true;
 LD   bool -1       ; true
 WRX  err
#debug_left bool err
#srcline 788 ;                                errCode  := MQTT_CONTROL_ERROR_CODE_ANSWER_LENGTH_TO_LONG;
 LD   usint 4
 WRX  errCode
#debug_left usint errCode
#srcline 789 ;                             end_if;
fbMQTTSubscriberEx_L63:
#srcline 790 ;                       end_if;
fbMQTTSubscriberEx_L54:
#srcline 791 ;                  end_if;
fbMQTTSubscriberEx_L49:
#srcline 792 ;                  rxCounter := rxCounter + 1;
 LDX  rxCounter
#debug uint rxCounter
 LD   uint 1
 ADD
 AND  $FFFF
 WRX  rxCounter
#debug_left uint rxCounter
#srcline 793 ;              end_if;
fbMQTTSubscriberEx_L46:
#srcline 794 ;          end_if;
fbMQTTSubscriberEx_L44:
#srcline 795 ;       else
 JMP  fbMQTTSubscriberEx_L39
fbMQTTSubscriberEx_L38:
#srcline 796 ;         connected_to_broker := false;
 LD   bool 0       ; false
 WRX  connected_to_broker
#debug_left bool connected_to_broker
#srcline 797 ;         wait_response       := false;
 LD   bool 0       ; false
 WRX  wait_response
#debug_left bool wait_response
#srcline 798 ;         ok                  := false;
 LD   bool 0       ; false
 WRX  ok
#debug_left bool ok
#srcline 799 ;         err                 := true;
 LD   bool -1       ; true
 WRX  err
#debug_left bool err
#srcline 800 ;         errCode             := MQTT_CONTROL_ERROR_CODE_BROKER_DISCONNECTED;
 LD   usint 3
 WRX  errCode
#debug_left usint errCode
#srcline 801 ;       end_if;
fbMQTTSubscriberEx_L39:
#srcline 802 ;   else
 JMP  fbMQTTSubscriberEx_L6
fbMQTTSubscriberEx_L5:
#srcline 803 ;     connected_to_broker := false;
 LD   bool 0       ; false
 WRX  connected_to_broker
#debug_left bool connected_to_broker
#srcline 804 ;     wait_response       := false;
 LD   bool 0       ; false
 WRX  wait_response
#debug_left bool wait_response
#srcline 805 ;     ok                  := false;
 LD   bool 0       ; false
 WRX  ok
#debug_left bool ok
#srcline 806 ;     err                 := true;
 LD   bool -1       ; true
 WRX  err
#debug_left bool err
#srcline 807 ;     errCode             := MQTT_CONTROL_ERROR_CODE_BROKER_DISCONNECTED;
 LD   usint 3
 WRX  errCode
#debug_left usint errCode
#srcline 808 ;   end_if;
fbMQTTSubscriberEx_L6:
#srcline 811 ;END_FUNCTION_BLOCK
fbMQTTSubscriberEx_RET:
 ULNK
RET
E     61

; Initialize - variables
P     61
fbMQTTSubscriberEx__InstanceInit__:
 LINK 0
 LD   uint 1883
 WRX  brokerPort
 LD   uint 5000
 WRX  localPort
 LD   bool -1   ; true
 WRX  keepAlive
 LD   time 20000
 WRX  keepAliveInterval
 LD   time 10000
 WRX  connTimeOut
 LD   time 15000
 WRX  pingInterval
 LD   bool -1   ; true
 WRX  clientId_auto
 LD   0
 SRC  byte __Init___fbMQTTSubscriberEx_com_param
 LEAX byte com_param
 LD   3
 MOV  %X0
 LD   udint $FFFFFFFF    ; nil
 WRX  pData
 LEAX MQTT_Comm_Init
 CAL  fbMQTT_Comm_Init__InstanceInit__
 LEAX SendTo
 CAL  fbSendTo__InstanceInit__
 LEAX RecvFrom
 CAL  fbRecvFrom__InstanceInit__
 LD   0
 SRC  byte __Init___fbMQTTSubscriberEx_MQTT_PROTOCOL
 LEAX byte MQTT_PROTOCOL
 LD   5
 MOV  %X0
 LD   0
 SRC  byte __Init___fbMQTTSubscriberEx_inDataCom_param
 LEAX byte inDataCom_param
 LD   3
 MOV  %X0
 LD   udint $FFFFFFFF    ; nil
 WRX  messageIDpubAck_ptr
 ULNK
RET
E     61
; End initialize - variables
#endpou 



 

#srcfile ''
V  C  